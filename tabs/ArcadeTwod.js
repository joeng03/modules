require => (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = (x => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function (x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return (fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res);
  };
  var __commonJS = (cb, mod) => function __require2() {
    return (mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
      exports: {}
    }).exports, mod), mod.exports);
  };
  var __export = (target, all) => {
    for (var name in all) __defProp(target, name, {
      get: all[name],
      enumerable: true
    });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
        get: () => from[key],
        enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
      });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
    value: mod,
    enumerable: true
  }) : target, mod));
  var __toCommonJS = mod => __copyProps(__defProp({}, "__esModule", {
    value: true
  }), mod);
  var define_process_default;
  var init_define_process = __esm({
    "<define:process>"() {
      define_process_default = {
        env: {
          NODE_ENV: "production"
        }
      };
    }
  });
  var require_phaser = __commonJS({
    "node_modules/phaser/dist/phaser.js"(exports, module) {
      init_define_process();
      (function webpackUniversalModuleDefinition(root, factory) {
        if (typeof exports === "object" && typeof module === "object") module.exports = factory(); else if (typeof define === "function" && define.amd) define("Phaser", [], factory); else if (typeof exports === "object") exports["Phaser"] = factory(); else root["Phaser"] = factory();
      })(exports, function () {
        return (function (modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              i: moduleId,
              l: false,
              exports: {}
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function (exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, {
                enumerable: true,
                get: getter
              });
            }
          };
          __webpack_require__.r = function (exports2) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports2, Symbol.toStringTag, {
                value: "Module"
              });
            }
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
          };
          __webpack_require__.t = function (value, mode) {
            if (mode & 1) value = __webpack_require__(value);
            if (mode & 8) return value;
            if (mode & 4 && typeof value === "object" && value && value.__esModule) return value;
            var ns2 = Object.create(null);
            __webpack_require__.r(ns2);
            Object.defineProperty(ns2, "default", {
              enumerable: true,
              value
            });
            if (mode & 2 && typeof value != "string") for (var key in value) __webpack_require__.d(ns2, key, (function (key2) {
              return value[key2];
            }).bind(null, key));
            return ns2;
          };
          __webpack_require__.n = function (module2) {
            var getter = module2 && module2.__esModule ? function getDefault() {
              return module2["default"];
            } : function getModuleExports() {
              return module2;
            };
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function (object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 1528);
        })([function (module2, exports2) {
          function hasGetterOrSetter(def) {
            return !!def.get && typeof def.get === "function" || !!def.set && typeof def.set === "function";
          }
          function getProperty(definition, k, isClassDescriptor) {
            var def = isClassDescriptor ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);
            if (!isClassDescriptor && def.value && typeof def.value === "object") {
              def = def.value;
            }
            if (def && hasGetterOrSetter(def)) {
              if (typeof def.enumerable === "undefined") {
                def.enumerable = true;
              }
              if (typeof def.configurable === "undefined") {
                def.configurable = true;
              }
              return def;
            } else {
              return false;
            }
          }
          function hasNonConfigurable(obj, k) {
            var prop = Object.getOwnPropertyDescriptor(obj, k);
            if (!prop) {
              return false;
            }
            if (prop.value && typeof prop.value === "object") {
              prop = prop.value;
            }
            if (prop.configurable === false) {
              return true;
            }
            return false;
          }
          function extend(ctor, definition, isClassDescriptor, extend2) {
            for (var k in definition) {
              if (!definition.hasOwnProperty(k)) {
                continue;
              }
              var def = getProperty(definition, k, isClassDescriptor);
              if (def !== false) {
                var parent = extend2 || ctor;
                if (hasNonConfigurable(parent.prototype, k)) {
                  if (Class.ignoreFinals) {
                    continue;
                  }
                  throw new Error("cannot override final property '" + k + "', set Class.ignoreFinals = true to skip");
                }
                Object.defineProperty(ctor.prototype, k, def);
              } else {
                ctor.prototype[k] = definition[k];
              }
            }
          }
          function mixin(myClass, mixins) {
            if (!mixins) {
              return;
            }
            if (!Array.isArray(mixins)) {
              mixins = [mixins];
            }
            for (var i = 0; i < mixins.length; i++) {
              extend(myClass, mixins[i].prototype || mixins[i]);
            }
          }
          function Class(definition) {
            if (!definition) {
              definition = {};
            }
            var initialize;
            var Extends;
            if (definition.initialize) {
              if (typeof definition.initialize !== "function") {
                throw new Error("initialize must be a function");
              }
              initialize = definition.initialize;
              delete definition.initialize;
            } else if (definition.Extends) {
              var base = definition.Extends;
              initialize = function () {
                base.apply(this, arguments);
              };
            } else {
              initialize = function () {};
            }
            if (definition.Extends) {
              initialize.prototype = Object.create(definition.Extends.prototype);
              initialize.prototype.constructor = initialize;
              Extends = definition.Extends;
              delete definition.Extends;
            } else {
              initialize.prototype.constructor = initialize;
            }
            var mixins = null;
            if (definition.Mixins) {
              mixins = definition.Mixins;
              delete definition.Mixins;
            }
            mixin(initialize, mixins);
            extend(initialize, definition, true, Extends);
            return initialize;
          }
          Class.extend = extend;
          Class.mixin = mixin;
          Class.ignoreFinals = false;
          module2.exports = Class;
        }, function (module2, exports2) {
          var NOOP = function () {};
          module2.exports = NOOP;
        }, function (module2, exports2) {
          var GetFastValue = function (source, key, defaultValue) {
            var t = typeof source;
            if (!source || t === "number" || t === "string") {
              return defaultValue;
            } else if (source.hasOwnProperty(key) && source[key] !== void 0) {
              return source[key];
            } else {
              return defaultValue;
            }
          };
          module2.exports = GetFastValue;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var FuzzyEqual = __webpack_require__(124);
          var Vector2 = new Class({
            initialize: function Vector22(x, y) {
              this.x = 0;
              this.y = 0;
              if (typeof x === "object") {
                this.x = x.x || 0;
                this.y = x.y || 0;
              } else {
                if (y === void 0) {
                  y = x;
                }
                this.x = x || 0;
                this.y = y || 0;
              }
            },
            clone: function () {
              return new Vector2(this.x, this.y);
            },
            copy: function (src) {
              this.x = src.x || 0;
              this.y = src.y || 0;
              return this;
            },
            setFromObject: function (obj) {
              this.x = obj.x || 0;
              this.y = obj.y || 0;
              return this;
            },
            set: function (x, y) {
              if (y === void 0) {
                y = x;
              }
              this.x = x;
              this.y = y;
              return this;
            },
            setTo: function (x, y) {
              return this.set(x, y);
            },
            setToPolar: function (azimuth, radius) {
              if (radius == null) {
                radius = 1;
              }
              this.x = Math.cos(azimuth) * radius;
              this.y = Math.sin(azimuth) * radius;
              return this;
            },
            equals: function (v) {
              return this.x === v.x && this.y === v.y;
            },
            fuzzyEquals: function (v, epsilon) {
              return FuzzyEqual(this.x, v.x, epsilon) && FuzzyEqual(this.y, v.y, epsilon);
            },
            angle: function () {
              var angle = Math.atan2(this.y, this.x);
              if (angle < 0) {
                angle += 2 * Math.PI;
              }
              return angle;
            },
            setAngle: function (angle) {
              return this.setToPolar(angle, this.length());
            },
            add: function (src) {
              this.x += src.x;
              this.y += src.y;
              return this;
            },
            subtract: function (src) {
              this.x -= src.x;
              this.y -= src.y;
              return this;
            },
            multiply: function (src) {
              this.x *= src.x;
              this.y *= src.y;
              return this;
            },
            scale: function (value) {
              if (isFinite(value)) {
                this.x *= value;
                this.y *= value;
              } else {
                this.x = 0;
                this.y = 0;
              }
              return this;
            },
            divide: function (src) {
              this.x /= src.x;
              this.y /= src.y;
              return this;
            },
            negate: function () {
              this.x = -this.x;
              this.y = -this.y;
              return this;
            },
            distance: function (src) {
              var dx = src.x - this.x;
              var dy = src.y - this.y;
              return Math.sqrt(dx * dx + dy * dy);
            },
            distanceSq: function (src) {
              var dx = src.x - this.x;
              var dy = src.y - this.y;
              return dx * dx + dy * dy;
            },
            length: function () {
              var x = this.x;
              var y = this.y;
              return Math.sqrt(x * x + y * y);
            },
            setLength: function (length) {
              return this.normalize().scale(length);
            },
            lengthSq: function () {
              var x = this.x;
              var y = this.y;
              return x * x + y * y;
            },
            normalize: function () {
              var x = this.x;
              var y = this.y;
              var len = x * x + y * y;
              if (len > 0) {
                len = 1 / Math.sqrt(len);
                this.x = x * len;
                this.y = y * len;
              }
              return this;
            },
            normalizeRightHand: function () {
              var x = this.x;
              this.x = this.y * -1;
              this.y = x;
              return this;
            },
            normalizeLeftHand: function () {
              var x = this.x;
              this.x = this.y;
              this.y = x * -1;
              return this;
            },
            dot: function (src) {
              return this.x * src.x + this.y * src.y;
            },
            cross: function (src) {
              return this.x * src.y - this.y * src.x;
            },
            lerp: function (src, t) {
              if (t === void 0) {
                t = 0;
              }
              var ax = this.x;
              var ay = this.y;
              this.x = ax + t * (src.x - ax);
              this.y = ay + t * (src.y - ay);
              return this;
            },
            transformMat3: function (mat) {
              var x = this.x;
              var y = this.y;
              var m = mat.val;
              this.x = m[0] * x + m[3] * y + m[6];
              this.y = m[1] * x + m[4] * y + m[7];
              return this;
            },
            transformMat4: function (mat) {
              var x = this.x;
              var y = this.y;
              var m = mat.val;
              this.x = m[0] * x + m[4] * y + m[12];
              this.y = m[1] * x + m[5] * y + m[13];
              return this;
            },
            reset: function () {
              this.x = 0;
              this.y = 0;
              return this;
            },
            limit: function (max) {
              var len = this.length();
              if (len && len > max) {
                this.scale(max / len);
              }
              return this;
            },
            reflect: function (normal) {
              normal = normal.clone().normalize();
              return this.subtract(normal.scale(2 * this.dot(normal)));
            },
            mirror: function (axis) {
              return this.reflect(axis).negate();
            },
            rotate: function (delta) {
              var cos = Math.cos(delta);
              var sin = Math.sin(delta);
              return this.set(cos * this.x - sin * this.y, sin * this.x + cos * this.y);
            }
          });
          Vector2.ZERO = new Vector2();
          Vector2.RIGHT = new Vector2(1, 0);
          Vector2.LEFT = new Vector2(-1, 0);
          Vector2.UP = new Vector2(0, -1);
          Vector2.DOWN = new Vector2(0, 1);
          Vector2.ONE = new Vector2(1, 1);
          module2.exports = Vector2;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GEOM_CONST = __webpack_require__(56);
          var Point = new Class({
            initialize: function Point2(x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = x;
              }
              this.type = GEOM_CONST.POINT;
              this.x = x;
              this.y = y;
            },
            setTo: function (x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = x;
              }
              this.x = x;
              this.y = y;
              return this;
            }
          });
          module2.exports = Point;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var PluginCache = __webpack_require__(24);
          var SceneEvents = __webpack_require__(20);
          var GameObjectFactory = new Class({
            initialize: function GameObjectFactory2(scene) {
              this.scene = scene;
              this.systems = scene.sys;
              this.events = scene.sys.events;
              this.displayList;
              this.updateList;
              this.events.once(SceneEvents.BOOT, this.boot, this);
              this.events.on(SceneEvents.START, this.start, this);
            },
            boot: function () {
              this.displayList = this.systems.displayList;
              this.updateList = this.systems.updateList;
              this.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            start: function () {
              this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            existing: function (child) {
              if (child.renderCanvas || child.renderWebGL) {
                this.displayList.add(child);
              }
              if (child.preUpdate) {
                this.updateList.add(child);
              }
              return child;
            },
            shutdown: function () {
              this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function () {
              this.shutdown();
              this.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
              this.events = null;
              this.displayList = null;
              this.updateList = null;
            }
          });
          GameObjectFactory.register = function (factoryType, factoryFunction) {
            if (!GameObjectFactory.prototype.hasOwnProperty(factoryType)) {
              GameObjectFactory.prototype[factoryType] = factoryFunction;
            }
          };
          GameObjectFactory.remove = function (factoryType) {
            if (GameObjectFactory.prototype.hasOwnProperty(factoryType)) {
              delete GameObjectFactory.prototype[factoryType];
            }
          };
          PluginCache.register("GameObjectFactory", GameObjectFactory, "add");
          module2.exports = GameObjectFactory;
        }, function (module2, exports2) {
          var GetValue = function (source, key, defaultValue) {
            if (!source || typeof source === "number") {
              return defaultValue;
            } else if (source.hasOwnProperty(key)) {
              return source[key];
            } else if (key.indexOf(".") !== -1) {
              var keys = key.split(".");
              var parent = source;
              var value = defaultValue;
              for (var i = 0; i < keys.length; i++) {
                if (parent.hasOwnProperty(keys[i])) {
                  value = parent[keys[i]];
                  parent = parent[keys[i]];
                } else {
                  value = defaultValue;
                  break;
                }
              }
              return value;
            } else {
              return defaultValue;
            }
          };
          module2.exports = GetValue;
        }, function (module2, exports2) {
          var IsPlainObject = function (obj) {
            if (typeof obj !== "object" || obj.nodeType || obj === obj.window) {
              return false;
            }
            try {
              if (obj.constructor && !({}).hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf")) {
                return false;
              }
            } catch (e) {
              return false;
            }
            return true;
          };
          module2.exports = IsPlainObject;
        }, function (module2, exports2) {
          var types = {};
          var FileTypesManager = {
            install: function (loader) {
              for (var key in types) {
                loader[key] = types[key];
              }
            },
            register: function (key, factoryFunction) {
              types[key] = factoryFunction;
            },
            destroy: function () {
              types = {};
            }
          };
          module2.exports = FileTypesManager;
        }, function (module2, exports2, __webpack_require__) {
          "use strict";
          var has = Object.prototype.hasOwnProperty, prefix = "~";
          function Events() {}
          if (Object.create) {
            Events.prototype = Object.create(null);
            if (!new Events().__proto__) prefix = false;
          }
          function EE(fn, context, once) {
            this.fn = fn;
            this.context = context;
            this.once = once || false;
          }
          function addListener(emitter, event, fn, context, once) {
            if (typeof fn !== "function") {
              throw new TypeError("The listener must be a function");
            }
            var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
            if (!emitter._events[evt]) (emitter._events[evt] = listener, emitter._eventsCount++); else if (!emitter._events[evt].fn) emitter._events[evt].push(listener); else emitter._events[evt] = [emitter._events[evt], listener];
            return emitter;
          }
          function clearEvent(emitter, evt) {
            if (--emitter._eventsCount === 0) emitter._events = new Events(); else delete emitter._events[evt];
          }
          function EventEmitter() {
            this._events = new Events();
            this._eventsCount = 0;
          }
          EventEmitter.prototype.eventNames = function eventNames() {
            var names = [], events, name;
            if (this._eventsCount === 0) return names;
            for (name in events = this._events) {
              if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
            }
            if (Object.getOwnPropertySymbols) {
              return names.concat(Object.getOwnPropertySymbols(events));
            }
            return names;
          };
          EventEmitter.prototype.listeners = function listeners(event) {
            var evt = prefix ? prefix + event : event, handlers = this._events[evt];
            if (!handlers) return [];
            if (handlers.fn) return [handlers.fn];
            for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
              ee[i] = handlers[i].fn;
            }
            return ee;
          };
          EventEmitter.prototype.listenerCount = function listenerCount(event) {
            var evt = prefix ? prefix + event : event, listeners = this._events[evt];
            if (!listeners) return 0;
            if (listeners.fn) return 1;
            return listeners.length;
          };
          EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
            var evt = prefix ? prefix + event : event;
            if (!this._events[evt]) return false;
            var listeners = this._events[evt], len = arguments.length, args, i;
            if (listeners.fn) {
              if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
              switch (len) {
                case 1:
                  return (listeners.fn.call(listeners.context), true);
                case 2:
                  return (listeners.fn.call(listeners.context, a1), true);
                case 3:
                  return (listeners.fn.call(listeners.context, a1, a2), true);
                case 4:
                  return (listeners.fn.call(listeners.context, a1, a2, a3), true);
                case 5:
                  return (listeners.fn.call(listeners.context, a1, a2, a3, a4), true);
                case 6:
                  return (listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true);
              }
              for ((i = 1, args = new Array(len - 1)); i < len; i++) {
                args[i - 1] = arguments[i];
              }
              listeners.fn.apply(listeners.context, args);
            } else {
              var length = listeners.length, j;
              for (i = 0; i < length; i++) {
                if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
                switch (len) {
                  case 1:
                    listeners[i].fn.call(listeners[i].context);
                    break;
                  case 2:
                    listeners[i].fn.call(listeners[i].context, a1);
                    break;
                  case 3:
                    listeners[i].fn.call(listeners[i].context, a1, a2);
                    break;
                  case 4:
                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                    break;
                  default:
                    if (!args) for ((j = 1, args = new Array(len - 1)); j < len; j++) {
                      args[j - 1] = arguments[j];
                    }
                    listeners[i].fn.apply(listeners[i].context, args);
                }
              }
            }
            return true;
          };
          EventEmitter.prototype.on = function on(event, fn, context) {
            return addListener(this, event, fn, context, false);
          };
          EventEmitter.prototype.once = function once(event, fn, context) {
            return addListener(this, event, fn, context, true);
          };
          EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
            var evt = prefix ? prefix + event : event;
            if (!this._events[evt]) return this;
            if (!fn) {
              clearEvent(this, evt);
              return this;
            }
            var listeners = this._events[evt];
            if (listeners.fn) {
              if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
                clearEvent(this, evt);
              }
            } else {
              for (var i = 0, events = [], length = listeners.length; i < length; i++) {
                if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
                  events.push(listeners[i]);
                }
              }
              if (events.length) this._events[evt] = events.length === 1 ? events[0] : events; else clearEvent(this, evt);
            }
            return this;
          };
          EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
            var evt;
            if (event) {
              evt = prefix ? prefix + event : event;
              if (this._events[evt]) clearEvent(this, evt);
            } else {
              this._events = new Events();
              this._eventsCount = 0;
            }
            return this;
          };
          EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
          EventEmitter.prototype.addListener = EventEmitter.prototype.on;
          EventEmitter.prefixed = prefix;
          EventEmitter.EventEmitter = EventEmitter;
          if (true) {
            module2.exports = EventEmitter;
          }
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Contains = __webpack_require__(57);
          var GetPoint = __webpack_require__(171);
          var GetPoints = __webpack_require__(306);
          var GEOM_CONST = __webpack_require__(56);
          var Line = __webpack_require__(47);
          var Random = __webpack_require__(174);
          var Rectangle = new Class({
            initialize: function Rectangle2(x, y, width, height) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = 0;
              }
              if (height === void 0) {
                height = 0;
              }
              this.type = GEOM_CONST.RECTANGLE;
              this.x = x;
              this.y = y;
              this.width = width;
              this.height = height;
            },
            contains: function (x, y) {
              return Contains(this, x, y);
            },
            getPoint: function (position, output) {
              return GetPoint(this, position, output);
            },
            getPoints: function (quantity, stepRate, output) {
              return GetPoints(this, quantity, stepRate, output);
            },
            getRandomPoint: function (point) {
              return Random(this, point);
            },
            setTo: function (x, y, width, height) {
              this.x = x;
              this.y = y;
              this.width = width;
              this.height = height;
              return this;
            },
            setEmpty: function () {
              return this.setTo(0, 0, 0, 0);
            },
            setPosition: function (x, y) {
              if (y === void 0) {
                y = x;
              }
              this.x = x;
              this.y = y;
              return this;
            },
            setSize: function (width, height) {
              if (height === void 0) {
                height = width;
              }
              this.width = width;
              this.height = height;
              return this;
            },
            isEmpty: function () {
              return this.width <= 0 || this.height <= 0;
            },
            getLineA: function (line) {
              if (line === void 0) {
                line = new Line();
              }
              line.setTo(this.x, this.y, this.right, this.y);
              return line;
            },
            getLineB: function (line) {
              if (line === void 0) {
                line = new Line();
              }
              line.setTo(this.right, this.y, this.right, this.bottom);
              return line;
            },
            getLineC: function (line) {
              if (line === void 0) {
                line = new Line();
              }
              line.setTo(this.right, this.bottom, this.x, this.bottom);
              return line;
            },
            getLineD: function (line) {
              if (line === void 0) {
                line = new Line();
              }
              line.setTo(this.x, this.bottom, this.x, this.y);
              return line;
            },
            left: {
              get: function () {
                return this.x;
              },
              set: function (value) {
                if (value >= this.right) {
                  this.width = 0;
                } else {
                  this.width = this.right - value;
                }
                this.x = value;
              }
            },
            right: {
              get: function () {
                return this.x + this.width;
              },
              set: function (value) {
                if (value <= this.x) {
                  this.width = 0;
                } else {
                  this.width = value - this.x;
                }
              }
            },
            top: {
              get: function () {
                return this.y;
              },
              set: function (value) {
                if (value >= this.bottom) {
                  this.height = 0;
                } else {
                  this.height = this.bottom - value;
                }
                this.y = value;
              }
            },
            bottom: {
              get: function () {
                return this.y + this.height;
              },
              set: function (value) {
                if (value <= this.y) {
                  this.height = 0;
                } else {
                  this.height = value - this.y;
                }
              }
            },
            centerX: {
              get: function () {
                return this.x + this.width / 2;
              },
              set: function (value) {
                this.x = value - this.width / 2;
              }
            },
            centerY: {
              get: function () {
                return this.y + this.height / 2;
              },
              set: function (value) {
                this.y = value - this.height / 2;
              }
            }
          });
          module2.exports = Rectangle;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Alpha: __webpack_require__(607),
            AlphaSingle: __webpack_require__(303),
            BlendMode: __webpack_require__(304),
            ComputedSize: __webpack_require__(608),
            Crop: __webpack_require__(609),
            Depth: __webpack_require__(305),
            Flip: __webpack_require__(610),
            GetBounds: __webpack_require__(611),
            Mask: __webpack_require__(309),
            Origin: __webpack_require__(632),
            PathFollower: __webpack_require__(633),
            Pipeline: __webpack_require__(167),
            ScrollFactor: __webpack_require__(312),
            Size: __webpack_require__(634),
            Texture: __webpack_require__(635),
            TextureCrop: __webpack_require__(636),
            Tint: __webpack_require__(637),
            ToJSON: __webpack_require__(176),
            Transform: __webpack_require__(313),
            TransformMatrix: __webpack_require__(25),
            Visible: __webpack_require__(314)
          };
        }, function (module2, exports2) {
          function GenerateSrc(maxIfs) {
            var src = "";
            for (var i = 0; i < maxIfs; ++i) {
              if (i > 0) {
                src += "\nelse ";
              }
              if (i < maxIfs - 1) {
                src += "if(test == " + i + ".0){}";
              }
            }
            return src;
          }
          module2.exports = {
            getTintFromFloats: function (r, g, b, a) {
              var ur = (r * 255 | 0) & 255;
              var ug = (g * 255 | 0) & 255;
              var ub = (b * 255 | 0) & 255;
              var ua = (a * 255 | 0) & 255;
              return (ua << 24 | ur << 16 | ug << 8 | ub) >>> 0;
            },
            getTintAppendFloatAlpha: function (rgb, a) {
              var ua = (a * 255 | 0) & 255;
              return (ua << 24 | rgb) >>> 0;
            },
            getTintAppendFloatAlphaAndSwap: function (rgb, a) {
              var ur = (rgb >> 16 | 0) & 255;
              var ug = (rgb >> 8 | 0) & 255;
              var ub = (rgb | 0) & 255;
              var ua = (a * 255 | 0) & 255;
              return (ua << 24 | ub << 16 | ug << 8 | ur) >>> 0;
            },
            getFloatsFromUintRGB: function (rgb) {
              var ur = (rgb >> 16 | 0) & 255;
              var ug = (rgb >> 8 | 0) & 255;
              var ub = (rgb | 0) & 255;
              return [ur / 255, ug / 255, ub / 255];
            },
            checkShaderMax: function (gl, maxTextures) {
              if (!maxTextures || maxTextures === -1) {
                maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
              }
              var shader = gl.createShader(gl.FRAGMENT_SHADER);
              var fragTemplate = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join("\n");
              while (true) {
                var fragmentSrc = fragTemplate.replace(/%forloop%/gi, GenerateSrc(maxTextures));
                gl.shaderSource(shader, fragmentSrc);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                  maxTextures = maxTextures / 2 | 0;
                } else {
                  break;
                }
              }
              return maxTextures;
            },
            parseFragmentShaderMaxTextures: function (fragmentShaderSource, maxTextures) {
              if (!fragmentShaderSource) {
                return "";
              }
              var src = "";
              for (var i = 0; i < maxTextures; i++) {
                if (i > 0) {
                  src += "\n	else ";
                }
                if (i < maxTextures - 1) {
                  src += "if (outTexId < " + i + ".5)";
                }
                src += "\n	{";
                src += "\n		texture = texture2D(uMainSampler[" + i + "], outTexCoord);";
                src += "\n	}";
              }
              fragmentShaderSource = fragmentShaderSource.replace(/%count%/gi, maxTextures.toString());
              return fragmentShaderSource.replace(/%forloop%/gi, src);
            }
          };
        }, function (module2, exports2, __webpack_require__) {
          var MATH = __webpack_require__(193);
          var GetValue = __webpack_require__(6);
          var GetAdvancedValue = function (source, key, defaultValue) {
            var value = GetValue(source, key, null);
            if (value === null) {
              return defaultValue;
            } else if (Array.isArray(value)) {
              return MATH.RND.pick(value);
            } else if (typeof value === "object") {
              if (value.hasOwnProperty("randInt")) {
                return MATH.RND.integerInRange(value.randInt[0], value.randInt[1]);
              } else if (value.hasOwnProperty("randFloat")) {
                return MATH.RND.realInRange(value.randFloat[0], value.randFloat[1]);
              }
            } else if (typeof value === "function") {
              return value(key);
            }
            return value;
          };
          module2.exports = GetAdvancedValue;
        }, function (module2, exports2) {
          var MATH_CONST = {
            PI2: Math.PI * 2,
            TAU: Math.PI * 0.5,
            EPSILON: 1e-6,
            DEG_TO_RAD: Math.PI / 180,
            RAD_TO_DEG: 180 / Math.PI,
            RND: null,
            MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991,
            MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991
          };
          module2.exports = MATH_CONST;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var ComponentsToJSON = __webpack_require__(176);
          var DataManager = __webpack_require__(101);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(75);
          var SceneEvents = __webpack_require__(20);
          var GameObject = new Class({
            Extends: EventEmitter,
            initialize: function GameObject2(scene, type) {
              EventEmitter.call(this);
              this.scene = scene;
              this.displayList = null;
              this.type = type;
              this.state = 0;
              this.parentContainer = null;
              this.name = "";
              this.active = true;
              this.tabIndex = -1;
              this.data = null;
              this.renderFlags = 15;
              this.cameraFilter = 0;
              this.input = null;
              this.body = null;
              this.ignoreDestroy = false;
              this.on(Events.ADDED_TO_SCENE, this.addedToScene, this);
              this.on(Events.REMOVED_FROM_SCENE, this.removedFromScene, this);
              scene.sys.queueDepthSort();
            },
            setActive: function (value) {
              this.active = value;
              return this;
            },
            setName: function (value) {
              this.name = value;
              return this;
            },
            setState: function (value) {
              this.state = value;
              return this;
            },
            setDataEnabled: function () {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              return this;
            },
            setData: function (key, value) {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              this.data.set(key, value);
              return this;
            },
            incData: function (key, value) {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              this.data.inc(key, value);
              return this;
            },
            toggleData: function (key) {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              this.data.toggle(key);
              return this;
            },
            getData: function (key) {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              return this.data.get(key);
            },
            setInteractive: function (hitArea, hitAreaCallback, dropZone) {
              this.scene.sys.input.enable(this, hitArea, hitAreaCallback, dropZone);
              return this;
            },
            disableInteractive: function () {
              if (this.input) {
                this.input.enabled = false;
              }
              return this;
            },
            removeInteractive: function () {
              this.scene.sys.input.clear(this);
              this.input = void 0;
              return this;
            },
            addedToScene: function () {},
            removedFromScene: function () {},
            update: function () {},
            toJSON: function () {
              return ComponentsToJSON(this);
            },
            willRender: function (camera) {
              return !(GameObject.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
            },
            getIndexList: function () {
              var child = this;
              var parent = this.parentContainer;
              var indexes = [];
              while (parent) {
                indexes.unshift(parent.getIndex(child));
                child = parent;
                if (!parent.parentContainer) {
                  break;
                } else {
                  parent = parent.parentContainer;
                }
              }
              if (this.displayList) {
                indexes.unshift(this.displayList.getIndex(child));
              } else {
                indexes.unshift(this.scene.sys.displayList.getIndex(child));
              }
              return indexes;
            },
            addToDisplayList: function (displayList) {
              if (displayList === void 0) {
                displayList = this.scene.sys.displayList;
              }
              if (this.displayList && this.displayList !== displayList) {
                this.removeFromDisplayList();
              }
              if (!displayList.exists(this)) {
                this.displayList = displayList;
                displayList.add(this, true);
                displayList.queueDepthSort();
                this.emit(Events.ADDED_TO_SCENE, this, this.scene);
                displayList.events.emit(SceneEvents.ADDED_TO_SCENE, this, this.scene);
              }
              return this;
            },
            addToUpdateList: function () {
              if (this.scene && this.preUpdate) {
                this.scene.sys.updateList.add(this);
              }
              return this;
            },
            removeFromDisplayList: function () {
              var displayList = this.displayList || this.scene.sys.displayList;
              if (displayList.exists(this)) {
                displayList.remove(this, true);
                displayList.queueDepthSort();
                this.displayList = null;
                this.emit(Events.REMOVED_FROM_SCENE, this, this.scene);
                displayList.events.emit(SceneEvents.REMOVED_FROM_SCENE, this, this.scene);
              }
              return this;
            },
            removeFromUpdateList: function () {
              if (this.scene && this.preUpdate) {
                this.scene.sys.updateList.remove(this);
              }
              return this;
            },
            destroy: function (fromScene) {
              if (!this.scene || this.ignoreDestroy) {
                return;
              }
              if (fromScene === void 0) {
                fromScene = false;
              }
              if (this.preDestroy) {
                this.preDestroy.call(this);
              }
              this.emit(Events.DESTROY, this, fromScene);
              this.removeAllListeners();
              if (this.postPipelines) {
                this.resetPostPipeline(true);
              }
              this.removeFromDisplayList();
              this.removeFromUpdateList();
              if (this.input) {
                this.scene.sys.input.clear(this);
                this.input = void 0;
              }
              if (this.data) {
                this.data.destroy();
                this.data = void 0;
              }
              if (this.body) {
                this.body.destroy();
                this.body = void 0;
              }
              this.active = false;
              this.visible = false;
              this.scene = void 0;
              this.parentContainer = void 0;
            }
          });
          GameObject.RENDER_MASK = 15;
          module2.exports = GameObject;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var PluginCache = __webpack_require__(24);
          var SceneEvents = __webpack_require__(20);
          var GameObjectCreator = new Class({
            initialize: function GameObjectCreator2(scene) {
              this.scene = scene;
              this.systems = scene.sys;
              this.events = scene.sys.events;
              this.displayList;
              this.updateList;
              this.events.once(SceneEvents.BOOT, this.boot, this);
              this.events.on(SceneEvents.START, this.start, this);
            },
            boot: function () {
              this.displayList = this.systems.displayList;
              this.updateList = this.systems.updateList;
              this.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            start: function () {
              this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            shutdown: function () {
              this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function () {
              this.shutdown();
              this.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
              this.events = null;
              this.displayList = null;
              this.updateList = null;
            }
          });
          GameObjectCreator.register = function (factoryType, factoryFunction) {
            if (!GameObjectCreator.prototype.hasOwnProperty(factoryType)) {
              GameObjectCreator.prototype[factoryType] = factoryFunction;
            }
          };
          GameObjectCreator.remove = function (factoryType) {
            if (GameObjectCreator.prototype.hasOwnProperty(factoryType)) {
              delete GameObjectCreator.prototype[factoryType];
            }
          };
          PluginCache.register("GameObjectCreator", GameObjectCreator, "make");
          module2.exports = GameObjectCreator;
        }, function (module2, exports2, __webpack_require__) {
          var IsPlainObject = __webpack_require__(7);
          var Extend = function () {
            var options, name, src, copy, copyIsArray, clone, target = arguments[0] || ({}), i = 1, length = arguments.length, deep = false;
            if (typeof target === "boolean") {
              deep = target;
              target = arguments[1] || ({});
              i = 2;
            }
            if (length === i) {
              target = this;
              --i;
            }
            for (; i < length; i++) {
              if ((options = arguments[i]) != null) {
                for (name in options) {
                  src = target[name];
                  copy = options[name];
                  if (target === copy) {
                    continue;
                  }
                  if (deep && copy && (IsPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                    if (copyIsArray) {
                      copyIsArray = false;
                      clone = src && Array.isArray(src) ? src : [];
                    } else {
                      clone = src && IsPlainObject(src) ? src : {};
                    }
                    target[name] = Extend(deep, clone, copy);
                  } else if (copy !== void 0) {
                    target[name] = copy;
                  }
                }
              }
            }
            return target;
          };
          module2.exports = Extend;
        }, function (module2, exports2) {
          var Clamp = function (value, min, max) {
            return Math.max(min, Math.min(max, value));
          };
          module2.exports = Clamp;
        }, function (module2, exports2, __webpack_require__) {
          var TransformMatrix = __webpack_require__(25);
          var tempMatrix1 = new TransformMatrix();
          var tempMatrix2 = new TransformMatrix();
          var tempMatrix3 = new TransformMatrix();
          var result = {
            camera: tempMatrix1,
            sprite: tempMatrix2,
            calc: tempMatrix3
          };
          var GetCalcMatrix = function (src, camera, parentMatrix) {
            var camMatrix = tempMatrix1;
            var spriteMatrix = tempMatrix2;
            var calcMatrix = tempMatrix3;
            spriteMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);
            camMatrix.copyFrom(camera.matrix);
            if (parentMatrix) {
              camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);
              spriteMatrix.e = src.x;
              spriteMatrix.f = src.y;
            } else {
              spriteMatrix.e -= camera.scrollX * src.scrollFactorX;
              spriteMatrix.f -= camera.scrollY * src.scrollFactorY;
            }
            camMatrix.multiply(spriteMatrix, calcMatrix);
            return result;
          };
          module2.exports = GetCalcMatrix;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            ADDED_TO_SCENE: __webpack_require__(656),
            BOOT: __webpack_require__(657),
            CREATE: __webpack_require__(658),
            DESTROY: __webpack_require__(659),
            PAUSE: __webpack_require__(660),
            POST_UPDATE: __webpack_require__(661),
            PRE_RENDER: __webpack_require__(662),
            PRE_UPDATE: __webpack_require__(663),
            READY: __webpack_require__(664),
            REMOVED_FROM_SCENE: __webpack_require__(665),
            RENDER: __webpack_require__(666),
            RESUME: __webpack_require__(667),
            SHUTDOWN: __webpack_require__(668),
            SLEEP: __webpack_require__(669),
            START: __webpack_require__(670),
            TRANSITION_COMPLETE: __webpack_require__(671),
            TRANSITION_INIT: __webpack_require__(672),
            TRANSITION_OUT: __webpack_require__(673),
            TRANSITION_START: __webpack_require__(674),
            TRANSITION_WAKE: __webpack_require__(675),
            UPDATE: __webpack_require__(676),
            WAKE: __webpack_require__(677)
          };
        }, function (module2, exports2) {
          var FILE_CONST = {
            LOADER_IDLE: 0,
            LOADER_LOADING: 1,
            LOADER_PROCESSING: 2,
            LOADER_COMPLETE: 3,
            LOADER_SHUTDOWN: 4,
            LOADER_DESTROYED: 5,
            FILE_PENDING: 10,
            FILE_LOADING: 11,
            FILE_LOADED: 12,
            FILE_FAILED: 13,
            FILE_PROCESSING: 14,
            FILE_ERRORED: 16,
            FILE_COMPLETE: 17,
            FILE_DESTROYED: 18,
            FILE_POPULATED: 19
          };
          module2.exports = FILE_CONST;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            BLUR: __webpack_require__(612),
            BOOT: __webpack_require__(613),
            CONTEXT_LOST: __webpack_require__(614),
            CONTEXT_RESTORED: __webpack_require__(615),
            DESTROY: __webpack_require__(616),
            FOCUS: __webpack_require__(617),
            HIDDEN: __webpack_require__(618),
            PAUSE: __webpack_require__(619),
            POST_RENDER: __webpack_require__(620),
            POST_STEP: __webpack_require__(621),
            PRE_RENDER: __webpack_require__(622),
            PRE_STEP: __webpack_require__(623),
            READY: __webpack_require__(624),
            RESUME: __webpack_require__(625),
            STEP: __webpack_require__(626),
            VISIBLE: __webpack_require__(627)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var Events = __webpack_require__(95);
          var GetFastValue = __webpack_require__(2);
          var GetURL = __webpack_require__(155);
          var MergeXHRSettings = __webpack_require__(240);
          var XHRLoader = __webpack_require__(517);
          var XHRSettings = __webpack_require__(156);
          var File = new Class({
            initialize: function File2(loader, fileConfig) {
              this.loader = loader;
              this.cache = GetFastValue(fileConfig, "cache", false);
              this.type = GetFastValue(fileConfig, "type", false);
              this.key = GetFastValue(fileConfig, "key", false);
              var loadKey = this.key;
              if (loader.prefix && loader.prefix !== "") {
                this.key = loader.prefix + loadKey;
              }
              if (!this.type || !this.key) {
                throw new Error("Invalid Loader." + this.type + " key");
              }
              var url = GetFastValue(fileConfig, "url");
              if (url === void 0) {
                url = loader.path + loadKey + "." + GetFastValue(fileConfig, "extension", "");
              } else if (typeof url === "string" && !url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/)) {
                url = loader.path + url;
              }
              this.url = url;
              this.src = "";
              this.xhrSettings = XHRSettings(GetFastValue(fileConfig, "responseType", void 0));
              if (GetFastValue(fileConfig, "xhrSettings", false)) {
                this.xhrSettings = MergeXHRSettings(this.xhrSettings, GetFastValue(fileConfig, "xhrSettings", {}));
              }
              this.xhrLoader = null;
              this.state = typeof this.url === "function" ? CONST.FILE_POPULATED : CONST.FILE_PENDING;
              this.bytesTotal = 0;
              this.bytesLoaded = -1;
              this.percentComplete = -1;
              this.crossOrigin = void 0;
              this.data = void 0;
              this.config = GetFastValue(fileConfig, "config", {});
              this.multiFile;
              this.linkFile;
            },
            setLink: function (fileB) {
              this.linkFile = fileB;
              fileB.linkFile = this;
            },
            resetXHR: function () {
              if (this.xhrLoader) {
                this.xhrLoader.onload = void 0;
                this.xhrLoader.onerror = void 0;
                this.xhrLoader.onprogress = void 0;
              }
            },
            load: function () {
              if (this.state === CONST.FILE_POPULATED) {
                this.loader.nextFile(this, true);
              } else {
                this.state = CONST.FILE_LOADING;
                this.src = GetURL(this, this.loader.baseURL);
                if (this.src.indexOf("data:") === 0) {
                  console.warn("Local data URIs are not supported: " + this.key);
                } else {
                  this.xhrLoader = XHRLoader(this, this.loader.xhr);
                }
              }
            },
            onLoad: function (xhr, event) {
              var isLocalFile = xhr.responseURL && (xhr.responseURL.indexOf("file://") === 0 || xhr.responseURL.indexOf("capacitor://") === 0);
              var localFileOk = isLocalFile && event.target.status === 0;
              var success = !(event.target && event.target.status !== 200) || localFileOk;
              if (xhr.readyState === 4 && xhr.status >= 400 && xhr.status <= 599) {
                success = false;
              }
              this.state = CONST.FILE_LOADED;
              this.resetXHR();
              this.loader.nextFile(this, success);
            },
            onError: function () {
              this.resetXHR();
              this.loader.nextFile(this, false);
            },
            onProgress: function (event) {
              if (event.lengthComputable) {
                this.bytesLoaded = event.loaded;
                this.bytesTotal = event.total;
                this.percentComplete = Math.min(this.bytesLoaded / this.bytesTotal, 1);
                this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);
              }
            },
            onProcess: function () {
              this.state = CONST.FILE_PROCESSING;
              this.onProcessComplete();
            },
            onProcessComplete: function () {
              this.state = CONST.FILE_COMPLETE;
              if (this.multiFile) {
                this.multiFile.onFileComplete(this);
              }
              this.loader.fileProcessComplete(this);
            },
            onProcessError: function () {
              this.state = CONST.FILE_ERRORED;
              if (this.multiFile) {
                this.multiFile.onFileFailed(this);
              }
              this.loader.fileProcessComplete(this);
            },
            hasCacheConflict: function () {
              return this.cache && this.cache.exists(this.key);
            },
            addToCache: function () {
              if (this.cache) {
                this.cache.add(this.key, this.data);
              }
              this.pendingDestroy();
            },
            pendingDestroy: function (data) {
              if (data === void 0) {
                data = this.data;
              }
              var key = this.key;
              var type = this.type;
              this.loader.emit(Events.FILE_COMPLETE, key, type, data);
              this.loader.emit(Events.FILE_KEY_COMPLETE + type + "-" + key, key, type, data);
              this.loader.flagForRemoval(this);
            },
            destroy: function () {
              this.loader = null;
              this.cache = null;
              this.xhrSettings = null;
              this.multiFile = null;
              this.linkFile = null;
              this.data = null;
            }
          });
          File.createObjectURL = function (image, blob, defaultType) {
            if (typeof URL === "function") {
              image.src = URL.createObjectURL(blob);
            } else {
              var reader = new FileReader();
              reader.onload = function () {
                image.removeAttribute("crossOrigin");
                image.src = "data:" + (blob.type || defaultType) + ";base64," + reader.result.split(",")[1];
              };
              reader.onerror = image.onerror;
              reader.readAsDataURL(blob);
            }
          };
          File.revokeObjectURL = function (image) {
            if (typeof URL === "function") {
              URL.revokeObjectURL(image.src);
            }
          };
          module2.exports = File;
        }, function (module2, exports2) {
          var corePlugins = {};
          var customPlugins = {};
          var PluginCache = {};
          PluginCache.register = function (key, plugin, mapping, custom) {
            if (custom === void 0) {
              custom = false;
            }
            corePlugins[key] = {
              plugin,
              mapping,
              custom
            };
          };
          PluginCache.registerCustom = function (key, plugin, mapping, data) {
            customPlugins[key] = {
              plugin,
              mapping,
              data
            };
          };
          PluginCache.hasCore = function (key) {
            return corePlugins.hasOwnProperty(key);
          };
          PluginCache.hasCustom = function (key) {
            return customPlugins.hasOwnProperty(key);
          };
          PluginCache.getCore = function (key) {
            return corePlugins[key];
          };
          PluginCache.getCustom = function (key) {
            return customPlugins[key];
          };
          PluginCache.getCustomClass = function (key) {
            return customPlugins.hasOwnProperty(key) ? customPlugins[key].plugin : null;
          };
          PluginCache.remove = function (key) {
            if (corePlugins.hasOwnProperty(key)) {
              delete corePlugins[key];
            }
          };
          PluginCache.removeCustom = function (key) {
            if (customPlugins.hasOwnProperty(key)) {
              delete customPlugins[key];
            }
          };
          PluginCache.destroyCorePlugins = function () {
            for (var key in corePlugins) {
              if (corePlugins.hasOwnProperty(key)) {
                delete corePlugins[key];
              }
            }
          };
          PluginCache.destroyCustomPlugins = function () {
            for (var key in customPlugins) {
              if (customPlugins.hasOwnProperty(key)) {
                delete customPlugins[key];
              }
            }
          };
          module2.exports = PluginCache;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var MATH_CONST = __webpack_require__(14);
          var Vector2 = __webpack_require__(3);
          var TransformMatrix = new Class({
            initialize: function TransformMatrix2(a, b, c, d, tx, ty) {
              if (a === void 0) {
                a = 1;
              }
              if (b === void 0) {
                b = 0;
              }
              if (c === void 0) {
                c = 0;
              }
              if (d === void 0) {
                d = 1;
              }
              if (tx === void 0) {
                tx = 0;
              }
              if (ty === void 0) {
                ty = 0;
              }
              this.matrix = new Float32Array([a, b, c, d, tx, ty, 0, 0, 1]);
              this.decomposedMatrix = {
                translateX: 0,
                translateY: 0,
                scaleX: 1,
                scaleY: 1,
                rotation: 0
              };
            },
            a: {
              get: function () {
                return this.matrix[0];
              },
              set: function (value) {
                this.matrix[0] = value;
              }
            },
            b: {
              get: function () {
                return this.matrix[1];
              },
              set: function (value) {
                this.matrix[1] = value;
              }
            },
            c: {
              get: function () {
                return this.matrix[2];
              },
              set: function (value) {
                this.matrix[2] = value;
              }
            },
            d: {
              get: function () {
                return this.matrix[3];
              },
              set: function (value) {
                this.matrix[3] = value;
              }
            },
            e: {
              get: function () {
                return this.matrix[4];
              },
              set: function (value) {
                this.matrix[4] = value;
              }
            },
            f: {
              get: function () {
                return this.matrix[5];
              },
              set: function (value) {
                this.matrix[5] = value;
              }
            },
            tx: {
              get: function () {
                return this.matrix[4];
              },
              set: function (value) {
                this.matrix[4] = value;
              }
            },
            ty: {
              get: function () {
                return this.matrix[5];
              },
              set: function (value) {
                this.matrix[5] = value;
              }
            },
            rotation: {
              get: function () {
                return Math.acos(this.a / this.scaleX) * (Math.atan(-this.c / this.a) < 0 ? -1 : 1);
              }
            },
            rotationNormalized: {
              get: function () {
                var matrix = this.matrix;
                var a = matrix[0];
                var b = matrix[1];
                var c = matrix[2];
                var d = matrix[3];
                if (a || b) {
                  return b > 0 ? Math.acos(a / this.scaleX) : -Math.acos(a / this.scaleX);
                } else if (c || d) {
                  return MATH_CONST.TAU - (d > 0 ? Math.acos(-c / this.scaleY) : -Math.acos(c / this.scaleY));
                } else {
                  return 0;
                }
              }
            },
            scaleX: {
              get: function () {
                return Math.sqrt(this.a * this.a + this.b * this.b);
              }
            },
            scaleY: {
              get: function () {
                return Math.sqrt(this.c * this.c + this.d * this.d);
              }
            },
            loadIdentity: function () {
              var matrix = this.matrix;
              matrix[0] = 1;
              matrix[1] = 0;
              matrix[2] = 0;
              matrix[3] = 1;
              matrix[4] = 0;
              matrix[5] = 0;
              return this;
            },
            translate: function (x, y) {
              var matrix = this.matrix;
              matrix[4] = matrix[0] * x + matrix[2] * y + matrix[4];
              matrix[5] = matrix[1] * x + matrix[3] * y + matrix[5];
              return this;
            },
            scale: function (x, y) {
              var matrix = this.matrix;
              matrix[0] *= x;
              matrix[1] *= x;
              matrix[2] *= y;
              matrix[3] *= y;
              return this;
            },
            rotate: function (angle) {
              var sin = Math.sin(angle);
              var cos = Math.cos(angle);
              var matrix = this.matrix;
              var a = matrix[0];
              var b = matrix[1];
              var c = matrix[2];
              var d = matrix[3];
              matrix[0] = a * cos + c * sin;
              matrix[1] = b * cos + d * sin;
              matrix[2] = a * -sin + c * cos;
              matrix[3] = b * -sin + d * cos;
              return this;
            },
            multiply: function (rhs, out) {
              var matrix = this.matrix;
              var source = rhs.matrix;
              var localA = matrix[0];
              var localB = matrix[1];
              var localC = matrix[2];
              var localD = matrix[3];
              var localE = matrix[4];
              var localF = matrix[5];
              var sourceA = source[0];
              var sourceB = source[1];
              var sourceC = source[2];
              var sourceD = source[3];
              var sourceE = source[4];
              var sourceF = source[5];
              var destinationMatrix = out === void 0 ? this : out;
              destinationMatrix.a = sourceA * localA + sourceB * localC;
              destinationMatrix.b = sourceA * localB + sourceB * localD;
              destinationMatrix.c = sourceC * localA + sourceD * localC;
              destinationMatrix.d = sourceC * localB + sourceD * localD;
              destinationMatrix.e = sourceE * localA + sourceF * localC + localE;
              destinationMatrix.f = sourceE * localB + sourceF * localD + localF;
              return destinationMatrix;
            },
            multiplyWithOffset: function (src, offsetX, offsetY) {
              var matrix = this.matrix;
              var otherMatrix = src.matrix;
              var a0 = matrix[0];
              var b0 = matrix[1];
              var c0 = matrix[2];
              var d0 = matrix[3];
              var tx0 = matrix[4];
              var ty0 = matrix[5];
              var pse = offsetX * a0 + offsetY * c0 + tx0;
              var psf = offsetX * b0 + offsetY * d0 + ty0;
              var a1 = otherMatrix[0];
              var b1 = otherMatrix[1];
              var c1 = otherMatrix[2];
              var d1 = otherMatrix[3];
              var tx1 = otherMatrix[4];
              var ty1 = otherMatrix[5];
              matrix[0] = a1 * a0 + b1 * c0;
              matrix[1] = a1 * b0 + b1 * d0;
              matrix[2] = c1 * a0 + d1 * c0;
              matrix[3] = c1 * b0 + d1 * d0;
              matrix[4] = tx1 * a0 + ty1 * c0 + pse;
              matrix[5] = tx1 * b0 + ty1 * d0 + psf;
              return this;
            },
            transform: function (a, b, c, d, tx, ty) {
              var matrix = this.matrix;
              var a0 = matrix[0];
              var b0 = matrix[1];
              var c0 = matrix[2];
              var d0 = matrix[3];
              var tx0 = matrix[4];
              var ty0 = matrix[5];
              matrix[0] = a * a0 + b * c0;
              matrix[1] = a * b0 + b * d0;
              matrix[2] = c * a0 + d * c0;
              matrix[3] = c * b0 + d * d0;
              matrix[4] = tx * a0 + ty * c0 + tx0;
              matrix[5] = tx * b0 + ty * d0 + ty0;
              return this;
            },
            transformPoint: function (x, y, point) {
              if (point === void 0) {
                point = {
                  x: 0,
                  y: 0
                };
              }
              var matrix = this.matrix;
              var a = matrix[0];
              var b = matrix[1];
              var c = matrix[2];
              var d = matrix[3];
              var tx = matrix[4];
              var ty = matrix[5];
              point.x = x * a + y * c + tx;
              point.y = x * b + y * d + ty;
              return point;
            },
            invert: function () {
              var matrix = this.matrix;
              var a = matrix[0];
              var b = matrix[1];
              var c = matrix[2];
              var d = matrix[3];
              var tx = matrix[4];
              var ty = matrix[5];
              var n = a * d - b * c;
              matrix[0] = d / n;
              matrix[1] = -b / n;
              matrix[2] = -c / n;
              matrix[3] = a / n;
              matrix[4] = (c * ty - d * tx) / n;
              matrix[5] = -(a * ty - b * tx) / n;
              return this;
            },
            copyFrom: function (src) {
              var matrix = this.matrix;
              matrix[0] = src.a;
              matrix[1] = src.b;
              matrix[2] = src.c;
              matrix[3] = src.d;
              matrix[4] = src.e;
              matrix[5] = src.f;
              return this;
            },
            copyFromArray: function (src) {
              var matrix = this.matrix;
              matrix[0] = src[0];
              matrix[1] = src[1];
              matrix[2] = src[2];
              matrix[3] = src[3];
              matrix[4] = src[4];
              matrix[5] = src[5];
              return this;
            },
            copyToContext: function (ctx) {
              var matrix = this.matrix;
              ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
              return ctx;
            },
            setToContext: function (ctx) {
              var matrix = this.matrix;
              ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
              return ctx;
            },
            copyToArray: function (out) {
              var matrix = this.matrix;
              if (out === void 0) {
                out = [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]];
              } else {
                out[0] = matrix[0];
                out[1] = matrix[1];
                out[2] = matrix[2];
                out[3] = matrix[3];
                out[4] = matrix[4];
                out[5] = matrix[5];
              }
              return out;
            },
            setTransform: function (a, b, c, d, tx, ty) {
              var matrix = this.matrix;
              matrix[0] = a;
              matrix[1] = b;
              matrix[2] = c;
              matrix[3] = d;
              matrix[4] = tx;
              matrix[5] = ty;
              return this;
            },
            decomposeMatrix: function () {
              var decomposedMatrix = this.decomposedMatrix;
              var matrix = this.matrix;
              var a = matrix[0];
              var b = matrix[1];
              var c = matrix[2];
              var d = matrix[3];
              var determ = a * d - b * c;
              decomposedMatrix.translateX = matrix[4];
              decomposedMatrix.translateY = matrix[5];
              if (a || b) {
                var r = Math.sqrt(a * a + b * b);
                decomposedMatrix.rotation = b > 0 ? Math.acos(a / r) : -Math.acos(a / r);
                decomposedMatrix.scaleX = r;
                decomposedMatrix.scaleY = determ / r;
              } else if (c || d) {
                var s = Math.sqrt(c * c + d * d);
                decomposedMatrix.rotation = Math.PI * 0.5 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));
                decomposedMatrix.scaleX = determ / s;
                decomposedMatrix.scaleY = s;
              } else {
                decomposedMatrix.rotation = 0;
                decomposedMatrix.scaleX = 0;
                decomposedMatrix.scaleY = 0;
              }
              return decomposedMatrix;
            },
            applyITRS: function (x, y, rotation, scaleX, scaleY) {
              var matrix = this.matrix;
              var radianSin = Math.sin(rotation);
              var radianCos = Math.cos(rotation);
              matrix[4] = x;
              matrix[5] = y;
              matrix[0] = radianCos * scaleX;
              matrix[1] = radianSin * scaleX;
              matrix[2] = -radianSin * scaleY;
              matrix[3] = radianCos * scaleY;
              return this;
            },
            applyInverse: function (x, y, output) {
              if (output === void 0) {
                output = new Vector2();
              }
              var matrix = this.matrix;
              var a = matrix[0];
              var b = matrix[1];
              var c = matrix[2];
              var d = matrix[3];
              var tx = matrix[4];
              var ty = matrix[5];
              var id = 1 / (a * d + c * -b);
              output.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;
              output.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;
              return output;
            },
            getX: function (x, y) {
              return x * this.a + y * this.c + this.e;
            },
            getY: function (x, y) {
              return x * this.b + y * this.d + this.f;
            },
            getXRound: function (x, y, round) {
              var v = this.getX(x, y);
              if (round) {
                v = Math.round(v);
              }
              return v;
            },
            getYRound: function (x, y, round) {
              var v = this.getY(x, y);
              if (round) {
                v = Math.round(v);
              }
              return v;
            },
            getCSSMatrix: function () {
              var m = this.matrix;
              return "matrix(" + m[0] + "," + m[1] + "," + m[2] + "," + m[3] + "," + m[4] + "," + m[5] + ")";
            },
            destroy: function () {
              this.matrix = null;
              this.decomposedMatrix = null;
            }
          });
          module2.exports = TransformMatrix;
        }, function (module2, exports2, __webpack_require__) {
          var GetFastValue = __webpack_require__(2);
          var GetTilesWithin = function (tileX, tileY, width, height, filteringOptions, layer) {
            if (tileX === void 0) {
              tileX = 0;
            }
            if (tileY === void 0) {
              tileY = 0;
            }
            if (width === void 0) {
              width = layer.width;
            }
            if (height === void 0) {
              height = layer.height;
            }
            if (!filteringOptions) {
              filteringOptions = {};
            }
            var isNotEmpty = GetFastValue(filteringOptions, "isNotEmpty", false);
            var isColliding = GetFastValue(filteringOptions, "isColliding", false);
            var hasInterestingFace = GetFastValue(filteringOptions, "hasInterestingFace", false);
            if (tileX < 0) {
              width += tileX;
              tileX = 0;
            }
            if (tileY < 0) {
              height += tileY;
              tileY = 0;
            }
            if (tileX + width > layer.width) {
              width = Math.max(layer.width - tileX, 0);
            }
            if (tileY + height > layer.height) {
              height = Math.max(layer.height - tileY, 0);
            }
            var results = [];
            for (var ty = tileY; ty < tileY + height; ty++) {
              for (var tx = tileX; tx < tileX + width; tx++) {
                var tile = layer.data[ty][tx];
                if (tile !== null) {
                  if (isNotEmpty && tile.index === -1) {
                    continue;
                  }
                  if (isColliding && !tile.collides) {
                    continue;
                  }
                  if (hasInterestingFace && !tile.hasInterestingFace) {
                    continue;
                  }
                  results.push(tile);
                }
              }
            }
            return results;
          };
          module2.exports = GetTilesWithin;
        }, function (module2, exports2) {
          var PropertyValueSet = function (items, key, value, step, index, direction) {
            if (step === void 0) {
              step = 0;
            }
            if (index === void 0) {
              index = 0;
            }
            if (direction === void 0) {
              direction = 1;
            }
            var i;
            var t = 0;
            var end = items.length;
            if (direction === 1) {
              for (i = index; i < end; i++) {
                items[i][key] = value + t * step;
                t++;
              }
            } else {
              for (i = index; i >= 0; i--) {
                items[i][key] = value + t * step;
                t++;
              }
            }
            return items;
          };
          module2.exports = PropertyValueSet;
        }, function (module2, exports2, __webpack_require__) {
          var BlendModes = __webpack_require__(35);
          var GetAdvancedValue = __webpack_require__(13);
          var BuildGameObject = function (scene, gameObject, config) {
            gameObject.x = GetAdvancedValue(config, "x", 0);
            gameObject.y = GetAdvancedValue(config, "y", 0);
            gameObject.depth = GetAdvancedValue(config, "depth", 0);
            gameObject.flipX = GetAdvancedValue(config, "flipX", false);
            gameObject.flipY = GetAdvancedValue(config, "flipY", false);
            var scale = GetAdvancedValue(config, "scale", null);
            if (typeof scale === "number") {
              gameObject.setScale(scale);
            } else if (scale !== null) {
              gameObject.scaleX = GetAdvancedValue(scale, "x", 1);
              gameObject.scaleY = GetAdvancedValue(scale, "y", 1);
            }
            var scrollFactor = GetAdvancedValue(config, "scrollFactor", null);
            if (typeof scrollFactor === "number") {
              gameObject.setScrollFactor(scrollFactor);
            } else if (scrollFactor !== null) {
              gameObject.scrollFactorX = GetAdvancedValue(scrollFactor, "x", 1);
              gameObject.scrollFactorY = GetAdvancedValue(scrollFactor, "y", 1);
            }
            gameObject.rotation = GetAdvancedValue(config, "rotation", 0);
            var angle = GetAdvancedValue(config, "angle", null);
            if (angle !== null) {
              gameObject.angle = angle;
            }
            gameObject.alpha = GetAdvancedValue(config, "alpha", 1);
            var origin = GetAdvancedValue(config, "origin", null);
            if (typeof origin === "number") {
              gameObject.setOrigin(origin);
            } else if (origin !== null) {
              var ox = GetAdvancedValue(origin, "x", 0.5);
              var oy = GetAdvancedValue(origin, "y", 0.5);
              gameObject.setOrigin(ox, oy);
            }
            gameObject.blendMode = GetAdvancedValue(config, "blendMode", BlendModes.NORMAL);
            gameObject.visible = GetAdvancedValue(config, "visible", true);
            var add = GetAdvancedValue(config, "add", true);
            if (add) {
              scene.sys.displayList.add(gameObject);
            }
            if (gameObject.preUpdate) {
              scene.sys.updateList.add(gameObject);
            }
            return gameObject;
          };
          module2.exports = BuildGameObject;
        }, function (module2, exports2) {
          module2.exports = {
            ORTHOGONAL: 0,
            ISOMETRIC: 1,
            STAGGERED: 2,
            HEXAGONAL: 3
          };
        }, function (module2, exports2, __webpack_require__) {
          var GetCalcMatrix = __webpack_require__(19);
          var SetTransform = function (renderer, ctx, src, camera, parentMatrix) {
            var alpha = camera.alpha * src.alpha;
            if (alpha <= 0) {
              return false;
            }
            var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
            ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
            ctx.globalAlpha = alpha;
            ctx.save();
            calcMatrix.setToContext(ctx);
            ctx.imageSmoothingEnabled = !(!renderer.antialias || src.frame && src.frame.source.scaleMode);
            return true;
          };
          module2.exports = SetTransform;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(33);
          var Smoothing = __webpack_require__(192);
          var pool = [];
          var _disableContextSmoothing = false;
          var CanvasPool = function () {
            var create = function (parent, width, height, canvasType, selfParent) {
              if (width === void 0) {
                width = 1;
              }
              if (height === void 0) {
                height = 1;
              }
              if (canvasType === void 0) {
                canvasType = CONST.CANVAS;
              }
              if (selfParent === void 0) {
                selfParent = false;
              }
              var canvas;
              var container = first(canvasType);
              if (container === null) {
                container = {
                  parent,
                  canvas: document.createElement("canvas"),
                  type: canvasType
                };
                if (canvasType === CONST.CANVAS) {
                  pool.push(container);
                }
                canvas = container.canvas;
              } else {
                container.parent = parent;
                canvas = container.canvas;
              }
              if (selfParent) {
                container.parent = canvas;
              }
              canvas.width = width;
              canvas.height = height;
              if (_disableContextSmoothing && canvasType === CONST.CANVAS) {
                Smoothing.disable(canvas.getContext("2d"));
              }
              return canvas;
            };
            var create2D = function (parent, width, height) {
              return create(parent, width, height, CONST.CANVAS);
            };
            var createWebGL = function (parent, width, height) {
              return create(parent, width, height, CONST.WEBGL);
            };
            var first = function (canvasType) {
              if (canvasType === void 0) {
                canvasType = CONST.CANVAS;
              }
              if (canvasType === CONST.WEBGL) {
                return null;
              }
              for (var i = 0; i < pool.length; i++) {
                var container = pool[i];
                if (!container.parent && container.type === canvasType) {
                  return container;
                }
              }
              return null;
            };
            var remove = function (parent) {
              var isCanvas = parent instanceof HTMLCanvasElement;
              pool.forEach(function (container) {
                if (isCanvas && container.canvas === parent || !isCanvas && container.parent === parent) {
                  container.parent = null;
                  container.canvas.width = 1;
                  container.canvas.height = 1;
                }
              });
            };
            var total = function () {
              var c = 0;
              pool.forEach(function (container) {
                if (container.parent) {
                  c++;
                }
              });
              return c;
            };
            var free = function () {
              return pool.length - total();
            };
            var disableSmoothing = function () {
              _disableContextSmoothing = true;
            };
            var enableSmoothing = function () {
              _disableContextSmoothing = false;
            };
            return {
              create2D,
              create,
              createWebGL,
              disableSmoothing,
              enableSmoothing,
              first,
              free,
              pool,
              remove,
              total
            };
          };
          module2.exports = CanvasPool();
        }, function (module2, exports2) {
          var Common = {};
          module2.exports = Common;
          (function () {
            Common._nextId = 0;
            Common._seed = 0;
            Common._nowStartTime = +new Date();
            Common.extend = function (obj, deep) {
              var argsStart, args, deepClone;
              if (typeof deep === "boolean") {
                argsStart = 2;
                deepClone = deep;
              } else {
                argsStart = 1;
                deepClone = true;
              }
              for (var i = argsStart; i < arguments.length; i++) {
                var source = arguments[i];
                if (source) {
                  for (var prop in source) {
                    if (deepClone && source[prop] && source[prop].constructor === Object) {
                      if (!obj[prop] || obj[prop].constructor === Object) {
                        obj[prop] = obj[prop] || ({});
                        Common.extend(obj[prop], deepClone, source[prop]);
                      } else {
                        obj[prop] = source[prop];
                      }
                    } else {
                      obj[prop] = source[prop];
                    }
                  }
                }
              }
              return obj;
            };
            Common.clone = function (obj, deep) {
              return Common.extend({}, deep, obj);
            };
            Common.keys = function (obj) {
              if (Object.keys) return Object.keys(obj);
              var keys = [];
              for (var key in obj) keys.push(key);
              return keys;
            };
            Common.values = function (obj) {
              var values = [];
              if (Object.keys) {
                var keys = Object.keys(obj);
                for (var i = 0; i < keys.length; i++) {
                  values.push(obj[keys[i]]);
                }
                return values;
              }
              for (var key in obj) values.push(obj[key]);
              return values;
            };
            Common.get = function (obj, path, begin, end) {
              path = path.split(".").slice(begin, end);
              for (var i = 0; i < path.length; i += 1) {
                obj = obj[path[i]];
              }
              return obj;
            };
            Common.set = function (obj, path, val, begin, end) {
              var parts = path.split(".").slice(begin, end);
              Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;
              return val;
            };
            Common.shuffle = function (array) {
              for (var i = array.length - 1; i > 0; i--) {
                var j = Math.floor(Common.random() * (i + 1));
                var temp = array[i];
                array[i] = array[j];
                array[j] = temp;
              }
              return array;
            };
            Common.choose = function (choices) {
              return choices[Math.floor(Common.random() * choices.length)];
            };
            Common.isElement = function (obj) {
              if (typeof HTMLElement !== "undefined") {
                return obj instanceof HTMLElement;
              }
              return !!(obj && obj.nodeType && obj.nodeName);
            };
            Common.isArray = function (obj) {
              return Object.prototype.toString.call(obj) === "[object Array]";
            };
            Common.isFunction = function (obj) {
              return typeof obj === "function";
            };
            Common.isPlainObject = function (obj) {
              return typeof obj === "object" && obj.constructor === Object;
            };
            Common.isString = function (obj) {
              return Object.prototype.toString.call(obj) === "[object String]";
            };
            Common.clamp = function (value, min, max) {
              if (value < min) return min;
              if (value > max) return max;
              return value;
            };
            Common.sign = function (value) {
              return value < 0 ? -1 : 1;
            };
            Common.now = function () {
              if (typeof window !== "undefined" && window.performance) {
                if (window.performance.now) {
                  return window.performance.now();
                } else if (window.performance.webkitNow) {
                  return window.performance.webkitNow();
                }
              }
              return new Date() - Common._nowStartTime;
            };
            Common.random = function (min, max) {
              min = typeof min !== "undefined" ? min : 0;
              max = typeof max !== "undefined" ? max : 1;
              return min + _seededRandom() * (max - min);
            };
            var _seededRandom = function () {
              Common._seed = (Common._seed * 9301 + 49297) % 233280;
              return Common._seed / 233280;
            };
            Common.colorToNumber = function (colorString) {
              colorString = colorString.replace("#", "");
              if (colorString.length == 3) {
                colorString = colorString.charAt(0) + colorString.charAt(0) + colorString.charAt(1) + colorString.charAt(1) + colorString.charAt(2) + colorString.charAt(2);
              }
              return parseInt(colorString, 16);
            };
            Common.logLevel = 1;
            Common.log = function () {
              if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
                console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
              }
            };
            Common.info = function () {
              if (console && Common.logLevel > 0 && Common.logLevel <= 2) {
                console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
              }
            };
            Common.warn = function () {
              if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
                console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
              }
            };
            Common.nextId = function () {
              return Common._nextId++;
            };
            Common.indexOf = function (haystack, needle) {
              if (haystack.indexOf) return haystack.indexOf(needle);
              for (var i = 0; i < haystack.length; i++) {
                if (haystack[i] === needle) return i;
              }
              return -1;
            };
            Common.map = function (list, func) {
              if (list.map) {
                return list.map(func);
              }
              var mapped = [];
              for (var i = 0; i < list.length; i += 1) {
                mapped.push(func(list[i]));
              }
              return mapped;
            };
            Common.topologicalSort = function (graph) {
              var result = [], visited = [], temp = [];
              for (var node in graph) {
                if (!visited[node] && !temp[node]) {
                  Common._topologicalSort(node, visited, temp, graph, result);
                }
              }
              return result;
            };
            Common._topologicalSort = function (node, visited, temp, graph, result) {
              var neighbors = graph[node] || [];
              temp[node] = true;
              for (var i = 0; i < neighbors.length; i += 1) {
                var neighbor = neighbors[i];
                if (temp[neighbor]) {
                  continue;
                }
                if (!visited[neighbor]) {
                  Common._topologicalSort(neighbor, visited, temp, graph, result);
                }
              }
              temp[node] = false;
              visited[node] = true;
              result.push(node);
            };
            Common.chain = function () {
              var funcs = [];
              for (var i = 0; i < arguments.length; i += 1) {
                var func = arguments[i];
                if (func._chained) {
                  funcs.push.apply(funcs, func._chained);
                } else {
                  funcs.push(func);
                }
              }
              var chain = function () {
                var lastResult, args = new Array(arguments.length);
                for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
                  args[i2] = arguments[i2];
                }
                for (i2 = 0; i2 < funcs.length; i2 += 1) {
                  var result = funcs[i2].apply(lastResult, args);
                  if (typeof result !== "undefined") {
                    lastResult = result;
                  }
                }
                return lastResult;
              };
              chain._chained = funcs;
              return chain;
            };
            Common.chainPathBefore = function (base, path, func) {
              return Common.set(base, path, Common.chain(func, Common.get(base, path)));
            };
            Common.chainPathAfter = function (base, path, func) {
              return Common.set(base, path, Common.chain(Common.get(base, path), func));
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          var CONST = {
            VERSION: "3.55.2",
            BlendModes: __webpack_require__(35),
            ScaleModes: __webpack_require__(168),
            AUTO: 0,
            CANVAS: 1,
            WEBGL: 2,
            HEADLESS: 3,
            FOREVER: -1,
            NONE: 4,
            UP: 5,
            DOWN: 6,
            LEFT: 7,
            RIGHT: 8
          };
          module2.exports = CONST;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var Line = __webpack_require__(47);
          var Shape = new Class({
            Extends: GameObject,
            Mixins: [Components.AlphaSingle, Components.BlendMode, Components.Depth, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Transform, Components.Visible],
            initialize: function Shape2(scene, type, data) {
              if (type === void 0) {
                type = "Shape";
              }
              GameObject.call(this, scene, type);
              this.geom = data;
              this.pathData = [];
              this.pathIndexes = [];
              this.fillColor = 16777215;
              this.fillAlpha = 1;
              this.strokeColor = 16777215;
              this.strokeAlpha = 1;
              this.lineWidth = 1;
              this.isFilled = false;
              this.isStroked = false;
              this.closePath = true;
              this._tempLine = new Line();
              this.width = 0;
              this.height = 0;
              this.initPipeline();
            },
            setFillStyle: function (color, alpha) {
              if (alpha === void 0) {
                alpha = 1;
              }
              if (color === void 0) {
                this.isFilled = false;
              } else {
                this.fillColor = color;
                this.fillAlpha = alpha;
                this.isFilled = true;
              }
              return this;
            },
            setStrokeStyle: function (lineWidth, color, alpha) {
              if (alpha === void 0) {
                alpha = 1;
              }
              if (lineWidth === void 0) {
                this.isStroked = false;
              } else {
                this.lineWidth = lineWidth;
                this.strokeColor = color;
                this.strokeAlpha = alpha;
                this.isStroked = true;
              }
              return this;
            },
            setClosePath: function (value) {
              this.closePath = value;
              return this;
            },
            setSize: function (width, height) {
              this.width = width;
              this.height = height;
              return this;
            },
            setDisplaySize: function (width, height) {
              this.displayWidth = width;
              this.displayHeight = height;
              return this;
            },
            preDestroy: function () {
              this.geom = null;
              this._tempLine = null;
              this.pathData = [];
              this.pathIndexes = [];
            },
            displayWidth: {
              get: function () {
                return this.scaleX * this.width;
              },
              set: function (value) {
                this.scaleX = value / this.width;
              }
            },
            displayHeight: {
              get: function () {
                return this.scaleY * this.height;
              },
              set: function (value) {
                this.scaleY = value / this.height;
              }
            }
          });
          module2.exports = Shape;
        }, function (module2, exports2) {
          module2.exports = {
            SKIP_CHECK: -1,
            NORMAL: 0,
            ADD: 1,
            MULTIPLY: 2,
            SCREEN: 3,
            OVERLAY: 4,
            DARKEN: 5,
            LIGHTEN: 6,
            COLOR_DODGE: 7,
            COLOR_BURN: 8,
            HARD_LIGHT: 9,
            SOFT_LIGHT: 10,
            DIFFERENCE: 11,
            EXCLUSION: 12,
            HUE: 13,
            SATURATION: 14,
            COLOR: 15,
            LUMINOSITY: 16,
            ERASE: 17,
            SOURCE_IN: 18,
            SOURCE_OUT: 19,
            SOURCE_ATOP: 20,
            DESTINATION_OVER: 21,
            DESTINATION_IN: 22,
            DESTINATION_OUT: 23,
            DESTINATION_ATOP: 24,
            LIGHTER: 25,
            COPY: 26,
            XOR: 27
          };
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(14);
          var DegToRad = function (degrees) {
            return degrees * CONST.DEG_TO_RAD;
          };
          module2.exports = DegToRad;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            DESTROY: __webpack_require__(743),
            FADE_IN_COMPLETE: __webpack_require__(744),
            FADE_IN_START: __webpack_require__(745),
            FADE_OUT_COMPLETE: __webpack_require__(746),
            FADE_OUT_START: __webpack_require__(747),
            FLASH_COMPLETE: __webpack_require__(748),
            FLASH_START: __webpack_require__(749),
            FOLLOW_UPDATE: __webpack_require__(750),
            PAN_COMPLETE: __webpack_require__(751),
            PAN_START: __webpack_require__(752),
            POST_RENDER: __webpack_require__(753),
            PRE_RENDER: __webpack_require__(754),
            ROTATE_COMPLETE: __webpack_require__(755),
            ROTATE_START: __webpack_require__(756),
            SHAKE_COMPLETE: __webpack_require__(757),
            SHAKE_START: __webpack_require__(758),
            ZOOM_COMPLETE: __webpack_require__(759),
            ZOOM_START: __webpack_require__(760)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GetColor = __webpack_require__(103);
          var GetColor32 = __webpack_require__(328);
          var HSVToRGB = __webpack_require__(188);
          var RGBToHSV = __webpack_require__(329);
          var Color = new Class({
            initialize: function Color2(red, green, blue, alpha) {
              if (red === void 0) {
                red = 0;
              }
              if (green === void 0) {
                green = 0;
              }
              if (blue === void 0) {
                blue = 0;
              }
              if (alpha === void 0) {
                alpha = 255;
              }
              this.r = 0;
              this.g = 0;
              this.b = 0;
              this.a = 255;
              this._h = 0;
              this._s = 0;
              this._v = 0;
              this._locked = false;
              this.gl = [0, 0, 0, 1];
              this._color = 0;
              this._color32 = 0;
              this._rgba = "";
              this.setTo(red, green, blue, alpha);
            },
            transparent: function () {
              this._locked = true;
              this.red = 0;
              this.green = 0;
              this.blue = 0;
              this.alpha = 0;
              this._locked = false;
              return this.update(true);
            },
            setTo: function (red, green, blue, alpha, updateHSV) {
              if (alpha === void 0) {
                alpha = 255;
              }
              if (updateHSV === void 0) {
                updateHSV = true;
              }
              this._locked = true;
              this.red = red;
              this.green = green;
              this.blue = blue;
              this.alpha = alpha;
              this._locked = false;
              return this.update(updateHSV);
            },
            setGLTo: function (red, green, blue, alpha) {
              if (alpha === void 0) {
                alpha = 1;
              }
              this._locked = true;
              this.redGL = red;
              this.greenGL = green;
              this.blueGL = blue;
              this.alphaGL = alpha;
              this._locked = false;
              return this.update(true);
            },
            setFromRGB: function (color) {
              this._locked = true;
              this.red = color.r;
              this.green = color.g;
              this.blue = color.b;
              if (color.hasOwnProperty("a")) {
                this.alpha = color.a;
              }
              this._locked = false;
              return this.update(true);
            },
            setFromHSV: function (h, s, v) {
              return HSVToRGB(h, s, v, this);
            },
            update: function (updateHSV) {
              if (updateHSV === void 0) {
                updateHSV = false;
              }
              if (this._locked) {
                return this;
              }
              var r = this.r;
              var g = this.g;
              var b = this.b;
              var a = this.a;
              this._color = GetColor(r, g, b);
              this._color32 = GetColor32(r, g, b, a);
              this._rgba = "rgba(" + r + "," + g + "," + b + "," + a / 255 + ")";
              if (updateHSV) {
                RGBToHSV(r, g, b, this);
              }
              return this;
            },
            updateHSV: function () {
              var r = this.r;
              var g = this.g;
              var b = this.b;
              RGBToHSV(r, g, b, this);
              return this;
            },
            clone: function () {
              return new Color(this.r, this.g, this.b, this.a);
            },
            gray: function (shade) {
              return this.setTo(shade, shade, shade);
            },
            random: function (min, max) {
              if (min === void 0) {
                min = 0;
              }
              if (max === void 0) {
                max = 255;
              }
              var r = Math.floor(min + Math.random() * (max - min));
              var g = Math.floor(min + Math.random() * (max - min));
              var b = Math.floor(min + Math.random() * (max - min));
              return this.setTo(r, g, b);
            },
            randomGray: function (min, max) {
              if (min === void 0) {
                min = 0;
              }
              if (max === void 0) {
                max = 255;
              }
              var s = Math.floor(min + Math.random() * (max - min));
              return this.setTo(s, s, s);
            },
            saturate: function (amount) {
              this.s += amount / 100;
              return this;
            },
            desaturate: function (amount) {
              this.s -= amount / 100;
              return this;
            },
            lighten: function (amount) {
              this.v += amount / 100;
              return this;
            },
            darken: function (amount) {
              this.v -= amount / 100;
              return this;
            },
            brighten: function (amount) {
              var r = this.r;
              var g = this.g;
              var b = this.b;
              r = Math.max(0, Math.min(255, r - Math.round(255 * -(amount / 100))));
              g = Math.max(0, Math.min(255, g - Math.round(255 * -(amount / 100))));
              b = Math.max(0, Math.min(255, b - Math.round(255 * -(amount / 100))));
              return this.setTo(r, g, b);
            },
            color: {
              get: function () {
                return this._color;
              }
            },
            color32: {
              get: function () {
                return this._color32;
              }
            },
            rgba: {
              get: function () {
                return this._rgba;
              }
            },
            redGL: {
              get: function () {
                return this.gl[0];
              },
              set: function (value) {
                this.gl[0] = Math.min(Math.abs(value), 1);
                this.r = Math.floor(this.gl[0] * 255);
                this.update(true);
              }
            },
            greenGL: {
              get: function () {
                return this.gl[1];
              },
              set: function (value) {
                this.gl[1] = Math.min(Math.abs(value), 1);
                this.g = Math.floor(this.gl[1] * 255);
                this.update(true);
              }
            },
            blueGL: {
              get: function () {
                return this.gl[2];
              },
              set: function (value) {
                this.gl[2] = Math.min(Math.abs(value), 1);
                this.b = Math.floor(this.gl[2] * 255);
                this.update(true);
              }
            },
            alphaGL: {
              get: function () {
                return this.gl[3];
              },
              set: function (value) {
                this.gl[3] = Math.min(Math.abs(value), 1);
                this.a = Math.floor(this.gl[3] * 255);
                this.update();
              }
            },
            red: {
              get: function () {
                return this.r;
              },
              set: function (value) {
                value = Math.floor(Math.abs(value));
                this.r = Math.min(value, 255);
                this.gl[0] = value / 255;
                this.update(true);
              }
            },
            green: {
              get: function () {
                return this.g;
              },
              set: function (value) {
                value = Math.floor(Math.abs(value));
                this.g = Math.min(value, 255);
                this.gl[1] = value / 255;
                this.update(true);
              }
            },
            blue: {
              get: function () {
                return this.b;
              },
              set: function (value) {
                value = Math.floor(Math.abs(value));
                this.b = Math.min(value, 255);
                this.gl[2] = value / 255;
                this.update(true);
              }
            },
            alpha: {
              get: function () {
                return this.a;
              },
              set: function (value) {
                value = Math.floor(Math.abs(value));
                this.a = Math.min(value, 255);
                this.gl[3] = value / 255;
                this.update();
              }
            },
            h: {
              get: function () {
                return this._h;
              },
              set: function (value) {
                this._h = value;
                HSVToRGB(value, this._s, this._v, this);
              }
            },
            s: {
              get: function () {
                return this._s;
              },
              set: function (value) {
                this._s = value;
                HSVToRGB(this._h, value, this._v, this);
              }
            },
            v: {
              get: function () {
                return this._v;
              },
              set: function (value) {
                this._v = value;
                HSVToRGB(this._h, this._s, value, this);
              }
            }
          });
          module2.exports = Color;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Vector3 = new Class({
            initialize: function Vector32(x, y, z) {
              this.x = 0;
              this.y = 0;
              this.z = 0;
              if (typeof x === "object") {
                this.x = x.x || 0;
                this.y = x.y || 0;
                this.z = x.z || 0;
              } else {
                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;
              }
            },
            up: function () {
              this.x = 0;
              this.y = 1;
              this.z = 0;
              return this;
            },
            min: function (v) {
              this.x = Math.min(this.x, v.x);
              this.y = Math.min(this.y, v.y);
              this.z = Math.min(this.z, v.z);
              return this;
            },
            max: function (v) {
              this.x = Math.max(this.x, v.x);
              this.y = Math.max(this.y, v.y);
              this.z = Math.max(this.z, v.z);
              return this;
            },
            clone: function () {
              return new Vector3(this.x, this.y, this.z);
            },
            addVectors: function (a, b) {
              this.x = a.x + b.x;
              this.y = a.y + b.y;
              this.z = a.z + b.z;
              return this;
            },
            crossVectors: function (a, b) {
              var ax = a.x;
              var ay = a.y;
              var az = a.z;
              var bx = b.x;
              var by = b.y;
              var bz = b.z;
              this.x = ay * bz - az * by;
              this.y = az * bx - ax * bz;
              this.z = ax * by - ay * bx;
              return this;
            },
            equals: function (v) {
              return this.x === v.x && this.y === v.y && this.z === v.z;
            },
            copy: function (src) {
              this.x = src.x;
              this.y = src.y;
              this.z = src.z || 0;
              return this;
            },
            set: function (x, y, z) {
              if (typeof x === "object") {
                this.x = x.x || 0;
                this.y = x.y || 0;
                this.z = x.z || 0;
              } else {
                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;
              }
              return this;
            },
            setFromMatrixPosition: function (m) {
              return this.fromArray(m.val, 12);
            },
            setFromMatrixColumn: function (mat4, index) {
              return this.fromArray(mat4.val, index * 4);
            },
            fromArray: function (array, offset) {
              if (offset === void 0) {
                offset = 0;
              }
              this.x = array[offset];
              this.y = array[offset + 1];
              this.z = array[offset + 2];
              return this;
            },
            add: function (v) {
              this.x += v.x;
              this.y += v.y;
              this.z += v.z || 0;
              return this;
            },
            addScalar: function (s) {
              this.x += s;
              this.y += s;
              this.z += s;
              return this;
            },
            addScale: function (v, scale) {
              this.x += v.x * scale;
              this.y += v.y * scale;
              this.z += v.z * scale || 0;
              return this;
            },
            subtract: function (v) {
              this.x -= v.x;
              this.y -= v.y;
              this.z -= v.z || 0;
              return this;
            },
            multiply: function (v) {
              this.x *= v.x;
              this.y *= v.y;
              this.z *= v.z || 1;
              return this;
            },
            scale: function (scale) {
              if (isFinite(scale)) {
                this.x *= scale;
                this.y *= scale;
                this.z *= scale;
              } else {
                this.x = 0;
                this.y = 0;
                this.z = 0;
              }
              return this;
            },
            divide: function (v) {
              this.x /= v.x;
              this.y /= v.y;
              this.z /= v.z || 1;
              return this;
            },
            negate: function () {
              this.x = -this.x;
              this.y = -this.y;
              this.z = -this.z;
              return this;
            },
            distance: function (v) {
              var dx = v.x - this.x;
              var dy = v.y - this.y;
              var dz = v.z - this.z || 0;
              return Math.sqrt(dx * dx + dy * dy + dz * dz);
            },
            distanceSq: function (v) {
              var dx = v.x - this.x;
              var dy = v.y - this.y;
              var dz = v.z - this.z || 0;
              return dx * dx + dy * dy + dz * dz;
            },
            length: function () {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              return Math.sqrt(x * x + y * y + z * z);
            },
            lengthSq: function () {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              return x * x + y * y + z * z;
            },
            normalize: function () {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var len = x * x + y * y + z * z;
              if (len > 0) {
                len = 1 / Math.sqrt(len);
                this.x = x * len;
                this.y = y * len;
                this.z = z * len;
              }
              return this;
            },
            dot: function (v) {
              return this.x * v.x + this.y * v.y + this.z * v.z;
            },
            cross: function (v) {
              var ax = this.x;
              var ay = this.y;
              var az = this.z;
              var bx = v.x;
              var by = v.y;
              var bz = v.z;
              this.x = ay * bz - az * by;
              this.y = az * bx - ax * bz;
              this.z = ax * by - ay * bx;
              return this;
            },
            lerp: function (v, t) {
              if (t === void 0) {
                t = 0;
              }
              var ax = this.x;
              var ay = this.y;
              var az = this.z;
              this.x = ax + t * (v.x - ax);
              this.y = ay + t * (v.y - ay);
              this.z = az + t * (v.z - az);
              return this;
            },
            applyMatrix3: function (mat3) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var m = mat3.val;
              this.x = m[0] * x + m[3] * y + m[6] * z;
              this.y = m[1] * x + m[4] * y + m[7] * z;
              this.z = m[2] * x + m[5] * y + m[8] * z;
              return this;
            },
            applyMatrix4: function (mat4) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var m = mat4.val;
              var w = 1 / (m[3] * x + m[7] * y + m[11] * z + m[15]);
              this.x = (m[0] * x + m[4] * y + m[8] * z + m[12]) * w;
              this.y = (m[1] * x + m[5] * y + m[9] * z + m[13]) * w;
              this.z = (m[2] * x + m[6] * y + m[10] * z + m[14]) * w;
              return this;
            },
            transformMat3: function (mat) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var m = mat.val;
              this.x = x * m[0] + y * m[3] + z * m[6];
              this.y = x * m[1] + y * m[4] + z * m[7];
              this.z = x * m[2] + y * m[5] + z * m[8];
              return this;
            },
            transformMat4: function (mat) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var m = mat.val;
              this.x = m[0] * x + m[4] * y + m[8] * z + m[12];
              this.y = m[1] * x + m[5] * y + m[9] * z + m[13];
              this.z = m[2] * x + m[6] * y + m[10] * z + m[14];
              return this;
            },
            transformCoordinates: function (mat) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var m = mat.val;
              var tx = x * m[0] + y * m[4] + z * m[8] + m[12];
              var ty = x * m[1] + y * m[5] + z * m[9] + m[13];
              var tz = x * m[2] + y * m[6] + z * m[10] + m[14];
              var tw = x * m[3] + y * m[7] + z * m[11] + m[15];
              this.x = tx / tw;
              this.y = ty / tw;
              this.z = tz / tw;
              return this;
            },
            transformQuat: function (q) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var qx = q.x;
              var qy = q.y;
              var qz = q.z;
              var qw = q.w;
              var ix = qw * x + qy * z - qz * y;
              var iy = qw * y + qz * x - qx * z;
              var iz = qw * z + qx * y - qy * x;
              var iw = -qx * x - qy * y - qz * z;
              this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
              this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
              this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
              return this;
            },
            project: function (mat) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var m = mat.val;
              var a00 = m[0];
              var a01 = m[1];
              var a02 = m[2];
              var a03 = m[3];
              var a10 = m[4];
              var a11 = m[5];
              var a12 = m[6];
              var a13 = m[7];
              var a20 = m[8];
              var a21 = m[9];
              var a22 = m[10];
              var a23 = m[11];
              var a30 = m[12];
              var a31 = m[13];
              var a32 = m[14];
              var a33 = m[15];
              var lw = 1 / (x * a03 + y * a13 + z * a23 + a33);
              this.x = (x * a00 + y * a10 + z * a20 + a30) * lw;
              this.y = (x * a01 + y * a11 + z * a21 + a31) * lw;
              this.z = (x * a02 + y * a12 + z * a22 + a32) * lw;
              return this;
            },
            projectViewMatrix: function (viewMatrix, projectionMatrix) {
              return this.applyMatrix4(viewMatrix).applyMatrix4(projectionMatrix);
            },
            unprojectViewMatrix: function (projectionMatrix, worldMatrix) {
              return this.applyMatrix4(projectionMatrix).applyMatrix4(worldMatrix);
            },
            unproject: function (viewport, invProjectionView) {
              var viewX = viewport.x;
              var viewY = viewport.y;
              var viewWidth = viewport.z;
              var viewHeight = viewport.w;
              var x = this.x - viewX;
              var y = viewHeight - this.y - 1 - viewY;
              var z = this.z;
              this.x = 2 * x / viewWidth - 1;
              this.y = 2 * y / viewHeight - 1;
              this.z = 2 * z - 1;
              return this.project(invProjectionView);
            },
            reset: function () {
              this.x = 0;
              this.y = 0;
              this.z = 0;
              return this;
            }
          });
          Vector3.ZERO = new Vector3();
          Vector3.RIGHT = new Vector3(1, 0, 0);
          Vector3.LEFT = new Vector3(-1, 0, 0);
          Vector3.UP = new Vector3(0, -1, 0);
          Vector3.DOWN = new Vector3(0, 1, 0);
          Vector3.FORWARD = new Vector3(0, 0, 1);
          Vector3.BACK = new Vector3(0, 0, -1);
          Vector3.ONE = new Vector3(1, 1, 1);
          module2.exports = Vector3;
        }, function (module2, exports2) {
          module2.exports = {
            CSV: 0,
            TILED_JSON: 1,
            ARRAY_2D: 2,
            WELTMEISTER: 3
          };
        }, function (module2, exports2, __webpack_require__) {
          var Body = {};
          module2.exports = Body;
          var Vertices = __webpack_require__(64);
          var Vector = __webpack_require__(83);
          var Sleeping = __webpack_require__(165);
          var Common = __webpack_require__(32);
          var Bounds = __webpack_require__(84);
          var Axes = __webpack_require__(271);
          (function () {
            Body._inertiaScale = 4;
            Body._nextCollidingGroupId = 1;
            Body._nextNonCollidingGroupId = -1;
            Body._nextCategory = 1;
            Body.create = function (options) {
              var defaults = {
                id: Common.nextId(),
                type: "body",
                label: "Body",
                parts: [],
                plugin: {},
                angle: 0,
                vertices: null,
                position: {
                  x: 0,
                  y: 0
                },
                force: {
                  x: 0,
                  y: 0
                },
                torque: 0,
                positionImpulse: {
                  x: 0,
                  y: 0
                },
                previousPositionImpulse: {
                  x: 0,
                  y: 0
                },
                constraintImpulse: {
                  x: 0,
                  y: 0,
                  angle: 0
                },
                totalContacts: 0,
                speed: 0,
                angularSpeed: 0,
                velocity: {
                  x: 0,
                  y: 0
                },
                angularVelocity: 0,
                isSensor: false,
                isStatic: false,
                isSleeping: false,
                motion: 0,
                sleepThreshold: 60,
                density: 1e-3,
                restitution: 0,
                friction: 0.1,
                frictionStatic: 0.5,
                frictionAir: 0.01,
                collisionFilter: {
                  category: 1,
                  mask: 4294967295,
                  group: 0
                },
                slop: 0.05,
                timeScale: 1,
                events: null,
                bounds: null,
                chamfer: null,
                circleRadius: 0,
                positionPrev: null,
                anglePrev: 0,
                parent: null,
                axes: null,
                area: 0,
                mass: 0,
                inverseMass: 0,
                inertia: 0,
                inverseInertia: 0,
                _original: null,
                render: {
                  visible: true,
                  opacity: 1,
                  sprite: {
                    xOffset: 0,
                    yOffset: 0
                  },
                  fillColor: null,
                  fillOpacity: null,
                  lineColor: null,
                  lineOpacity: null,
                  lineThickness: null
                },
                gameObject: null,
                scale: {
                  x: 1,
                  y: 1
                },
                centerOfMass: {
                  x: 0,
                  y: 0
                },
                centerOffset: {
                  x: 0,
                  y: 0
                },
                gravityScale: {
                  x: 1,
                  y: 1
                },
                ignoreGravity: false,
                ignorePointer: false,
                onCollideCallback: null,
                onCollideEndCallback: null,
                onCollideActiveCallback: null,
                onCollideWith: {}
              };
              if (!options.hasOwnProperty("position") && options.hasOwnProperty("vertices")) {
                options.position = Vertices.centre(options.vertices);
              } else if (!options.hasOwnProperty("vertices")) {
                defaults.vertices = Vertices.fromPath("L 0 0 L 40 0 L 40 40 L 0 40");
              }
              var body = Common.extend(defaults, options);
              _initProperties(body, options);
              body.setOnCollideWith = function (body2, callback) {
                if (callback) {
                  this.onCollideWith[body2.id] = callback;
                } else {
                  delete this.onCollideWith[body2.id];
                }
                return this;
              };
              return body;
            };
            Body.nextGroup = function (isNonColliding) {
              if (isNonColliding) return Body._nextNonCollidingGroupId--;
              return Body._nextCollidingGroupId++;
            };
            Body.nextCategory = function () {
              Body._nextCategory = Body._nextCategory << 1;
              return Body._nextCategory;
            };
            var _initProperties = function (body, options) {
              options = options || ({});
              Body.set(body, {
                bounds: body.bounds || Bounds.create(body.vertices),
                positionPrev: body.positionPrev || Vector.clone(body.position),
                anglePrev: body.anglePrev || body.angle,
                vertices: body.vertices,
                parts: body.parts || [body],
                isStatic: body.isStatic,
                isSleeping: body.isSleeping,
                parent: body.parent || body
              });
              var bounds = body.bounds;
              Vertices.rotate(body.vertices, body.angle, body.position);
              Axes.rotate(body.axes, body.angle);
              Bounds.update(bounds, body.vertices, body.velocity);
              Body.set(body, {
                axes: options.axes || body.axes,
                area: options.area || body.area,
                mass: options.mass || body.mass,
                inertia: options.inertia || body.inertia
              });
              if (body.parts.length === 1) {
                var centerOfMass = body.centerOfMass;
                var centerOffset = body.centerOffset;
                var bodyWidth = bounds.max.x - bounds.min.x;
                var bodyHeight = bounds.max.y - bounds.min.y;
                centerOfMass.x = -(bounds.min.x - body.position.x) / bodyWidth;
                centerOfMass.y = -(bounds.min.y - body.position.y) / bodyHeight;
                centerOffset.x = bodyWidth * centerOfMass.x;
                centerOffset.y = bodyHeight * centerOfMass.y;
              }
            };
            Body.set = function (body, settings, value) {
              var property;
              if (typeof settings === "string") {
                property = settings;
                settings = {};
                settings[property] = value;
              }
              for (property in settings) {
                if (!Object.prototype.hasOwnProperty.call(settings, property)) continue;
                value = settings[property];
                switch (property) {
                  case "isStatic":
                    Body.setStatic(body, value);
                    break;
                  case "isSleeping":
                    Sleeping.set(body, value);
                    break;
                  case "mass":
                    Body.setMass(body, value);
                    break;
                  case "density":
                    Body.setDensity(body, value);
                    break;
                  case "inertia":
                    Body.setInertia(body, value);
                    break;
                  case "vertices":
                    Body.setVertices(body, value);
                    break;
                  case "position":
                    Body.setPosition(body, value);
                    break;
                  case "angle":
                    Body.setAngle(body, value);
                    break;
                  case "velocity":
                    Body.setVelocity(body, value);
                    break;
                  case "angularVelocity":
                    Body.setAngularVelocity(body, value);
                    break;
                  case "parts":
                    Body.setParts(body, value);
                    break;
                  case "centre":
                    Body.setCentre(body, value);
                    break;
                  default:
                    body[property] = value;
                }
              }
            };
            Body.setStatic = function (body, isStatic) {
              for (var i = 0; i < body.parts.length; i++) {
                var part = body.parts[i];
                part.isStatic = isStatic;
                if (isStatic) {
                  part._original = {
                    restitution: part.restitution,
                    friction: part.friction,
                    mass: part.mass,
                    inertia: part.inertia,
                    density: part.density,
                    inverseMass: part.inverseMass,
                    inverseInertia: part.inverseInertia
                  };
                  part.restitution = 0;
                  part.friction = 1;
                  part.mass = part.inertia = part.density = Infinity;
                  part.inverseMass = part.inverseInertia = 0;
                  part.positionPrev.x = part.position.x;
                  part.positionPrev.y = part.position.y;
                  part.anglePrev = part.angle;
                  part.angularVelocity = 0;
                  part.speed = 0;
                  part.angularSpeed = 0;
                  part.motion = 0;
                } else if (part._original) {
                  part.restitution = part._original.restitution;
                  part.friction = part._original.friction;
                  part.mass = part._original.mass;
                  part.inertia = part._original.inertia;
                  part.density = part._original.density;
                  part.inverseMass = part._original.inverseMass;
                  part.inverseInertia = part._original.inverseInertia;
                  part._original = null;
                }
              }
            };
            Body.setMass = function (body, mass) {
              var moment = body.inertia / (body.mass / 6);
              body.inertia = moment * (mass / 6);
              body.inverseInertia = 1 / body.inertia;
              body.mass = mass;
              body.inverseMass = 1 / body.mass;
              body.density = body.mass / body.area;
            };
            Body.setDensity = function (body, density) {
              Body.setMass(body, density * body.area);
              body.density = density;
            };
            Body.setInertia = function (body, inertia) {
              body.inertia = inertia;
              body.inverseInertia = 1 / body.inertia;
            };
            Body.setVertices = function (body, vertices) {
              if (vertices[0].body === body) {
                body.vertices = vertices;
              } else {
                body.vertices = Vertices.create(vertices, body);
              }
              body.axes = Axes.fromVertices(body.vertices);
              body.area = Vertices.area(body.vertices);
              Body.setMass(body, body.density * body.area);
              var centre = Vertices.centre(body.vertices);
              Vertices.translate(body.vertices, centre, -1);
              Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));
              Vertices.translate(body.vertices, body.position);
              Bounds.update(body.bounds, body.vertices, body.velocity);
            };
            Body.setParts = function (body, parts, autoHull) {
              var i;
              parts = parts.slice(0);
              body.parts.length = 0;
              body.parts.push(body);
              body.parent = body;
              for (i = 0; i < parts.length; i++) {
                var part = parts[i];
                if (part !== body) {
                  part.parent = body;
                  body.parts.push(part);
                }
              }
              if (body.parts.length === 1) return;
              autoHull = typeof autoHull !== "undefined" ? autoHull : true;
              if (autoHull) {
                var vertices = [];
                for (i = 0; i < parts.length; i++) {
                  vertices = vertices.concat(parts[i].vertices);
                }
                Vertices.clockwiseSort(vertices);
                var hull = Vertices.hull(vertices), hullCentre = Vertices.centre(hull);
                Body.setVertices(body, hull);
                Vertices.translate(body.vertices, hullCentre);
              }
              var total = Body._totalProperties(body);
              var cx = total.centre.x;
              var cy = total.centre.y;
              var bounds = body.bounds;
              var centerOfMass = body.centerOfMass;
              var centerOffset = body.centerOffset;
              Bounds.update(bounds, body.vertices, body.velocity);
              centerOfMass.x = -(bounds.min.x - cx) / (bounds.max.x - bounds.min.x);
              centerOfMass.y = -(bounds.min.y - cy) / (bounds.max.y - bounds.min.y);
              centerOffset.x = cx;
              centerOffset.y = cy;
              body.area = total.area;
              body.parent = body;
              body.position.x = cx;
              body.position.y = cy;
              body.positionPrev.x = cx;
              body.positionPrev.y = cy;
              Body.setMass(body, total.mass);
              Body.setInertia(body, total.inertia);
              Body.setPosition(body, total.centre);
            };
            Body.setCentre = function (body, centre, relative) {
              if (!relative) {
                body.positionPrev.x = centre.x - (body.position.x - body.positionPrev.x);
                body.positionPrev.y = centre.y - (body.position.y - body.positionPrev.y);
                body.position.x = centre.x;
                body.position.y = centre.y;
              } else {
                body.positionPrev.x += centre.x;
                body.positionPrev.y += centre.y;
                body.position.x += centre.x;
                body.position.y += centre.y;
              }
            };
            Body.setPosition = function (body, position) {
              var delta = Vector.sub(position, body.position);
              body.positionPrev.x += delta.x;
              body.positionPrev.y += delta.y;
              for (var i = 0; i < body.parts.length; i++) {
                var part = body.parts[i];
                part.position.x += delta.x;
                part.position.y += delta.y;
                Vertices.translate(part.vertices, delta);
                Bounds.update(part.bounds, part.vertices, body.velocity);
              }
            };
            Body.setAngle = function (body, angle) {
              var delta = angle - body.angle;
              body.anglePrev += delta;
              for (var i = 0; i < body.parts.length; i++) {
                var part = body.parts[i];
                part.angle += delta;
                Vertices.rotate(part.vertices, delta, body.position);
                Axes.rotate(part.axes, delta);
                Bounds.update(part.bounds, part.vertices, body.velocity);
                if (i > 0) {
                  Vector.rotateAbout(part.position, delta, body.position, part.position);
                }
              }
            };
            Body.setVelocity = function (body, velocity) {
              body.positionPrev.x = body.position.x - velocity.x;
              body.positionPrev.y = body.position.y - velocity.y;
              body.velocity.x = velocity.x;
              body.velocity.y = velocity.y;
              body.speed = Vector.magnitude(body.velocity);
            };
            Body.setAngularVelocity = function (body, velocity) {
              body.anglePrev = body.angle - velocity;
              body.angularVelocity = velocity;
              body.angularSpeed = Math.abs(body.angularVelocity);
            };
            Body.translate = function (body, translation) {
              Body.setPosition(body, Vector.add(body.position, translation));
            };
            Body.rotate = function (body, rotation, point) {
              if (!point) {
                Body.setAngle(body, body.angle + rotation);
              } else {
                var cos = Math.cos(rotation), sin = Math.sin(rotation), dx = body.position.x - point.x, dy = body.position.y - point.y;
                Body.setPosition(body, {
                  x: point.x + (dx * cos - dy * sin),
                  y: point.y + (dx * sin + dy * cos)
                });
                Body.setAngle(body, body.angle + rotation);
              }
            };
            Body.scale = function (body, scaleX, scaleY, point) {
              var totalArea = 0, totalInertia = 0;
              point = point || body.position;
              for (var i = 0; i < body.parts.length; i++) {
                var part = body.parts[i];
                part.scale.x = scaleX;
                part.scale.y = scaleY;
                Vertices.scale(part.vertices, scaleX, scaleY, point);
                part.axes = Axes.fromVertices(part.vertices);
                part.area = Vertices.area(part.vertices);
                Body.setMass(part, body.density * part.area);
                Vertices.translate(part.vertices, {
                  x: -part.position.x,
                  y: -part.position.y
                });
                Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass));
                Vertices.translate(part.vertices, {
                  x: part.position.x,
                  y: part.position.y
                });
                if (i > 0) {
                  totalArea += part.area;
                  totalInertia += part.inertia;
                }
                part.position.x = point.x + (part.position.x - point.x) * scaleX;
                part.position.y = point.y + (part.position.y - point.y) * scaleY;
                Bounds.update(part.bounds, part.vertices, body.velocity);
              }
              if (body.parts.length > 1) {
                body.area = totalArea;
                if (!body.isStatic) {
                  Body.setMass(body, body.density * totalArea);
                  Body.setInertia(body, totalInertia);
                }
              }
              if (body.circleRadius) {
                if (scaleX === scaleY) {
                  body.circleRadius *= scaleX;
                } else {
                  body.circleRadius = null;
                }
              }
            };
            Body.update = function (body, deltaTime, timeScale, correction) {
              var deltaTimeSquared = Math.pow(deltaTime * timeScale * body.timeScale, 2);
              var frictionAir = 1 - body.frictionAir * timeScale * body.timeScale, velocityPrevX = body.position.x - body.positionPrev.x, velocityPrevY = body.position.y - body.positionPrev.y;
              body.velocity.x = velocityPrevX * frictionAir * correction + body.force.x / body.mass * deltaTimeSquared;
              body.velocity.y = velocityPrevY * frictionAir * correction + body.force.y / body.mass * deltaTimeSquared;
              body.positionPrev.x = body.position.x;
              body.positionPrev.y = body.position.y;
              body.position.x += body.velocity.x;
              body.position.y += body.velocity.y;
              body.angularVelocity = (body.angle - body.anglePrev) * frictionAir * correction + body.torque / body.inertia * deltaTimeSquared;
              body.anglePrev = body.angle;
              body.angle += body.angularVelocity;
              body.speed = Vector.magnitude(body.velocity);
              body.angularSpeed = Math.abs(body.angularVelocity);
              for (var i = 0; i < body.parts.length; i++) {
                var part = body.parts[i];
                Vertices.translate(part.vertices, body.velocity);
                if (i > 0) {
                  part.position.x += body.velocity.x;
                  part.position.y += body.velocity.y;
                }
                if (body.angularVelocity !== 0) {
                  Vertices.rotate(part.vertices, body.angularVelocity, body.position);
                  Axes.rotate(part.axes, body.angularVelocity);
                  if (i > 0) {
                    Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);
                  }
                }
                Bounds.update(part.bounds, part.vertices, body.velocity);
              }
            };
            Body.applyForce = function (body, position, force) {
              body.force.x += force.x;
              body.force.y += force.y;
              var offset = {
                x: position.x - body.position.x,
                y: position.y - body.position.y
              };
              body.torque += offset.x * force.y - offset.y * force.x;
            };
            Body._totalProperties = function (body) {
              var properties = {
                mass: 0,
                area: 0,
                inertia: 0,
                centre: {
                  x: 0,
                  y: 0
                }
              };
              for (var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++) {
                var part = body.parts[i], mass = part.mass !== Infinity ? part.mass : 1;
                properties.mass += mass;
                properties.area += part.area;
                properties.inertia += part.inertia;
                properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));
              }
              properties.centre = Vector.div(properties.centre, properties.mass);
              return properties;
            };
          })();
        }, function (module2, exports2) {
          var GetBottom = function (gameObject) {
            return gameObject.y + gameObject.height - gameObject.height * gameObject.originY;
          };
          module2.exports = GetBottom;
        }, function (module2, exports2) {
          var GetLeft = function (gameObject) {
            return gameObject.x - gameObject.width * gameObject.originX;
          };
          module2.exports = GetLeft;
        }, function (module2, exports2) {
          var GetRight = function (gameObject) {
            return gameObject.x + gameObject.width - gameObject.width * gameObject.originX;
          };
          module2.exports = GetRight;
        }, function (module2, exports2) {
          var GetTop = function (gameObject) {
            return gameObject.y - gameObject.height * gameObject.originY;
          };
          module2.exports = GetTop;
        }, function (module2, exports2) {
          var PropertyValueInc = function (items, key, value, step, index, direction) {
            if (step === void 0) {
              step = 0;
            }
            if (index === void 0) {
              index = 0;
            }
            if (direction === void 0) {
              direction = 1;
            }
            var i;
            var t = 0;
            var end = items.length;
            if (direction === 1) {
              for (i = index; i < end; i++) {
                items[i][key] += value + t * step;
                t++;
              }
            } else {
              for (i = index; i >= 0; i--) {
                items[i][key] += value + t * step;
                t++;
              }
            }
            return items;
          };
          module2.exports = PropertyValueInc;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GetPoint = __webpack_require__(307);
          var GetPoints = __webpack_require__(172);
          var GEOM_CONST = __webpack_require__(56);
          var Random = __webpack_require__(173);
          var Vector2 = __webpack_require__(3);
          var Line = new Class({
            initialize: function Line2(x1, y1, x2, y2) {
              if (x1 === void 0) {
                x1 = 0;
              }
              if (y1 === void 0) {
                y1 = 0;
              }
              if (x2 === void 0) {
                x2 = 0;
              }
              if (y2 === void 0) {
                y2 = 0;
              }
              this.type = GEOM_CONST.LINE;
              this.x1 = x1;
              this.y1 = y1;
              this.x2 = x2;
              this.y2 = y2;
            },
            getPoint: function (position, output) {
              return GetPoint(this, position, output);
            },
            getPoints: function (quantity, stepRate, output) {
              return GetPoints(this, quantity, stepRate, output);
            },
            getRandomPoint: function (point) {
              return Random(this, point);
            },
            setTo: function (x1, y1, x2, y2) {
              if (x1 === void 0) {
                x1 = 0;
              }
              if (y1 === void 0) {
                y1 = 0;
              }
              if (x2 === void 0) {
                x2 = 0;
              }
              if (y2 === void 0) {
                y2 = 0;
              }
              this.x1 = x1;
              this.y1 = y1;
              this.x2 = x2;
              this.y2 = y2;
              return this;
            },
            getPointA: function (vec2) {
              if (vec2 === void 0) {
                vec2 = new Vector2();
              }
              vec2.set(this.x1, this.y1);
              return vec2;
            },
            getPointB: function (vec2) {
              if (vec2 === void 0) {
                vec2 = new Vector2();
              }
              vec2.set(this.x2, this.y2);
              return vec2;
            },
            left: {
              get: function () {
                return Math.min(this.x1, this.x2);
              },
              set: function (value) {
                if (this.x1 <= this.x2) {
                  this.x1 = value;
                } else {
                  this.x2 = value;
                }
              }
            },
            right: {
              get: function () {
                return Math.max(this.x1, this.x2);
              },
              set: function (value) {
                if (this.x1 > this.x2) {
                  this.x1 = value;
                } else {
                  this.x2 = value;
                }
              }
            },
            top: {
              get: function () {
                return Math.min(this.y1, this.y2);
              },
              set: function (value) {
                if (this.y1 <= this.y2) {
                  this.y1 = value;
                } else {
                  this.y2 = value;
                }
              }
            },
            bottom: {
              get: function () {
                return Math.max(this.y1, this.y2);
              },
              set: function (value) {
                if (this.y1 > this.y2) {
                  this.y1 = value;
                } else {
                  this.y2 = value;
                }
              }
            }
          });
          module2.exports = Line;
        }, function (module2, exports2) {
          var FillStyleCanvas = function (ctx, src, altColor, altAlpha) {
            var fillColor = altColor ? altColor : src.fillColor;
            var fillAlpha = altAlpha ? altAlpha : src.fillAlpha;
            var red = (fillColor & 16711680) >>> 16;
            var green = (fillColor & 65280) >>> 8;
            var blue = fillColor & 255;
            ctx.fillStyle = "rgba(" + red + "," + green + "," + blue + "," + fillAlpha + ")";
          };
          module2.exports = FillStyleCanvas;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var MultiFile = new Class({
            initialize: function MultiFile2(loader, type, key, files) {
              var finalFiles = [];
              files.forEach(function (file) {
                if (file) {
                  finalFiles.push(file);
                }
              });
              this.loader = loader;
              this.type = type;
              this.key = key;
              this.multiKeyIndex = loader.multiKeyIndex++;
              this.files = finalFiles;
              this.complete = false;
              this.pending = finalFiles.length;
              this.failed = 0;
              this.config = {};
              this.baseURL = loader.baseURL;
              this.path = loader.path;
              this.prefix = loader.prefix;
              for (var i = 0; i < finalFiles.length; i++) {
                finalFiles[i].multiFile = this;
              }
            },
            isReadyToProcess: function () {
              return this.pending === 0 && this.failed === 0 && !this.complete;
            },
            addToMultiFile: function (file) {
              this.files.push(file);
              file.multiFile = this;
              this.pending++;
              this.complete = false;
              return this;
            },
            onFileComplete: function (file) {
              var index = this.files.indexOf(file);
              if (index !== -1) {
                this.pending--;
              }
            },
            onFileFailed: function (file) {
              var index = this.files.indexOf(file);
              if (index !== -1) {
                this.failed++;
              }
            }
          });
          module2.exports = MultiFile;
        }, function (module2, exports2) {
          var DistanceBetween = function (x1, y1, x2, y2) {
            var dx = x1 - x2;
            var dy = y1 - y2;
            return Math.sqrt(dx * dx + dy * dy);
          };
          module2.exports = DistanceBetween;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            BOOT: __webpack_require__(922),
            DESTROY: __webpack_require__(923),
            DRAG_END: __webpack_require__(924),
            DRAG_ENTER: __webpack_require__(925),
            DRAG: __webpack_require__(926),
            DRAG_LEAVE: __webpack_require__(927),
            DRAG_OVER: __webpack_require__(928),
            DRAG_START: __webpack_require__(929),
            DROP: __webpack_require__(930),
            GAME_OUT: __webpack_require__(931),
            GAME_OVER: __webpack_require__(932),
            GAMEOBJECT_DOWN: __webpack_require__(933),
            GAMEOBJECT_DRAG_END: __webpack_require__(934),
            GAMEOBJECT_DRAG_ENTER: __webpack_require__(935),
            GAMEOBJECT_DRAG: __webpack_require__(936),
            GAMEOBJECT_DRAG_LEAVE: __webpack_require__(937),
            GAMEOBJECT_DRAG_OVER: __webpack_require__(938),
            GAMEOBJECT_DRAG_START: __webpack_require__(939),
            GAMEOBJECT_DROP: __webpack_require__(940),
            GAMEOBJECT_MOVE: __webpack_require__(941),
            GAMEOBJECT_OUT: __webpack_require__(942),
            GAMEOBJECT_OVER: __webpack_require__(943),
            GAMEOBJECT_POINTER_DOWN: __webpack_require__(944),
            GAMEOBJECT_POINTER_MOVE: __webpack_require__(945),
            GAMEOBJECT_POINTER_OUT: __webpack_require__(946),
            GAMEOBJECT_POINTER_OVER: __webpack_require__(947),
            GAMEOBJECT_POINTER_UP: __webpack_require__(948),
            GAMEOBJECT_POINTER_WHEEL: __webpack_require__(949),
            GAMEOBJECT_UP: __webpack_require__(950),
            GAMEOBJECT_WHEEL: __webpack_require__(951),
            MANAGER_BOOT: __webpack_require__(952),
            MANAGER_PROCESS: __webpack_require__(953),
            MANAGER_UPDATE: __webpack_require__(954),
            POINTER_DOWN: __webpack_require__(955),
            POINTER_DOWN_OUTSIDE: __webpack_require__(956),
            POINTER_MOVE: __webpack_require__(957),
            POINTER_OUT: __webpack_require__(958),
            POINTER_OVER: __webpack_require__(959),
            POINTER_UP: __webpack_require__(960),
            POINTER_UP_OUTSIDE: __webpack_require__(961),
            POINTER_WHEEL: __webpack_require__(962),
            POINTERLOCK_CHANGE: __webpack_require__(963),
            PRE_UPDATE: __webpack_require__(964),
            SHUTDOWN: __webpack_require__(965),
            START: __webpack_require__(966),
            UPDATE: __webpack_require__(967)
          };
        }, function (module2, exports2) {
          var SetTop = function (gameObject, value) {
            gameObject.y = value + gameObject.height * gameObject.originY;
            return gameObject;
          };
          module2.exports = SetTop;
        }, function (module2, exports2) {
          var SetLeft = function (gameObject, value) {
            gameObject.x = value + gameObject.width * gameObject.originX;
            return gameObject;
          };
          module2.exports = SetLeft;
        }, function (module2, exports2) {
          var SetRight = function (gameObject, value) {
            gameObject.x = value - gameObject.width + gameObject.width * gameObject.originX;
            return gameObject;
          };
          module2.exports = SetRight;
        }, function (module2, exports2) {
          var SetBottom = function (gameObject, value) {
            gameObject.y = value - gameObject.height + gameObject.height * gameObject.originY;
            return gameObject;
          };
          module2.exports = SetBottom;
        }, function (module2, exports2) {
          var GEOM_CONST = {
            CIRCLE: 0,
            ELLIPSE: 1,
            LINE: 2,
            POINT: 3,
            POLYGON: 4,
            RECTANGLE: 5,
            TRIANGLE: 6
          };
          module2.exports = GEOM_CONST;
        }, function (module2, exports2) {
          var Contains = function (rect, x, y) {
            if (rect.width <= 0 || rect.height <= 0) {
              return false;
            }
            return rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y;
          };
          module2.exports = Contains;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var DeepCopy = __webpack_require__(175);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(374);
          var GetFastValue = __webpack_require__(2);
          var Matrix4 = __webpack_require__(69);
          var RendererEvents = __webpack_require__(91);
          var RenderTarget = __webpack_require__(141);
          var Utils = __webpack_require__(12);
          var WebGLShader = __webpack_require__(375);
          var WebGLPipeline = new Class({
            Extends: EventEmitter,
            initialize: function WebGLPipeline2(config) {
              EventEmitter.call(this);
              var game = config.game;
              var renderer = game.renderer;
              var gl = renderer.gl;
              this.name = GetFastValue(config, "name", "WebGLPipeline");
              this.game = game;
              this.renderer = renderer;
              this.manager;
              this.gl = gl;
              this.view = game.canvas;
              this.width = 0;
              this.height = 0;
              this.vertexCount = 0;
              this.vertexCapacity = 0;
              this.vertexData;
              this.vertexBuffer;
              this.topology = GetFastValue(config, "topology", gl.TRIANGLES);
              this.bytes;
              this.vertexViewF32;
              this.vertexViewU32;
              this.active = true;
              this.currentUnit = 0;
              this.forceZero = GetFastValue(config, "forceZero", false);
              this.hasBooted = false;
              this.isPostFX = false;
              this.renderTargets = [];
              this.currentRenderTarget;
              this.shaders = [];
              this.currentShader;
              this.projectionMatrix;
              this.projectionWidth = 0;
              this.projectionHeight = 0;
              this.config = config;
              this.glReset = false;
            },
            boot: function () {
              var i;
              var gl = this.gl;
              var config = this.config;
              var renderer = this.renderer;
              if (!this.isPostFX) {
                this.projectionMatrix = new Matrix4().identity();
              }
              var renderTargets = this.renderTargets;
              var targets = GetFastValue(config, "renderTarget", false);
              if (typeof targets === "boolean" && targets) {
                targets = 1;
              }
              var width = renderer.width;
              var height = renderer.height;
              if (typeof targets === "number") {
                for (i = 0; i < targets; i++) {
                  renderTargets.push(new RenderTarget(renderer, width, height, 1, 0, true));
                }
              } else if (Array.isArray(targets)) {
                for (i = 0; i < targets.length; i++) {
                  var scale = GetFastValue(targets[i], "scale", 1);
                  var minFilter = GetFastValue(targets[i], "minFilter", 0);
                  var autoClear = GetFastValue(targets[i], "autoClear", 1);
                  renderTargets.push(new RenderTarget(renderer, width, height, scale, minFilter, autoClear));
                }
              }
              if (renderTargets.length) {
                this.currentRenderTarget = renderTargets[0];
              }
              this.setShadersFromConfig(config);
              var shaders = this.shaders;
              var vertexSize = 0;
              for (i = 0; i < shaders.length; i++) {
                if (shaders[i].vertexSize > vertexSize) {
                  vertexSize = shaders[i].vertexSize;
                }
              }
              var batchSize = GetFastValue(config, "batchSize", renderer.config.batchSize);
              this.vertexCapacity = batchSize * 6;
              var data = new ArrayBuffer(this.vertexCapacity * vertexSize);
              this.vertexData = data;
              this.bytes = new Uint8Array(data);
              this.vertexViewF32 = new Float32Array(data);
              this.vertexViewU32 = new Uint32Array(data);
              var configVerts = GetFastValue(config, "vertices", null);
              if (configVerts) {
                this.vertexViewF32.set(configVerts);
                this.vertexBuffer = renderer.createVertexBuffer(data, gl.STATIC_DRAW);
              } else {
                this.vertexBuffer = renderer.createVertexBuffer(data.byteLength, gl.DYNAMIC_DRAW);
              }
              this.setVertexBuffer();
              for (i = shaders.length - 1; i >= 0; i--) {
                shaders[i].rebind();
              }
              this.hasBooted = true;
              renderer.on(RendererEvents.RESIZE, this.resize, this);
              renderer.on(RendererEvents.PRE_RENDER, this.onPreRender, this);
              renderer.on(RendererEvents.RENDER, this.onRender, this);
              renderer.on(RendererEvents.POST_RENDER, this.onPostRender, this);
              this.emit(Events.BOOT, this);
              this.onBoot();
            },
            onBoot: function () {},
            onResize: function () {},
            setShader: function (shader, setAttributes) {
              var renderer = this.renderer;
              if (shader !== this.currentShader || renderer.currentProgram !== this.currentShader.program) {
                this.flush();
                renderer.resetTextures();
                var wasBound = this.setVertexBuffer();
                if (wasBound && !setAttributes) {
                  setAttributes = true;
                }
                shader.bind(setAttributes, false);
                this.currentShader = shader;
              }
              return this;
            },
            getShaderByName: function (name) {
              var shaders = this.shaders;
              for (var i = 0; i < shaders.length; i++) {
                if (shaders[i].name === name) {
                  return shaders[i];
                }
              }
            },
            setShadersFromConfig: function (config) {
              var i;
              var shaders = this.shaders;
              var renderer = this.renderer;
              for (i = 0; i < shaders.length; i++) {
                shaders[i].destroy();
              }
              var vName = "vertShader";
              var fName = "fragShader";
              var aName = "attributes";
              var defaultVertShader = GetFastValue(config, vName, null);
              var defaultFragShader = Utils.parseFragmentShaderMaxTextures(GetFastValue(config, fName, null), renderer.maxTextures);
              var defaultAttribs = GetFastValue(config, aName, null);
              var configShaders = GetFastValue(config, "shaders", []);
              var len = configShaders.length;
              if (len === 0) {
                if (defaultVertShader && defaultFragShader) {
                  this.shaders = [new WebGLShader(this, "default", defaultVertShader, defaultFragShader, DeepCopy(defaultAttribs))];
                }
              } else {
                var newShaders = [];
                for (i = 0; i < len; i++) {
                  var shaderEntry = configShaders[i];
                  var name = GetFastValue(shaderEntry, "name", "default");
                  var vertShader = GetFastValue(shaderEntry, vName, defaultVertShader);
                  var fragShader = Utils.parseFragmentShaderMaxTextures(GetFastValue(shaderEntry, fName, defaultFragShader), renderer.maxTextures);
                  var attributes = GetFastValue(shaderEntry, aName, defaultAttribs);
                  if (vertShader && fragShader) {
                    newShaders.push(new WebGLShader(this, name, vertShader, fragShader, DeepCopy(attributes)));
                  }
                }
                this.shaders = newShaders;
              }
              if (this.shaders.length === 0) {
                console.warn("Pipeline: " + this.name + " - Invalid shader config");
              } else {
                this.currentShader = this.shaders[0];
              }
              return this;
            },
            setGameObject: function (gameObject, frame) {
              if (frame === void 0) {
                frame = gameObject.frame;
              }
              this.currentUnit = this.renderer.setTextureSource(frame.source);
              return this.currentUnit;
            },
            shouldFlush: function (amount) {
              if (amount === void 0) {
                amount = 0;
              }
              return this.vertexCount + amount > this.vertexCapacity;
            },
            resize: function (width, height) {
              if (width !== this.width || height !== this.height) {
                this.flush();
              }
              this.width = width;
              this.height = height;
              var targets = this.renderTargets;
              for (var i = 0; i < targets.length; i++) {
                targets[i].resize(width, height);
              }
              this.setProjectionMatrix(width, height);
              this.emit(Events.RESIZE, width, height, this);
              this.onResize(width, height);
              return this;
            },
            setProjectionMatrix: function (width, height) {
              var projectionMatrix = this.projectionMatrix;
              if (!projectionMatrix) {
                return this;
              }
              this.projectionWidth = width;
              this.projectionHeight = height;
              projectionMatrix.ortho(0, width, height, 0, -1e3, 1e3);
              var shaders = this.shaders;
              var name = "uProjectionMatrix";
              for (var i = 0; i < shaders.length; i++) {
                var shader = shaders[i];
                if (shader.hasUniform(name)) {
                  shader.resetUniform(name);
                  shader.setMatrix4fv(name, false, projectionMatrix.val, shader);
                }
              }
              return this;
            },
            updateProjectionMatrix: function () {
              if (this.projectionMatrix) {
                var globalWidth = this.renderer.projectionWidth;
                var globalHeight = this.renderer.projectionHeight;
                if (this.projectionWidth !== globalWidth || this.projectionHeight !== globalHeight) {
                  this.setProjectionMatrix(globalWidth, globalHeight);
                }
              }
            },
            bind: function (currentShader) {
              if (currentShader === void 0) {
                currentShader = this.currentShader;
              }
              if (this.glReset) {
                return this.rebind(currentShader);
              }
              var wasBound = this.setVertexBuffer();
              currentShader.bind(wasBound);
              this.currentShader = currentShader;
              this.emit(Events.BIND, this, currentShader);
              this.onActive(currentShader);
              return this;
            },
            rebind: function (currentShader) {
              this.setVertexBuffer();
              var shaders = this.shaders;
              for (var i = shaders.length - 1; i >= 0; i--) {
                var shader = shaders[i].rebind();
                if (!currentShader || shader === currentShader) {
                  this.currentShader = shader;
                }
              }
              this.emit(Events.REBIND, this.currentShader);
              this.onActive(this.currentShader);
              this.onRebind();
              this.glReset = false;
              return this;
            },
            setVertexBuffer: function () {
              var gl = this.gl;
              var buffer = this.vertexBuffer;
              if (gl.getParameter(gl.ARRAY_BUFFER_BINDING) !== buffer) {
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                return true;
              }
              return false;
            },
            preBatch: function (gameObject) {
              if (this.currentRenderTarget) {
                this.currentRenderTarget.bind();
              }
              this.onPreBatch(gameObject);
              return this;
            },
            postBatch: function (gameObject) {
              this.onDraw(this.currentRenderTarget);
              this.onPostBatch(gameObject);
              return this;
            },
            onDraw: function () {},
            unbind: function () {
              if (this.currentRenderTarget) {
                this.currentRenderTarget.unbind();
              }
            },
            flush: function (isPostFlush) {
              if (isPostFlush === void 0) {
                isPostFlush = false;
              }
              if (this.vertexCount > 0) {
                this.emit(Events.BEFORE_FLUSH, this, isPostFlush);
                this.onBeforeFlush(isPostFlush);
                var gl = this.gl;
                var vertexCount = this.vertexCount;
                var vertexSize = this.currentShader.vertexSize;
                if (this.active) {
                  this.setVertexBuffer();
                  if (vertexCount === this.vertexCapacity) {
                    gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.DYNAMIC_DRAW);
                  } else {
                    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));
                  }
                  gl.drawArrays(this.topology, 0, vertexCount);
                }
                this.vertexCount = 0;
                this.emit(Events.AFTER_FLUSH, this, isPostFlush);
                this.onAfterFlush(isPostFlush);
              }
              return this;
            },
            onActive: function () {},
            onBind: function () {},
            onRebind: function () {},
            onBatch: function () {},
            onPreBatch: function () {},
            onPostBatch: function () {},
            onPreRender: function () {},
            onRender: function () {},
            onPostRender: function () {},
            onBeforeFlush: function () {},
            onAfterFlush: function () {},
            batchVert: function (x, y, u, v, unit, tintEffect, tint) {
              var vertexViewF32 = this.vertexViewF32;
              var vertexViewU32 = this.vertexViewU32;
              var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
              vertexViewF32[++vertexOffset] = x;
              vertexViewF32[++vertexOffset] = y;
              vertexViewF32[++vertexOffset] = u;
              vertexViewF32[++vertexOffset] = v;
              vertexViewF32[++vertexOffset] = unit;
              vertexViewF32[++vertexOffset] = tintEffect;
              vertexViewU32[++vertexOffset] = tint;
              this.vertexCount++;
            },
            batchQuad: function (gameObject, x0, y0, x1, y1, x2, y2, x3, y3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, unit) {
              if (unit === void 0) {
                unit = this.currentUnit;
              }
              var hasFlushed = false;
              if (this.shouldFlush(6)) {
                this.flush();
                hasFlushed = true;
                unit = this.setTexture2D(texture);
              }
              this.batchVert(x0, y0, u0, v0, unit, tintEffect, tintTL);
              this.batchVert(x1, y1, u0, v1, unit, tintEffect, tintBL);
              this.batchVert(x2, y2, u1, v1, unit, tintEffect, tintBR);
              this.batchVert(x0, y0, u0, v0, unit, tintEffect, tintTL);
              this.batchVert(x2, y2, u1, v1, unit, tintEffect, tintBR);
              this.batchVert(x3, y3, u1, v0, unit, tintEffect, tintTR);
              this.onBatch(gameObject);
              return hasFlushed;
            },
            batchTri: function (gameObject, x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintEffect, texture, unit) {
              if (unit === void 0) {
                unit = this.currentUnit;
              }
              var hasFlushed = false;
              if (this.shouldFlush(3)) {
                this.flush();
                hasFlushed = true;
                unit = this.setTexture2D(texture);
              }
              this.batchVert(x0, y0, u0, v0, unit, tintEffect, tintTL);
              this.batchVert(x1, y1, u0, v1, unit, tintEffect, tintTR);
              this.batchVert(x2, y2, u1, v1, unit, tintEffect, tintBL);
              this.onBatch(gameObject);
              return hasFlushed;
            },
            drawFillRect: function (x, y, width, height, color, alpha, texture, flipUV) {
              if (texture === void 0) {
                texture = this.renderer.whiteTexture.glTexture;
              }
              if (flipUV === void 0) {
                flipUV = true;
              }
              x = Math.floor(x);
              y = Math.floor(y);
              var xw = Math.floor(x + width);
              var yh = Math.floor(y + height);
              var unit = this.setTexture2D(texture);
              var tint = Utils.getTintAppendFloatAlphaAndSwap(color, alpha);
              var u0 = 0;
              var v0 = 0;
              var u1 = 1;
              var v1 = 1;
              if (flipUV) {
                v0 = 1;
                v1 = 0;
              }
              this.batchQuad(null, x, y, x, yh, xw, yh, xw, y, u0, v0, u1, v1, tint, tint, tint, tint, 0, texture, unit);
            },
            setTexture2D: function (texture) {
              if (texture === void 0) {
                texture = this.renderer.whiteTexture.glTexture;
              }
              this.currentUnit = this.renderer.setTexture2D(texture);
              return this.currentUnit;
            },
            bindTexture: function (texture, unit) {
              if (unit === void 0) {
                unit = 0;
              }
              var gl = this.gl;
              gl.activeTexture(gl.TEXTURE0 + unit);
              gl.bindTexture(gl.TEXTURE_2D, texture);
              return this;
            },
            bindRenderTarget: function (target, unit) {
              return this.bindTexture(target.texture, unit);
            },
            setTime: function (uniform) {
              this.set1f(uniform, this.game.loop.getDuration());
              return this;
            },
            set1f: function (name, x, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set1f(name, x);
              return this;
            },
            set2f: function (name, x, y, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set2f(name, x, y);
              return this;
            },
            set3f: function (name, x, y, z, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set3f(name, x, y, z);
              return this;
            },
            set4f: function (name, x, y, z, w, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set4f(name, x, y, z, w);
              return this;
            },
            set1fv: function (name, arr, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set1fv(name, arr);
              return this;
            },
            set2fv: function (name, arr, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set2fv(name, arr);
              return this;
            },
            set3fv: function (name, arr, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set3fv(name, arr);
              return this;
            },
            set4fv: function (name, arr, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set4fv(name, arr);
              return this;
            },
            set1iv: function (name, arr, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set1iv(name, arr);
              return this;
            },
            set2iv: function (name, arr, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set2iv(name, arr);
              return this;
            },
            set3iv: function (name, arr, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set3iv(name, arr);
              return this;
            },
            set4iv: function (name, arr, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set4iv(name, arr);
              return this;
            },
            set1i: function (name, x, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set1i(name, x);
              return this;
            },
            set2i: function (name, x, y, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set2i(name, x, y);
              return this;
            },
            set3i: function (name, x, y, z, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set3i(name, x, y, z);
              return this;
            },
            set4i: function (name, x, y, z, w, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.set4i(name, x, y, z, w);
              return this;
            },
            setMatrix2fv: function (name, transpose, matrix, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.setMatrix2fv(name, transpose, matrix);
              return this;
            },
            setMatrix3fv: function (name, transpose, matrix, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.setMatrix3fv(name, transpose, matrix);
              return this;
            },
            setMatrix4fv: function (name, transpose, matrix, shader) {
              if (shader === void 0) {
                shader = this.currentShader;
              }
              shader.setMatrix4fv(name, transpose, matrix);
              return this;
            },
            destroy: function () {
              this.emit(Events.DESTROY, this);
              var i;
              var shaders = this.shaders;
              for (i = 0; i < shaders.length; i++) {
                shaders[i].destroy();
              }
              var targets = this.renderTargets;
              for (i = 0; i < targets.length; i++) {
                targets[i].destroy();
              }
              this.gl.deleteBuffer(this.vertexBuffer);
              var renderer = this.renderer;
              renderer.off(RendererEvents.RESIZE, this.resize, this);
              renderer.off(RendererEvents.PRE_RENDER, this.onPreRender, this);
              renderer.off(RendererEvents.RENDER, this.onRender, this);
              renderer.off(RendererEvents.POST_RENDER, this.onPostRender, this);
              this.removeAllListeners();
              this.game = null;
              this.renderer = null;
              this.manager = null;
              this.gl = null;
              this.view = null;
              this.shaders = null;
              this.renderTargets = null;
              this.bytes = null;
              this.vertexViewF32 = null;
              this.vertexViewU32 = null;
              this.vertexData = null;
              this.vertexBuffer = null;
              this.currentShader = null;
              this.currentRenderTarget = null;
              return this;
            }
          });
          module2.exports = WebGLPipeline;
        }, function (module2, exports2, __webpack_require__) {
          "use strict";
          function earcut(data, holeIndices, dim) {
            dim = dim || 2;
            var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
            if (!outerNode || outerNode.next === outerNode.prev) return triangles;
            var minX, minY, maxX, maxY, x, y, invSize;
            if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
            if (data.length > 80 * dim) {
              minX = maxX = data[0];
              minY = maxY = data[1];
              for (var i = dim; i < outerLen; i += dim) {
                x = data[i];
                y = data[i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
              }
              invSize = Math.max(maxX - minX, maxY - minY);
              invSize = invSize !== 0 ? 1 / invSize : 0;
            }
            earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
            return triangles;
          }
          function linkedList(data, start, end, dim, clockwise) {
            var i, last;
            if (clockwise === signedArea(data, start, end, dim) > 0) {
              for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
            } else {
              for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
            }
            if (last && equals(last, last.next)) {
              removeNode(last);
              last = last.next;
            }
            return last;
          }
          function filterPoints(start, end) {
            if (!start) return start;
            if (!end) end = start;
            var p3 = start, again;
            do {
              again = false;
              if (!p3.steiner && (equals(p3, p3.next) || area(p3.prev, p3, p3.next) === 0)) {
                removeNode(p3);
                p3 = end = p3.prev;
                if (p3 === p3.next) break;
                again = true;
              } else {
                p3 = p3.next;
              }
            } while (again || p3 !== end);
            return end;
          }
          function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
            if (!ear) return;
            if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
            var stop = ear, prev, next;
            while (ear.prev !== ear.next) {
              prev = ear.prev;
              next = ear.next;
              if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                triangles.push(prev.i / dim);
                triangles.push(ear.i / dim);
                triangles.push(next.i / dim);
                removeNode(ear);
                ear = next.next;
                stop = next.next;
                continue;
              }
              ear = next;
              if (ear === stop) {
                if (!pass) {
                  earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                } else if (pass === 1) {
                  ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                  earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                } else if (pass === 2) {
                  splitEarcut(ear, triangles, dim, minX, minY, invSize);
                }
                break;
              }
            }
          }
          function isEar(ear) {
            var a = ear.prev, b = ear, c = ear.next;
            if (area(a, b, c) >= 0) return false;
            var p3 = ear.next.next;
            while (p3 !== ear.prev) {
              if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0) return false;
              p3 = p3.next;
            }
            return true;
          }
          function isEarHashed(ear, minX, minY, invSize) {
            var a = ear.prev, b = ear, c = ear.next;
            if (area(a, b, c) >= 0) return false;
            var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
            var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
            var p3 = ear.prevZ, n = ear.nextZ;
            while (p3 && p3.z >= minZ && n && n.z <= maxZ) {
              if (p3 !== ear.prev && p3 !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0) return false;
              p3 = p3.prevZ;
              if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
              n = n.nextZ;
            }
            while (p3 && p3.z >= minZ) {
              if (p3 !== ear.prev && p3 !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0) return false;
              p3 = p3.prevZ;
            }
            while (n && n.z <= maxZ) {
              if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
              n = n.nextZ;
            }
            return true;
          }
          function cureLocalIntersections(start, triangles, dim) {
            var p3 = start;
            do {
              var a = p3.prev, b = p3.next.next;
              if (!equals(a, b) && intersects(a, p3, p3.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                triangles.push(a.i / dim);
                triangles.push(p3.i / dim);
                triangles.push(b.i / dim);
                removeNode(p3);
                removeNode(p3.next);
                p3 = start = b;
              }
              p3 = p3.next;
            } while (p3 !== start);
            return filterPoints(p3);
          }
          function splitEarcut(start, triangles, dim, minX, minY, invSize) {
            var a = start;
            do {
              var b = a.next.next;
              while (b !== a.prev) {
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                  var c = splitPolygon(a, b);
                  a = filterPoints(a, a.next);
                  c = filterPoints(c, c.next);
                  earcutLinked(a, triangles, dim, minX, minY, invSize);
                  earcutLinked(c, triangles, dim, minX, minY, invSize);
                  return;
                }
                b = b.next;
              }
              a = a.next;
            } while (a !== start);
          }
          function eliminateHoles(data, holeIndices, outerNode, dim) {
            var queue = [], i, len, start, end, list;
            for ((i = 0, len = holeIndices.length); i < len; i++) {
              start = holeIndices[i] * dim;
              end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
              list = linkedList(data, start, end, dim, false);
              if (list === list.next) list.steiner = true;
              queue.push(getLeftmost(list));
            }
            queue.sort(compareX);
            for (i = 0; i < queue.length; i++) {
              eliminateHole(queue[i], outerNode);
              outerNode = filterPoints(outerNode, outerNode.next);
            }
            return outerNode;
          }
          function compareX(a, b) {
            return a.x - b.x;
          }
          function eliminateHole(hole, outerNode) {
            outerNode = findHoleBridge(hole, outerNode);
            if (outerNode) {
              var b = splitPolygon(outerNode, hole);
              filterPoints(outerNode, outerNode.next);
              filterPoints(b, b.next);
            }
          }
          function findHoleBridge(hole, outerNode) {
            var p3 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
            do {
              if (hy <= p3.y && hy >= p3.next.y && p3.next.y !== p3.y) {
                var x = p3.x + (hy - p3.y) * (p3.next.x - p3.x) / (p3.next.y - p3.y);
                if (x <= hx && x > qx) {
                  qx = x;
                  if (x === hx) {
                    if (hy === p3.y) return p3;
                    if (hy === p3.next.y) return p3.next;
                  }
                  m = p3.x < p3.next.x ? p3 : p3.next;
                }
              }
              p3 = p3.next;
            } while (p3 !== outerNode);
            if (!m) return null;
            if (hx === qx) return m;
            var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
            p3 = m;
            do {
              if (hx >= p3.x && p3.x >= mx && hx !== p3.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p3.x, p3.y)) {
                tan = Math.abs(hy - p3.y) / (hx - p3.x);
                if (locallyInside(p3, hole) && (tan < tanMin || tan === tanMin && (p3.x > m.x || p3.x === m.x && sectorContainsSector(m, p3)))) {
                  m = p3;
                  tanMin = tan;
                }
              }
              p3 = p3.next;
            } while (p3 !== stop);
            return m;
          }
          function sectorContainsSector(m, p3) {
            return area(m.prev, m, p3.prev) < 0 && area(p3.next, m, m.next) < 0;
          }
          function indexCurve(start, minX, minY, invSize) {
            var p3 = start;
            do {
              if (p3.z === null) p3.z = zOrder(p3.x, p3.y, minX, minY, invSize);
              p3.prevZ = p3.prev;
              p3.nextZ = p3.next;
              p3 = p3.next;
            } while (p3 !== start);
            p3.prevZ.nextZ = null;
            p3.prevZ = null;
            sortLinked(p3);
          }
          function sortLinked(list) {
            var i, p3, q, e, tail, numMerges, pSize, qSize, inSize = 1;
            do {
              p3 = list;
              list = null;
              tail = null;
              numMerges = 0;
              while (p3) {
                numMerges++;
                q = p3;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                  pSize++;
                  q = q.nextZ;
                  if (!q) break;
                }
                qSize = inSize;
                while (pSize > 0 || qSize > 0 && q) {
                  if (pSize !== 0 && (qSize === 0 || !q || p3.z <= q.z)) {
                    e = p3;
                    p3 = p3.nextZ;
                    pSize--;
                  } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                  }
                  if (tail) tail.nextZ = e; else list = e;
                  e.prevZ = tail;
                  tail = e;
                }
                p3 = q;
              }
              tail.nextZ = null;
              inSize *= 2;
            } while (numMerges > 1);
            return list;
          }
          function zOrder(x, y, minX, minY, invSize) {
            x = 32767 * (x - minX) * invSize;
            y = 32767 * (y - minY) * invSize;
            x = (x | x << 8) & 16711935;
            x = (x | x << 4) & 252645135;
            x = (x | x << 2) & 858993459;
            x = (x | x << 1) & 1431655765;
            y = (y | y << 8) & 16711935;
            y = (y | y << 4) & 252645135;
            y = (y | y << 2) & 858993459;
            y = (y | y << 1) & 1431655765;
            return x | y << 1;
          }
          function getLeftmost(start) {
            var p3 = start, leftmost = start;
            do {
              if (p3.x < leftmost.x || p3.x === leftmost.x && p3.y < leftmost.y) leftmost = p3;
              p3 = p3.next;
            } while (p3 !== start);
            return leftmost;
          }
          function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
            return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
          }
          function isValidDiagonal(a, b) {
            return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
          }
          function area(p3, q, r) {
            return (q.y - p3.y) * (r.x - q.x) - (q.x - p3.x) * (r.y - q.y);
          }
          function equals(p1, p22) {
            return p1.x === p22.x && p1.y === p22.y;
          }
          function intersects(p1, q1, p22, q2) {
            var o1 = sign(area(p1, q1, p22));
            var o2 = sign(area(p1, q1, q2));
            var o3 = sign(area(p22, q2, p1));
            var o4 = sign(area(p22, q2, q1));
            if (o1 !== o2 && o3 !== o4) return true;
            if (o1 === 0 && onSegment(p1, p22, q1)) return true;
            if (o2 === 0 && onSegment(p1, q2, q1)) return true;
            if (o3 === 0 && onSegment(p22, p1, q2)) return true;
            if (o4 === 0 && onSegment(p22, q1, q2)) return true;
            return false;
          }
          function onSegment(p3, q, r) {
            return q.x <= Math.max(p3.x, r.x) && q.x >= Math.min(p3.x, r.x) && q.y <= Math.max(p3.y, r.y) && q.y >= Math.min(p3.y, r.y);
          }
          function sign(num) {
            return num > 0 ? 1 : num < 0 ? -1 : 0;
          }
          function intersectsPolygon(a, b) {
            var p3 = a;
            do {
              if (p3.i !== a.i && p3.next.i !== a.i && p3.i !== b.i && p3.next.i !== b.i && intersects(p3, p3.next, a, b)) return true;
              p3 = p3.next;
            } while (p3 !== a);
            return false;
          }
          function locallyInside(a, b) {
            return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
          }
          function middleInside(a, b) {
            var p3 = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
            do {
              if (p3.y > py !== p3.next.y > py && p3.next.y !== p3.y && px < (p3.next.x - p3.x) * (py - p3.y) / (p3.next.y - p3.y) + p3.x) inside = !inside;
              p3 = p3.next;
            } while (p3 !== a);
            return inside;
          }
          function splitPolygon(a, b) {
            var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
            a.next = b;
            b.prev = a;
            a2.next = an;
            an.prev = a2;
            b2.next = a2;
            a2.prev = b2;
            bp.next = b2;
            b2.prev = bp;
            return b2;
          }
          function insertNode(i, x, y, last) {
            var p3 = new Node(i, x, y);
            if (!last) {
              p3.prev = p3;
              p3.next = p3;
            } else {
              p3.next = last.next;
              p3.prev = last;
              last.next.prev = p3;
              last.next = p3;
            }
            return p3;
          }
          function removeNode(p3) {
            p3.next.prev = p3.prev;
            p3.prev.next = p3.next;
            if (p3.prevZ) p3.prevZ.nextZ = p3.nextZ;
            if (p3.nextZ) p3.nextZ.prevZ = p3.prevZ;
          }
          function Node(i, x, y) {
            this.i = i;
            this.x = x;
            this.y = y;
            this.prev = null;
            this.next = null;
            this.z = null;
            this.prevZ = null;
            this.nextZ = null;
            this.steiner = false;
          }
          earcut.deviation = function (data, holeIndices, dim, triangles) {
            var hasHoles = holeIndices && holeIndices.length;
            var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
            var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
            if (hasHoles) {
              for (var i = 0, len = holeIndices.length; i < len; i++) {
                var start = holeIndices[i] * dim;
                var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                polygonArea -= Math.abs(signedArea(data, start, end, dim));
              }
            }
            var trianglesArea = 0;
            for (i = 0; i < triangles.length; i += 3) {
              var a = triangles[i] * dim;
              var b = triangles[i + 1] * dim;
              var c = triangles[i + 2] * dim;
              trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
            }
            return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
          };
          function signedArea(data, start, end, dim) {
            var sum = 0;
            for (var i = start, j = end - dim; i < end; i += dim) {
              sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
              j = i;
            }
            return sum;
          }
          earcut.flatten = function (data) {
            var dim = data[0][0].length, result = {
              vertices: [],
              holes: [],
              dimensions: dim
            }, holeIndex = 0;
            for (var i = 0; i < data.length; i++) {
              for (var j = 0; j < data[i].length; j++) {
                for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
              }
              if (i > 0) {
                holeIndex += data[i - 1].length;
                result.holes.push(holeIndex);
              }
            }
            return result;
          };
          module2.exports = earcut;
        }, function (module2, exports2) {
          var LineStyleCanvas = function (ctx, src, altColor, altAlpha) {
            var strokeColor = altColor ? altColor : src.strokeColor;
            var strokeAlpha = altAlpha ? altAlpha : src.strokeAlpha;
            var red = (strokeColor & 16711680) >>> 16;
            var green = (strokeColor & 65280) >>> 8;
            var blue = strokeColor & 255;
            ctx.strokeStyle = "rgba(" + red + "," + green + "," + blue + "," + strokeAlpha + ")";
            ctx.lineWidth = src.lineWidth;
          };
          module2.exports = LineStyleCanvas;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var GetValue = __webpack_require__(6);
          var IsPlainObject = __webpack_require__(7);
          var JSONFile = new Class({
            Extends: File,
            initialize: function JSONFile2(loader, key, url, xhrSettings, dataKey) {
              var extension = "json";
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                url = GetFastValue(config, "url");
                xhrSettings = GetFastValue(config, "xhrSettings");
                extension = GetFastValue(config, "extension", extension);
                dataKey = GetFastValue(config, "dataKey", dataKey);
              }
              var fileConfig = {
                type: "json",
                cache: loader.cacheManager.json,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings,
                config: dataKey
              };
              File.call(this, loader, fileConfig);
              if (IsPlainObject(url)) {
                if (dataKey) {
                  this.data = GetValue(url, dataKey);
                } else {
                  this.data = url;
                }
                this.state = CONST.FILE_POPULATED;
              }
            },
            onProcess: function () {
              if (this.state !== CONST.FILE_POPULATED) {
                this.state = CONST.FILE_PROCESSING;
                try {
                  var json = JSON.parse(this.xhrLoader.responseText);
                } catch (e) {
                  console.warn("Invalid JSON: " + this.key);
                  this.onProcessError();
                  throw e;
                }
                var key = this.config;
                if (typeof key === "string") {
                  this.data = GetValue(json, key, json);
                } else {
                  this.data = json;
                }
              }
              this.onProcessComplete();
            }
          });
          FileTypesManager.register("json", function (key, url, dataKey, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new JSONFile(this, key[i]));
              }
            } else {
              this.addFile(new JSONFile(this, key, url, xhrSettings, dataKey));
            }
            return this;
          });
          module2.exports = JSONFile;
        }, function (module2, exports2) {
          var CONST = {
            DYNAMIC_BODY: 0,
            STATIC_BODY: 1,
            GROUP: 2,
            TILEMAPLAYER: 3,
            FACING_NONE: 10,
            FACING_UP: 11,
            FACING_DOWN: 12,
            FACING_LEFT: 13,
            FACING_RIGHT: 14
          };
          module2.exports = CONST;
        }, function (module2, exports2, __webpack_require__) {
          var GetTileAt = __webpack_require__(158);
          var GetTilesWithin = __webpack_require__(26);
          var CalculateFacesWithin = function (tileX, tileY, width, height, layer) {
            var above = null;
            var below = null;
            var left = null;
            var right = null;
            var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
            for (var i = 0; i < tiles.length; i++) {
              var tile = tiles[i];
              if (tile) {
                if (tile.collides) {
                  above = GetTileAt(tile.x, tile.y - 1, true, layer);
                  below = GetTileAt(tile.x, tile.y + 1, true, layer);
                  left = GetTileAt(tile.x - 1, tile.y, true, layer);
                  right = GetTileAt(tile.x + 1, tile.y, true, layer);
                  tile.faceTop = above && above.collides ? false : true;
                  tile.faceBottom = below && below.collides ? false : true;
                  tile.faceLeft = left && left.collides ? false : true;
                  tile.faceRight = right && right.collides ? false : true;
                } else {
                  tile.resetFaces();
                }
              }
            }
          };
          module2.exports = CalculateFacesWithin;
        }, function (module2, exports2, __webpack_require__) {
          var Vertices = {};
          module2.exports = Vertices;
          var Vector = __webpack_require__(83);
          var Common = __webpack_require__(32);
          (function () {
            Vertices.create = function (points, body) {
              var vertices = [];
              for (var i = 0; i < points.length; i++) {
                var point = points[i], vertex = {
                  x: point.x,
                  y: point.y,
                  index: i,
                  body,
                  isInternal: false,
                  contact: null,
                  offset: null
                };
                vertex.contact = {
                  vertex,
                  normalImpulse: 0,
                  tangentImpulse: 0
                };
                vertices.push(vertex);
              }
              return vertices;
            };
            Vertices.fromPath = function (path, body) {
              var pathPattern = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig, points = [];
              path.replace(pathPattern, function (match, x, y) {
                points.push({
                  x: parseFloat(x),
                  y: parseFloat(y)
                });
              });
              return Vertices.create(points, body);
            };
            Vertices.centre = function (vertices) {
              var area = Vertices.area(vertices, true), centre = {
                x: 0,
                y: 0
              }, cross, temp, j;
              for (var i = 0; i < vertices.length; i++) {
                j = (i + 1) % vertices.length;
                cross = Vector.cross(vertices[i], vertices[j]);
                temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);
                centre = Vector.add(centre, temp);
              }
              return Vector.div(centre, 6 * area);
            };
            Vertices.mean = function (vertices) {
              var average = {
                x: 0,
                y: 0
              };
              for (var i = 0; i < vertices.length; i++) {
                average.x += vertices[i].x;
                average.y += vertices[i].y;
              }
              return Vector.div(average, vertices.length);
            };
            Vertices.area = function (vertices, signed) {
              var area = 0, j = vertices.length - 1;
              for (var i = 0; i < vertices.length; i++) {
                area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);
                j = i;
              }
              if (signed) return area / 2;
              return Math.abs(area) / 2;
            };
            Vertices.inertia = function (vertices, mass) {
              var numerator = 0, denominator = 0, v = vertices, cross, j;
              for (var n = 0; n < v.length; n++) {
                j = (n + 1) % v.length;
                cross = Math.abs(Vector.cross(v[j], v[n]));
                numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));
                denominator += cross;
              }
              return mass / 6 * (numerator / denominator);
            };
            Vertices.translate = function (vertices, vector, scalar) {
              var i;
              if (scalar) {
                for (i = 0; i < vertices.length; i++) {
                  vertices[i].x += vector.x * scalar;
                  vertices[i].y += vector.y * scalar;
                }
              } else {
                for (i = 0; i < vertices.length; i++) {
                  vertices[i].x += vector.x;
                  vertices[i].y += vector.y;
                }
              }
              return vertices;
            };
            Vertices.rotate = function (vertices, angle, point) {
              if (angle === 0) return;
              var cos = Math.cos(angle), sin = Math.sin(angle);
              for (var i = 0; i < vertices.length; i++) {
                var vertice = vertices[i], dx = vertice.x - point.x, dy = vertice.y - point.y;
                vertice.x = point.x + (dx * cos - dy * sin);
                vertice.y = point.y + (dx * sin + dy * cos);
              }
              return vertices;
            };
            Vertices.contains = function (vertices, point) {
              for (var i = 0; i < vertices.length; i++) {
                var vertice = vertices[i], nextVertice = vertices[(i + 1) % vertices.length];
                if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {
                  return false;
                }
              }
              return true;
            };
            Vertices.scale = function (vertices, scaleX, scaleY, point) {
              if (scaleX === 1 && scaleY === 1) return vertices;
              point = point || Vertices.centre(vertices);
              var vertex, delta;
              for (var i = 0; i < vertices.length; i++) {
                vertex = vertices[i];
                delta = Vector.sub(vertex, point);
                vertices[i].x = point.x + delta.x * scaleX;
                vertices[i].y = point.y + delta.y * scaleY;
              }
              return vertices;
            };
            Vertices.chamfer = function (vertices, radius, quality, qualityMin, qualityMax) {
              if (typeof radius === "number") {
                radius = [radius];
              } else {
                radius = radius || [8];
              }
              quality = typeof quality !== "undefined" ? quality : -1;
              qualityMin = qualityMin || 2;
              qualityMax = qualityMax || 14;
              var newVertices = [];
              for (var i = 0; i < vertices.length; i++) {
                var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1], vertex = vertices[i], nextVertex = vertices[(i + 1) % vertices.length], currentRadius = radius[i < radius.length ? i : radius.length - 1];
                if (currentRadius === 0) {
                  newVertices.push(vertex);
                  continue;
                }
                var prevNormal = Vector.normalise({
                  x: vertex.y - prevVertex.y,
                  y: prevVertex.x - vertex.x
                });
                var nextNormal = Vector.normalise({
                  x: nextVertex.y - vertex.y,
                  y: vertex.x - nextVertex.x
                });
                var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)), radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius), midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)), scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));
                var precision = quality;
                if (quality === -1) {
                  precision = Math.pow(currentRadius, 0.32) * 1.75;
                }
                precision = Common.clamp(precision, qualityMin, qualityMax);
                if (precision % 2 === 1) precision += 1;
                var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)), theta = alpha / precision;
                for (var j = 0; j < precision; j++) {
                  newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));
                }
              }
              return newVertices;
            };
            Vertices.clockwiseSort = function (vertices) {
              var centre = Vertices.mean(vertices);
              vertices.sort(function (vertexA, vertexB) {
                return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);
              });
              return vertices;
            };
            Vertices.isConvex = function (vertices) {
              var flag = 0, n = vertices.length, i, j, k, z;
              if (n < 3) return null;
              for (i = 0; i < n; i++) {
                j = (i + 1) % n;
                k = (i + 2) % n;
                z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);
                z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);
                if (z < 0) {
                  flag |= 1;
                } else if (z > 0) {
                  flag |= 2;
                }
                if (flag === 3) {
                  return false;
                }
              }
              if (flag !== 0) {
                return true;
              } else {
                return null;
              }
            };
            Vertices.hull = function (vertices) {
              var upper = [], lower = [], vertex, i;
              vertices = vertices.slice(0);
              vertices.sort(function (vertexA, vertexB) {
                var dx = vertexA.x - vertexB.x;
                return dx !== 0 ? dx : vertexA.y - vertexB.y;
              });
              for (i = 0; i < vertices.length; i += 1) {
                vertex = vertices[i];
                while (lower.length >= 2 && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {
                  lower.pop();
                }
                lower.push(vertex);
              }
              for (i = vertices.length - 1; i >= 0; i -= 1) {
                vertex = vertices[i];
                while (upper.length >= 2 && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {
                  upper.pop();
                }
                upper.push(vertex);
              }
              upper.pop();
              lower.pop();
              return upper.concat(lower);
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Contains = __webpack_require__(66);
          var GetPoint = __webpack_require__(300);
          var GetPoints = __webpack_require__(301);
          var GEOM_CONST = __webpack_require__(56);
          var Random = __webpack_require__(170);
          var Circle = new Class({
            initialize: function Circle2(x, y, radius) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (radius === void 0) {
                radius = 0;
              }
              this.type = GEOM_CONST.CIRCLE;
              this.x = x;
              this.y = y;
              this._radius = radius;
              this._diameter = radius * 2;
            },
            contains: function (x, y) {
              return Contains(this, x, y);
            },
            getPoint: function (position, point) {
              return GetPoint(this, position, point);
            },
            getPoints: function (quantity, stepRate, output) {
              return GetPoints(this, quantity, stepRate, output);
            },
            getRandomPoint: function (point) {
              return Random(this, point);
            },
            setTo: function (x, y, radius) {
              this.x = x;
              this.y = y;
              this._radius = radius;
              this._diameter = radius * 2;
              return this;
            },
            setEmpty: function () {
              this._radius = 0;
              this._diameter = 0;
              return this;
            },
            setPosition: function (x, y) {
              if (y === void 0) {
                y = x;
              }
              this.x = x;
              this.y = y;
              return this;
            },
            isEmpty: function () {
              return this._radius <= 0;
            },
            radius: {
              get: function () {
                return this._radius;
              },
              set: function (value) {
                this._radius = value;
                this._diameter = value * 2;
              }
            },
            diameter: {
              get: function () {
                return this._diameter;
              },
              set: function (value) {
                this._diameter = value;
                this._radius = value * 0.5;
              }
            },
            left: {
              get: function () {
                return this.x - this._radius;
              },
              set: function (value) {
                this.x = value + this._radius;
              }
            },
            right: {
              get: function () {
                return this.x + this._radius;
              },
              set: function (value) {
                this.x = value - this._radius;
              }
            },
            top: {
              get: function () {
                return this.y - this._radius;
              },
              set: function (value) {
                this.y = value + this._radius;
              }
            },
            bottom: {
              get: function () {
                return this.y + this._radius;
              },
              set: function (value) {
                this.y = value - this._radius;
              }
            }
          });
          module2.exports = Circle;
        }, function (module2, exports2) {
          var Contains = function (circle, x, y) {
            if (circle.radius > 0 && x >= circle.left && x <= circle.right && y >= circle.top && y <= circle.bottom) {
              var dx = (circle.x - x) * (circle.x - x);
              var dy = (circle.y - y) * (circle.y - y);
              return dx + dy <= circle.radius * circle.radius;
            } else {
              return false;
            }
          };
          module2.exports = Contains;
        }, function (module2, exports2) {
          var Length = function (line) {
            return Math.sqrt((line.x2 - line.x1) * (line.x2 - line.x1) + (line.y2 - line.y1) * (line.y2 - line.y1));
          };
          module2.exports = Length;
        }, function (module2, exports2) {
          var Wrap = function (value, min, max) {
            var range = max - min;
            return min + ((value - min) % range + range) % range;
          };
          module2.exports = Wrap;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Vector3 = __webpack_require__(39);
          var EPSILON = 1e-6;
          var Matrix4 = new Class({
            initialize: function Matrix42(m) {
              this.val = new Float32Array(16);
              if (m) {
                this.copy(m);
              } else {
                this.identity();
              }
            },
            clone: function () {
              return new Matrix4(this);
            },
            set: function (src) {
              return this.copy(src);
            },
            setValues: function (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
              var out = this.val;
              out[0] = m00;
              out[1] = m01;
              out[2] = m02;
              out[3] = m03;
              out[4] = m10;
              out[5] = m11;
              out[6] = m12;
              out[7] = m13;
              out[8] = m20;
              out[9] = m21;
              out[10] = m22;
              out[11] = m23;
              out[12] = m30;
              out[13] = m31;
              out[14] = m32;
              out[15] = m33;
              return this;
            },
            copy: function (src) {
              var a = src.val;
              return this.setValues(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
            },
            fromArray: function (a) {
              return this.setValues(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
            },
            zero: function () {
              return this.setValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            },
            transform: function (position, scale, rotation) {
              var rotMatrix = _tempMat1.fromQuat(rotation);
              var rm = rotMatrix.val;
              var sx = scale.x;
              var sy = scale.y;
              var sz = scale.z;
              return this.setValues(rm[0] * sx, rm[1] * sx, rm[2] * sx, 0, rm[4] * sy, rm[5] * sy, rm[6] * sy, 0, rm[8] * sz, rm[9] * sz, rm[10] * sz, 0, position.x, position.y, position.z, 1);
            },
            xyz: function (x, y, z) {
              this.identity();
              var out = this.val;
              out[12] = x;
              out[13] = y;
              out[14] = z;
              return this;
            },
            scaling: function (x, y, z) {
              this.zero();
              var out = this.val;
              out[0] = x;
              out[5] = y;
              out[10] = z;
              out[15] = 1;
              return this;
            },
            identity: function () {
              return this.setValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            },
            transpose: function () {
              var a = this.val;
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a12 = a[6];
              var a13 = a[7];
              var a23 = a[11];
              a[1] = a[4];
              a[2] = a[8];
              a[3] = a[12];
              a[4] = a01;
              a[6] = a[9];
              a[7] = a[13];
              a[8] = a02;
              a[9] = a12;
              a[11] = a[14];
              a[12] = a03;
              a[13] = a13;
              a[14] = a23;
              return this;
            },
            getInverse: function (m) {
              this.copy(m);
              return this.invert();
            },
            invert: function () {
              var a = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a10 = a[4];
              var a11 = a[5];
              var a12 = a[6];
              var a13 = a[7];
              var a20 = a[8];
              var a21 = a[9];
              var a22 = a[10];
              var a23 = a[11];
              var a30 = a[12];
              var a31 = a[13];
              var a32 = a[14];
              var a33 = a[15];
              var b00 = a00 * a11 - a01 * a10;
              var b01 = a00 * a12 - a02 * a10;
              var b02 = a00 * a13 - a03 * a10;
              var b03 = a01 * a12 - a02 * a11;
              var b04 = a01 * a13 - a03 * a11;
              var b05 = a02 * a13 - a03 * a12;
              var b06 = a20 * a31 - a21 * a30;
              var b07 = a20 * a32 - a22 * a30;
              var b08 = a20 * a33 - a23 * a30;
              var b09 = a21 * a32 - a22 * a31;
              var b10 = a21 * a33 - a23 * a31;
              var b11 = a22 * a33 - a23 * a32;
              var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
              if (!det) {
                return this;
              }
              det = 1 / det;
              return this.setValues((a11 * b11 - a12 * b10 + a13 * b09) * det, (a02 * b10 - a01 * b11 - a03 * b09) * det, (a31 * b05 - a32 * b04 + a33 * b03) * det, (a22 * b04 - a21 * b05 - a23 * b03) * det, (a12 * b08 - a10 * b11 - a13 * b07) * det, (a00 * b11 - a02 * b08 + a03 * b07) * det, (a32 * b02 - a30 * b05 - a33 * b01) * det, (a20 * b05 - a22 * b02 + a23 * b01) * det, (a10 * b10 - a11 * b08 + a13 * b06) * det, (a01 * b08 - a00 * b10 - a03 * b06) * det, (a30 * b04 - a31 * b02 + a33 * b00) * det, (a21 * b02 - a20 * b04 - a23 * b00) * det, (a11 * b07 - a10 * b09 - a12 * b06) * det, (a00 * b09 - a01 * b07 + a02 * b06) * det, (a31 * b01 - a30 * b03 - a32 * b00) * det, (a20 * b03 - a21 * b01 + a22 * b00) * det);
            },
            adjoint: function () {
              var a = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a10 = a[4];
              var a11 = a[5];
              var a12 = a[6];
              var a13 = a[7];
              var a20 = a[8];
              var a21 = a[9];
              var a22 = a[10];
              var a23 = a[11];
              var a30 = a[12];
              var a31 = a[13];
              var a32 = a[14];
              var a33 = a[15];
              return this.setValues(a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22), -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22)), a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12), -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12)), -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22)), a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22), -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12)), a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12), a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21), -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21)), a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11), -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11)), -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21)), a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21), -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11)), a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
            },
            determinant: function () {
              var a = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a10 = a[4];
              var a11 = a[5];
              var a12 = a[6];
              var a13 = a[7];
              var a20 = a[8];
              var a21 = a[9];
              var a22 = a[10];
              var a23 = a[11];
              var a30 = a[12];
              var a31 = a[13];
              var a32 = a[14];
              var a33 = a[15];
              var b00 = a00 * a11 - a01 * a10;
              var b01 = a00 * a12 - a02 * a10;
              var b02 = a00 * a13 - a03 * a10;
              var b03 = a01 * a12 - a02 * a11;
              var b04 = a01 * a13 - a03 * a11;
              var b05 = a02 * a13 - a03 * a12;
              var b06 = a20 * a31 - a21 * a30;
              var b07 = a20 * a32 - a22 * a30;
              var b08 = a20 * a33 - a23 * a30;
              var b09 = a21 * a32 - a22 * a31;
              var b10 = a21 * a33 - a23 * a31;
              var b11 = a22 * a33 - a23 * a32;
              return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            },
            multiply: function (src) {
              var a = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a10 = a[4];
              var a11 = a[5];
              var a12 = a[6];
              var a13 = a[7];
              var a20 = a[8];
              var a21 = a[9];
              var a22 = a[10];
              var a23 = a[11];
              var a30 = a[12];
              var a31 = a[13];
              var a32 = a[14];
              var a33 = a[15];
              var b = src.val;
              var b0 = b[0];
              var b1 = b[1];
              var b2 = b[2];
              var b3 = b[3];
              a[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
              a[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
              a[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
              a[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
              b0 = b[4];
              b1 = b[5];
              b2 = b[6];
              b3 = b[7];
              a[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
              a[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
              a[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
              a[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
              b0 = b[8];
              b1 = b[9];
              b2 = b[10];
              b3 = b[11];
              a[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
              a[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
              a[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
              a[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
              b0 = b[12];
              b1 = b[13];
              b2 = b[14];
              b3 = b[15];
              a[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
              a[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
              a[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
              a[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
              return this;
            },
            multiplyLocal: function (src) {
              var a = this.val;
              var b = src.val;
              return this.setValues(a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12], a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13], a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14], a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15], a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12], a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13], a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14], a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15], a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12], a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13], a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14], a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15], a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12], a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13], a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14], a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15]);
            },
            premultiply: function (m) {
              return this.multiplyMatrices(m, this);
            },
            multiplyMatrices: function (a, b) {
              var am = a.val;
              var bm = b.val;
              var a11 = am[0];
              var a12 = am[4];
              var a13 = am[8];
              var a14 = am[12];
              var a21 = am[1];
              var a22 = am[5];
              var a23 = am[9];
              var a24 = am[13];
              var a31 = am[2];
              var a32 = am[6];
              var a33 = am[10];
              var a34 = am[14];
              var a41 = am[3];
              var a42 = am[7];
              var a43 = am[11];
              var a44 = am[15];
              var b11 = bm[0];
              var b12 = bm[4];
              var b13 = bm[8];
              var b14 = bm[12];
              var b21 = bm[1];
              var b22 = bm[5];
              var b23 = bm[9];
              var b24 = bm[13];
              var b31 = bm[2];
              var b32 = bm[6];
              var b33 = bm[10];
              var b34 = bm[14];
              var b41 = bm[3];
              var b42 = bm[7];
              var b43 = bm[11];
              var b44 = bm[15];
              return this.setValues(a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41, a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41, a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41, a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41, a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42, a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42, a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42, a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42, a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43, a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43, a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43, a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43, a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44, a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44, a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44, a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44);
            },
            translate: function (v) {
              return this.translateXYZ(v.x, v.y, v.z);
            },
            translateXYZ: function (x, y, z) {
              var a = this.val;
              a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
              a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
              a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
              a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
              return this;
            },
            scale: function (v) {
              return this.scaleXYZ(v.x, v.y, v.z);
            },
            scaleXYZ: function (x, y, z) {
              var a = this.val;
              a[0] = a[0] * x;
              a[1] = a[1] * x;
              a[2] = a[2] * x;
              a[3] = a[3] * x;
              a[4] = a[4] * y;
              a[5] = a[5] * y;
              a[6] = a[6] * y;
              a[7] = a[7] * y;
              a[8] = a[8] * z;
              a[9] = a[9] * z;
              a[10] = a[10] * z;
              a[11] = a[11] * z;
              return this;
            },
            makeRotationAxis: function (axis, angle) {
              var c = Math.cos(angle);
              var s = Math.sin(angle);
              var t = 1 - c;
              var x = axis.x;
              var y = axis.y;
              var z = axis.z;
              var tx = t * x;
              var ty = t * y;
              return this.setValues(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
            },
            rotate: function (rad, axis) {
              var a = this.val;
              var x = axis.x;
              var y = axis.y;
              var z = axis.z;
              var len = Math.sqrt(x * x + y * y + z * z);
              if (Math.abs(len) < EPSILON) {
                return this;
              }
              len = 1 / len;
              x *= len;
              y *= len;
              z *= len;
              var s = Math.sin(rad);
              var c = Math.cos(rad);
              var t = 1 - c;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a10 = a[4];
              var a11 = a[5];
              var a12 = a[6];
              var a13 = a[7];
              var a20 = a[8];
              var a21 = a[9];
              var a22 = a[10];
              var a23 = a[11];
              var a30 = a[12];
              var a31 = a[13];
              var a32 = a[14];
              var a33 = a[15];
              var b00 = x * x * t + c;
              var b01 = y * x * t + z * s;
              var b02 = z * x * t - y * s;
              var b10 = x * y * t - z * s;
              var b11 = y * y * t + c;
              var b12 = z * y * t + x * s;
              var b20 = x * z * t + y * s;
              var b21 = y * z * t - x * s;
              var b22 = z * z * t + c;
              return this.setValues(a00 * b00 + a10 * b01 + a20 * b02, a01 * b00 + a11 * b01 + a21 * b02, a02 * b00 + a12 * b01 + a22 * b02, a03 * b00 + a13 * b01 + a23 * b02, a00 * b10 + a10 * b11 + a20 * b12, a01 * b10 + a11 * b11 + a21 * b12, a02 * b10 + a12 * b11 + a22 * b12, a03 * b10 + a13 * b11 + a23 * b12, a00 * b20 + a10 * b21 + a20 * b22, a01 * b20 + a11 * b21 + a21 * b22, a02 * b20 + a12 * b21 + a22 * b22, a03 * b20 + a13 * b21 + a23 * b22, a30, a31, a32, a33);
            },
            rotateX: function (rad) {
              var a = this.val;
              var s = Math.sin(rad);
              var c = Math.cos(rad);
              var a10 = a[4];
              var a11 = a[5];
              var a12 = a[6];
              var a13 = a[7];
              var a20 = a[8];
              var a21 = a[9];
              var a22 = a[10];
              var a23 = a[11];
              a[4] = a10 * c + a20 * s;
              a[5] = a11 * c + a21 * s;
              a[6] = a12 * c + a22 * s;
              a[7] = a13 * c + a23 * s;
              a[8] = a20 * c - a10 * s;
              a[9] = a21 * c - a11 * s;
              a[10] = a22 * c - a12 * s;
              a[11] = a23 * c - a13 * s;
              return this;
            },
            rotateY: function (rad) {
              var a = this.val;
              var s = Math.sin(rad);
              var c = Math.cos(rad);
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a20 = a[8];
              var a21 = a[9];
              var a22 = a[10];
              var a23 = a[11];
              a[0] = a00 * c - a20 * s;
              a[1] = a01 * c - a21 * s;
              a[2] = a02 * c - a22 * s;
              a[3] = a03 * c - a23 * s;
              a[8] = a00 * s + a20 * c;
              a[9] = a01 * s + a21 * c;
              a[10] = a02 * s + a22 * c;
              a[11] = a03 * s + a23 * c;
              return this;
            },
            rotateZ: function (rad) {
              var a = this.val;
              var s = Math.sin(rad);
              var c = Math.cos(rad);
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a10 = a[4];
              var a11 = a[5];
              var a12 = a[6];
              var a13 = a[7];
              a[0] = a00 * c + a10 * s;
              a[1] = a01 * c + a11 * s;
              a[2] = a02 * c + a12 * s;
              a[3] = a03 * c + a13 * s;
              a[4] = a10 * c - a00 * s;
              a[5] = a11 * c - a01 * s;
              a[6] = a12 * c - a02 * s;
              a[7] = a13 * c - a03 * s;
              return this;
            },
            fromRotationTranslation: function (q, v) {
              var x = q.x;
              var y = q.y;
              var z = q.z;
              var w = q.w;
              var x2 = x + x;
              var y2 = y + y;
              var z2 = z + z;
              var xx = x * x2;
              var xy = x * y2;
              var xz = x * z2;
              var yy = y * y2;
              var yz = y * z2;
              var zz = z * z2;
              var wx = w * x2;
              var wy = w * y2;
              var wz = w * z2;
              return this.setValues(1 - (yy + zz), xy + wz, xz - wy, 0, xy - wz, 1 - (xx + zz), yz + wx, 0, xz + wy, yz - wx, 1 - (xx + yy), 0, v.x, v.y, v.z, 1);
            },
            fromQuat: function (q) {
              var x = q.x;
              var y = q.y;
              var z = q.z;
              var w = q.w;
              var x2 = x + x;
              var y2 = y + y;
              var z2 = z + z;
              var xx = x * x2;
              var xy = x * y2;
              var xz = x * z2;
              var yy = y * y2;
              var yz = y * z2;
              var zz = z * z2;
              var wx = w * x2;
              var wy = w * y2;
              var wz = w * z2;
              return this.setValues(1 - (yy + zz), xy + wz, xz - wy, 0, xy - wz, 1 - (xx + zz), yz + wx, 0, xz + wy, yz - wx, 1 - (xx + yy), 0, 0, 0, 0, 1);
            },
            frustum: function (left, right, bottom, top, near, far) {
              var rl = 1 / (right - left);
              var tb = 1 / (top - bottom);
              var nf = 1 / (near - far);
              return this.setValues(near * 2 * rl, 0, 0, 0, 0, near * 2 * tb, 0, 0, (right + left) * rl, (top + bottom) * tb, (far + near) * nf, -1, 0, 0, far * near * 2 * nf, 0);
            },
            perspective: function (fovy, aspect, near, far) {
              var f = 1 / Math.tan(fovy / 2);
              var nf = 1 / (near - far);
              return this.setValues(f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (far + near) * nf, -1, 0, 0, 2 * far * near * nf, 0);
            },
            perspectiveLH: function (width, height, near, far) {
              return this.setValues(2 * near / width, 0, 0, 0, 0, 2 * near / height, 0, 0, 0, 0, -far / (near - far), 1, 0, 0, near * far / (near - far), 0);
            },
            ortho: function (left, right, bottom, top, near, far) {
              var lr = left - right;
              var bt = bottom - top;
              var nf = near - far;
              lr = lr === 0 ? lr : 1 / lr;
              bt = bt === 0 ? bt : 1 / bt;
              nf = nf === 0 ? nf : 1 / nf;
              return this.setValues(-2 * lr, 0, 0, 0, 0, -2 * bt, 0, 0, 0, 0, 2 * nf, 0, (left + right) * lr, (top + bottom) * bt, (far + near) * nf, 1);
            },
            lookAtRH: function (eye, target, up) {
              var m = this.val;
              _z.subVectors(eye, target);
              if (_z.getLengthSquared() === 0) {
                _z.z = 1;
              }
              _z.normalize();
              _x.crossVectors(up, _z);
              if (_x.getLengthSquared() === 0) {
                if (Math.abs(up.z) === 1) {
                  _z.x += 1e-4;
                } else {
                  _z.z += 1e-4;
                }
                _z.normalize();
                _x.crossVectors(up, _z);
              }
              _x.normalize();
              _y.crossVectors(_z, _x);
              m[0] = _x.x;
              m[1] = _x.y;
              m[2] = _x.z;
              m[4] = _y.x;
              m[5] = _y.y;
              m[6] = _y.z;
              m[8] = _z.x;
              m[9] = _z.y;
              m[10] = _z.z;
              return this;
            },
            lookAt: function (eye, center, up) {
              var eyex = eye.x;
              var eyey = eye.y;
              var eyez = eye.z;
              var upx = up.x;
              var upy = up.y;
              var upz = up.z;
              var centerx = center.x;
              var centery = center.y;
              var centerz = center.z;
              if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
                return this.identity();
              }
              var z0 = eyex - centerx;
              var z1 = eyey - centery;
              var z2 = eyez - centerz;
              var len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
              z0 *= len;
              z1 *= len;
              z2 *= len;
              var x0 = upy * z2 - upz * z1;
              var x1 = upz * z0 - upx * z2;
              var x2 = upx * z1 - upy * z0;
              len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
              if (!len) {
                x0 = 0;
                x1 = 0;
                x2 = 0;
              } else {
                len = 1 / len;
                x0 *= len;
                x1 *= len;
                x2 *= len;
              }
              var y0 = z1 * x2 - z2 * x1;
              var y1 = z2 * x0 - z0 * x2;
              var y2 = z0 * x1 - z1 * x0;
              len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
              if (!len) {
                y0 = 0;
                y1 = 0;
                y2 = 0;
              } else {
                len = 1 / len;
                y0 *= len;
                y1 *= len;
                y2 *= len;
              }
              return this.setValues(x0, y0, z0, 0, x1, y1, z1, 0, x2, y2, z2, 0, -(x0 * eyex + x1 * eyey + x2 * eyez), -(y0 * eyex + y1 * eyey + y2 * eyez), -(z0 * eyex + z1 * eyey + z2 * eyez), 1);
            },
            yawPitchRoll: function (yaw, pitch, roll) {
              this.zero();
              _tempMat1.zero();
              _tempMat2.zero();
              var m0 = this.val;
              var m1 = _tempMat1.val;
              var m2 = _tempMat2.val;
              var s = Math.sin(roll);
              var c = Math.cos(roll);
              m0[10] = 1;
              m0[15] = 1;
              m0[0] = c;
              m0[1] = s;
              m0[4] = -s;
              m0[5] = c;
              s = Math.sin(pitch);
              c = Math.cos(pitch);
              m1[0] = 1;
              m1[15] = 1;
              m1[5] = c;
              m1[10] = c;
              m1[9] = -s;
              m1[6] = s;
              s = Math.sin(yaw);
              c = Math.cos(yaw);
              m2[5] = 1;
              m2[15] = 1;
              m2[0] = c;
              m2[2] = -s;
              m2[8] = s;
              m2[10] = c;
              this.multiplyLocal(_tempMat1);
              this.multiplyLocal(_tempMat2);
              return this;
            },
            setWorldMatrix: function (rotation, position, scale, viewMatrix, projectionMatrix) {
              this.yawPitchRoll(rotation.y, rotation.x, rotation.z);
              _tempMat1.scaling(scale.x, scale.y, scale.z);
              _tempMat2.xyz(position.x, position.y, position.z);
              this.multiplyLocal(_tempMat1);
              this.multiplyLocal(_tempMat2);
              if (viewMatrix) {
                this.multiplyLocal(viewMatrix);
              }
              if (projectionMatrix) {
                this.multiplyLocal(projectionMatrix);
              }
              return this;
            },
            multiplyToMat4: function (src, out) {
              var a = this.val;
              var b = src.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a10 = a[4];
              var a11 = a[5];
              var a12 = a[6];
              var a13 = a[7];
              var a20 = a[8];
              var a21 = a[9];
              var a22 = a[10];
              var a23 = a[11];
              var a30 = a[12];
              var a31 = a[13];
              var a32 = a[14];
              var a33 = a[15];
              var b00 = b[0];
              var b01 = b[1];
              var b02 = b[2];
              var b03 = b[3];
              var b10 = b[4];
              var b11 = b[5];
              var b12 = b[6];
              var b13 = b[7];
              var b20 = b[8];
              var b21 = b[9];
              var b22 = b[10];
              var b23 = b[11];
              var b30 = b[12];
              var b31 = b[13];
              var b32 = b[14];
              var b33 = b[15];
              return out.setValues(b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30, b01 * a01 + b01 * a11 + b02 * a21 + b03 * a31, b02 * a02 + b01 * a12 + b02 * a22 + b03 * a32, b03 * a03 + b01 * a13 + b02 * a23 + b03 * a33, b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30, b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31, b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32, b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33, b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30, b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31, b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32, b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33, b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30, b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31, b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32, b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33);
            },
            fromRotationXYTranslation: function (rotation, position, translateFirst) {
              var x = position.x;
              var y = position.y;
              var z = position.z;
              var sx = Math.sin(rotation.x);
              var cx = Math.cos(rotation.x);
              var sy = Math.sin(rotation.y);
              var cy = Math.cos(rotation.y);
              var a30 = x;
              var a31 = y;
              var a32 = z;
              var b21 = -sx;
              var c01 = 0 - b21 * sy;
              var c02 = 0 - cx * sy;
              var c21 = b21 * cy;
              var c22 = cx * cy;
              if (!translateFirst) {
                a30 = cy * x + sy * z;
                a31 = c01 * x + cx * y + c21 * z;
                a32 = c02 * x + sx * y + c22 * z;
              }
              return this.setValues(cy, c01, c02, 0, 0, cx, sx, 0, sy, c21, c22, 0, a30, a31, a32, 1);
            },
            getMaxScaleOnAxis: function () {
              var m = this.val;
              var scaleXSq = m[0] * m[0] + m[1] * m[1] + m[2] * m[2];
              var scaleYSq = m[4] * m[4] + m[5] * m[5] + m[6] * m[6];
              var scaleZSq = m[8] * m[8] + m[9] * m[9] + m[10] * m[10];
              return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
            }
          });
          var _tempMat1 = new Matrix4();
          var _tempMat2 = new Matrix4();
          var _x = new Vector3();
          var _y = new Vector3();
          var _z = new Vector3();
          module2.exports = Matrix4;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            COMPLETE: __webpack_require__(987),
            DECODED: __webpack_require__(988),
            DECODED_ALL: __webpack_require__(989),
            DESTROY: __webpack_require__(990),
            DETUNE: __webpack_require__(991),
            GLOBAL_DETUNE: __webpack_require__(992),
            GLOBAL_MUTE: __webpack_require__(993),
            GLOBAL_RATE: __webpack_require__(994),
            GLOBAL_VOLUME: __webpack_require__(995),
            LOOP: __webpack_require__(996),
            LOOPED: __webpack_require__(997),
            MUTE: __webpack_require__(998),
            PAN: __webpack_require__(999),
            PAUSE_ALL: __webpack_require__(1e3),
            PAUSE: __webpack_require__(1001),
            PLAY: __webpack_require__(1002),
            RATE: __webpack_require__(1003),
            RESUME_ALL: __webpack_require__(1004),
            RESUME: __webpack_require__(1005),
            SEEK: __webpack_require__(1006),
            STOP_ALL: __webpack_require__(1007),
            STOP: __webpack_require__(1008),
            UNLOCKED: __webpack_require__(1009),
            VOLUME: __webpack_require__(1010)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var ImageFile = new Class({
            Extends: File,
            initialize: function ImageFile2(loader, key, url, xhrSettings, frameConfig) {
              var extension = "png";
              var normalMapURL;
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                url = GetFastValue(config, "url");
                normalMapURL = GetFastValue(config, "normalMap");
                xhrSettings = GetFastValue(config, "xhrSettings");
                extension = GetFastValue(config, "extension", extension);
                frameConfig = GetFastValue(config, "frameConfig");
              }
              if (Array.isArray(url)) {
                normalMapURL = url[1];
                url = url[0];
              }
              var fileConfig = {
                type: "image",
                cache: loader.textureManager,
                extension,
                responseType: "blob",
                key,
                url,
                xhrSettings,
                config: frameConfig
              };
              File.call(this, loader, fileConfig);
              if (normalMapURL) {
                var normalMap = new ImageFile2(loader, this.key, normalMapURL, xhrSettings, frameConfig);
                normalMap.type = "normalMap";
                this.setLink(normalMap);
                loader.addFile(normalMap);
              }
            },
            onProcess: function () {
              this.state = CONST.FILE_PROCESSING;
              this.data = new Image();
              this.data.crossOrigin = this.crossOrigin;
              var _this = this;
              this.data.onload = function () {
                File.revokeObjectURL(_this.data);
                _this.onProcessComplete();
              };
              this.data.onerror = function () {
                File.revokeObjectURL(_this.data);
                _this.onProcessError();
              };
              File.createObjectURL(this.data, this.xhrLoader.response, "image/png");
            },
            addToCache: function () {
              var texture;
              var linkFile = this.linkFile;
              if (linkFile && linkFile.state === CONST.FILE_COMPLETE) {
                if (this.type === "image") {
                  texture = this.cache.addImage(this.key, this.data, linkFile.data);
                } else {
                  texture = this.cache.addImage(linkFile.key, linkFile.data, this.data);
                }
                this.pendingDestroy(texture);
                linkFile.pendingDestroy(texture);
              } else if (!linkFile) {
                texture = this.cache.addImage(this.key, this.data);
                this.pendingDestroy(texture);
              }
            }
          });
          FileTypesManager.register("image", function (key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new ImageFile(this, key[i]));
              }
            } else {
              this.addFile(new ImageFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = ImageFile;
        }, function (module2, exports2) {
          var SetTileCollision = function (tile, collides) {
            if (collides) {
              tile.setCollision(true, true, true, true, false);
            } else {
              tile.resetCollision(false);
            }
          };
          module2.exports = SetTileCollision;
        }, function (module2, exports2, __webpack_require__) {
          var AnimationState = __webpack_require__(164);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var SpriteRender = __webpack_require__(1065);
          var Sprite = new Class({
            Extends: GameObject,
            Mixins: [Components.Alpha, Components.BlendMode, Components.Depth, Components.Flip, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Size, Components.TextureCrop, Components.Tint, Components.Transform, Components.Visible, SpriteRender],
            initialize: function Sprite2(scene, x, y, texture, frame) {
              GameObject.call(this, scene, "Sprite");
              this._crop = this.resetCropObject();
              this.anims = new AnimationState(this);
              this.setTexture(texture, frame);
              this.setPosition(x, y);
              this.setSizeToFrame();
              this.setOriginFromFrame();
              this.initPipeline();
            },
            addedToScene: function () {
              this.scene.sys.updateList.add(this);
            },
            removedFromScene: function () {
              this.scene.sys.updateList.remove(this);
            },
            preUpdate: function (time, delta) {
              this.anims.update(time, delta);
            },
            play: function (key, ignoreIfPlaying) {
              return this.anims.play(key, ignoreIfPlaying);
            },
            playReverse: function (key, ignoreIfPlaying) {
              return this.anims.playReverse(key, ignoreIfPlaying);
            },
            playAfterDelay: function (key, delay) {
              return this.anims.playAfterDelay(key, delay);
            },
            playAfterRepeat: function (key, repeatCount) {
              return this.anims.playAfterRepeat(key, repeatCount);
            },
            chain: function (key) {
              return this.anims.chain(key);
            },
            stop: function () {
              return this.anims.stop();
            },
            stopAfterDelay: function (delay) {
              return this.anims.stopAfterDelay(delay);
            },
            stopAfterRepeat: function (repeatCount) {
              return this.anims.stopAfterRepeat(repeatCount);
            },
            stopOnFrame: function (frame) {
              return this.anims.stopOnFrame(frame);
            },
            toJSON: function () {
              return Components.ToJSON(this);
            },
            preDestroy: function () {
              this.anims.destroy();
              this.anims = void 0;
            }
          });
          module2.exports = Sprite;
        }, function (module2, exports2) {
          var SpliceOne = function (array, index) {
            if (index >= array.length) {
              return;
            }
            var len = array.length - 1;
            var item = array[index];
            for (var i = index; i < len; i++) {
              array[i] = array[i + 1];
            }
            array.length = len;
            return item;
          };
          module2.exports = SpliceOne;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            ADDED_TO_SCENE: __webpack_require__(643),
            DESTROY: __webpack_require__(644),
            REMOVED_FROM_SCENE: __webpack_require__(645),
            VIDEO_COMPLETE: __webpack_require__(646),
            VIDEO_CREATED: __webpack_require__(647),
            VIDEO_ERROR: __webpack_require__(648),
            VIDEO_LOOP: __webpack_require__(649),
            VIDEO_PLAY: __webpack_require__(650),
            VIDEO_SEEKED: __webpack_require__(651),
            VIDEO_SEEKING: __webpack_require__(652),
            VIDEO_STOP: __webpack_require__(653),
            VIDEO_TIMEOUT: __webpack_require__(654),
            VIDEO_UNLOCKED: __webpack_require__(655)
          };
        }, function (module2, exports2) {
          var SnapFloor = function (value, gap, start, divide) {
            if (start === void 0) {
              start = 0;
            }
            if (gap === 0) {
              return value;
            }
            value -= start;
            value = gap * Math.floor(value / gap);
            return divide ? (start + value) / gap : start + value;
          };
          module2.exports = SnapFloor;
        }, function (module2, exports2) {
          var Clone = function (obj) {
            var clone = {};
            for (var key in obj) {
              if (Array.isArray(obj[key])) {
                clone[key] = obj[key].slice(0);
              } else {
                clone[key] = obj[key];
              }
            }
            return clone;
          };
          module2.exports = Clone;
        }, function (module2, exports2) {
          var SafeRange = function (array, startIndex, endIndex, throwError) {
            var len = array.length;
            if (startIndex < 0 || startIndex > len || startIndex >= endIndex || endIndex > len || startIndex + endIndex > len) {
              if (throwError) {
                throw new Error("Range Error: Values outside acceptable range");
              }
              return false;
            } else {
              return true;
            }
          };
          module2.exports = SafeRange;
        }, function (module2, exports2) {
          function Compare(a, b) {
            return String(a).localeCompare(b);
          }
          function Process(array, compare) {
            var len = array.length;
            if (len <= 1) {
              return array;
            }
            var buffer = new Array(len);
            for (var chk = 1; chk < len; chk *= 2) {
              RunPass(array, compare, chk, buffer);
              var tmp = array;
              array = buffer;
              buffer = tmp;
            }
            return array;
          }
          function RunPass(arr, comp, chk, result) {
            var len = arr.length;
            var i = 0;
            var dbl = chk * 2;
            var l, r, e;
            var li, ri;
            for (l = 0; l < len; l += dbl) {
              r = l + chk;
              e = r + chk;
              if (r > len) {
                r = len;
              }
              if (e > len) {
                e = len;
              }
              li = l;
              ri = r;
              while (true) {
                if (li < r && ri < e) {
                  if (comp(arr[li], arr[ri]) <= 0) {
                    result[i++] = arr[li++];
                  } else {
                    result[i++] = arr[ri++];
                  }
                } else if (li < r) {
                  result[i++] = arr[li++];
                } else if (ri < e) {
                  result[i++] = arr[ri++];
                } else {
                  break;
                }
              }
            }
          }
          var StableSort = function (array, compare) {
            if (compare === void 0) {
              compare = Compare;
            }
            var result = Process(array, compare);
            if (result !== array) {
              RunPass(result, null, array.length, array);
            }
            return array;
          };
          module2.exports = StableSort;
        }, function (module2, exports2, __webpack_require__) {
          var EaseMap = __webpack_require__(134);
          var UppercaseFirst = __webpack_require__(205);
          var GetEaseFunction = function (ease, easeParams) {
            var easeFunction = EaseMap.Power0;
            if (typeof ease === "string") {
              if (EaseMap.hasOwnProperty(ease)) {
                easeFunction = EaseMap[ease];
              } else {
                var direction = "";
                if (ease.indexOf(".")) {
                  direction = ease.substr(ease.indexOf(".") + 1);
                  if (direction.toLowerCase() === "in") {
                    direction = "easeIn";
                  } else if (direction.toLowerCase() === "out") {
                    direction = "easeOut";
                  } else if (direction.toLowerCase() === "inout") {
                    direction = "easeInOut";
                  }
                }
                ease = UppercaseFirst(ease.substr(0, ease.indexOf(".") + 1) + direction);
                if (EaseMap.hasOwnProperty(ease)) {
                  easeFunction = EaseMap[ease];
                }
              }
            } else if (typeof ease === "function") {
              easeFunction = ease;
            } else if (Array.isArray(ease) && ease.length === 4) {}
            if (!easeParams) {
              return easeFunction;
            }
            var cloneParams = easeParams.slice(0);
            cloneParams.unshift(0);
            return function (v) {
              cloneParams[0] = v;
              return easeFunction.apply(this, cloneParams);
            };
          };
          module2.exports = GetEaseFunction;
        }, function (module2, exports2, __webpack_require__) {
          var Utils = __webpack_require__(12);
          var StrokePathWebGL = function (pipeline, src, alpha, dx, dy) {
            var strokeTint = pipeline.strokeTint;
            var strokeTintColor = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);
            strokeTint.TL = strokeTintColor;
            strokeTint.TR = strokeTintColor;
            strokeTint.BL = strokeTintColor;
            strokeTint.BR = strokeTintColor;
            var path = src.pathData;
            var pathLength = path.length - 1;
            var lineWidth = src.lineWidth;
            var halfLineWidth = lineWidth / 2;
            var px1 = path[0] - dx;
            var py1 = path[1] - dy;
            if (!src.closePath) {
              pathLength -= 2;
            }
            for (var i = 2; i < pathLength; i += 2) {
              var px2 = path[i] - dx;
              var py2 = path[i + 1] - dy;
              pipeline.batchLine(px1, py1, px2, py2, halfLineWidth, halfLineWidth, lineWidth, i - 2, src.closePath ? i === pathLength - 1 : false);
              px1 = px2;
              py1 = py2;
            }
          };
          module2.exports = StrokePathWebGL;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Contains = __webpack_require__(115);
          var GetPoint = __webpack_require__(476);
          var GetPoints = __webpack_require__(477);
          var GEOM_CONST = __webpack_require__(56);
          var Line = __webpack_require__(47);
          var Random = __webpack_require__(181);
          var Triangle = new Class({
            initialize: function Triangle2(x1, y1, x2, y2, x3, y3) {
              if (x1 === void 0) {
                x1 = 0;
              }
              if (y1 === void 0) {
                y1 = 0;
              }
              if (x2 === void 0) {
                x2 = 0;
              }
              if (y2 === void 0) {
                y2 = 0;
              }
              if (x3 === void 0) {
                x3 = 0;
              }
              if (y3 === void 0) {
                y3 = 0;
              }
              this.type = GEOM_CONST.TRIANGLE;
              this.x1 = x1;
              this.y1 = y1;
              this.x2 = x2;
              this.y2 = y2;
              this.x3 = x3;
              this.y3 = y3;
            },
            contains: function (x, y) {
              return Contains(this, x, y);
            },
            getPoint: function (position, output) {
              return GetPoint(this, position, output);
            },
            getPoints: function (quantity, stepRate, output) {
              return GetPoints(this, quantity, stepRate, output);
            },
            getRandomPoint: function (point) {
              return Random(this, point);
            },
            setTo: function (x1, y1, x2, y2, x3, y3) {
              if (x1 === void 0) {
                x1 = 0;
              }
              if (y1 === void 0) {
                y1 = 0;
              }
              if (x2 === void 0) {
                x2 = 0;
              }
              if (y2 === void 0) {
                y2 = 0;
              }
              if (x3 === void 0) {
                x3 = 0;
              }
              if (y3 === void 0) {
                y3 = 0;
              }
              this.x1 = x1;
              this.y1 = y1;
              this.x2 = x2;
              this.y2 = y2;
              this.x3 = x3;
              this.y3 = y3;
              return this;
            },
            getLineA: function (line) {
              if (line === void 0) {
                line = new Line();
              }
              line.setTo(this.x1, this.y1, this.x2, this.y2);
              return line;
            },
            getLineB: function (line) {
              if (line === void 0) {
                line = new Line();
              }
              line.setTo(this.x2, this.y2, this.x3, this.y3);
              return line;
            },
            getLineC: function (line) {
              if (line === void 0) {
                line = new Line();
              }
              line.setTo(this.x3, this.y3, this.x1, this.y1);
              return line;
            },
            left: {
              get: function () {
                return Math.min(this.x1, this.x2, this.x3);
              },
              set: function (value) {
                var diff = 0;
                if (this.x1 <= this.x2 && this.x1 <= this.x3) {
                  diff = this.x1 - value;
                } else if (this.x2 <= this.x1 && this.x2 <= this.x3) {
                  diff = this.x2 - value;
                } else {
                  diff = this.x3 - value;
                }
                this.x1 -= diff;
                this.x2 -= diff;
                this.x3 -= diff;
              }
            },
            right: {
              get: function () {
                return Math.max(this.x1, this.x2, this.x3);
              },
              set: function (value) {
                var diff = 0;
                if (this.x1 >= this.x2 && this.x1 >= this.x3) {
                  diff = this.x1 - value;
                } else if (this.x2 >= this.x1 && this.x2 >= this.x3) {
                  diff = this.x2 - value;
                } else {
                  diff = this.x3 - value;
                }
                this.x1 -= diff;
                this.x2 -= diff;
                this.x3 -= diff;
              }
            },
            top: {
              get: function () {
                return Math.min(this.y1, this.y2, this.y3);
              },
              set: function (value) {
                var diff = 0;
                if (this.y1 <= this.y2 && this.y1 <= this.y3) {
                  diff = this.y1 - value;
                } else if (this.y2 <= this.y1 && this.y2 <= this.y3) {
                  diff = this.y2 - value;
                } else {
                  diff = this.y3 - value;
                }
                this.y1 -= diff;
                this.y2 -= diff;
                this.y3 -= diff;
              }
            },
            bottom: {
              get: function () {
                return Math.max(this.y1, this.y2, this.y3);
              },
              set: function (value) {
                var diff = 0;
                if (this.y1 >= this.y2 && this.y1 >= this.y3) {
                  diff = this.y1 - value;
                } else if (this.y2 >= this.y1 && this.y2 >= this.y3) {
                  diff = this.y2 - value;
                } else {
                  diff = this.y3 - value;
                }
                this.y1 -= diff;
                this.y2 -= diff;
                this.y3 -= diff;
              }
            }
          });
          module2.exports = Triangle;
        }, function (module2, exports2) {
          var Vector = {};
          module2.exports = Vector;
          (function () {
            Vector.create = function (x, y) {
              return {
                x: x || 0,
                y: y || 0
              };
            };
            Vector.clone = function (vector) {
              return {
                x: vector.x,
                y: vector.y
              };
            };
            Vector.magnitude = function (vector) {
              return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
            };
            Vector.magnitudeSquared = function (vector) {
              return vector.x * vector.x + vector.y * vector.y;
            };
            Vector.rotate = function (vector, angle, output) {
              var cos = Math.cos(angle), sin = Math.sin(angle);
              if (!output) output = {};
              var x = vector.x * cos - vector.y * sin;
              output.y = vector.x * sin + vector.y * cos;
              output.x = x;
              return output;
            };
            Vector.rotateAbout = function (vector, angle, point, output) {
              var cos = Math.cos(angle), sin = Math.sin(angle);
              if (!output) output = {};
              var x = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);
              output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);
              output.x = x;
              return output;
            };
            Vector.normalise = function (vector) {
              var magnitude = Vector.magnitude(vector);
              if (magnitude === 0) return {
                x: 0,
                y: 0
              };
              return {
                x: vector.x / magnitude,
                y: vector.y / magnitude
              };
            };
            Vector.dot = function (vectorA, vectorB) {
              return vectorA.x * vectorB.x + vectorA.y * vectorB.y;
            };
            Vector.cross = function (vectorA, vectorB) {
              return vectorA.x * vectorB.y - vectorA.y * vectorB.x;
            };
            Vector.cross3 = function (vectorA, vectorB, vectorC) {
              return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);
            };
            Vector.add = function (vectorA, vectorB, output) {
              if (!output) output = {};
              output.x = vectorA.x + vectorB.x;
              output.y = vectorA.y + vectorB.y;
              return output;
            };
            Vector.sub = function (vectorA, vectorB, output) {
              if (!output) output = {};
              output.x = vectorA.x - vectorB.x;
              output.y = vectorA.y - vectorB.y;
              return output;
            };
            Vector.mult = function (vector, scalar) {
              return {
                x: vector.x * scalar,
                y: vector.y * scalar
              };
            };
            Vector.div = function (vector, scalar) {
              return {
                x: vector.x / scalar,
                y: vector.y / scalar
              };
            };
            Vector.perp = function (vector, negate) {
              negate = negate === true ? -1 : 1;
              return {
                x: negate * -vector.y,
                y: negate * vector.x
              };
            };
            Vector.neg = function (vector) {
              return {
                x: -vector.x,
                y: -vector.y
              };
            };
            Vector.angle = function (vectorA, vectorB) {
              return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);
            };
            Vector._temp = [Vector.create(), Vector.create(), Vector.create(), Vector.create(), Vector.create(), Vector.create()];
          })();
        }, function (module2, exports2) {
          var Bounds = {};
          module2.exports = Bounds;
          (function () {
            Bounds.create = function (vertices) {
              var bounds = {
                min: {
                  x: 0,
                  y: 0
                },
                max: {
                  x: 0,
                  y: 0
                }
              };
              if (vertices) Bounds.update(bounds, vertices);
              return bounds;
            };
            Bounds.update = function (bounds, vertices, velocity) {
              bounds.min.x = Infinity;
              bounds.max.x = -Infinity;
              bounds.min.y = Infinity;
              bounds.max.y = -Infinity;
              for (var i = 0; i < vertices.length; i++) {
                var vertex = vertices[i];
                if (vertex.x > bounds.max.x) bounds.max.x = vertex.x;
                if (vertex.x < bounds.min.x) bounds.min.x = vertex.x;
                if (vertex.y > bounds.max.y) bounds.max.y = vertex.y;
                if (vertex.y < bounds.min.y) bounds.min.y = vertex.y;
              }
              if (velocity) {
                if (velocity.x > 0) {
                  bounds.max.x += velocity.x;
                } else {
                  bounds.min.x += velocity.x;
                }
                if (velocity.y > 0) {
                  bounds.max.y += velocity.y;
                } else {
                  bounds.min.y += velocity.y;
                }
              }
            };
            Bounds.contains = function (bounds, point) {
              return point.x >= bounds.min.x && point.x <= bounds.max.x && point.y >= bounds.min.y && point.y <= bounds.max.y;
            };
            Bounds.overlaps = function (boundsA, boundsB) {
              return boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y;
            };
            Bounds.translate = function (bounds, vector) {
              bounds.min.x += vector.x;
              bounds.max.x += vector.x;
              bounds.min.y += vector.y;
              bounds.max.y += vector.y;
            };
            Bounds.shift = function (bounds, position) {
              var deltaX = bounds.max.x - bounds.min.x, deltaY = bounds.max.y - bounds.min.y;
              bounds.min.x = position.x;
              bounds.max.x = position.x + deltaX;
              bounds.min.y = position.y;
              bounds.max.y = position.y + deltaY;
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(29);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var Rectangle = __webpack_require__(502);
          var Tile = new Class({
            Mixins: [Components.Alpha, Components.Flip, Components.Visible],
            initialize: function Tile2(layer, index, x, y, width, height, baseWidth, baseHeight) {
              this.layer = layer;
              this.index = index;
              this.x = x;
              this.y = y;
              this.width = width;
              this.height = height;
              this.right;
              this.bottom;
              this.baseWidth = baseWidth !== void 0 ? baseWidth : width;
              this.baseHeight = baseHeight !== void 0 ? baseHeight : height;
              this.pixelX = 0;
              this.pixelY = 0;
              this.updatePixelXY();
              this.properties = {};
              this.rotation = 0;
              this.collideLeft = false;
              this.collideRight = false;
              this.collideUp = false;
              this.collideDown = false;
              this.faceLeft = false;
              this.faceRight = false;
              this.faceTop = false;
              this.faceBottom = false;
              this.collisionCallback = void 0;
              this.collisionCallbackContext = this;
              this.tint = 16777215;
              this.physics = {};
            },
            containsPoint: function (x, y) {
              return !(x < this.pixelX || y < this.pixelY || x > this.right || y > this.bottom);
            },
            copy: function (tile) {
              this.index = tile.index;
              this.alpha = tile.alpha;
              this.properties = tile.properties;
              this.visible = tile.visible;
              this.setFlip(tile.flipX, tile.flipY);
              this.tint = tile.tint;
              this.rotation = tile.rotation;
              this.collideUp = tile.collideUp;
              this.collideDown = tile.collideDown;
              this.collideLeft = tile.collideLeft;
              this.collideRight = tile.collideRight;
              this.collisionCallback = tile.collisionCallback;
              this.collisionCallbackContext = tile.collisionCallbackContext;
              return this;
            },
            getCollisionGroup: function () {
              return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null;
            },
            getTileData: function () {
              return this.tileset ? this.tileset.getTileData(this.index) : null;
            },
            getLeft: function (camera) {
              var tilemapLayer = this.tilemapLayer;
              return tilemapLayer ? tilemapLayer.tileToWorldX(this.x, camera) : this.x * this.baseWidth;
            },
            getRight: function (camera) {
              var tilemapLayer = this.tilemapLayer;
              return tilemapLayer ? this.getLeft(camera) + this.width * tilemapLayer.scaleX : this.getLeft(camera) + this.width;
            },
            getTop: function (camera) {
              var tilemapLayer = this.tilemapLayer;
              return tilemapLayer ? tilemapLayer.tileToWorldY(this.y, camera) - (this.height - this.baseHeight) * tilemapLayer.scaleY : this.y * this.baseHeight - (this.height - this.baseHeight);
            },
            getBottom: function (camera) {
              var tilemapLayer = this.tilemapLayer;
              return tilemapLayer ? this.getTop(camera) + this.height * tilemapLayer.scaleY : this.getTop(camera) + this.height;
            },
            getBounds: function (camera, output) {
              if (output === void 0) {
                output = new Rectangle();
              }
              output.x = this.getLeft();
              output.y = this.getTop();
              output.width = this.getRight() - output.x;
              output.height = this.getBottom() - output.y;
              return output;
            },
            getCenterX: function (camera) {
              return (this.getLeft(camera) + this.getRight(camera)) / 2;
            },
            getCenterY: function (camera) {
              return (this.getTop(camera) + this.getBottom(camera)) / 2;
            },
            intersects: function (x, y, right, bottom) {
              return !(right <= this.pixelX || bottom <= this.pixelY || x >= this.right || y >= this.bottom);
            },
            isInteresting: function (collides, faces) {
              if (collides && faces) {
                return this.canCollide || this.hasInterestingFace;
              } else if (collides) {
                return this.collides;
              } else if (faces) {
                return this.hasInterestingFace;
              }
              return false;
            },
            resetCollision: function (recalculateFaces) {
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              this.collideLeft = false;
              this.collideRight = false;
              this.collideUp = false;
              this.collideDown = false;
              this.faceTop = false;
              this.faceBottom = false;
              this.faceLeft = false;
              this.faceRight = false;
              if (recalculateFaces) {
                var tilemapLayer = this.tilemapLayer;
                if (tilemapLayer) {
                  this.tilemapLayer.calculateFacesAt(this.x, this.y);
                }
              }
              return this;
            },
            resetFaces: function () {
              this.faceTop = false;
              this.faceBottom = false;
              this.faceLeft = false;
              this.faceRight = false;
              return this;
            },
            setCollision: function (left, right, up, down, recalculateFaces) {
              if (right === void 0) {
                right = left;
              }
              if (up === void 0) {
                up = left;
              }
              if (down === void 0) {
                down = left;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              this.collideLeft = left;
              this.collideRight = right;
              this.collideUp = up;
              this.collideDown = down;
              this.faceLeft = left;
              this.faceRight = right;
              this.faceTop = up;
              this.faceBottom = down;
              if (recalculateFaces) {
                var tilemapLayer = this.tilemapLayer;
                if (tilemapLayer) {
                  this.tilemapLayer.calculateFacesAt(this.x, this.y);
                }
              }
              return this;
            },
            setCollisionCallback: function (callback, context) {
              if (callback === null) {
                this.collisionCallback = void 0;
                this.collisionCallbackContext = void 0;
              } else {
                this.collisionCallback = callback;
                this.collisionCallbackContext = context;
              }
              return this;
            },
            setSize: function (tileWidth, tileHeight, baseWidth, baseHeight) {
              if (tileWidth !== void 0) {
                this.width = tileWidth;
              }
              if (tileHeight !== void 0) {
                this.height = tileHeight;
              }
              if (baseWidth !== void 0) {
                this.baseWidth = baseWidth;
              }
              if (baseHeight !== void 0) {
                this.baseHeight = baseHeight;
              }
              this.updatePixelXY();
              return this;
            },
            updatePixelXY: function () {
              var orientation = this.layer.orientation;
              if (orientation === CONST.ORTHOGONAL) {
                this.pixelX = this.x * this.baseWidth;
                this.pixelY = this.y * this.baseHeight;
              } else if (orientation === CONST.ISOMETRIC) {
                this.pixelX = (this.x - this.y) * this.baseWidth * 0.5;
                this.pixelY = (this.x + this.y) * this.baseHeight * 0.5;
              } else if (orientation === CONST.STAGGERED) {
                this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2);
                this.pixelY = this.y * (this.baseHeight / 2);
              } else if (orientation === CONST.HEXAGONAL) {
                var len = this.layer.hexSideLength;
                var rowHeight = (this.baseHeight - len) / 2 + len;
                this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2);
                this.pixelY = this.y * rowHeight;
              }
              this.right = this.pixelX + this.baseWidth;
              this.bottom = this.pixelY + this.baseHeight;
              return this;
            },
            destroy: function () {
              this.collisionCallback = void 0;
              this.collisionCallbackContext = void 0;
              this.properties = void 0;
            },
            canCollide: {
              get: function () {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback !== void 0;
              }
            },
            collides: {
              get: function () {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown;
              }
            },
            hasInterestingFace: {
              get: function () {
                return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight;
              }
            },
            tileset: {
              get: function () {
                var tilemapLayer = this.layer.tilemapLayer;
                if (tilemapLayer) {
                  var tileset = tilemapLayer.gidMap[this.index];
                  if (tileset) {
                    return tileset;
                  }
                }
                return null;
              }
            },
            tilemapLayer: {
              get: function () {
                return this.layer.tilemapLayer;
              }
            },
            tilemap: {
              get: function () {
                var tilemapLayer = this.tilemapLayer;
                return tilemapLayer ? tilemapLayer.tilemap : null;
              }
            }
          });
          module2.exports = Tile;
        }, function (module2, exports2, __webpack_require__) {
          var Bodies = {};
          module2.exports = Bodies;
          var Vertices = __webpack_require__(64);
          var Common = __webpack_require__(32);
          var Body = __webpack_require__(41);
          var Bounds = __webpack_require__(84);
          var Vector = __webpack_require__(83);
          var decomp = __webpack_require__(1393);
          (function () {
            Bodies.rectangle = function (x, y, width, height, options) {
              options = options || ({});
              var rectangle = {
                label: "Rectangle Body",
                position: {
                  x,
                  y
                },
                vertices: Vertices.fromPath("L 0 0 L " + width + " 0 L " + width + " " + height + " L 0 " + height)
              };
              if (options.chamfer) {
                var chamfer = options.chamfer;
                rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
                delete options.chamfer;
              }
              return Body.create(Common.extend({}, rectangle, options));
            };
            Bodies.trapezoid = function (x, y, width, height, slope, options) {
              options = options || ({});
              slope *= 0.5;
              var roof = (1 - slope * 2) * width;
              var x1 = width * slope, x2 = x1 + roof, x3 = x2 + x1, verticesPath;
              if (slope < 0.5) {
                verticesPath = "L 0 0 L " + x1 + " " + -height + " L " + x2 + " " + -height + " L " + x3 + " 0";
              } else {
                verticesPath = "L 0 0 L " + x2 + " " + -height + " L " + x3 + " 0";
              }
              var trapezoid = {
                label: "Trapezoid Body",
                position: {
                  x,
                  y
                },
                vertices: Vertices.fromPath(verticesPath)
              };
              if (options.chamfer) {
                var chamfer = options.chamfer;
                trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
                delete options.chamfer;
              }
              return Body.create(Common.extend({}, trapezoid, options));
            };
            Bodies.circle = function (x, y, radius, options, maxSides) {
              options = options || ({});
              var circle = {
                label: "Circle Body",
                circleRadius: radius
              };
              maxSides = maxSides || 25;
              var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));
              if (sides % 2 === 1) sides += 1;
              return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));
            };
            Bodies.polygon = function (x, y, sides, radius, options) {
              options = options || ({});
              if (sides < 3) return Bodies.circle(x, y, radius, options);
              var theta = 2 * Math.PI / sides, path = "", offset = theta * 0.5;
              for (var i = 0; i < sides; i += 1) {
                var angle = offset + i * theta, xx = Math.cos(angle) * radius, yy = Math.sin(angle) * radius;
                path += "L " + xx.toFixed(3) + " " + yy.toFixed(3) + " ";
              }
              var polygon = {
                label: "Polygon Body",
                position: {
                  x,
                  y
                },
                vertices: Vertices.fromPath(path)
              };
              if (options.chamfer) {
                var chamfer = options.chamfer;
                polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
                delete options.chamfer;
              }
              return Body.create(Common.extend({}, polygon, options));
            };
            Bodies.fromVertices = function (x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea) {
              var body, parts, isConvex, vertices, i, j, k, v, z;
              options = options || ({});
              parts = [];
              flagInternal = typeof flagInternal !== "undefined" ? flagInternal : false;
              removeCollinear = typeof removeCollinear !== "undefined" ? removeCollinear : 0.01;
              minimumArea = typeof minimumArea !== "undefined" ? minimumArea : 10;
              if (!decomp) {
                Common.warn("Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.");
              }
              if (!Common.isArray(vertexSets[0])) {
                vertexSets = [vertexSets];
              }
              for (v = 0; v < vertexSets.length; v += 1) {
                vertices = vertexSets[v];
                isConvex = Vertices.isConvex(vertices);
                if (isConvex || !decomp) {
                  if (isConvex) {
                    vertices = Vertices.clockwiseSort(vertices);
                  } else {
                    vertices = Vertices.hull(vertices);
                  }
                  parts.push({
                    position: {
                      x,
                      y
                    },
                    vertices
                  });
                } else {
                  var concave = vertices.map(function (vertex) {
                    return [vertex.x, vertex.y];
                  });
                  decomp.makeCCW(concave);
                  if (removeCollinear !== false) decomp.removeCollinearPoints(concave, removeCollinear);
                  var decomposed = decomp.quickDecomp(concave);
                  for (i = 0; i < decomposed.length; i++) {
                    var chunk = decomposed[i];
                    var chunkVertices = chunk.map(function (vertices2) {
                      return {
                        x: vertices2[0],
                        y: vertices2[1]
                      };
                    });
                    if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea) continue;
                    parts.push({
                      position: Vertices.centre(chunkVertices),
                      vertices: chunkVertices
                    });
                  }
                }
              }
              for (i = 0; i < parts.length; i++) {
                parts[i] = Body.create(Common.extend(parts[i], options));
              }
              if (flagInternal) {
                Bodies.flagCoincidentParts(parts, 5);
              }
              if (parts.length > 1) {
                body = Body.create(Common.extend({
                  parts: parts.slice(0)
                }, options));
                Body.setPosition(body, {
                  x,
                  y
                });
                return body;
              } else {
                return parts[0];
              }
            };
            Bodies.flagCoincidentParts = function (parts, maxDistance) {
              if (maxDistance === void 0) {
                maxDistance = 5;
              }
              for (var i = 0; i < parts.length; i++) {
                var partA = parts[i];
                for (var j = i + 1; j < parts.length; j++) {
                  var partB = parts[j];
                  if (Bounds.overlaps(partA.bounds, partB.bounds)) {
                    var pav = partA.vertices;
                    var pbv = partB.vertices;
                    for (var k = 0; k < partA.vertices.length; k++) {
                      for (var z = 0; z < partB.vertices.length; z++) {
                        var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z]));
                        var db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));
                        if (da < maxDistance && db < maxDistance) {
                          pav[k].isInternal = true;
                          pbv[z].isInternal = true;
                        }
                      }
                    }
                  }
                }
              }
              return parts;
            };
          })();
        }, function (module2, exports2) {
          var GetCenterX = function (gameObject) {
            return gameObject.x - gameObject.width * gameObject.originX + gameObject.width * 0.5;
          };
          module2.exports = GetCenterX;
        }, function (module2, exports2) {
          var SetCenterX = function (gameObject, x) {
            var offsetX = gameObject.width * gameObject.originX;
            gameObject.x = x + offsetX - gameObject.width * 0.5;
            return gameObject;
          };
          module2.exports = SetCenterX;
        }, function (module2, exports2) {
          var GetCenterY = function (gameObject) {
            return gameObject.y - gameObject.height * gameObject.originY + gameObject.height * 0.5;
          };
          module2.exports = GetCenterY;
        }, function (module2, exports2) {
          var SetCenterY = function (gameObject, y) {
            var offsetY = gameObject.height * gameObject.originY;
            gameObject.y = y + offsetY - gameObject.height * 0.5;
            return gameObject;
          };
          module2.exports = SetCenterY;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            POST_RENDER: __webpack_require__(628),
            PRE_RENDER: __webpack_require__(629),
            RENDER: __webpack_require__(630),
            RESIZE: __webpack_require__(631)
          };
        }, function (module2, exports2) {
          var PIPELINE_CONST = {
            BITMAPMASK_PIPELINE: "BitmapMaskPipeline",
            LIGHT_PIPELINE: "Light2D",
            POINTLIGHT_PIPELINE: "PointLightPipeline",
            SINGLE_PIPELINE: "SinglePipeline",
            MULTI_PIPELINE: "MultiPipeline",
            ROPE_PIPELINE: "RopePipeline",
            GRAPHICS_PIPELINE: "GraphicsPipeline",
            POSTFX_PIPELINE: "PostFXPipeline",
            UTILITY_PIPELINE: "UtilityPipeline"
          };
          module2.exports = PIPELINE_CONST;
        }, function (module2, exports2, __webpack_require__) {
          var SpliceOne = __webpack_require__(74);
          var Remove = function (array, item, callback, context) {
            if (context === void 0) {
              context = array;
            }
            var index;
            if (!Array.isArray(item)) {
              index = array.indexOf(item);
              if (index !== -1) {
                SpliceOne(array, index);
                if (callback) {
                  callback.call(context, item);
                }
                return item;
              } else {
                return null;
              }
            }
            var itemLength = item.length - 1;
            var removed = [];
            while (itemLength >= 0) {
              var entry = item[itemLength];
              index = array.indexOf(entry);
              if (index !== -1) {
                SpliceOne(array, index);
                removed.push(entry);
                if (callback) {
                  callback.call(context, entry);
                }
              }
              itemLength--;
            }
            return removed;
          };
          module2.exports = Remove;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var FromPoints = __webpack_require__(199);
          var Rectangle = __webpack_require__(10);
          var Vector2 = __webpack_require__(3);
          var Curve = new Class({
            initialize: function Curve2(type) {
              this.type = type;
              this.defaultDivisions = 5;
              this.arcLengthDivisions = 100;
              this.cacheArcLengths = [];
              this.needsUpdate = true;
              this.active = true;
              this._tmpVec2A = new Vector2();
              this._tmpVec2B = new Vector2();
            },
            draw: function (graphics, pointsTotal) {
              if (pointsTotal === void 0) {
                pointsTotal = 32;
              }
              return graphics.strokePoints(this.getPoints(pointsTotal));
            },
            getBounds: function (out, accuracy) {
              if (!out) {
                out = new Rectangle();
              }
              if (accuracy === void 0) {
                accuracy = 16;
              }
              var len = this.getLength();
              if (accuracy > len) {
                accuracy = len / 2;
              }
              var spaced = Math.max(1, Math.round(len / accuracy));
              return FromPoints(this.getSpacedPoints(spaced), out);
            },
            getDistancePoints: function (distance) {
              var len = this.getLength();
              var spaced = Math.max(1, len / distance);
              return this.getSpacedPoints(spaced);
            },
            getEndPoint: function (out) {
              if (out === void 0) {
                out = new Vector2();
              }
              return this.getPointAt(1, out);
            },
            getLength: function () {
              var lengths = this.getLengths();
              return lengths[lengths.length - 1];
            },
            getLengths: function (divisions) {
              if (divisions === void 0) {
                divisions = this.arcLengthDivisions;
              }
              if (this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
                return this.cacheArcLengths;
              }
              this.needsUpdate = false;
              var cache = [];
              var current;
              var last = this.getPoint(0, this._tmpVec2A);
              var sum = 0;
              cache.push(0);
              for (var p3 = 1; p3 <= divisions; p3++) {
                current = this.getPoint(p3 / divisions, this._tmpVec2B);
                sum += current.distance(last);
                cache.push(sum);
                last.copy(current);
              }
              this.cacheArcLengths = cache;
              return cache;
            },
            getPointAt: function (u, out) {
              var t = this.getUtoTmapping(u);
              return this.getPoint(t, out);
            },
            getPoints: function (divisions, stepRate, out) {
              if (out === void 0) {
                out = [];
              }
              if (!divisions) {
                if (!stepRate) {
                  divisions = this.defaultDivisions;
                } else {
                  divisions = this.getLength() / stepRate;
                }
              }
              for (var d = 0; d <= divisions; d++) {
                out.push(this.getPoint(d / divisions));
              }
              return out;
            },
            getRandomPoint: function (out) {
              if (out === void 0) {
                out = new Vector2();
              }
              return this.getPoint(Math.random(), out);
            },
            getSpacedPoints: function (divisions, stepRate, out) {
              if (out === void 0) {
                out = [];
              }
              if (!divisions) {
                if (!stepRate) {
                  divisions = this.defaultDivisions;
                } else {
                  divisions = this.getLength() / stepRate;
                }
              }
              for (var d = 0; d <= divisions; d++) {
                var t = this.getUtoTmapping(d / divisions, null, divisions);
                out.push(this.getPoint(t));
              }
              return out;
            },
            getStartPoint: function (out) {
              if (out === void 0) {
                out = new Vector2();
              }
              return this.getPointAt(0, out);
            },
            getTangent: function (t, out) {
              if (out === void 0) {
                out = new Vector2();
              }
              var delta = 1e-4;
              var t1 = t - delta;
              var t2 = t + delta;
              if (t1 < 0) {
                t1 = 0;
              }
              if (t2 > 1) {
                t2 = 1;
              }
              this.getPoint(t1, this._tmpVec2A);
              this.getPoint(t2, out);
              return out.subtract(this._tmpVec2A).normalize();
            },
            getTangentAt: function (u, out) {
              var t = this.getUtoTmapping(u);
              return this.getTangent(t, out);
            },
            getTFromDistance: function (distance, divisions) {
              if (distance <= 0) {
                return 0;
              }
              return this.getUtoTmapping(0, distance, divisions);
            },
            getUtoTmapping: function (u, distance, divisions) {
              var arcLengths = this.getLengths(divisions);
              var i = 0;
              var il = arcLengths.length;
              var targetArcLength;
              if (distance) {
                targetArcLength = Math.min(distance, arcLengths[il - 1]);
              } else {
                targetArcLength = u * arcLengths[il - 1];
              }
              var low = 0;
              var high = il - 1;
              var comparison;
              while (low <= high) {
                i = Math.floor(low + (high - low) / 2);
                comparison = arcLengths[i] - targetArcLength;
                if (comparison < 0) {
                  low = i + 1;
                } else if (comparison > 0) {
                  high = i - 1;
                } else {
                  high = i;
                  break;
                }
              }
              i = high;
              if (arcLengths[i] === targetArcLength) {
                return i / (il - 1);
              }
              var lengthBefore = arcLengths[i];
              var lengthAfter = arcLengths[i + 1];
              var segmentLength = lengthAfter - lengthBefore;
              var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
              return (i + segmentFraction) / (il - 1);
            },
            updateArcLengths: function () {
              this.needsUpdate = true;
              this.getLengths();
            }
          });
          module2.exports = Curve;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            ADD: __webpack_require__(968),
            COMPLETE: __webpack_require__(969),
            FILE_COMPLETE: __webpack_require__(970),
            FILE_KEY_COMPLETE: __webpack_require__(971),
            FILE_LOAD_ERROR: __webpack_require__(972),
            FILE_LOAD: __webpack_require__(973),
            FILE_PROGRESS: __webpack_require__(974),
            POST_PROCESS: __webpack_require__(975),
            PROGRESS: __webpack_require__(976),
            START: __webpack_require__(977)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var LineToLine = function (line1, line2, out) {
            if (out === void 0) {
              out = new Point();
            }
            var x1 = line1.x1;
            var y1 = line1.y1;
            var x2 = line1.x2;
            var y2 = line1.y2;
            var x3 = line2.x1;
            var y3 = line2.y1;
            var x4 = line2.x2;
            var y4 = line2.y2;
            var numA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
            var numB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
            var deNom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            if (deNom === 0) {
              return false;
            }
            var uA = numA / deNom;
            var uB = numB / deNom;
            if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
              out.x = x1 + uA * (x2 - x1);
              out.y = y1 + uA * (y2 - y1);
              return true;
            }
            return false;
          };
          module2.exports = LineToLine;
        }, function (module2, exports2) {
          var Angle = function (line) {
            return Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
          };
          module2.exports = Angle;
        }, function (module2, exports2, __webpack_require__) {
          var Clamp = __webpack_require__(18);
          var FromPercent = function (percent, min, max) {
            percent = Clamp(percent, 0, 1);
            return (max - min) * percent + min;
          };
          module2.exports = FromPercent;
        }, function (module2, exports2) {
          var GetBoolean = function (source, key, defaultValue) {
            if (!source) {
              return defaultValue;
            } else if (source.hasOwnProperty(key)) {
              return source[key];
            } else {
              return defaultValue;
            }
          };
          module2.exports = GetBoolean;
        }, function (module2, exports2) {
          var TWEEN_CONST = {
            CREATED: 0,
            INIT: 1,
            DELAY: 2,
            OFFSET_DELAY: 3,
            PENDING_RENDER: 4,
            PLAYING_FORWARD: 5,
            PLAYING_BACKWARD: 6,
            HOLD_DELAY: 7,
            REPEAT_DELAY: 8,
            COMPLETE: 9,
            PENDING_ADD: 20,
            PAUSED: 21,
            LOOP_DELAY: 22,
            ACTIVE: 23,
            COMPLETE_DELAY: 24,
            PENDING_REMOVE: 25,
            REMOVED: 26
          };
          module2.exports = TWEEN_CONST;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(315);
          var DataManager = new Class({
            initialize: function DataManager2(parent, eventEmitter) {
              this.parent = parent;
              this.events = eventEmitter;
              if (!eventEmitter) {
                this.events = parent.events ? parent.events : parent;
              }
              this.list = {};
              this.values = {};
              this._frozen = false;
              if (!parent.hasOwnProperty("sys") && this.events) {
                this.events.once(Events.DESTROY, this.destroy, this);
              }
            },
            get: function (key) {
              var list = this.list;
              if (Array.isArray(key)) {
                var output = [];
                for (var i = 0; i < key.length; i++) {
                  output.push(list[key[i]]);
                }
                return output;
              } else {
                return list[key];
              }
            },
            getAll: function () {
              var results = {};
              for (var key in this.list) {
                if (this.list.hasOwnProperty(key)) {
                  results[key] = this.list[key];
                }
              }
              return results;
            },
            query: function (search) {
              var results = {};
              for (var key in this.list) {
                if (this.list.hasOwnProperty(key) && key.match(search)) {
                  results[key] = this.list[key];
                }
              }
              return results;
            },
            set: function (key, data) {
              if (this._frozen) {
                return this;
              }
              if (typeof key === "string") {
                return this.setValue(key, data);
              } else {
                for (var entry in key) {
                  this.setValue(entry, key[entry]);
                }
              }
              return this;
            },
            inc: function (key, data) {
              if (this._frozen) {
                return this;
              }
              if (data === void 0) {
                data = 1;
              }
              var value = this.get(key);
              if (value === void 0) {
                value = 0;
              }
              this.set(key, value + data);
              return this;
            },
            toggle: function (key) {
              if (this._frozen) {
                return this;
              }
              this.set(key, !this.get(key));
              return this;
            },
            setValue: function (key, data) {
              if (this._frozen) {
                return this;
              }
              if (this.has(key)) {
                this.values[key] = data;
              } else {
                var _this = this;
                var list = this.list;
                var events = this.events;
                var parent = this.parent;
                Object.defineProperty(this.values, key, {
                  enumerable: true,
                  configurable: true,
                  get: function () {
                    return list[key];
                  },
                  set: function (value) {
                    if (!_this._frozen) {
                      var previousValue = list[key];
                      list[key] = value;
                      events.emit(Events.CHANGE_DATA, parent, key, value, previousValue);
                      events.emit(Events.CHANGE_DATA_KEY + key, parent, value, previousValue);
                    }
                  }
                });
                list[key] = data;
                events.emit(Events.SET_DATA, parent, key, data);
              }
              return this;
            },
            each: function (callback, context) {
              var args = [this.parent, null, void 0];
              for (var i = 1; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              for (var key in this.list) {
                args[1] = key;
                args[2] = this.list[key];
                callback.apply(context, args);
              }
              return this;
            },
            merge: function (data, overwrite) {
              if (overwrite === void 0) {
                overwrite = true;
              }
              for (var key in data) {
                if (data.hasOwnProperty(key) && (overwrite || !overwrite && !this.has(key))) {
                  this.setValue(key, data[key]);
                }
              }
              return this;
            },
            remove: function (key) {
              if (this._frozen) {
                return this;
              }
              if (Array.isArray(key)) {
                for (var i = 0; i < key.length; i++) {
                  this.removeValue(key[i]);
                }
              } else {
                return this.removeValue(key);
              }
              return this;
            },
            removeValue: function (key) {
              if (this.has(key)) {
                var data = this.list[key];
                delete this.list[key];
                delete this.values[key];
                this.events.emit(Events.REMOVE_DATA, this.parent, key, data);
              }
              return this;
            },
            pop: function (key) {
              var data = void 0;
              if (!this._frozen && this.has(key)) {
                data = this.list[key];
                delete this.list[key];
                delete this.values[key];
                this.events.emit(Events.REMOVE_DATA, this.parent, key, data);
              }
              return data;
            },
            has: function (key) {
              return this.list.hasOwnProperty(key);
            },
            setFreeze: function (value) {
              this._frozen = value;
              return this;
            },
            reset: function () {
              for (var key in this.list) {
                delete this.list[key];
                delete this.values[key];
              }
              this._frozen = false;
              return this;
            },
            destroy: function () {
              this.reset();
              this.events.off(Events.CHANGE_DATA);
              this.events.off(Events.SET_DATA);
              this.events.off(Events.REMOVE_DATA);
              this.parent = null;
            },
            freeze: {
              get: function () {
                return this._frozen;
              },
              set: function (value) {
                this._frozen = value ? true : false;
              }
            },
            count: {
              get: function () {
                var i = 0;
                for (var key in this.list) {
                  if (this.list[key] !== void 0) {
                    i++;
                  }
                }
                return i;
              }
            }
          });
          module2.exports = DataManager;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Map2 = new Class({
            initialize: function Map3(elements) {
              this.entries = {};
              this.size = 0;
              if (Array.isArray(elements)) {
                for (var i = 0; i < elements.length; i++) {
                  this.set(elements[i][0], elements[i][1]);
                }
              }
            },
            set: function (key, value) {
              if (!this.has(key)) {
                this.size++;
              }
              this.entries[key] = value;
              return this;
            },
            get: function (key) {
              if (this.has(key)) {
                return this.entries[key];
              }
            },
            getArray: function () {
              var output = [];
              var entries = this.entries;
              for (var key in entries) {
                output.push(entries[key]);
              }
              return output;
            },
            has: function (key) {
              return this.entries.hasOwnProperty(key);
            },
            delete: function (key) {
              if (this.has(key)) {
                delete this.entries[key];
                this.size--;
              }
              return this;
            },
            clear: function () {
              Object.keys(this.entries).forEach(function (prop) {
                delete this.entries[prop];
              }, this);
              this.size = 0;
              return this;
            },
            keys: function () {
              return Object.keys(this.entries);
            },
            values: function () {
              var output = [];
              var entries = this.entries;
              for (var key in entries) {
                output.push(entries[key]);
              }
              return output;
            },
            dump: function () {
              var entries = this.entries;
              console.group("Map");
              for (var key in entries) {
                console.log(key, entries[key]);
              }
              console.groupEnd();
            },
            each: function (callback) {
              var entries = this.entries;
              for (var key in entries) {
                if (callback(key, entries[key]) === false) {
                  break;
                }
              }
              return this;
            },
            contains: function (value) {
              var entries = this.entries;
              for (var key in entries) {
                if (entries[key] === value) {
                  return true;
                }
              }
              return false;
            },
            merge: function (map, override) {
              if (override === void 0) {
                override = false;
              }
              var local = this.entries;
              var source = map.entries;
              for (var key in source) {
                if (local.hasOwnProperty(key) && override) {
                  local[key] = source[key];
                } else {
                  this.set(key, source[key]);
                }
              }
              return this;
            }
          });
          module2.exports = Map2;
        }, function (module2, exports2) {
          var GetColor = function (red, green, blue) {
            return red << 16 | green << 8 | blue;
          };
          module2.exports = GetColor;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            ENTER_FULLSCREEN: __webpack_require__(800),
            FULLSCREEN_FAILED: __webpack_require__(801),
            FULLSCREEN_UNSUPPORTED: __webpack_require__(802),
            LEAVE_FULLSCREEN: __webpack_require__(803),
            ORIENTATION_CHANGE: __webpack_require__(804),
            RESIZE: __webpack_require__(805)
          };
        }, function (module2, exports2, __webpack_require__) {
          (function (process2) {
            var OS = {
              android: false,
              chromeOS: false,
              cordova: false,
              crosswalk: false,
              desktop: false,
              ejecta: false,
              electron: false,
              iOS: false,
              iOSVersion: 0,
              iPad: false,
              iPhone: false,
              kindle: false,
              linux: false,
              macOS: false,
              node: false,
              nodeWebkit: false,
              pixelRatio: 1,
              webApp: false,
              windows: false,
              windowsPhone: false
            };
            function init() {
              if (typeof importScripts === "function") {
                return OS;
              }
              var ua = navigator.userAgent;
              if ((/Windows/).test(ua)) {
                OS.windows = true;
              } else if ((/Mac OS/).test(ua) && !(/like Mac OS/).test(ua)) {
                if (navigator.maxTouchPoints && navigator.maxTouchPoints > 2) {
                  OS.iOS = true;
                  OS.iPad = true;
                  navigator.appVersion.match(/Version\/(\d+)/);
                  OS.iOSVersion = parseInt(RegExp.$1, 10);
                } else {
                  OS.macOS = true;
                }
              } else if ((/Android/).test(ua)) {
                OS.android = true;
              } else if ((/Linux/).test(ua)) {
                OS.linux = true;
              } else if ((/iP[ao]d|iPhone/i).test(ua)) {
                OS.iOS = true;
                navigator.appVersion.match(/OS (\d+)/);
                OS.iOSVersion = parseInt(RegExp.$1, 10);
                OS.iPhone = ua.toLowerCase().indexOf("iphone") !== -1;
                OS.iPad = ua.toLowerCase().indexOf("ipad") !== -1;
              } else if ((/Kindle/).test(ua) || (/\bKF[A-Z][A-Z]+/).test(ua) || (/Silk.*Mobile Safari/).test(ua)) {
                OS.kindle = true;
              } else if ((/CrOS/).test(ua)) {
                OS.chromeOS = true;
              }
              if ((/Windows Phone/i).test(ua) || (/IEMobile/i).test(ua)) {
                OS.android = false;
                OS.iOS = false;
                OS.macOS = false;
                OS.windows = true;
                OS.windowsPhone = true;
              }
              var silk = (/Silk/).test(ua);
              if (OS.windows || OS.macOS || OS.linux && !silk || OS.chromeOS) {
                OS.desktop = true;
              }
              if (OS.windowsPhone || (/Windows NT/i).test(ua) && (/Touch/i).test(ua)) {
                OS.desktop = false;
              }
              if (navigator.standalone) {
                OS.webApp = true;
              }
              if (typeof importScripts !== "function") {
                if (window.cordova !== void 0) {
                  OS.cordova = true;
                }
                if (window.ejecta !== void 0) {
                  OS.ejecta = true;
                }
              }
              if (typeof process2 !== "undefined" && process2.versions && process2.versions.node) {
                OS.node = true;
              }
              if (OS.node && typeof process2.versions === "object") {
                OS.nodeWebkit = !!process2.versions["node-webkit"];
                OS.electron = !!process2.versions.electron;
              }
              if ((/Crosswalk/).test(ua)) {
                OS.crosswalk = true;
              }
              OS.pixelRatio = window["devicePixelRatio"] || 1;
              return OS;
            }
            module2.exports = init();
          }).call(this, __webpack_require__(807));
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            ADD: __webpack_require__(861),
            ERROR: __webpack_require__(862),
            LOAD: __webpack_require__(863),
            READY: __webpack_require__(864),
            REMOVE: __webpack_require__(865)
          };
        }, function (module2, exports2) {
          var WEBGL_CONST = {
            BYTE: {
              enum: 5120,
              size: 1
            },
            UNSIGNED_BYTE: {
              enum: 5121,
              size: 1
            },
            SHORT: {
              enum: 5122,
              size: 2
            },
            UNSIGNED_SHORT: {
              enum: 5123,
              size: 2
            },
            INT: {
              enum: 5124,
              size: 4
            },
            UNSIGNED_INT: {
              enum: 5125,
              size: 4
            },
            FLOAT: {
              enum: 5126,
              size: 4
            }
          };
          module2.exports = WEBGL_CONST;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Earcut = __webpack_require__(59);
          var GetFastValue = __webpack_require__(2);
          var ShaderSourceFS = __webpack_require__(878);
          var ShaderSourceVS = __webpack_require__(879);
          var TransformMatrix = __webpack_require__(25);
          var Utils = __webpack_require__(12);
          var WEBGL_CONST = __webpack_require__(107);
          var WebGLPipeline = __webpack_require__(58);
          var MultiPipeline = new Class({
            Extends: WebGLPipeline,
            initialize: function MultiPipeline2(config) {
              var renderer = config.game.renderer;
              var fragmentShaderSource = GetFastValue(config, "fragShader", ShaderSourceFS);
              config.fragShader = Utils.parseFragmentShaderMaxTextures(fragmentShaderSource, renderer.maxTextures);
              config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS);
              config.attributes = GetFastValue(config, "attributes", [{
                name: "inPosition",
                size: 2
              }, {
                name: "inTexCoord",
                size: 2
              }, {
                name: "inTexId"
              }, {
                name: "inTintEffect"
              }, {
                name: "inTint",
                size: 4,
                type: WEBGL_CONST.UNSIGNED_BYTE,
                normalized: true
              }]);
              WebGLPipeline.call(this, config);
              this._tempMatrix1 = new TransformMatrix();
              this._tempMatrix2 = new TransformMatrix();
              this._tempMatrix3 = new TransformMatrix();
              this.calcMatrix = new TransformMatrix();
              this.tempTriangle = [{
                x: 0,
                y: 0,
                width: 0
              }, {
                x: 0,
                y: 0,
                width: 0
              }, {
                x: 0,
                y: 0,
                width: 0
              }, {
                x: 0,
                y: 0,
                width: 0
              }];
              this.strokeTint = {
                TL: 0,
                TR: 0,
                BL: 0,
                BR: 0
              };
              this.fillTint = {
                TL: 0,
                TR: 0,
                BL: 0,
                BR: 0
              };
              this.currentFrame = {
                u0: 0,
                v0: 0,
                u1: 1,
                v1: 1
              };
              this.firstQuad = [0, 0, 0, 0, 0];
              this.prevQuad = [0, 0, 0, 0, 0];
              this.polygonCache = [];
            },
            boot: function () {
              WebGLPipeline.prototype.boot.call(this);
              this.currentShader.set1iv("uMainSampler", this.renderer.textureIndexes);
            },
            batchSprite: function (gameObject, camera, parentTransformMatrix) {
              this.manager.set(this, gameObject);
              var camMatrix = this._tempMatrix1;
              var spriteMatrix = this._tempMatrix2;
              var calcMatrix = this._tempMatrix3;
              var frame = gameObject.frame;
              var texture = frame.glTexture;
              var u0 = frame.u0;
              var v0 = frame.v0;
              var u1 = frame.u1;
              var v1 = frame.v1;
              var frameX = frame.x;
              var frameY = frame.y;
              var frameWidth = frame.cutWidth;
              var frameHeight = frame.cutHeight;
              var customPivot = frame.customPivot;
              var displayOriginX = gameObject.displayOriginX;
              var displayOriginY = gameObject.displayOriginY;
              var x = -displayOriginX + frameX;
              var y = -displayOriginY + frameY;
              if (gameObject.isCropped) {
                var crop = gameObject._crop;
                if (crop.flipX !== gameObject.flipX || crop.flipY !== gameObject.flipY) {
                  frame.updateCropUVs(crop, gameObject.flipX, gameObject.flipY);
                }
                u0 = crop.u0;
                v0 = crop.v0;
                u1 = crop.u1;
                v1 = crop.v1;
                frameWidth = crop.width;
                frameHeight = crop.height;
                frameX = crop.x;
                frameY = crop.y;
                x = -displayOriginX + frameX;
                y = -displayOriginY + frameY;
              }
              var flipX = 1;
              var flipY = 1;
              if (gameObject.flipX) {
                if (!customPivot) {
                  x += -frame.realWidth + displayOriginX * 2;
                }
                flipX = -1;
              }
              if (gameObject.flipY || frame.source.isGLTexture && !texture.flipY) {
                if (!customPivot) {
                  y += -frame.realHeight + displayOriginY * 2;
                }
                flipY = -1;
              }
              spriteMatrix.applyITRS(gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX * flipX, gameObject.scaleY * flipY);
              camMatrix.copyFrom(camera.matrix);
              if (parentTransformMatrix) {
                camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * gameObject.scrollFactorX, -camera.scrollY * gameObject.scrollFactorY);
                spriteMatrix.e = gameObject.x;
                spriteMatrix.f = gameObject.y;
              } else {
                spriteMatrix.e -= camera.scrollX * gameObject.scrollFactorX;
                spriteMatrix.f -= camera.scrollY * gameObject.scrollFactorY;
              }
              camMatrix.multiply(spriteMatrix, calcMatrix);
              var xw = x + frameWidth;
              var yh = y + frameHeight;
              var roundPixels = camera.roundPixels;
              var tx0 = calcMatrix.getXRound(x, y, roundPixels);
              var ty0 = calcMatrix.getYRound(x, y, roundPixels);
              var tx1 = calcMatrix.getXRound(x, yh, roundPixels);
              var ty1 = calcMatrix.getYRound(x, yh, roundPixels);
              var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);
              var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);
              var tx3 = calcMatrix.getXRound(xw, y, roundPixels);
              var ty3 = calcMatrix.getYRound(xw, y, roundPixels);
              var getTint = Utils.getTintAppendFloatAlpha;
              var cameraAlpha = camera.alpha;
              var tintTL = getTint(gameObject.tintTopLeft, cameraAlpha * gameObject._alphaTL);
              var tintTR = getTint(gameObject.tintTopRight, cameraAlpha * gameObject._alphaTR);
              var tintBL = getTint(gameObject.tintBottomLeft, cameraAlpha * gameObject._alphaBL);
              var tintBR = getTint(gameObject.tintBottomRight, cameraAlpha * gameObject._alphaBR);
              if (this.shouldFlush(6)) {
                this.flush();
              }
              var unit = this.setGameObject(gameObject, frame);
              this.manager.preBatch(gameObject);
              this.batchQuad(gameObject, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, gameObject.tintFill, texture, unit);
              this.manager.postBatch(gameObject);
            },
            batchTexture: function (gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix, skipFlip, textureUnit) {
              this.manager.set(this, gameObject);
              var camMatrix = this._tempMatrix1;
              var spriteMatrix = this._tempMatrix2;
              var calcMatrix = this._tempMatrix3;
              var u0 = frameX / textureWidth + uOffset;
              var v0 = frameY / textureHeight + vOffset;
              var u1 = (frameX + frameWidth) / textureWidth + uOffset;
              var v1 = (frameY + frameHeight) / textureHeight + vOffset;
              var width = srcWidth;
              var height = srcHeight;
              var x = -displayOriginX;
              var y = -displayOriginY;
              if (gameObject.isCropped) {
                var crop = gameObject._crop;
                var cropWidth = crop.width;
                var cropHeight = crop.height;
                width = cropWidth;
                height = cropHeight;
                srcWidth = cropWidth;
                srcHeight = cropHeight;
                frameX = crop.x;
                frameY = crop.y;
                var ox = frameX;
                var oy = frameY;
                if (flipX) {
                  ox = frameWidth - crop.x - cropWidth;
                }
                if (flipY) {
                  oy = frameHeight - crop.y - cropHeight;
                }
                u0 = ox / textureWidth + uOffset;
                v0 = oy / textureHeight + vOffset;
                u1 = (ox + cropWidth) / textureWidth + uOffset;
                v1 = (oy + cropHeight) / textureHeight + vOffset;
                x = -displayOriginX + frameX;
                y = -displayOriginY + frameY;
              }
              flipY = flipY ^ (!skipFlip && texture.isRenderTexture ? 1 : 0);
              if (flipX) {
                width *= -1;
                x += srcWidth;
              }
              if (flipY) {
                height *= -1;
                y += srcHeight;
              }
              var xw = x + width;
              var yh = y + height;
              spriteMatrix.applyITRS(srcX, srcY, rotation, scaleX, scaleY);
              camMatrix.copyFrom(camera.matrix);
              if (parentTransformMatrix) {
                camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);
                spriteMatrix.e = srcX;
                spriteMatrix.f = srcY;
              } else {
                spriteMatrix.e -= camera.scrollX * scrollFactorX;
                spriteMatrix.f -= camera.scrollY * scrollFactorY;
              }
              camMatrix.multiply(spriteMatrix, calcMatrix);
              var roundPixels = camera.roundPixels;
              var tx0 = calcMatrix.getXRound(x, y, roundPixels);
              var ty0 = calcMatrix.getYRound(x, y, roundPixels);
              var tx1 = calcMatrix.getXRound(x, yh, roundPixels);
              var ty1 = calcMatrix.getYRound(x, yh, roundPixels);
              var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);
              var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);
              var tx3 = calcMatrix.getXRound(xw, y, roundPixels);
              var ty3 = calcMatrix.getYRound(xw, y, roundPixels);
              if (textureUnit === void 0) {
                textureUnit = this.renderer.setTexture2D(texture);
              }
              if (gameObject) {
                this.manager.preBatch(gameObject);
              }
              this.batchQuad(gameObject, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
              if (gameObject) {
                this.manager.postBatch(gameObject);
              }
            },
            batchTextureFrame: function (frame, x, y, tint, alpha, transformMatrix, parentTransformMatrix) {
              this.manager.set(this);
              var spriteMatrix = this._tempMatrix1.copyFrom(transformMatrix);
              var calcMatrix = this._tempMatrix2;
              var xw = x + frame.width;
              var yh = y + frame.height;
              if (parentTransformMatrix) {
                spriteMatrix.multiply(parentTransformMatrix, calcMatrix);
              } else {
                calcMatrix = spriteMatrix;
              }
              var tx0 = calcMatrix.getX(x, y);
              var ty0 = calcMatrix.getY(x, y);
              var tx1 = calcMatrix.getX(x, yh);
              var ty1 = calcMatrix.getY(x, yh);
              var tx2 = calcMatrix.getX(xw, yh);
              var ty2 = calcMatrix.getY(xw, yh);
              var tx3 = calcMatrix.getX(xw, y);
              var ty3 = calcMatrix.getY(xw, y);
              var unit = this.renderer.setTextureSource(frame.source);
              tint = Utils.getTintAppendFloatAlpha(tint, alpha);
              this.batchQuad(null, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, 0, frame.glTexture, unit);
            },
            batchFillRect: function (x, y, width, height, currentMatrix, parentMatrix) {
              this.renderer.pipelines.set(this);
              var calcMatrix = this.calcMatrix;
              if (parentMatrix) {
                parentMatrix.multiply(currentMatrix, calcMatrix);
              }
              var xw = x + width;
              var yh = y + height;
              var x0 = calcMatrix.getX(x, y);
              var y0 = calcMatrix.getY(x, y);
              var x1 = calcMatrix.getX(x, yh);
              var y1 = calcMatrix.getY(x, yh);
              var x2 = calcMatrix.getX(xw, yh);
              var y2 = calcMatrix.getY(xw, yh);
              var x3 = calcMatrix.getX(xw, y);
              var y3 = calcMatrix.getY(xw, y);
              var tint = this.fillTint;
              this.batchQuad(null, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint.TL, tint.TR, tint.BL, tint.BR, 2);
            },
            batchFillTriangle: function (x0, y0, x1, y1, x2, y2, currentMatrix, parentMatrix) {
              this.renderer.pipelines.set(this);
              var calcMatrix = this.calcMatrix;
              if (parentMatrix) {
                parentMatrix.multiply(currentMatrix, calcMatrix);
              }
              var tx0 = calcMatrix.getX(x0, y0);
              var ty0 = calcMatrix.getY(x0, y0);
              var tx1 = calcMatrix.getX(x1, y1);
              var ty1 = calcMatrix.getY(x1, y1);
              var tx2 = calcMatrix.getX(x2, y2);
              var ty2 = calcMatrix.getY(x2, y2);
              var tint = this.fillTint;
              this.batchTri(null, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, tint.TL, tint.TR, tint.BL, 2);
            },
            batchStrokeTriangle: function (x0, y0, x1, y1, x2, y2, lineWidth, currentMatrix, parentMatrix) {
              var tempTriangle = this.tempTriangle;
              tempTriangle[0].x = x0;
              tempTriangle[0].y = y0;
              tempTriangle[0].width = lineWidth;
              tempTriangle[1].x = x1;
              tempTriangle[1].y = y1;
              tempTriangle[1].width = lineWidth;
              tempTriangle[2].x = x2;
              tempTriangle[2].y = y2;
              tempTriangle[2].width = lineWidth;
              tempTriangle[3].x = x0;
              tempTriangle[3].y = y0;
              tempTriangle[3].width = lineWidth;
              this.batchStrokePath(tempTriangle, lineWidth, false, currentMatrix, parentMatrix);
            },
            batchFillPath: function (path, currentMatrix, parentMatrix) {
              this.renderer.pipelines.set(this);
              var calcMatrix = this.calcMatrix;
              if (parentMatrix) {
                parentMatrix.multiply(currentMatrix, calcMatrix);
              }
              var length = path.length;
              var polygonCache = this.polygonCache;
              var polygonIndexArray;
              var point;
              var tintTL = this.fillTint.TL;
              var tintTR = this.fillTint.TR;
              var tintBL = this.fillTint.BL;
              for (var pathIndex = 0; pathIndex < length; ++pathIndex) {
                point = path[pathIndex];
                polygonCache.push(point.x, point.y);
              }
              polygonIndexArray = Earcut(polygonCache);
              length = polygonIndexArray.length;
              for (var index = 0; index < length; index += 3) {
                var p0 = polygonIndexArray[index + 0] * 2;
                var p1 = polygonIndexArray[index + 1] * 2;
                var p22 = polygonIndexArray[index + 2] * 2;
                var x0 = polygonCache[p0 + 0];
                var y0 = polygonCache[p0 + 1];
                var x1 = polygonCache[p1 + 0];
                var y1 = polygonCache[p1 + 1];
                var x2 = polygonCache[p22 + 0];
                var y2 = polygonCache[p22 + 1];
                var tx0 = calcMatrix.getX(x0, y0);
                var ty0 = calcMatrix.getY(x0, y0);
                var tx1 = calcMatrix.getX(x1, y1);
                var ty1 = calcMatrix.getY(x1, y1);
                var tx2 = calcMatrix.getX(x2, y2);
                var ty2 = calcMatrix.getY(x2, y2);
                this.batchTri(null, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, tintTL, tintTR, tintBL, 2);
              }
              polygonCache.length = 0;
            },
            batchStrokePath: function (path, lineWidth, pathOpen, currentMatrix, parentMatrix) {
              this.renderer.pipelines.set(this);
              this.prevQuad[4] = 0;
              this.firstQuad[4] = 0;
              var pathLength = path.length - 1;
              for (var pathIndex = 0; pathIndex < pathLength; pathIndex++) {
                var point0 = path[pathIndex];
                var point1 = path[pathIndex + 1];
                this.batchLine(point0.x, point0.y, point1.x, point1.y, point0.width / 2, point1.width / 2, lineWidth, pathIndex, !pathOpen && pathIndex === pathLength - 1, currentMatrix, parentMatrix);
              }
            },
            batchLine: function (ax, ay, bx, by, aLineWidth, bLineWidth, lineWidth, index, closePath, currentMatrix, parentMatrix) {
              this.renderer.pipelines.set(this);
              var calcMatrix = this.calcMatrix;
              if (parentMatrix) {
                parentMatrix.multiply(currentMatrix, calcMatrix);
              }
              var dx = bx - ax;
              var dy = by - ay;
              var len = Math.sqrt(dx * dx + dy * dy);
              var al0 = aLineWidth * (by - ay) / len;
              var al1 = aLineWidth * (ax - bx) / len;
              var bl0 = bLineWidth * (by - ay) / len;
              var bl1 = bLineWidth * (ax - bx) / len;
              var lx0 = bx - bl0;
              var ly0 = by - bl1;
              var lx1 = ax - al0;
              var ly1 = ay - al1;
              var lx2 = bx + bl0;
              var ly2 = by + bl1;
              var lx3 = ax + al0;
              var ly3 = ay + al1;
              var brX = calcMatrix.getX(lx0, ly0);
              var brY = calcMatrix.getY(lx0, ly0);
              var blX = calcMatrix.getX(lx1, ly1);
              var blY = calcMatrix.getY(lx1, ly1);
              var trX = calcMatrix.getX(lx2, ly2);
              var trY = calcMatrix.getY(lx2, ly2);
              var tlX = calcMatrix.getX(lx3, ly3);
              var tlY = calcMatrix.getY(lx3, ly3);
              var tint = this.strokeTint;
              var tintTL = tint.TL;
              var tintTR = tint.TR;
              var tintBL = tint.BL;
              var tintBR = tint.BR;
              this.batchQuad(null, tlX, tlY, blX, blY, brX, brY, trX, trY, 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);
              if (lineWidth <= 2) {
                return;
              }
              var prev = this.prevQuad;
              var first = this.firstQuad;
              if (index > 0 && prev[4]) {
                this.batchQuad(null, tlX, tlY, blX, blY, prev[0], prev[1], prev[2], prev[3], 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);
              } else {
                first[0] = tlX;
                first[1] = tlY;
                first[2] = blX;
                first[3] = blY;
                first[4] = 1;
              }
              if (closePath && first[4]) {
                this.batchQuad(null, brX, brY, trX, trY, first[0], first[1], first[2], first[3], 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);
              } else {
                prev[0] = brX;
                prev[1] = brY;
                prev[2] = trX;
                prev[3] = trY;
                prev[4] = 1;
              }
            }
          });
          module2.exports = MultiPipeline;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Clamp = __webpack_require__(18);
          var Extend = __webpack_require__(17);
          var Frame = new Class({
            initialize: function Frame2(texture, name, sourceIndex, x, y, width, height) {
              this.texture = texture;
              this.name = name;
              this.source = texture.source[sourceIndex];
              this.sourceIndex = sourceIndex;
              this.glTexture = this.source.glTexture;
              this.cutX;
              this.cutY;
              this.cutWidth;
              this.cutHeight;
              this.x = 0;
              this.y = 0;
              this.width;
              this.height;
              this.halfWidth;
              this.halfHeight;
              this.centerX;
              this.centerY;
              this.pivotX = 0;
              this.pivotY = 0;
              this.customPivot = false;
              this.rotated = false;
              this.autoRound = -1;
              this.customData = {};
              this.u0 = 0;
              this.v0 = 0;
              this.u1 = 0;
              this.v1 = 0;
              this.data = {
                cut: {
                  x: 0,
                  y: 0,
                  w: 0,
                  h: 0,
                  r: 0,
                  b: 0
                },
                trim: false,
                sourceSize: {
                  w: 0,
                  h: 0
                },
                spriteSourceSize: {
                  x: 0,
                  y: 0,
                  w: 0,
                  h: 0,
                  r: 0,
                  b: 0
                },
                radius: 0,
                drawImage: {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                }
              };
              this.setSize(width, height, x, y);
            },
            setSize: function (width, height, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              this.cutX = x;
              this.cutY = y;
              this.cutWidth = width;
              this.cutHeight = height;
              this.width = width;
              this.height = height;
              this.halfWidth = Math.floor(width * 0.5);
              this.halfHeight = Math.floor(height * 0.5);
              this.centerX = Math.floor(width / 2);
              this.centerY = Math.floor(height / 2);
              var data = this.data;
              var cut = data.cut;
              cut.x = x;
              cut.y = y;
              cut.w = width;
              cut.h = height;
              cut.r = x + width;
              cut.b = y + height;
              data.sourceSize.w = width;
              data.sourceSize.h = height;
              data.spriteSourceSize.w = width;
              data.spriteSourceSize.h = height;
              data.radius = 0.5 * Math.sqrt(width * width + height * height);
              var drawImage = data.drawImage;
              drawImage.x = x;
              drawImage.y = y;
              drawImage.width = width;
              drawImage.height = height;
              return this.updateUVs();
            },
            setTrim: function (actualWidth, actualHeight, destX, destY, destWidth, destHeight) {
              var data = this.data;
              var ss = data.spriteSourceSize;
              data.trim = true;
              data.sourceSize.w = actualWidth;
              data.sourceSize.h = actualHeight;
              ss.x = destX;
              ss.y = destY;
              ss.w = destWidth;
              ss.h = destHeight;
              ss.r = destX + destWidth;
              ss.b = destY + destHeight;
              this.x = destX;
              this.y = destY;
              this.width = destWidth;
              this.height = destHeight;
              this.halfWidth = destWidth * 0.5;
              this.halfHeight = destHeight * 0.5;
              this.centerX = Math.floor(destWidth / 2);
              this.centerY = Math.floor(destHeight / 2);
              return this.updateUVs();
            },
            setCropUVs: function (crop, x, y, width, height, flipX, flipY) {
              var cx = this.cutX;
              var cy = this.cutY;
              var cw = this.cutWidth;
              var ch = this.cutHeight;
              var rw = this.realWidth;
              var rh = this.realHeight;
              x = Clamp(x, 0, rw);
              y = Clamp(y, 0, rh);
              width = Clamp(width, 0, rw - x);
              height = Clamp(height, 0, rh - y);
              var ox = cx + x;
              var oy = cy + y;
              var ow = width;
              var oh = height;
              var data = this.data;
              if (data.trim) {
                var ss = data.spriteSourceSize;
                width = Clamp(width, 0, cw - x);
                height = Clamp(height, 0, ch - y);
                var cropRight = x + width;
                var cropBottom = y + height;
                var intersects = !(ss.r < x || ss.b < y || ss.x > cropRight || ss.y > cropBottom);
                if (intersects) {
                  var ix = Math.max(ss.x, x);
                  var iy = Math.max(ss.y, y);
                  var iw = Math.min(ss.r, cropRight) - ix;
                  var ih = Math.min(ss.b, cropBottom) - iy;
                  ow = iw;
                  oh = ih;
                  if (flipX) {
                    ox = cx + (cw - (ix - ss.x) - iw);
                  } else {
                    ox = cx + (ix - ss.x);
                  }
                  if (flipY) {
                    oy = cy + (ch - (iy - ss.y) - ih);
                  } else {
                    oy = cy + (iy - ss.y);
                  }
                  x = ix;
                  y = iy;
                  width = iw;
                  height = ih;
                } else {
                  ox = 0;
                  oy = 0;
                  ow = 0;
                  oh = 0;
                }
              } else {
                if (flipX) {
                  ox = cx + (cw - x - width);
                }
                if (flipY) {
                  oy = cy + (ch - y - height);
                }
              }
              var tw = this.source.width;
              var th = this.source.height;
              crop.u0 = Math.max(0, ox / tw);
              crop.v0 = Math.max(0, oy / th);
              crop.u1 = Math.min(1, (ox + ow) / tw);
              crop.v1 = Math.min(1, (oy + oh) / th);
              crop.x = x;
              crop.y = y;
              crop.cx = ox;
              crop.cy = oy;
              crop.cw = ow;
              crop.ch = oh;
              crop.width = width;
              crop.height = height;
              crop.flipX = flipX;
              crop.flipY = flipY;
              return crop;
            },
            updateCropUVs: function (crop, flipX, flipY) {
              return this.setCropUVs(crop, crop.x, crop.y, crop.width, crop.height, flipX, flipY);
            },
            setUVs: function (width, height, u0, v0, u1, v1) {
              var cd = this.data.drawImage;
              cd.width = width;
              cd.height = height;
              this.u0 = u0;
              this.v0 = v0;
              this.u1 = u1;
              this.v1 = v1;
              return this;
            },
            updateUVs: function () {
              var cx = this.cutX;
              var cy = this.cutY;
              var cw = this.cutWidth;
              var ch = this.cutHeight;
              var cd = this.data.drawImage;
              cd.width = cw;
              cd.height = ch;
              var tw = this.source.width;
              var th = this.source.height;
              this.u0 = cx / tw;
              this.v0 = cy / th;
              this.u1 = (cx + cw) / tw;
              this.v1 = (cy + ch) / th;
              return this;
            },
            updateUVsInverted: function () {
              var tw = this.source.width;
              var th = this.source.height;
              this.u0 = (this.cutX + this.cutHeight) / tw;
              this.v0 = this.cutY / th;
              this.u1 = this.cutX / tw;
              this.v1 = (this.cutY + this.cutWidth) / th;
              return this;
            },
            clone: function () {
              var clone = new Frame(this.texture, this.name, this.sourceIndex);
              clone.cutX = this.cutX;
              clone.cutY = this.cutY;
              clone.cutWidth = this.cutWidth;
              clone.cutHeight = this.cutHeight;
              clone.x = this.x;
              clone.y = this.y;
              clone.width = this.width;
              clone.height = this.height;
              clone.halfWidth = this.halfWidth;
              clone.halfHeight = this.halfHeight;
              clone.centerX = this.centerX;
              clone.centerY = this.centerY;
              clone.rotated = this.rotated;
              clone.data = Extend(true, clone.data, this.data);
              clone.updateUVs();
              return clone;
            },
            destroy: function () {
              this.source = null;
              this.texture = null;
              this.glTexture = null;
              this.customData = null;
              this.data = null;
            },
            realWidth: {
              get: function () {
                return this.data.sourceSize.w;
              }
            },
            realHeight: {
              get: function () {
                return this.data.sourceSize.h;
              }
            },
            radius: {
              get: function () {
                return this.data.radius;
              }
            },
            trimmed: {
              get: function () {
                return this.data.trim;
              }
            },
            canvasData: {
              get: function () {
                return this.data.drawImage;
              }
            }
          });
          module2.exports = Frame;
        }, function (module2, exports2, __webpack_require__) {
          var ArrayUtils = __webpack_require__(208);
          var Class = __webpack_require__(0);
          var NOOP = __webpack_require__(1);
          var StableSort = __webpack_require__(79);
          var List = new Class({
            initialize: function List2(parent) {
              this.parent = parent;
              this.list = [];
              this.position = 0;
              this.addCallback = NOOP;
              this.removeCallback = NOOP;
              this._sortKey = "";
            },
            add: function (child, skipCallback) {
              if (skipCallback) {
                return ArrayUtils.Add(this.list, child);
              } else {
                return ArrayUtils.Add(this.list, child, 0, this.addCallback, this);
              }
            },
            addAt: function (child, index, skipCallback) {
              if (skipCallback) {
                return ArrayUtils.AddAt(this.list, child, index);
              } else {
                return ArrayUtils.AddAt(this.list, child, index, 0, this.addCallback, this);
              }
            },
            getAt: function (index) {
              return this.list[index];
            },
            getIndex: function (child) {
              return this.list.indexOf(child);
            },
            sort: function (property, handler) {
              if (!property) {
                return this;
              }
              if (handler === void 0) {
                handler = function (childA, childB) {
                  return childA[property] - childB[property];
                };
              }
              StableSort(this.list, handler);
              return this;
            },
            getByName: function (name) {
              return ArrayUtils.GetFirst(this.list, "name", name);
            },
            getRandom: function (startIndex, length) {
              return ArrayUtils.GetRandom(this.list, startIndex, length);
            },
            getFirst: function (property, value, startIndex, endIndex) {
              return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);
            },
            getAll: function (property, value, startIndex, endIndex) {
              return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);
            },
            count: function (property, value) {
              return ArrayUtils.CountAllMatching(this.list, property, value);
            },
            swap: function (child1, child2) {
              ArrayUtils.Swap(this.list, child1, child2);
            },
            moveTo: function (child, index) {
              return ArrayUtils.MoveTo(this.list, child, index);
            },
            moveAbove: function (child1, child2) {
              return ArrayUtils.MoveAbove(this.list, child1, child2);
            },
            moveBelow: function (child1, child2) {
              return ArrayUtils.MoveBelow(this.list, child1, child2);
            },
            remove: function (child, skipCallback) {
              if (skipCallback) {
                return ArrayUtils.Remove(this.list, child);
              } else {
                return ArrayUtils.Remove(this.list, child, this.removeCallback, this);
              }
            },
            removeAt: function (index, skipCallback) {
              if (skipCallback) {
                return ArrayUtils.RemoveAt(this.list, index);
              } else {
                return ArrayUtils.RemoveAt(this.list, index, this.removeCallback, this);
              }
            },
            removeBetween: function (startIndex, endIndex, skipCallback) {
              if (skipCallback) {
                return ArrayUtils.RemoveBetween(this.list, startIndex, endIndex);
              } else {
                return ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeCallback, this);
              }
            },
            removeAll: function (skipCallback) {
              var i = this.list.length;
              while (i--) {
                this.remove(this.list[i], skipCallback);
              }
              return this;
            },
            bringToTop: function (child) {
              return ArrayUtils.BringToTop(this.list, child);
            },
            sendToBack: function (child) {
              return ArrayUtils.SendToBack(this.list, child);
            },
            moveUp: function (child) {
              ArrayUtils.MoveUp(this.list, child);
              return child;
            },
            moveDown: function (child) {
              ArrayUtils.MoveDown(this.list, child);
              return child;
            },
            reverse: function () {
              this.list.reverse();
              return this;
            },
            shuffle: function () {
              ArrayUtils.Shuffle(this.list);
              return this;
            },
            replace: function (oldChild, newChild) {
              return ArrayUtils.Replace(this.list, oldChild, newChild);
            },
            exists: function (child) {
              return this.list.indexOf(child) > -1;
            },
            setAll: function (property, value, startIndex, endIndex) {
              ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);
              return this;
            },
            each: function (callback, context) {
              var args = [null];
              for (var i = 2; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              for (i = 0; i < this.list.length; i++) {
                args[0] = this.list[i];
                callback.apply(context, args);
              }
            },
            shutdown: function () {
              this.removeAll();
              this.list = [];
            },
            destroy: function () {
              this.removeAll();
              this.parent = null;
              this.addCallback = null;
              this.removeCallback = null;
            },
            length: {
              get: function () {
                return this.list.length;
              }
            },
            first: {
              get: function () {
                this.position = 0;
                if (this.list.length > 0) {
                  return this.list[0];
                } else {
                  return null;
                }
              }
            },
            last: {
              get: function () {
                if (this.list.length > 0) {
                  this.position = this.list.length - 1;
                  return this.list[this.position];
                } else {
                  return null;
                }
              }
            },
            next: {
              get: function () {
                if (this.position < this.list.length) {
                  this.position++;
                  return this.list[this.position];
                } else {
                  return null;
                }
              }
            },
            previous: {
              get: function () {
                if (this.position > 0) {
                  this.position--;
                  return this.list[this.position];
                } else {
                  return null;
                }
              }
            }
          });
          module2.exports = List;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Contains = __webpack_require__(112);
          var GetPoint = __webpack_require__(445);
          var GetPoints = __webpack_require__(446);
          var GEOM_CONST = __webpack_require__(56);
          var Random = __webpack_require__(180);
          var Ellipse = new Class({
            initialize: function Ellipse2(x, y, width, height) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = 0;
              }
              if (height === void 0) {
                height = 0;
              }
              this.type = GEOM_CONST.ELLIPSE;
              this.x = x;
              this.y = y;
              this.width = width;
              this.height = height;
            },
            contains: function (x, y) {
              return Contains(this, x, y);
            },
            getPoint: function (position, point) {
              return GetPoint(this, position, point);
            },
            getPoints: function (quantity, stepRate, output) {
              return GetPoints(this, quantity, stepRate, output);
            },
            getRandomPoint: function (point) {
              return Random(this, point);
            },
            setTo: function (x, y, width, height) {
              this.x = x;
              this.y = y;
              this.width = width;
              this.height = height;
              return this;
            },
            setEmpty: function () {
              this.width = 0;
              this.height = 0;
              return this;
            },
            setPosition: function (x, y) {
              if (y === void 0) {
                y = x;
              }
              this.x = x;
              this.y = y;
              return this;
            },
            setSize: function (width, height) {
              if (height === void 0) {
                height = width;
              }
              this.width = width;
              this.height = height;
              return this;
            },
            isEmpty: function () {
              return this.width <= 0 || this.height <= 0;
            },
            getMinorRadius: function () {
              return Math.min(this.width, this.height) / 2;
            },
            getMajorRadius: function () {
              return Math.max(this.width, this.height) / 2;
            },
            left: {
              get: function () {
                return this.x - this.width / 2;
              },
              set: function (value) {
                this.x = value + this.width / 2;
              }
            },
            right: {
              get: function () {
                return this.x + this.width / 2;
              },
              set: function (value) {
                this.x = value - this.width / 2;
              }
            },
            top: {
              get: function () {
                return this.y - this.height / 2;
              },
              set: function (value) {
                this.y = value + this.height / 2;
              }
            },
            bottom: {
              get: function () {
                return this.y + this.height / 2;
              },
              set: function (value) {
                this.y = value - this.height / 2;
              }
            }
          });
          module2.exports = Ellipse;
        }, function (module2, exports2) {
          var Contains = function (ellipse, x, y) {
            if (ellipse.width <= 0 || ellipse.height <= 0) {
              return false;
            }
            var normx = (x - ellipse.x) / ellipse.width;
            var normy = (y - ellipse.y) / ellipse.height;
            normx *= normx;
            normy *= normy;
            return normx + normy < 0.25;
          };
          module2.exports = Contains;
        }, function (module2, exports2, __webpack_require__) {
          var Actions = __webpack_require__(275);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(75);
          var EventEmitter = __webpack_require__(9);
          var GetAll = __webpack_require__(207);
          var GetFastValue = __webpack_require__(2);
          var GetValue = __webpack_require__(6);
          var IsPlainObject = __webpack_require__(7);
          var Range = __webpack_require__(437);
          var Set = __webpack_require__(149);
          var Sprite = __webpack_require__(73);
          var Group = new Class({
            Extends: EventEmitter,
            initialize: function Group2(scene, children, config) {
              EventEmitter.call(this);
              if (config) {
                if (children && !Array.isArray(children)) {
                  children = [children];
                }
              } else if (Array.isArray(children)) {
                if (IsPlainObject(children[0])) {
                  config = children;
                  children = null;
                }
              } else if (IsPlainObject(children)) {
                config = children;
                children = null;
              }
              this.scene = scene;
              this.children = new Set();
              this.isParent = true;
              this.type = "Group";
              this.classType = GetFastValue(config, "classType", Sprite);
              this.name = GetFastValue(config, "name", "");
              this.active = GetFastValue(config, "active", true);
              this.maxSize = GetFastValue(config, "maxSize", -1);
              this.defaultKey = GetFastValue(config, "defaultKey", null);
              this.defaultFrame = GetFastValue(config, "defaultFrame", null);
              this.runChildUpdate = GetFastValue(config, "runChildUpdate", false);
              this.createCallback = GetFastValue(config, "createCallback", null);
              this.removeCallback = GetFastValue(config, "removeCallback", null);
              this.createMultipleCallback = GetFastValue(config, "createMultipleCallback", null);
              this.internalCreateCallback = GetFastValue(config, "internalCreateCallback", null);
              this.internalRemoveCallback = GetFastValue(config, "internalRemoveCallback", null);
              if (children) {
                this.addMultiple(children);
              }
              if (config) {
                this.createMultiple(config);
              }
              this.on(Events.ADDED_TO_SCENE, this.addedToScene, this);
              this.on(Events.REMOVED_FROM_SCENE, this.removedFromScene, this);
            },
            addedToScene: function () {
              this.scene.sys.updateList.add(this);
            },
            removedFromScene: function () {
              this.scene.sys.updateList.remove(this);
            },
            create: function (x, y, key, frame, visible, active) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (key === void 0) {
                key = this.defaultKey;
              }
              if (frame === void 0) {
                frame = this.defaultFrame;
              }
              if (visible === void 0) {
                visible = true;
              }
              if (active === void 0) {
                active = true;
              }
              if (this.isFull()) {
                return null;
              }
              var child = new this.classType(this.scene, x, y, key, frame);
              child.addToDisplayList(this.scene.sys.displayList);
              child.addToUpdateList();
              child.visible = visible;
              child.setActive(active);
              this.add(child);
              return child;
            },
            createMultiple: function (config) {
              if (this.isFull()) {
                return [];
              }
              if (!Array.isArray(config)) {
                config = [config];
              }
              var output = [];
              if (config[0].key) {
                for (var i = 0; i < config.length; i++) {
                  var entries = this.createFromConfig(config[i]);
                  output = output.concat(entries);
                }
              }
              return output;
            },
            createFromConfig: function (options) {
              if (this.isFull()) {
                return [];
              }
              this.classType = GetFastValue(options, "classType", this.classType);
              var key = GetFastValue(options, "key", void 0);
              var frame = GetFastValue(options, "frame", null);
              var visible = GetFastValue(options, "visible", true);
              var active = GetFastValue(options, "active", true);
              var entries = [];
              if (key === void 0) {
                return entries;
              } else {
                if (!Array.isArray(key)) {
                  key = [key];
                }
                if (!Array.isArray(frame)) {
                  frame = [frame];
                }
              }
              var repeat = GetFastValue(options, "repeat", 0);
              var randomKey = GetFastValue(options, "randomKey", false);
              var randomFrame = GetFastValue(options, "randomFrame", false);
              var yoyo = GetFastValue(options, "yoyo", false);
              var quantity = GetFastValue(options, "quantity", false);
              var frameQuantity = GetFastValue(options, "frameQuantity", 1);
              var max = GetFastValue(options, "max", 0);
              var range = Range(key, frame, {
                max,
                qty: quantity ? quantity : frameQuantity,
                random: randomKey,
                randomB: randomFrame,
                repeat,
                yoyo
              });
              if (options.createCallback) {
                this.createCallback = options.createCallback;
              }
              if (options.removeCallback) {
                this.removeCallback = options.removeCallback;
              }
              for (var c = 0; c < range.length; c++) {
                var created = this.create(0, 0, range[c].a, range[c].b, visible, active);
                if (!created) {
                  break;
                }
                entries.push(created);
              }
              var x = GetValue(options, "setXY.x", 0);
              var y = GetValue(options, "setXY.y", 0);
              var stepX = GetValue(options, "setXY.stepX", 0);
              var stepY = GetValue(options, "setXY.stepY", 0);
              Actions.SetXY(entries, x, y, stepX, stepY);
              var rotation = GetValue(options, "setRotation.value", 0);
              var stepRotation = GetValue(options, "setRotation.step", 0);
              Actions.SetRotation(entries, rotation, stepRotation);
              var scaleX = GetValue(options, "setScale.x", 1);
              var scaleY = GetValue(options, "setScale.y", scaleX);
              var stepScaleX = GetValue(options, "setScale.stepX", 0);
              var stepScaleY = GetValue(options, "setScale.stepY", 0);
              Actions.SetScale(entries, scaleX, scaleY, stepScaleX, stepScaleY);
              var originX = GetValue(options, "setOrigin.x", 0.5);
              var originY = GetValue(options, "setOrigin.y", originX);
              var stepOriginX = GetValue(options, "setOrigin.stepX", 0);
              var stepOriginY = GetValue(options, "setOrigin.stepY", 0);
              Actions.SetOrigin(entries, originX, originY, stepOriginX, stepOriginY);
              var alpha = GetValue(options, "setAlpha.value", 1);
              var stepAlpha = GetValue(options, "setAlpha.step", 0);
              Actions.SetAlpha(entries, alpha, stepAlpha);
              var depth = GetValue(options, "setDepth.value", 0);
              var stepDepth = GetValue(options, "setDepth.step", 0);
              Actions.SetDepth(entries, depth, stepDepth);
              var scrollFactorX = GetValue(options, "setScrollFactor.x", 1);
              var scrollFactorY = GetValue(options, "setScrollFactor.y", scrollFactorX);
              var stepScrollFactorX = GetValue(options, "setScrollFactor.stepX", 0);
              var stepScrollFactorY = GetValue(options, "setScrollFactor.stepY", 0);
              Actions.SetScrollFactor(entries, scrollFactorX, scrollFactorY, stepScrollFactorX, stepScrollFactorY);
              var hitArea = GetFastValue(options, "hitArea", null);
              var hitAreaCallback = GetFastValue(options, "hitAreaCallback", null);
              if (hitArea) {
                Actions.SetHitArea(entries, hitArea, hitAreaCallback);
              }
              var grid = GetFastValue(options, "gridAlign", false);
              if (grid) {
                Actions.GridAlign(entries, grid);
              }
              if (this.createMultipleCallback) {
                this.createMultipleCallback.call(this, entries);
              }
              return entries;
            },
            preUpdate: function (time, delta) {
              if (!this.runChildUpdate || this.children.size === 0) {
                return;
              }
              var temp = this.children.entries.slice();
              for (var i = 0; i < temp.length; i++) {
                var item = temp[i];
                if (item.active) {
                  item.update(time, delta);
                }
              }
            },
            add: function (child, addToScene) {
              if (addToScene === void 0) {
                addToScene = false;
              }
              if (this.isFull()) {
                return this;
              }
              this.children.set(child);
              if (this.internalCreateCallback) {
                this.internalCreateCallback.call(this, child);
              }
              if (this.createCallback) {
                this.createCallback.call(this, child);
              }
              if (addToScene) {
                child.addToDisplayList(this.scene.sys.displayList);
                child.addToUpdateList();
              }
              child.on(Events.DESTROY, this.remove, this);
              return this;
            },
            addMultiple: function (children, addToScene) {
              if (addToScene === void 0) {
                addToScene = false;
              }
              if (Array.isArray(children)) {
                for (var i = 0; i < children.length; i++) {
                  this.add(children[i], addToScene);
                }
              }
              return this;
            },
            remove: function (child, removeFromScene, destroyChild) {
              if (removeFromScene === void 0) {
                removeFromScene = false;
              }
              if (destroyChild === void 0) {
                destroyChild = false;
              }
              if (!this.children.contains(child)) {
                return this;
              }
              this.children.delete(child);
              if (this.internalRemoveCallback) {
                this.internalRemoveCallback.call(this, child);
              }
              if (this.removeCallback) {
                this.removeCallback.call(this, child);
              }
              child.off(Events.DESTROY, this.remove, this);
              if (destroyChild) {
                child.destroy();
              } else if (removeFromScene) {
                child.removeFromDisplayList();
                child.removeFromUpdateList();
              }
              return this;
            },
            clear: function (removeFromScene, destroyChild) {
              if (removeFromScene === void 0) {
                removeFromScene = false;
              }
              if (destroyChild === void 0) {
                destroyChild = false;
              }
              var children = this.children;
              for (var i = 0; i < children.size; i++) {
                var gameObject = children.entries[i];
                gameObject.off(Events.DESTROY, this.remove, this);
                if (destroyChild) {
                  gameObject.destroy();
                } else if (removeFromScene) {
                  gameObject.removeFromDisplayList();
                  gameObject.removeFromUpdateList();
                }
              }
              this.children.clear();
              return this;
            },
            contains: function (child) {
              return this.children.contains(child);
            },
            getChildren: function () {
              return this.children.entries;
            },
            getLength: function () {
              return this.children.size;
            },
            getMatching: function (property, value, startIndex, endIndex) {
              return GetAll(this.children.entries, property, value, startIndex, endIndex);
            },
            getFirst: function (state, createIfNull, x, y, key, frame, visible) {
              return this.getHandler(true, 1, state, createIfNull, x, y, key, frame, visible);
            },
            getFirstNth: function (nth, state, createIfNull, x, y, key, frame, visible) {
              return this.getHandler(true, nth, state, createIfNull, x, y, key, frame, visible);
            },
            getLast: function (state, createIfNull, x, y, key, frame, visible) {
              return this.getHandler(false, 1, state, createIfNull, x, y, key, frame, visible);
            },
            getLastNth: function (nth, state, createIfNull, x, y, key, frame, visible) {
              return this.getHandler(false, nth, state, createIfNull, x, y, key, frame, visible);
            },
            getHandler: function (forwards, nth, state, createIfNull, x, y, key, frame, visible) {
              if (state === void 0) {
                state = false;
              }
              if (createIfNull === void 0) {
                createIfNull = false;
              }
              var gameObject;
              var i;
              var total = 0;
              var children = this.children.entries;
              if (forwards) {
                for (i = 0; i < children.length; i++) {
                  gameObject = children[i];
                  if (gameObject.active === state) {
                    total++;
                    if (total === nth) {
                      break;
                    }
                  } else {
                    gameObject = null;
                  }
                }
              } else {
                for (i = children.length - 1; i >= 0; i--) {
                  gameObject = children[i];
                  if (gameObject.active === state) {
                    total++;
                    if (total === nth) {
                      break;
                    }
                  } else {
                    gameObject = null;
                  }
                }
              }
              if (gameObject) {
                if (typeof x === "number") {
                  gameObject.x = x;
                }
                if (typeof y === "number") {
                  gameObject.y = y;
                }
                return gameObject;
              }
              if (createIfNull) {
                return this.create(x, y, key, frame, visible);
              } else {
                return null;
              }
            },
            get: function (x, y, key, frame, visible) {
              return this.getFirst(false, true, x, y, key, frame, visible);
            },
            getFirstAlive: function (createIfNull, x, y, key, frame, visible) {
              return this.getFirst(true, createIfNull, x, y, key, frame, visible);
            },
            getFirstDead: function (createIfNull, x, y, key, frame, visible) {
              return this.getFirst(false, createIfNull, x, y, key, frame, visible);
            },
            playAnimation: function (key, startFrame) {
              Actions.PlayAnimation(this.children.entries, key, startFrame);
              return this;
            },
            isFull: function () {
              if (this.maxSize === -1) {
                return false;
              } else {
                return this.children.size >= this.maxSize;
              }
            },
            countActive: function (value) {
              if (value === void 0) {
                value = true;
              }
              var total = 0;
              for (var i = 0; i < this.children.size; i++) {
                if (this.children.entries[i].active === value) {
                  total++;
                }
              }
              return total;
            },
            getTotalUsed: function () {
              return this.countActive();
            },
            getTotalFree: function () {
              var used = this.getTotalUsed();
              var capacity = this.maxSize === -1 ? 999999999999 : this.maxSize;
              return capacity - used;
            },
            setActive: function (value) {
              this.active = value;
              return this;
            },
            setName: function (value) {
              this.name = value;
              return this;
            },
            propertyValueSet: function (key, value, step, index, direction) {
              Actions.PropertyValueSet(this.children.entries, key, value, step, index, direction);
              return this;
            },
            propertyValueInc: function (key, value, step, index, direction) {
              Actions.PropertyValueInc(this.children.entries, key, value, step, index, direction);
              return this;
            },
            setX: function (value, step) {
              Actions.SetX(this.children.entries, value, step);
              return this;
            },
            setY: function (value, step) {
              Actions.SetY(this.children.entries, value, step);
              return this;
            },
            setXY: function (x, y, stepX, stepY) {
              Actions.SetXY(this.children.entries, x, y, stepX, stepY);
              return this;
            },
            incX: function (value, step) {
              Actions.IncX(this.children.entries, value, step);
              return this;
            },
            incY: function (value, step) {
              Actions.IncY(this.children.entries, value, step);
              return this;
            },
            incXY: function (x, y, stepX, stepY) {
              Actions.IncXY(this.children.entries, x, y, stepX, stepY);
              return this;
            },
            shiftPosition: function (x, y, direction) {
              Actions.ShiftPosition(this.children.entries, x, y, direction);
              return this;
            },
            angle: function (value, step) {
              Actions.Angle(this.children.entries, value, step);
              return this;
            },
            rotate: function (value, step) {
              Actions.Rotate(this.children.entries, value, step);
              return this;
            },
            rotateAround: function (point, angle) {
              Actions.RotateAround(this.children.entries, point, angle);
              return this;
            },
            rotateAroundDistance: function (point, angle, distance) {
              Actions.RotateAroundDistance(this.children.entries, point, angle, distance);
              return this;
            },
            setAlpha: function (value, step) {
              Actions.SetAlpha(this.children.entries, value, step);
              return this;
            },
            setTint: function (topLeft, topRight, bottomLeft, bottomRight) {
              Actions.SetTint(this.children.entries, topLeft, topRight, bottomLeft, bottomRight);
              return this;
            },
            setOrigin: function (originX, originY, stepX, stepY) {
              Actions.SetOrigin(this.children.entries, originX, originY, stepX, stepY);
              return this;
            },
            scaleX: function (value, step) {
              Actions.ScaleX(this.children.entries, value, step);
              return this;
            },
            scaleY: function (value, step) {
              Actions.ScaleY(this.children.entries, value, step);
              return this;
            },
            scaleXY: function (scaleX, scaleY, stepX, stepY) {
              Actions.ScaleXY(this.children.entries, scaleX, scaleY, stepX, stepY);
              return this;
            },
            setDepth: function (value, step) {
              Actions.SetDepth(this.children.entries, value, step);
              return this;
            },
            setBlendMode: function (value) {
              Actions.SetBlendMode(this.children.entries, value);
              return this;
            },
            setHitArea: function (hitArea, hitAreaCallback) {
              Actions.SetHitArea(this.children.entries, hitArea, hitAreaCallback);
              return this;
            },
            shuffle: function () {
              Actions.Shuffle(this.children.entries);
              return this;
            },
            kill: function (gameObject) {
              if (this.children.contains(gameObject)) {
                gameObject.setActive(false);
              }
            },
            killAndHide: function (gameObject) {
              if (this.children.contains(gameObject)) {
                gameObject.setActive(false);
                gameObject.setVisible(false);
              }
            },
            setVisible: function (value, index, direction) {
              Actions.SetVisible(this.children.entries, value, index, direction);
              return this;
            },
            toggleVisible: function () {
              Actions.ToggleVisible(this.children.entries);
              return this;
            },
            destroy: function (destroyChildren, removeFromScene) {
              if (destroyChildren === void 0) {
                destroyChildren = false;
              }
              if (removeFromScene === void 0) {
                removeFromScene = false;
              }
              if (!this.scene || this.ignoreDestroy) {
                return;
              }
              this.emit(Events.DESTROY, this);
              this.removeAllListeners();
              this.scene.sys.updateList.remove(this);
              this.clear(removeFromScene, destroyChildren);
              this.scene = void 0;
              this.children = void 0;
            }
          });
          module2.exports = Group;
        }, function (module2, exports2, __webpack_require__) {
          var Utils = __webpack_require__(12);
          var FillPathWebGL = function (pipeline, calcMatrix, src, alpha, dx, dy) {
            var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
            var path = src.pathData;
            var pathIndexes = src.pathIndexes;
            for (var i = 0; i < pathIndexes.length; i += 3) {
              var p0 = pathIndexes[i] * 2;
              var p1 = pathIndexes[i + 1] * 2;
              var p22 = pathIndexes[i + 2] * 2;
              var x0 = path[p0 + 0] - dx;
              var y0 = path[p0 + 1] - dy;
              var x1 = path[p1 + 0] - dx;
              var y1 = path[p1 + 1] - dy;
              var x2 = path[p22 + 0] - dx;
              var y2 = path[p22 + 1] - dy;
              var tx0 = calcMatrix.getX(x0, y0);
              var ty0 = calcMatrix.getY(x0, y0);
              var tx1 = calcMatrix.getX(x1, y1);
              var ty1 = calcMatrix.getY(x1, y1);
              var tx2 = calcMatrix.getX(x2, y2);
              var ty2 = calcMatrix.getY(x2, y2);
              pipeline.batchTri(src, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, fillTintColor, fillTintColor, fillTintColor, 2);
            }
          };
          module2.exports = FillPathWebGL;
        }, function (module2, exports2) {
          var Contains = function (triangle, x, y) {
            var v0x = triangle.x3 - triangle.x1;
            var v0y = triangle.y3 - triangle.y1;
            var v1x = triangle.x2 - triangle.x1;
            var v1y = triangle.y2 - triangle.y1;
            var v2x = x - triangle.x1;
            var v2y = y - triangle.y1;
            var dot00 = v0x * v0x + v0y * v0y;
            var dot01 = v0x * v1x + v0y * v1y;
            var dot02 = v0x * v2x + v0y * v2y;
            var dot11 = v1x * v1x + v1y * v1y;
            var dot12 = v1x * v2x + v1y * v2y;
            var b = dot00 * dot11 - dot01 * dot01;
            var inv = b === 0 ? 0 : 1 / b;
            var u = (dot11 * dot02 - dot01 * dot12) * inv;
            var v = (dot00 * dot12 - dot01 * dot02) * inv;
            return u >= 0 && v >= 0 && u + v < 1;
          };
          module2.exports = Contains;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Rectangle = __webpack_require__(10);
          var Vector2 = __webpack_require__(3);
          function GetLength(x1, y1, x2, y2) {
            var x = x1 - x2;
            var y = y1 - y2;
            var magnitude = x * x + y * y;
            return Math.sqrt(magnitude);
          }
          var Face = new Class({
            initialize: function Face2(vertex1, vertex2, vertex3) {
              this.vertex1 = vertex1;
              this.vertex2 = vertex2;
              this.vertex3 = vertex3;
              this.bounds = new Rectangle();
              this._inCenter = new Vector2();
            },
            getInCenter: function (local) {
              if (local === void 0) {
                local = true;
              }
              var v1 = this.vertex1;
              var v2 = this.vertex2;
              var v3 = this.vertex3;
              var v1x;
              var v1y;
              var v2x;
              var v2y;
              var v3x;
              var v3y;
              if (local) {
                v1x = v1.x;
                v1y = v1.y;
                v2x = v2.x;
                v2y = v2.y;
                v3x = v3.x;
                v3y = v3.y;
              } else {
                v1x = v1.vx;
                v1y = v1.vy;
                v2x = v2.vx;
                v2y = v2.vy;
                v3x = v3.vx;
                v3y = v3.vy;
              }
              var d1 = GetLength(v3x, v3y, v2x, v2y);
              var d2 = GetLength(v1x, v1y, v3x, v3y);
              var d3 = GetLength(v2x, v2y, v1x, v1y);
              var p3 = d1 + d2 + d3;
              return this._inCenter.set((v1x * d1 + v2x * d2 + v3x * d3) / p3, (v1y * d1 + v2y * d2 + v3y * d3) / p3);
            },
            contains: function (x, y, calcMatrix) {
              var vertex1 = this.vertex1;
              var vertex2 = this.vertex2;
              var vertex3 = this.vertex3;
              var v1x = vertex1.vx;
              var v1y = vertex1.vy;
              var v2x = vertex2.vx;
              var v2y = vertex2.vy;
              var v3x = vertex3.vx;
              var v3y = vertex3.vy;
              if (calcMatrix) {
                var a = calcMatrix.a;
                var b = calcMatrix.b;
                var c = calcMatrix.c;
                var d = calcMatrix.d;
                var e = calcMatrix.e;
                var f = calcMatrix.f;
                v1x = vertex1.vx * a + vertex1.vy * c + e;
                v1y = vertex1.vx * b + vertex1.vy * d + f;
                v2x = vertex2.vx * a + vertex2.vy * c + e;
                v2y = vertex2.vx * b + vertex2.vy * d + f;
                v3x = vertex3.vx * a + vertex3.vy * c + e;
                v3y = vertex3.vx * b + vertex3.vy * d + f;
              }
              var t0x = v3x - v1x;
              var t0y = v3y - v1y;
              var t1x = v2x - v1x;
              var t1y = v2y - v1y;
              var t2x = x - v1x;
              var t2y = y - v1y;
              var dot00 = t0x * t0x + t0y * t0y;
              var dot01 = t0x * t1x + t0y * t1y;
              var dot02 = t0x * t2x + t0y * t2y;
              var dot11 = t1x * t1x + t1y * t1y;
              var dot12 = t1x * t2x + t1y * t2y;
              var bc = dot00 * dot11 - dot01 * dot01;
              var inv = bc === 0 ? 0 : 1 / bc;
              var u = (dot11 * dot02 - dot01 * dot12) * inv;
              var v = (dot00 * dot12 - dot01 * dot02) * inv;
              return u >= 0 && v >= 0 && u + v < 1;
            },
            isCounterClockwise: function (z) {
              var v1 = this.vertex1;
              var v2 = this.vertex2;
              var v3 = this.vertex3;
              var d = (v2.vx - v1.vx) * (v3.vy - v1.vy) - (v2.vy - v1.vy) * (v3.vx - v1.vx);
              return z <= 0 ? d >= 0 : d < 0;
            },
            load: function (F32, U32, offset, textureUnit, tintEffect) {
              offset = this.vertex1.load(F32, U32, offset, textureUnit, tintEffect);
              offset = this.vertex2.load(F32, U32, offset, textureUnit, tintEffect);
              offset = this.vertex3.load(F32, U32, offset, textureUnit, tintEffect);
              return offset;
            },
            transformCoordinatesLocal: function (transformMatrix, width, height, cameraZ) {
              this.vertex1.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);
              this.vertex2.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);
              this.vertex3.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);
              return this;
            },
            updateBounds: function () {
              var v1 = this.vertex1;
              var v2 = this.vertex2;
              var v3 = this.vertex3;
              var bounds = this.bounds;
              bounds.x = Math.min(v1.vx, v2.vx, v3.vx);
              bounds.y = Math.min(v1.vy, v2.vy, v3.vy);
              bounds.width = Math.max(v1.vx, v2.vx, v3.vx) - bounds.x;
              bounds.height = Math.max(v1.vy, v2.vy, v3.vy) - bounds.y;
              return this;
            },
            isInView: function (camera, hideCCW, z, alpha, a, b, c, d, e, f, roundPixels) {
              var v1 = this.vertex1.update(a, b, c, d, e, f, roundPixels, alpha);
              var v2 = this.vertex2.update(a, b, c, d, e, f, roundPixels, alpha);
              var v3 = this.vertex3.update(a, b, c, d, e, f, roundPixels, alpha);
              if (v1.ta <= 0 && v2.ta <= 0 && v3.ta <= 0) {
                return false;
              }
              if (hideCCW && !this.isCounterClockwise(z)) {
                return false;
              }
              var bounds = this.bounds;
              bounds.x = Math.min(v1.tx, v2.tx, v3.tx);
              bounds.y = Math.min(v1.ty, v2.ty, v3.ty);
              bounds.width = Math.max(v1.tx, v2.tx, v3.tx) - bounds.x;
              bounds.height = Math.max(v1.ty, v2.ty, v3.ty) - bounds.y;
              var cr = camera.x + camera.width;
              var cb = camera.y + camera.height;
              if (bounds.width <= 0 || bounds.height <= 0 || camera.width <= 0 || camera.height <= 0) {
                return false;
              }
              return !(bounds.right < camera.x || bounds.bottom < camera.y || bounds.x > cr || bounds.y > cb);
            },
            translate: function (x, y) {
              if (y === void 0) {
                y = 0;
              }
              var v1 = this.vertex1;
              var v2 = this.vertex2;
              var v3 = this.vertex3;
              v1.x += x;
              v1.y += y;
              v2.x += x;
              v2.y += y;
              v3.x += x;
              v3.y += y;
              return this;
            },
            x: {
              get: function () {
                return this.getInCenter().x;
              },
              set: function (value) {
                var current = this.getInCenter();
                this.translate(value - current.x, 0);
              }
            },
            y: {
              get: function () {
                return this.getInCenter().y;
              },
              set: function (value) {
                var current = this.getInCenter();
                this.translate(0, value - current.y);
              }
            },
            alpha: {
              get: function () {
                var v1 = this.vertex1;
                var v2 = this.vertex2;
                var v3 = this.vertex3;
                return (v1.alpha + v2.alpha + v3.alpha) / 3;
              },
              set: function (value) {
                this.vertex1.alpha = value;
                this.vertex2.alpha = value;
                this.vertex3.alpha = value;
              }
            },
            depth: {
              get: function () {
                var v1 = this.vertex1;
                var v2 = this.vertex2;
                var v3 = this.vertex3;
                return (v1.vz + v2.vz + v3.vz) / 3;
              }
            },
            destroy: function () {
              this.vertex1 = null;
              this.vertex2 = null;
              this.vertex3 = null;
            }
          });
          module2.exports = Face;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Utils = __webpack_require__(12);
          var Vector3 = __webpack_require__(39);
          var Vertex = new Class({
            Extends: Vector3,
            initialize: function Vertex2(x, y, z, u, v, color, alpha, nx, ny, nz) {
              if (color === void 0) {
                color = 16777215;
              }
              if (alpha === void 0) {
                alpha = 1;
              }
              if (nx === void 0) {
                nx = 0;
              }
              if (ny === void 0) {
                ny = 0;
              }
              if (nz === void 0) {
                nz = 0;
              }
              Vector3.call(this, x, y, z);
              this.vx = 0;
              this.vy = 0;
              this.vz = 0;
              this.nx = nx;
              this.ny = ny;
              this.nz = nz;
              this.u = u;
              this.v = v;
              this.color = color;
              this.alpha = alpha;
              this.tx = 0;
              this.ty = 0;
              this.ta = 0;
            },
            setUVs: function (u, v) {
              this.u = u;
              this.v = v;
              return this;
            },
            transformCoordinatesLocal: function (transformMatrix, width, height, cameraZ) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var m = transformMatrix.val;
              var tx = x * m[0] + y * m[4] + z * m[8] + m[12];
              var ty = x * m[1] + y * m[5] + z * m[9] + m[13];
              var tz = x * m[2] + y * m[6] + z * m[10] + m[14];
              var tw = x * m[3] + y * m[7] + z * m[11] + m[15];
              this.vx = tx / tw * width;
              this.vy = -(ty / tw) * height;
              if (cameraZ <= 0) {
                this.vz = tz / tw;
              } else {
                this.vz = -(tz / tw);
              }
            },
            update: function (a, b, c, d, e, f, roundPixels, alpha) {
              var tx = this.vx * a + this.vy * c + e;
              var ty = this.vx * b + this.vy * d + f;
              if (roundPixels) {
                tx = Math.round(tx);
                ty = Math.round(ty);
              }
              this.tx = tx;
              this.ty = ty;
              this.ta = this.alpha * alpha;
              return this;
            },
            load: function (F32, U32, offset, textureUnit, tintEffect) {
              F32[++offset] = this.tx;
              F32[++offset] = this.ty;
              F32[++offset] = this.u;
              F32[++offset] = this.v;
              F32[++offset] = textureUnit;
              F32[++offset] = tintEffect;
              U32[++offset] = Utils.getTintAppendFloatAlpha(this.color, this.ta);
              return offset;
            }
          });
          module2.exports = Vertex;
        }, function (module2, exports2, __webpack_require__) {
          var Composite = {};
          module2.exports = Composite;
          var Events = __webpack_require__(166);
          var Common = __webpack_require__(32);
          var Bounds = __webpack_require__(84);
          var Body = __webpack_require__(41);
          (function () {
            Composite.create = function (options) {
              return Common.extend({
                id: Common.nextId(),
                type: "composite",
                parent: null,
                isModified: false,
                bodies: [],
                constraints: [],
                composites: [],
                label: "Composite",
                plugin: {}
              }, options);
            };
            Composite.setModified = function (composite, isModified, updateParents, updateChildren) {
              Events.trigger(composite, "compositeModified", composite);
              composite.isModified = isModified;
              if (updateParents && composite.parent) {
                Composite.setModified(composite.parent, isModified, updateParents, updateChildren);
              }
              if (updateChildren) {
                for (var i = 0; i < composite.composites.length; i++) {
                  var childComposite = composite.composites[i];
                  Composite.setModified(childComposite, isModified, updateParents, updateChildren);
                }
              }
            };
            Composite.add = function (composite, object) {
              var objects = [].concat(object);
              Events.trigger(composite, "beforeAdd", {
                object
              });
              for (var i = 0; i < objects.length; i++) {
                var obj = objects[i];
                switch (obj.type) {
                  case "body":
                    if (obj.parent !== obj) {
                      Common.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");
                      break;
                    }
                    Composite.addBody(composite, obj);
                    break;
                  case "constraint":
                    Composite.addConstraint(composite, obj);
                    break;
                  case "composite":
                    Composite.addComposite(composite, obj);
                    break;
                  case "mouseConstraint":
                    Composite.addConstraint(composite, obj.constraint);
                    break;
                }
              }
              Events.trigger(composite, "afterAdd", {
                object
              });
              return composite;
            };
            Composite.remove = function (composite, object, deep) {
              var objects = [].concat(object);
              Events.trigger(composite, "beforeRemove", {
                object
              });
              for (var i = 0; i < objects.length; i++) {
                var obj = objects[i];
                switch (obj.type) {
                  case "body":
                    Composite.removeBody(composite, obj, deep);
                    break;
                  case "constraint":
                    Composite.removeConstraint(composite, obj, deep);
                    break;
                  case "composite":
                    Composite.removeComposite(composite, obj, deep);
                    break;
                  case "mouseConstraint":
                    Composite.removeConstraint(composite, obj.constraint);
                    break;
                }
              }
              Events.trigger(composite, "afterRemove", {
                object
              });
              return composite;
            };
            Composite.addComposite = function (compositeA, compositeB) {
              compositeA.composites.push(compositeB);
              compositeB.parent = compositeA;
              Composite.setModified(compositeA, true, true, false);
              return compositeA;
            };
            Composite.removeComposite = function (compositeA, compositeB, deep) {
              var position = compositeA.composites.indexOf(compositeB);
              if (position !== -1) {
                Composite.removeCompositeAt(compositeA, position);
                Composite.setModified(compositeA, true, true, false);
              }
              if (deep) {
                for (var i = 0; i < compositeA.composites.length; i++) {
                  Composite.removeComposite(compositeA.composites[i], compositeB, true);
                }
              }
              return compositeA;
            };
            Composite.removeCompositeAt = function (composite, position) {
              composite.composites.splice(position, 1);
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.addBody = function (composite, body) {
              composite.bodies.push(body);
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.removeBody = function (composite, body, deep) {
              var position = composite.bodies.indexOf(body);
              if (position !== -1) {
                Composite.removeBodyAt(composite, position);
                Composite.setModified(composite, true, true, false);
              }
              if (deep) {
                for (var i = 0; i < composite.composites.length; i++) {
                  Composite.removeBody(composite.composites[i], body, true);
                }
              }
              return composite;
            };
            Composite.removeBodyAt = function (composite, position) {
              composite.bodies.splice(position, 1);
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.addConstraint = function (composite, constraint) {
              composite.constraints.push(constraint);
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.removeConstraint = function (composite, constraint, deep) {
              var position = composite.constraints.indexOf(constraint);
              if (position !== -1) {
                Composite.removeConstraintAt(composite, position);
              }
              if (deep) {
                for (var i = 0; i < composite.composites.length; i++) {
                  Composite.removeConstraint(composite.composites[i], constraint, true);
                }
              }
              return composite;
            };
            Composite.removeConstraintAt = function (composite, position) {
              composite.constraints.splice(position, 1);
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.clear = function (composite, keepStatic, deep) {
              if (deep) {
                for (var i = 0; i < composite.composites.length; i++) {
                  Composite.clear(composite.composites[i], keepStatic, true);
                }
              }
              if (keepStatic) {
                composite.bodies = composite.bodies.filter(function (body) {
                  return body.isStatic;
                });
              } else {
                composite.bodies.length = 0;
              }
              composite.constraints.length = 0;
              composite.composites.length = 0;
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.allBodies = function (composite) {
              var bodies = [].concat(composite.bodies);
              for (var i = 0; i < composite.composites.length; i++) bodies = bodies.concat(Composite.allBodies(composite.composites[i]));
              return bodies;
            };
            Composite.allConstraints = function (composite) {
              var constraints = [].concat(composite.constraints);
              for (var i = 0; i < composite.composites.length; i++) constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));
              return constraints;
            };
            Composite.allComposites = function (composite) {
              var composites = [].concat(composite.composites);
              for (var i = 0; i < composite.composites.length; i++) composites = composites.concat(Composite.allComposites(composite.composites[i]));
              return composites;
            };
            Composite.get = function (composite, id, type) {
              var objects, object;
              switch (type) {
                case "body":
                  objects = Composite.allBodies(composite);
                  break;
                case "constraint":
                  objects = Composite.allConstraints(composite);
                  break;
                case "composite":
                  objects = Composite.allComposites(composite).concat(composite);
                  break;
              }
              if (!objects) return null;
              object = objects.filter(function (object2) {
                return object2.id.toString() === id.toString();
              });
              return object.length === 0 ? null : object[0];
            };
            Composite.move = function (compositeA, objects, compositeB) {
              Composite.remove(compositeA, objects);
              Composite.add(compositeB, objects);
              return compositeA;
            };
            Composite.rebase = function (composite) {
              var objects = Composite.allBodies(composite).concat(Composite.allConstraints(composite)).concat(Composite.allComposites(composite));
              for (var i = 0; i < objects.length; i++) {
                objects[i].id = Common.nextId();
              }
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.translate = function (composite, translation, recursive) {
              var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;
              for (var i = 0; i < bodies.length; i++) {
                Body.translate(bodies[i], translation);
              }
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.rotate = function (composite, rotation, point, recursive) {
              var cos = Math.cos(rotation), sin = Math.sin(rotation), bodies = recursive ? Composite.allBodies(composite) : composite.bodies;
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i], dx = body.position.x - point.x, dy = body.position.y - point.y;
                Body.setPosition(body, {
                  x: point.x + (dx * cos - dy * sin),
                  y: point.y + (dx * sin + dy * cos)
                });
                Body.rotate(body, rotation);
              }
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.scale = function (composite, scaleX, scaleY, point, recursive) {
              var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i], dx = body.position.x - point.x, dy = body.position.y - point.y;
                Body.setPosition(body, {
                  x: point.x + dx * scaleX,
                  y: point.y + dy * scaleY
                });
                Body.scale(body, scaleX, scaleY);
              }
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.bounds = function (composite) {
              var bodies = Composite.allBodies(composite), vertices = [];
              for (var i = 0; i < bodies.length; i += 1) {
                var body = bodies[i];
                vertices.push(body.bounds.min, body.bounds.max);
              }
              return Bounds.create(vertices);
            };
          })();
        }, function (module2, exports2) {
          var IsInLayerBounds = function (tileX, tileY, layer) {
            return tileX >= 0 && tileX < layer.width && tileY >= 0 && tileY < layer.height;
          };
          module2.exports = IsInLayerBounds;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(29);
          var GetFastValue = __webpack_require__(2);
          var LayerData = new Class({
            initialize: function LayerData2(config) {
              if (config === void 0) {
                config = {};
              }
              this.name = GetFastValue(config, "name", "layer");
              this.x = GetFastValue(config, "x", 0);
              this.y = GetFastValue(config, "y", 0);
              this.width = GetFastValue(config, "width", 0);
              this.height = GetFastValue(config, "height", 0);
              this.tileWidth = GetFastValue(config, "tileWidth", 0);
              this.tileHeight = GetFastValue(config, "tileHeight", 0);
              this.baseTileWidth = GetFastValue(config, "baseTileWidth", this.tileWidth);
              this.baseTileHeight = GetFastValue(config, "baseTileHeight", this.tileHeight);
              this.orientation = GetFastValue(config, "orientation", CONST.ORTHOGONAL);
              this.widthInPixels = GetFastValue(config, "widthInPixels", this.width * this.baseTileWidth);
              this.heightInPixels = GetFastValue(config, "heightInPixels", this.height * this.baseTileHeight);
              this.alpha = GetFastValue(config, "alpha", 1);
              this.visible = GetFastValue(config, "visible", true);
              this.properties = GetFastValue(config, "properties", []);
              this.indexes = GetFastValue(config, "indexes", []);
              this.collideIndexes = GetFastValue(config, "collideIndexes", []);
              this.callbacks = GetFastValue(config, "callbacks", []);
              this.bodies = GetFastValue(config, "bodies", []);
              this.data = GetFastValue(config, "data", []);
              this.tilemapLayer = GetFastValue(config, "tilemapLayer", null);
              this.hexSideLength = GetFastValue(config, "hexSideLength", 0);
            }
          });
          module2.exports = LayerData;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(29);
          var GetFastValue = __webpack_require__(2);
          var MapData = new Class({
            initialize: function MapData2(config) {
              if (config === void 0) {
                config = {};
              }
              this.name = GetFastValue(config, "name", "map");
              this.width = GetFastValue(config, "width", 0);
              this.height = GetFastValue(config, "height", 0);
              this.infinite = GetFastValue(config, "infinite", false);
              this.tileWidth = GetFastValue(config, "tileWidth", 0);
              this.tileHeight = GetFastValue(config, "tileHeight", 0);
              this.widthInPixels = GetFastValue(config, "widthInPixels", this.width * this.tileWidth);
              this.heightInPixels = GetFastValue(config, "heightInPixels", this.height * this.tileHeight);
              this.format = GetFastValue(config, "format", null);
              this.orientation = GetFastValue(config, "orientation", CONST.ORTHOGONAL);
              this.renderOrder = GetFastValue(config, "renderOrder", "right-down");
              this.version = GetFastValue(config, "version", "1");
              this.properties = GetFastValue(config, "properties", {});
              this.layers = GetFastValue(config, "layers", []);
              this.images = GetFastValue(config, "images", []);
              this.objects = GetFastValue(config, "objects", {});
              this.collision = GetFastValue(config, "collision", {});
              this.tilesets = GetFastValue(config, "tilesets", []);
              this.imageCollections = GetFastValue(config, "imageCollections", []);
              this.tiles = GetFastValue(config, "tiles", []);
              this.hexSideLength = GetFastValue(config, "hexSideLength", 0);
            }
          });
          module2.exports = MapData;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Tileset = new Class({
            initialize: function Tileset2(name, firstgid, tileWidth, tileHeight, tileMargin, tileSpacing, tileProperties, tileData) {
              if (tileWidth === void 0 || tileWidth <= 0) {
                tileWidth = 32;
              }
              if (tileHeight === void 0 || tileHeight <= 0) {
                tileHeight = 32;
              }
              if (tileMargin === void 0) {
                tileMargin = 0;
              }
              if (tileSpacing === void 0) {
                tileSpacing = 0;
              }
              if (tileProperties === void 0) {
                tileProperties = {};
              }
              if (tileData === void 0) {
                tileData = {};
              }
              this.name = name;
              this.firstgid = firstgid;
              this.tileWidth = tileWidth;
              this.tileHeight = tileHeight;
              this.tileMargin = tileMargin;
              this.tileSpacing = tileSpacing;
              this.tileProperties = tileProperties;
              this.tileData = tileData;
              this.image = null;
              this.glTexture = null;
              this.rows = 0;
              this.columns = 0;
              this.total = 0;
              this.texCoordinates = [];
            },
            getTileProperties: function (tileIndex) {
              if (!this.containsTileIndex(tileIndex)) {
                return null;
              }
              return this.tileProperties[tileIndex - this.firstgid];
            },
            getTileData: function (tileIndex) {
              if (!this.containsTileIndex(tileIndex)) {
                return null;
              }
              return this.tileData[tileIndex - this.firstgid];
            },
            getTileCollisionGroup: function (tileIndex) {
              var data = this.getTileData(tileIndex);
              return data && data.objectgroup ? data.objectgroup : null;
            },
            containsTileIndex: function (tileIndex) {
              return tileIndex >= this.firstgid && tileIndex < this.firstgid + this.total;
            },
            getTileTextureCoordinates: function (tileIndex) {
              if (!this.containsTileIndex(tileIndex)) {
                return null;
              }
              return this.texCoordinates[tileIndex - this.firstgid];
            },
            setImage: function (texture) {
              this.image = texture;
              this.glTexture = texture.get().source.glTexture;
              this.updateTileData(this.image.source[0].width, this.image.source[0].height);
              return this;
            },
            setTileSize: function (tileWidth, tileHeight) {
              if (tileWidth !== void 0) {
                this.tileWidth = tileWidth;
              }
              if (tileHeight !== void 0) {
                this.tileHeight = tileHeight;
              }
              if (this.image) {
                this.updateTileData(this.image.source[0].width, this.image.source[0].height);
              }
              return this;
            },
            setSpacing: function (margin, spacing) {
              if (margin !== void 0) {
                this.tileMargin = margin;
              }
              if (spacing !== void 0) {
                this.tileSpacing = spacing;
              }
              if (this.image) {
                this.updateTileData(this.image.source[0].width, this.image.source[0].height);
              }
              return this;
            },
            updateTileData: function (imageWidth, imageHeight) {
              var rowCount = (imageHeight - this.tileMargin * 2 + this.tileSpacing) / (this.tileHeight + this.tileSpacing);
              var colCount = (imageWidth - this.tileMargin * 2 + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
              if (rowCount % 1 !== 0 || colCount % 1 !== 0) {
                console.warn("Image tile area not tile size multiple in: " + this.name);
              }
              rowCount = Math.floor(rowCount);
              colCount = Math.floor(colCount);
              this.rows = rowCount;
              this.columns = colCount;
              this.total = rowCount * colCount;
              this.texCoordinates.length = 0;
              var tx = this.tileMargin;
              var ty = this.tileMargin;
              for (var y = 0; y < this.rows; y++) {
                for (var x = 0; x < this.columns; x++) {
                  this.texCoordinates.push({
                    x: tx,
                    y: ty
                  });
                  tx += this.tileWidth + this.tileSpacing;
                }
                tx = this.tileMargin;
                ty += this.tileHeight + this.tileSpacing;
              }
              return this;
            }
          });
          module2.exports = Tileset;
        }, function (module2, exports2) {
          var ALIGN_CONST = {
            TOP_LEFT: 0,
            TOP_CENTER: 1,
            TOP_RIGHT: 2,
            LEFT_TOP: 3,
            LEFT_CENTER: 4,
            LEFT_BOTTOM: 5,
            CENTER: 6,
            RIGHT_TOP: 7,
            RIGHT_CENTER: 8,
            RIGHT_BOTTOM: 9,
            BOTTOM_LEFT: 10,
            BOTTOM_CENTER: 11,
            BOTTOM_RIGHT: 12
          };
          module2.exports = ALIGN_CONST;
        }, function (module2, exports2) {
          var Equal = function (a, b, epsilon) {
            if (epsilon === void 0) {
              epsilon = 1e-4;
            }
            return Math.abs(a - b) < epsilon;
          };
          module2.exports = Equal;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var ImageRender = __webpack_require__(1068);
          var Image2 = new Class({
            Extends: GameObject,
            Mixins: [Components.Alpha, Components.BlendMode, Components.Depth, Components.Flip, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Size, Components.TextureCrop, Components.Tint, Components.Transform, Components.Visible, ImageRender],
            initialize: function Image3(scene, x, y, texture, frame) {
              GameObject.call(this, scene, "Image");
              this._crop = this.resetCropObject();
              this.setTexture(texture, frame);
              this.setPosition(x, y);
              this.setSizeToFrame();
              this.setOriginFromFrame();
              this.initPipeline();
            }
          });
          module2.exports = Image2;
        }, function (module2, exports2) {
          var HasValue = function (source, key) {
            return source.hasOwnProperty(key);
          };
          module2.exports = HasValue;
        }, function (module2, exports2, __webpack_require__) {
          var Clone = __webpack_require__(77);
          var Merge = function (obj1, obj2) {
            var clone = Clone(obj1);
            for (var key in obj2) {
              if (!clone.hasOwnProperty(key)) {
                clone[key] = obj2[key];
              }
            }
            return clone;
          };
          module2.exports = Merge;
        }, function (module2, exports2, __webpack_require__) {
          var Constraint = {};
          module2.exports = Constraint;
          var Vertices = __webpack_require__(64);
          var Vector = __webpack_require__(83);
          var Sleeping = __webpack_require__(165);
          var Bounds = __webpack_require__(84);
          var Axes = __webpack_require__(271);
          var Common = __webpack_require__(32);
          (function () {
            Constraint._warming = 0.4;
            Constraint._torqueDampen = 1;
            Constraint._minLength = 1e-6;
            Constraint.create = function (options) {
              var constraint = options;
              if (constraint.bodyA && !constraint.pointA) constraint.pointA = {
                x: 0,
                y: 0
              };
              if (constraint.bodyB && !constraint.pointB) constraint.pointB = {
                x: 0,
                y: 0
              };
              var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA, initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB, length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));
              constraint.length = typeof constraint.length !== "undefined" ? constraint.length : length;
              constraint.id = constraint.id || Common.nextId();
              constraint.label = constraint.label || "Constraint";
              constraint.type = "constraint";
              constraint.stiffness = constraint.stiffness || (constraint.length > 0 ? 1 : 0.7);
              constraint.damping = constraint.damping || 0;
              constraint.angularStiffness = constraint.angularStiffness || 0;
              constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;
              constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;
              constraint.plugin = {};
              var render = {
                visible: true,
                type: "line",
                anchors: true,
                lineColor: null,
                lineOpacity: null,
                lineThickness: null,
                pinSize: null,
                anchorColor: null,
                anchorSize: null
              };
              if (constraint.length === 0 && constraint.stiffness > 0.1) {
                render.type = "pin";
                render.anchors = false;
              } else if (constraint.stiffness < 0.9) {
                render.type = "spring";
              }
              constraint.render = Common.extend(render, constraint.render);
              return constraint;
            };
            Constraint.preSolveAll = function (bodies) {
              for (var i = 0; i < bodies.length; i += 1) {
                var body = bodies[i], impulse = body.constraintImpulse;
                if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {
                  continue;
                }
                body.position.x += impulse.x;
                body.position.y += impulse.y;
                body.angle += impulse.angle;
              }
            };
            Constraint.solveAll = function (constraints, timeScale) {
              for (var i = 0; i < constraints.length; i += 1) {
                var constraint = constraints[i], fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic, fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;
                if (fixedA || fixedB) {
                  Constraint.solve(constraints[i], timeScale);
                }
              }
              for (i = 0; i < constraints.length; i += 1) {
                constraint = constraints[i];
                fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic;
                fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;
                if (!fixedA && !fixedB) {
                  Constraint.solve(constraints[i], timeScale);
                }
              }
            };
            Constraint.solve = function (constraint, timeScale) {
              var bodyA = constraint.bodyA, bodyB = constraint.bodyB, pointA = constraint.pointA, pointB = constraint.pointB;
              if (!bodyA && !bodyB) return;
              if (bodyA && !bodyA.isStatic) {
                Vector.rotate(pointA, bodyA.angle - constraint.angleA, pointA);
                constraint.angleA = bodyA.angle;
              }
              if (bodyB && !bodyB.isStatic) {
                Vector.rotate(pointB, bodyB.angle - constraint.angleB, pointB);
                constraint.angleB = bodyB.angle;
              }
              var pointAWorld = pointA, pointBWorld = pointB;
              if (bodyA) pointAWorld = Vector.add(bodyA.position, pointA);
              if (bodyB) pointBWorld = Vector.add(bodyB.position, pointB);
              if (!pointAWorld || !pointBWorld) return;
              var delta = Vector.sub(pointAWorld, pointBWorld), currentLength = Vector.magnitude(delta);
              if (currentLength < Constraint._minLength) {
                currentLength = Constraint._minLength;
              }
              var difference = (currentLength - constraint.length) / currentLength, stiffness = constraint.stiffness < 1 ? constraint.stiffness * timeScale : constraint.stiffness, force = Vector.mult(delta, difference * stiffness), massTotal = (bodyA ? bodyA.inverseMass : 0) + (bodyB ? bodyB.inverseMass : 0), inertiaTotal = (bodyA ? bodyA.inverseInertia : 0) + (bodyB ? bodyB.inverseInertia : 0), resistanceTotal = massTotal + inertiaTotal, torque, share, normal, normalVelocity, relativeVelocity;
              if (constraint.damping) {
                var zero = Vector.create();
                normal = Vector.div(delta, currentLength);
                relativeVelocity = Vector.sub(bodyB && Vector.sub(bodyB.position, bodyB.positionPrev) || zero, bodyA && Vector.sub(bodyA.position, bodyA.positionPrev) || zero);
                normalVelocity = Vector.dot(normal, relativeVelocity);
              }
              if (bodyA && !bodyA.isStatic) {
                share = bodyA.inverseMass / massTotal;
                bodyA.constraintImpulse.x -= force.x * share;
                bodyA.constraintImpulse.y -= force.y * share;
                bodyA.position.x -= force.x * share;
                bodyA.position.y -= force.y * share;
                if (constraint.damping) {
                  bodyA.positionPrev.x -= constraint.damping * normal.x * normalVelocity * share;
                  bodyA.positionPrev.y -= constraint.damping * normal.y * normalVelocity * share;
                }
                torque = Vector.cross(pointA, force) / resistanceTotal * Constraint._torqueDampen * bodyA.inverseInertia * (1 - constraint.angularStiffness);
                bodyA.constraintImpulse.angle -= torque;
                bodyA.angle -= torque;
              }
              if (bodyB && !bodyB.isStatic) {
                share = bodyB.inverseMass / massTotal;
                bodyB.constraintImpulse.x += force.x * share;
                bodyB.constraintImpulse.y += force.y * share;
                bodyB.position.x += force.x * share;
                bodyB.position.y += force.y * share;
                if (constraint.damping) {
                  bodyB.positionPrev.x += constraint.damping * normal.x * normalVelocity * share;
                  bodyB.positionPrev.y += constraint.damping * normal.y * normalVelocity * share;
                }
                torque = Vector.cross(pointB, force) / resistanceTotal * Constraint._torqueDampen * bodyB.inverseInertia * (1 - constraint.angularStiffness);
                bodyB.constraintImpulse.angle += torque;
                bodyB.angle += torque;
              }
            };
            Constraint.postSolveAll = function (bodies) {
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i], impulse = body.constraintImpulse;
                if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {
                  continue;
                }
                Sleeping.set(body, false);
                for (var j = 0; j < body.parts.length; j++) {
                  var part = body.parts[j];
                  Vertices.translate(part.vertices, impulse);
                  if (j > 0) {
                    part.position.x += impulse.x;
                    part.position.y += impulse.y;
                  }
                  if (impulse.angle !== 0) {
                    Vertices.rotate(part.vertices, impulse.angle, body.position);
                    Axes.rotate(part.axes, impulse.angle);
                    if (j > 0) {
                      Vector.rotateAbout(part.position, impulse.angle, body.position, part.position);
                    }
                  }
                  Bounds.update(part.bounds, part.vertices, body.velocity);
                }
                impulse.angle *= Constraint._warming;
                impulse.x *= Constraint._warming;
                impulse.y *= Constraint._warming;
              }
            };
            Constraint.pointAWorld = function (constraint) {
              return {
                x: (constraint.bodyA ? constraint.bodyA.position.x : 0) + constraint.pointA.x,
                y: (constraint.bodyA ? constraint.bodyA.position.y : 0) + constraint.pointA.y
              };
            };
            Constraint.pointBWorld = function (constraint) {
              return {
                x: (constraint.bodyB ? constraint.bodyB.position.x : 0) + constraint.pointB.x,
                y: (constraint.bodyB ? constraint.bodyB.position.y : 0) + constraint.pointB.y
              };
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          var BlendModes = __webpack_require__(35);
          var Circle = __webpack_require__(65);
          var CircleContains = __webpack_require__(66);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var Rectangle = __webpack_require__(10);
          var RectangleContains = __webpack_require__(57);
          var Zone = new Class({
            Extends: GameObject,
            Mixins: [Components.Depth, Components.GetBounds, Components.Origin, Components.Transform, Components.ScrollFactor, Components.Visible],
            initialize: function Zone2(scene, x, y, width, height) {
              if (width === void 0) {
                width = 1;
              }
              if (height === void 0) {
                height = width;
              }
              GameObject.call(this, scene, "Zone");
              this.setPosition(x, y);
              this.width = width;
              this.height = height;
              this.blendMode = BlendModes.NORMAL;
              this.updateDisplayOrigin();
            },
            displayWidth: {
              get: function () {
                return this.scaleX * this.width;
              },
              set: function (value) {
                this.scaleX = value / this.width;
              }
            },
            displayHeight: {
              get: function () {
                return this.scaleY * this.height;
              },
              set: function (value) {
                this.scaleY = value / this.height;
              }
            },
            setSize: function (width, height, resizeInput) {
              if (resizeInput === void 0) {
                resizeInput = true;
              }
              this.width = width;
              this.height = height;
              this.updateDisplayOrigin();
              var input = this.input;
              if (resizeInput && input && !input.customHitArea) {
                input.hitArea.width = width;
                input.hitArea.height = height;
              }
              return this;
            },
            setDisplaySize: function (width, height) {
              this.displayWidth = width;
              this.displayHeight = height;
              return this;
            },
            setCircleDropZone: function (radius) {
              return this.setDropZone(new Circle(0, 0, radius), CircleContains);
            },
            setRectangleDropZone: function (width, height) {
              return this.setDropZone(new Rectangle(0, 0, width, height), RectangleContains);
            },
            setDropZone: function (hitArea, hitAreaCallback) {
              if (hitArea === void 0) {
                this.setRectangleDropZone(this.width, this.height);
              } else if (!this.input) {
                this.setInteractive(hitArea, hitAreaCallback, true);
              }
              return this;
            },
            setAlpha: function () {},
            setBlendMode: function () {},
            renderCanvas: function (renderer, src, camera) {
              camera.addToRenderList(src);
            },
            renderWebGL: function (renderer, src, camera) {
              camera.addToRenderList(src);
            }
          });
          module2.exports = Zone;
        }, function (module2, exports2) {
          var Perimeter = function (rect) {
            return 2 * (rect.width + rect.height);
          };
          module2.exports = Perimeter;
        }, function (module2, exports2) {
          var Shuffle = function (array) {
            for (var i = array.length - 1; i > 0; i--) {
              var j = Math.floor(Math.random() * (i + 1));
              var temp = array[i];
              array[i] = array[j];
              array[j] = temp;
            }
            return array;
          };
          module2.exports = Shuffle;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            ADD_ANIMATION: __webpack_require__(724),
            ANIMATION_COMPLETE: __webpack_require__(725),
            ANIMATION_COMPLETE_KEY: __webpack_require__(726),
            ANIMATION_REPEAT: __webpack_require__(727),
            ANIMATION_RESTART: __webpack_require__(728),
            ANIMATION_START: __webpack_require__(729),
            ANIMATION_STOP: __webpack_require__(730),
            ANIMATION_UPDATE: __webpack_require__(731),
            PAUSE_ALL: __webpack_require__(732),
            REMOVE_ANIMATION: __webpack_require__(733),
            RESUME_ALL: __webpack_require__(734)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var DegToRad = __webpack_require__(36);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(37);
          var Rectangle = __webpack_require__(10);
          var TransformMatrix = __webpack_require__(25);
          var ValueToColor = __webpack_require__(187);
          var Vector2 = __webpack_require__(3);
          var BaseCamera = new Class({
            Extends: EventEmitter,
            Mixins: [Components.Alpha, Components.Visible],
            initialize: function BaseCamera2(x, y, width, height) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = 0;
              }
              if (height === void 0) {
                height = 0;
              }
              EventEmitter.call(this);
              this.scene;
              this.sceneManager;
              this.scaleManager;
              this.cameraManager;
              this.id = 0;
              this.name = "";
              this.roundPixels = false;
              this.useBounds = false;
              this.worldView = new Rectangle();
              this.dirty = true;
              this._x = x;
              this._y = y;
              this._width = width;
              this._height = height;
              this._bounds = new Rectangle();
              this._scrollX = 0;
              this._scrollY = 0;
              this._zoomX = 1;
              this._zoomY = 1;
              this._rotation = 0;
              this.matrix = new TransformMatrix();
              this.transparent = true;
              this.backgroundColor = ValueToColor("rgba(0,0,0,0)");
              this.disableCull = false;
              this.culledObjects = [];
              this.midPoint = new Vector2(width / 2, height / 2);
              this.originX = 0.5;
              this.originY = 0.5;
              this._customViewport = false;
              this.mask = null;
              this._maskCamera = null;
              this.renderList = [];
            },
            addToRenderList: function (child) {
              this.renderList.push(child);
            },
            setOrigin: function (x, y) {
              if (x === void 0) {
                x = 0.5;
              }
              if (y === void 0) {
                y = x;
              }
              this.originX = x;
              this.originY = y;
              return this;
            },
            getScroll: function (x, y, out) {
              if (out === void 0) {
                out = new Vector2();
              }
              var originX = this.width * 0.5;
              var originY = this.height * 0.5;
              out.x = x - originX;
              out.y = y - originY;
              if (this.useBounds) {
                out.x = this.clampX(out.x);
                out.y = this.clampY(out.y);
              }
              return out;
            },
            centerOnX: function (x) {
              var originX = this.width * 0.5;
              this.midPoint.x = x;
              this.scrollX = x - originX;
              if (this.useBounds) {
                this.scrollX = this.clampX(this.scrollX);
              }
              return this;
            },
            centerOnY: function (y) {
              var originY = this.height * 0.5;
              this.midPoint.y = y;
              this.scrollY = y - originY;
              if (this.useBounds) {
                this.scrollY = this.clampY(this.scrollY);
              }
              return this;
            },
            centerOn: function (x, y) {
              this.centerOnX(x);
              this.centerOnY(y);
              return this;
            },
            centerToBounds: function () {
              if (this.useBounds) {
                var bounds = this._bounds;
                var originX = this.width * 0.5;
                var originY = this.height * 0.5;
                this.midPoint.set(bounds.centerX, bounds.centerY);
                this.scrollX = bounds.centerX - originX;
                this.scrollY = bounds.centerY - originY;
              }
              return this;
            },
            centerToSize: function () {
              this.scrollX = this.width * 0.5;
              this.scrollY = this.height * 0.5;
              return this;
            },
            cull: function (renderableObjects) {
              if (this.disableCull) {
                return renderableObjects;
              }
              var cameraMatrix = this.matrix.matrix;
              var mva = cameraMatrix[0];
              var mvb = cameraMatrix[1];
              var mvc = cameraMatrix[2];
              var mvd = cameraMatrix[3];
              var determinant = mva * mvd - mvb * mvc;
              if (!determinant) {
                return renderableObjects;
              }
              var mve = cameraMatrix[4];
              var mvf = cameraMatrix[5];
              var scrollX = this.scrollX;
              var scrollY = this.scrollY;
              var cameraW = this.width;
              var cameraH = this.height;
              var cullTop = this.y;
              var cullBottom = cullTop + cameraH;
              var cullLeft = this.x;
              var cullRight = cullLeft + cameraW;
              var culledObjects = this.culledObjects;
              var length = renderableObjects.length;
              determinant = 1 / determinant;
              culledObjects.length = 0;
              for (var index = 0; index < length; ++index) {
                var object = renderableObjects[index];
                if (!object.hasOwnProperty("width") || object.parentContainer) {
                  culledObjects.push(object);
                  continue;
                }
                var objectW = object.width;
                var objectH = object.height;
                var objectX = object.x - scrollX * object.scrollFactorX - objectW * object.originX;
                var objectY = object.y - scrollY * object.scrollFactorY - objectH * object.originY;
                var tx = objectX * mva + objectY * mvc + mve;
                var ty = objectX * mvb + objectY * mvd + mvf;
                var tw = (objectX + objectW) * mva + (objectY + objectH) * mvc + mve;
                var th = (objectX + objectW) * mvb + (objectY + objectH) * mvd + mvf;
                if (tw > cullLeft && tx < cullRight && (th > cullTop && ty < cullBottom)) {
                  culledObjects.push(object);
                }
              }
              return culledObjects;
            },
            getWorldPoint: function (x, y, output) {
              if (output === void 0) {
                output = new Vector2();
              }
              var cameraMatrix = this.matrix.matrix;
              var mva = cameraMatrix[0];
              var mvb = cameraMatrix[1];
              var mvc = cameraMatrix[2];
              var mvd = cameraMatrix[3];
              var mve = cameraMatrix[4];
              var mvf = cameraMatrix[5];
              var determinant = mva * mvd - mvb * mvc;
              if (!determinant) {
                output.x = x;
                output.y = y;
                return output;
              }
              determinant = 1 / determinant;
              var ima = mvd * determinant;
              var imb = -mvb * determinant;
              var imc = -mvc * determinant;
              var imd = mva * determinant;
              var ime = (mvc * mvf - mvd * mve) * determinant;
              var imf = (mvb * mve - mva * mvf) * determinant;
              var c = Math.cos(this.rotation);
              var s = Math.sin(this.rotation);
              var zoomX = this.zoomX;
              var zoomY = this.zoomY;
              var scrollX = this.scrollX;
              var scrollY = this.scrollY;
              var sx = x + (scrollX * c - scrollY * s) * zoomX;
              var sy = y + (scrollX * s + scrollY * c) * zoomY;
              output.x = sx * ima + sy * imc + ime;
              output.y = sx * imb + sy * imd + imf;
              return output;
            },
            ignore: function (entries) {
              var id = this.id;
              if (!Array.isArray(entries)) {
                entries = [entries];
              }
              for (var i = 0; i < entries.length; i++) {
                var entry = entries[i];
                if (Array.isArray(entry)) {
                  this.ignore(entry);
                } else if (entry.isParent) {
                  this.ignore(entry.getChildren());
                } else {
                  entry.cameraFilter |= id;
                }
              }
              return this;
            },
            preRender: function () {
              this.renderList.length = 0;
              var width = this.width;
              var height = this.height;
              var halfWidth = width * 0.5;
              var halfHeight = height * 0.5;
              var zoomX = this.zoomX;
              var zoomY = this.zoomY;
              var matrix = this.matrix;
              var originX = width * this.originX;
              var originY = height * this.originY;
              var sx = this.scrollX;
              var sy = this.scrollY;
              if (this.useBounds) {
                sx = this.clampX(sx);
                sy = this.clampY(sy);
              }
              if (this.roundPixels) {
                originX = Math.round(originX);
                originY = Math.round(originY);
              }
              this.scrollX = sx;
              this.scrollY = sy;
              var midX = sx + halfWidth;
              var midY = sy + halfHeight;
              this.midPoint.set(midX, midY);
              var displayWidth = width / zoomX;
              var displayHeight = height / zoomY;
              this.worldView.setTo(midX - displayWidth / 2, midY - displayHeight / 2, displayWidth, displayHeight);
              matrix.applyITRS(this.x + originX, this.y + originY, this.rotation, zoomX, zoomY);
              matrix.translate(-originX, -originY);
            },
            clampX: function (x) {
              var bounds = this._bounds;
              var dw = this.displayWidth;
              var bx = bounds.x + (dw - this.width) / 2;
              var bw = Math.max(bx, bx + bounds.width - dw);
              if (x < bx) {
                x = bx;
              } else if (x > bw) {
                x = bw;
              }
              return x;
            },
            clampY: function (y) {
              var bounds = this._bounds;
              var dh = this.displayHeight;
              var by = bounds.y + (dh - this.height) / 2;
              var bh = Math.max(by, by + bounds.height - dh);
              if (y < by) {
                y = by;
              } else if (y > bh) {
                y = bh;
              }
              return y;
            },
            removeBounds: function () {
              this.useBounds = false;
              this.dirty = true;
              this._bounds.setEmpty();
              return this;
            },
            setAngle: function (value) {
              if (value === void 0) {
                value = 0;
              }
              this.rotation = DegToRad(value);
              return this;
            },
            setBackgroundColor: function (color) {
              if (color === void 0) {
                color = "rgba(0,0,0,0)";
              }
              this.backgroundColor = ValueToColor(color);
              this.transparent = this.backgroundColor.alpha === 0;
              return this;
            },
            setBounds: function (x, y, width, height, centerOn) {
              if (centerOn === void 0) {
                centerOn = false;
              }
              this._bounds.setTo(x, y, width, height);
              this.dirty = true;
              this.useBounds = true;
              if (centerOn) {
                this.centerToBounds();
              } else {
                this.scrollX = this.clampX(this.scrollX);
                this.scrollY = this.clampY(this.scrollY);
              }
              return this;
            },
            getBounds: function (out) {
              if (out === void 0) {
                out = new Rectangle();
              }
              var source = this._bounds;
              out.setTo(source.x, source.y, source.width, source.height);
              return out;
            },
            setName: function (value) {
              if (value === void 0) {
                value = "";
              }
              this.name = value;
              return this;
            },
            setPosition: function (x, y) {
              if (y === void 0) {
                y = x;
              }
              this.x = x;
              this.y = y;
              return this;
            },
            setRotation: function (value) {
              if (value === void 0) {
                value = 0;
              }
              this.rotation = value;
              return this;
            },
            setRoundPixels: function (value) {
              this.roundPixels = value;
              return this;
            },
            setScene: function (scene) {
              if (this.scene && this._customViewport) {
                this.sceneManager.customViewports--;
              }
              this.scene = scene;
              var sys = scene.sys;
              this.sceneManager = sys.game.scene;
              this.scaleManager = sys.scale;
              this.cameraManager = sys.cameras;
              this.updateSystem();
              return this;
            },
            setScroll: function (x, y) {
              if (y === void 0) {
                y = x;
              }
              this.scrollX = x;
              this.scrollY = y;
              return this;
            },
            setSize: function (width, height) {
              if (height === void 0) {
                height = width;
              }
              this.width = width;
              this.height = height;
              return this;
            },
            setViewport: function (x, y, width, height) {
              this.x = x;
              this.y = y;
              this.width = width;
              this.height = height;
              return this;
            },
            setZoom: function (x, y) {
              if (x === void 0) {
                x = 1;
              }
              if (y === void 0) {
                y = x;
              }
              if (x === 0) {
                x = 1e-3;
              }
              if (y === 0) {
                y = 1e-3;
              }
              this.zoomX = x;
              this.zoomY = y;
              return this;
            },
            setMask: function (mask, fixedPosition) {
              if (fixedPosition === void 0) {
                fixedPosition = true;
              }
              this.mask = mask;
              this._maskCamera = fixedPosition ? this.cameraManager.default : this;
              return this;
            },
            clearMask: function (destroyMask) {
              if (destroyMask === void 0) {
                destroyMask = false;
              }
              if (destroyMask && this.mask) {
                this.mask.destroy();
              }
              this.mask = null;
              return this;
            },
            toJSON: function () {
              var output = {
                name: this.name,
                x: this.x,
                y: this.y,
                width: this.width,
                height: this.height,
                zoom: this.zoom,
                rotation: this.rotation,
                roundPixels: this.roundPixels,
                scrollX: this.scrollX,
                scrollY: this.scrollY,
                backgroundColor: this.backgroundColor.rgba
              };
              if (this.useBounds) {
                output["bounds"] = {
                  x: this._bounds.x,
                  y: this._bounds.y,
                  width: this._bounds.width,
                  height: this._bounds.height
                };
              }
              return output;
            },
            update: function () {},
            updateSystem: function () {
              if (!this.scaleManager) {
                return;
              }
              var custom = this._x !== 0 || this._y !== 0 || this.scaleManager.width !== this._width || this.scaleManager.height !== this._height;
              var sceneManager = this.sceneManager;
              if (custom && !this._customViewport) {
                sceneManager.customViewports++;
              } else if (!custom && this._customViewport) {
                sceneManager.customViewports--;
              }
              this.dirty = true;
              this._customViewport = custom;
            },
            destroy: function () {
              this.emit(Events.DESTROY, this);
              this.removeAllListeners();
              this.matrix.destroy();
              this.culledObjects = [];
              if (this._customViewport) {
                this.sceneManager.customViewports--;
              }
              this.renderList = [];
              this._bounds = null;
              this.scene = null;
              this.scaleManager = null;
              this.sceneManager = null;
              this.cameraManager = null;
            },
            x: {
              get: function () {
                return this._x;
              },
              set: function (value) {
                this._x = value;
                this.updateSystem();
              }
            },
            y: {
              get: function () {
                return this._y;
              },
              set: function (value) {
                this._y = value;
                this.updateSystem();
              }
            },
            width: {
              get: function () {
                return this._width;
              },
              set: function (value) {
                this._width = value;
                this.updateSystem();
              }
            },
            height: {
              get: function () {
                return this._height;
              },
              set: function (value) {
                this._height = value;
                this.updateSystem();
              }
            },
            scrollX: {
              get: function () {
                return this._scrollX;
              },
              set: function (value) {
                this._scrollX = value;
                this.dirty = true;
              }
            },
            scrollY: {
              get: function () {
                return this._scrollY;
              },
              set: function (value) {
                this._scrollY = value;
                this.dirty = true;
              }
            },
            zoom: {
              get: function () {
                return (this._zoomX + this._zoomY) / 2;
              },
              set: function (value) {
                this._zoomX = value;
                this._zoomY = value;
                this.dirty = true;
              }
            },
            zoomX: {
              get: function () {
                return this._zoomX;
              },
              set: function (value) {
                this._zoomX = value;
                this.dirty = true;
              }
            },
            zoomY: {
              get: function () {
                return this._zoomY;
              },
              set: function (value) {
                this._zoomY = value;
                this.dirty = true;
              }
            },
            rotation: {
              get: function () {
                return this._rotation;
              },
              set: function (value) {
                this._rotation = value;
                this.dirty = true;
              }
            },
            centerX: {
              get: function () {
                return this.x + 0.5 * this.width;
              }
            },
            centerY: {
              get: function () {
                return this.y + 0.5 * this.height;
              }
            },
            displayWidth: {
              get: function () {
                return this.width / this.zoomX;
              }
            },
            displayHeight: {
              get: function () {
                return this.height / this.zoomY;
              }
            }
          });
          module2.exports = BaseCamera;
        }, function (module2, exports2, __webpack_require__) {
          var Back = __webpack_require__(334);
          var Bounce = __webpack_require__(335);
          var Circular = __webpack_require__(336);
          var Cubic = __webpack_require__(337);
          var Elastic = __webpack_require__(338);
          var Expo = __webpack_require__(339);
          var Linear = __webpack_require__(340);
          var Quadratic = __webpack_require__(341);
          var Quartic = __webpack_require__(342);
          var Quintic = __webpack_require__(343);
          var Sine = __webpack_require__(344);
          var Stepped = __webpack_require__(345);
          module2.exports = {
            Power0: Linear,
            Power1: Quadratic.Out,
            Power2: Cubic.Out,
            Power3: Quartic.Out,
            Power4: Quintic.Out,
            Linear,
            Quad: Quadratic.Out,
            Cubic: Cubic.Out,
            Quart: Quartic.Out,
            Quint: Quintic.Out,
            Sine: Sine.Out,
            Expo: Expo.Out,
            Circ: Circular.Out,
            Elastic: Elastic.Out,
            Back: Back.Out,
            Bounce: Bounce.Out,
            Stepped,
            "Quad.easeIn": Quadratic.In,
            "Cubic.easeIn": Cubic.In,
            "Quart.easeIn": Quartic.In,
            "Quint.easeIn": Quintic.In,
            "Sine.easeIn": Sine.In,
            "Expo.easeIn": Expo.In,
            "Circ.easeIn": Circular.In,
            "Elastic.easeIn": Elastic.In,
            "Back.easeIn": Back.In,
            "Bounce.easeIn": Bounce.In,
            "Quad.easeOut": Quadratic.Out,
            "Cubic.easeOut": Cubic.Out,
            "Quart.easeOut": Quartic.Out,
            "Quint.easeOut": Quintic.Out,
            "Sine.easeOut": Sine.Out,
            "Expo.easeOut": Expo.Out,
            "Circ.easeOut": Circular.Out,
            "Elastic.easeOut": Elastic.Out,
            "Back.easeOut": Back.Out,
            "Bounce.easeOut": Bounce.Out,
            "Quad.easeInOut": Quadratic.InOut,
            "Cubic.easeInOut": Cubic.InOut,
            "Quart.easeInOut": Quartic.InOut,
            "Quint.easeInOut": Quintic.InOut,
            "Sine.easeInOut": Sine.InOut,
            "Expo.easeInOut": Expo.InOut,
            "Circ.easeInOut": Circular.InOut,
            "Elastic.easeInOut": Elastic.InOut,
            "Back.easeInOut": Back.InOut,
            "Bounce.easeInOut": Bounce.InOut
          };
        }, function (module2, exports2) {
          var Linear = function (p0, p1, t) {
            return (p1 - p0) * t + p0;
          };
          module2.exports = Linear;
        }, function (module2, exports2, __webpack_require__) {
          var OS = __webpack_require__(105);
          var Browser = {
            chrome: false,
            chromeVersion: 0,
            edge: false,
            firefox: false,
            firefoxVersion: 0,
            ie: false,
            ieVersion: 0,
            mobileSafari: false,
            opera: false,
            safari: false,
            safariVersion: 0,
            silk: false,
            trident: false,
            tridentVersion: 0
          };
          function init() {
            var ua = navigator.userAgent;
            if ((/Edge\/\d+/).test(ua)) {
              Browser.edge = true;
            } else if ((/Chrome\/(\d+)/).test(ua) && !OS.windowsPhone) {
              Browser.chrome = true;
              Browser.chromeVersion = parseInt(RegExp.$1, 10);
            } else if ((/Firefox\D+(\d+)/).test(ua)) {
              Browser.firefox = true;
              Browser.firefoxVersion = parseInt(RegExp.$1, 10);
            } else if ((/AppleWebKit/).test(ua) && OS.iOS) {
              Browser.mobileSafari = true;
            } else if ((/MSIE (\d+\.\d+);/).test(ua)) {
              Browser.ie = true;
              Browser.ieVersion = parseInt(RegExp.$1, 10);
            } else if ((/Opera/).test(ua)) {
              Browser.opera = true;
            } else if ((/Safari/).test(ua) && !OS.windowsPhone) {
              Browser.safari = true;
            } else if ((/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/).test(ua)) {
              Browser.ie = true;
              Browser.trident = true;
              Browser.tridentVersion = parseInt(RegExp.$1, 10);
              Browser.ieVersion = parseInt(RegExp.$3, 10);
            }
            if ((/Silk/).test(ua)) {
              Browser.silk = true;
            }
            return Browser;
          }
          module2.exports = init();
        }, function (module2, exports2) {
          var FloatBetween = function (min, max) {
            return Math.random() * (max - min) + min;
          };
          module2.exports = FloatBetween;
        }, function (module2, exports2) {
          var IsSizePowerOfTwo = function (width, height) {
            return width > 0 && (width & width - 1) === 0 && height > 0 && (height & height - 1) === 0;
          };
          module2.exports = IsSizePowerOfTwo;
        }, function (module2, exports2) {
          var SnapCeil = function (value, gap, start, divide) {
            if (start === void 0) {
              start = 0;
            }
            if (gap === 0) {
              return value;
            }
            value -= start;
            value = gap * Math.ceil(value / gap);
            return divide ? (start + value) / gap : start + value;
          };
          module2.exports = SnapCeil;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Vector4 = new Class({
            initialize: function Vector42(x, y, z, w) {
              this.x = 0;
              this.y = 0;
              this.z = 0;
              this.w = 0;
              if (typeof x === "object") {
                this.x = x.x || 0;
                this.y = x.y || 0;
                this.z = x.z || 0;
                this.w = x.w || 0;
              } else {
                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;
                this.w = w || 0;
              }
            },
            clone: function () {
              return new Vector4(this.x, this.y, this.z, this.w);
            },
            copy: function (src) {
              this.x = src.x;
              this.y = src.y;
              this.z = src.z || 0;
              this.w = src.w || 0;
              return this;
            },
            equals: function (v) {
              return this.x === v.x && this.y === v.y && this.z === v.z && this.w === v.w;
            },
            set: function (x, y, z, w) {
              if (typeof x === "object") {
                this.x = x.x || 0;
                this.y = x.y || 0;
                this.z = x.z || 0;
                this.w = x.w || 0;
              } else {
                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;
                this.w = w || 0;
              }
              return this;
            },
            add: function (v) {
              this.x += v.x;
              this.y += v.y;
              this.z += v.z || 0;
              this.w += v.w || 0;
              return this;
            },
            subtract: function (v) {
              this.x -= v.x;
              this.y -= v.y;
              this.z -= v.z || 0;
              this.w -= v.w || 0;
              return this;
            },
            scale: function (scale) {
              this.x *= scale;
              this.y *= scale;
              this.z *= scale;
              this.w *= scale;
              return this;
            },
            length: function () {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var w = this.w;
              return Math.sqrt(x * x + y * y + z * z + w * w);
            },
            lengthSq: function () {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var w = this.w;
              return x * x + y * y + z * z + w * w;
            },
            normalize: function () {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var w = this.w;
              var len = x * x + y * y + z * z + w * w;
              if (len > 0) {
                len = 1 / Math.sqrt(len);
                this.x = x * len;
                this.y = y * len;
                this.z = z * len;
                this.w = w * len;
              }
              return this;
            },
            dot: function (v) {
              return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
            },
            lerp: function (v, t) {
              if (t === void 0) {
                t = 0;
              }
              var ax = this.x;
              var ay = this.y;
              var az = this.z;
              var aw = this.w;
              this.x = ax + t * (v.x - ax);
              this.y = ay + t * (v.y - ay);
              this.z = az + t * (v.z - az);
              this.w = aw + t * (v.w - aw);
              return this;
            },
            multiply: function (v) {
              this.x *= v.x;
              this.y *= v.y;
              this.z *= v.z || 1;
              this.w *= v.w || 1;
              return this;
            },
            divide: function (v) {
              this.x /= v.x;
              this.y /= v.y;
              this.z /= v.z || 1;
              this.w /= v.w || 1;
              return this;
            },
            distance: function (v) {
              var dx = v.x - this.x;
              var dy = v.y - this.y;
              var dz = v.z - this.z || 0;
              var dw = v.w - this.w || 0;
              return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
            },
            distanceSq: function (v) {
              var dx = v.x - this.x;
              var dy = v.y - this.y;
              var dz = v.z - this.z || 0;
              var dw = v.w - this.w || 0;
              return dx * dx + dy * dy + dz * dz + dw * dw;
            },
            negate: function () {
              this.x = -this.x;
              this.y = -this.y;
              this.z = -this.z;
              this.w = -this.w;
              return this;
            },
            transformMat4: function (mat) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var w = this.w;
              var m = mat.val;
              this.x = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
              this.y = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
              this.z = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
              this.w = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
              return this;
            },
            transformQuat: function (q) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var qx = q.x;
              var qy = q.y;
              var qz = q.z;
              var qw = q.w;
              var ix = qw * x + qy * z - qz * y;
              var iy = qw * y + qz * x - qx * z;
              var iz = qw * z + qx * y - qy * x;
              var iw = -qx * x - qy * y - qz * z;
              this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
              this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
              this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
              return this;
            },
            reset: function () {
              this.x = 0;
              this.y = 0;
              this.z = 0;
              this.w = 0;
              return this;
            }
          });
          Vector4.prototype.sub = Vector4.prototype.subtract;
          Vector4.prototype.mul = Vector4.prototype.multiply;
          Vector4.prototype.div = Vector4.prototype.divide;
          Vector4.prototype.dist = Vector4.prototype.distance;
          Vector4.prototype.distSq = Vector4.prototype.distanceSq;
          Vector4.prototype.len = Vector4.prototype.length;
          Vector4.prototype.lenSq = Vector4.prototype.lengthSq;
          module2.exports = Vector4;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(91);
          var RenderTarget = new Class({
            initialize: function RenderTarget2(renderer, width, height, scale, minFilter, autoClear, autoResize) {
              if (scale === void 0) {
                scale = 1;
              }
              if (minFilter === void 0) {
                minFilter = 0;
              }
              if (autoClear === void 0) {
                autoClear = true;
              }
              if (autoResize === void 0) {
                autoResize = false;
              }
              this.renderer = renderer;
              this.framebuffer = null;
              this.texture = null;
              this.width = 0;
              this.height = 0;
              this.scale = scale;
              this.minFilter = minFilter;
              this.autoClear = autoClear;
              this.autoResize = false;
              this.resize(width, height);
              if (autoResize) {
                this.setAutoResize(true);
              }
            },
            setAutoResize: function (autoResize) {
              if (autoResize && !this.autoResize) {
                this.renderer.on(Events.RESIZE, this.resize, this);
                this.autoResize = true;
              } else if (!autoResize && this.autoResize) {
                this.renderer.off(Events.RESIZE, this.resize, this);
                this.autoResize = false;
              }
              return this;
            },
            resize: function (width, height) {
              var scaledWidth = width * this.scale;
              var scaledHeight = height * this.scale;
              if (scaledWidth !== this.width || scaledHeight !== this.height) {
                var renderer = this.renderer;
                renderer.deleteFramebuffer(this.framebuffer);
                renderer.deleteTexture(this.texture);
                width *= this.scale;
                height *= this.scale;
                width = Math.round(width);
                height = Math.round(height);
                if (width <= 0) {
                  width = 1;
                }
                if (height <= 0) {
                  height = 1;
                }
                this.texture = renderer.createTextureFromSource(null, width, height, this.minFilter);
                this.framebuffer = renderer.createFramebuffer(width, height, this.texture, false);
                this.width = width;
                this.height = height;
              }
              return this;
            },
            bind: function (adjustViewport, width, height) {
              if (adjustViewport === void 0) {
                adjustViewport = false;
              }
              if (adjustViewport) {
                this.renderer.flush();
              }
              if (width && height) {
                this.resize(width, height);
              }
              this.renderer.pushFramebuffer(this.framebuffer, false, false, false);
              if (adjustViewport) {
                this.adjustViewport();
              }
              if (this.autoClear) {
                var gl = this.renderer.gl;
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
              }
            },
            adjustViewport: function () {
              var gl = this.renderer.gl;
              gl.viewport(0, 0, this.width, this.height);
              gl.disable(gl.SCISSOR_TEST);
            },
            clear: function () {
              var renderer = this.renderer;
              var gl = renderer.gl;
              renderer.pushFramebuffer(this.framebuffer);
              gl.disable(gl.SCISSOR_TEST);
              gl.clearColor(0, 0, 0, 0);
              gl.clear(gl.COLOR_BUFFER_BIT);
              renderer.popFramebuffer();
              renderer.resetScissor();
            },
            unbind: function (flush) {
              if (flush === void 0) {
                flush = false;
              }
              var renderer = this.renderer;
              if (flush) {
                renderer.flush();
              }
              return renderer.popFramebuffer();
            },
            destroy: function () {
              var renderer = this.renderer;
              renderer.deleteFramebuffer(this.framebuffer);
              renderer.deleteTexture(this.texture);
              renderer.off(Events.RESIZE, this.resize, this);
              this.renderer = null;
              this.framebuffer = null;
              this.texture = null;
            }
          });
          module2.exports = RenderTarget;
        }, function (module2, exports2) {
          var AddToDOM = function (element, parent) {
            var target;
            if (parent) {
              if (typeof parent === "string") {
                target = document.getElementById(parent);
              } else if (typeof parent === "object" && parent.nodeType === 1) {
                target = parent;
              }
            } else if (element.parentElement || parent === null) {
              return element;
            }
            if (!target) {
              target = document.body;
            }
            target.appendChild(element);
            return element;
          };
          module2.exports = AddToDOM;
        }, function (module2, exports2) {
          var KeyCodes = {
            BACKSPACE: 8,
            TAB: 9,
            ENTER: 13,
            SHIFT: 16,
            CTRL: 17,
            ALT: 18,
            PAUSE: 19,
            CAPS_LOCK: 20,
            ESC: 27,
            SPACE: 32,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            END: 35,
            HOME: 36,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            PRINT_SCREEN: 42,
            INSERT: 45,
            DELETE: 46,
            ZERO: 48,
            ONE: 49,
            TWO: 50,
            THREE: 51,
            FOUR: 52,
            FIVE: 53,
            SIX: 54,
            SEVEN: 55,
            EIGHT: 56,
            NINE: 57,
            NUMPAD_ZERO: 96,
            NUMPAD_ONE: 97,
            NUMPAD_TWO: 98,
            NUMPAD_THREE: 99,
            NUMPAD_FOUR: 100,
            NUMPAD_FIVE: 101,
            NUMPAD_SIX: 102,
            NUMPAD_SEVEN: 103,
            NUMPAD_EIGHT: 104,
            NUMPAD_NINE: 105,
            NUMPAD_ADD: 107,
            NUMPAD_SUBTRACT: 109,
            A: 65,
            B: 66,
            C: 67,
            D: 68,
            E: 69,
            F: 70,
            G: 71,
            H: 72,
            I: 73,
            J: 74,
            K: 75,
            L: 76,
            M: 77,
            N: 78,
            O: 79,
            P: 80,
            Q: 81,
            R: 82,
            S: 83,
            T: 84,
            U: 85,
            V: 86,
            W: 87,
            X: 88,
            Y: 89,
            Z: 90,
            F1: 112,
            F2: 113,
            F3: 114,
            F4: 115,
            F5: 116,
            F6: 117,
            F7: 118,
            F8: 119,
            F9: 120,
            F10: 121,
            F11: 122,
            F12: 123,
            SEMICOLON: 186,
            PLUS: 187,
            COMMA: 188,
            MINUS: 189,
            PERIOD: 190,
            FORWARD_SLASH: 191,
            BACK_SLASH: 220,
            QUOTES: 222,
            BACKTICK: 192,
            OPEN_BRACKET: 219,
            CLOSED_BRACKET: 221,
            SEMICOLON_FIREFOX: 59,
            COLON: 58,
            COMMA_FIREFOX_WINDOWS: 60,
            COMMA_FIREFOX: 62,
            BRACKET_RIGHT_FIREFOX: 174,
            BRACKET_LEFT_FIREFOX: 175
          };
          module2.exports = KeyCodes;
        }, function (module2, exports2) {
          var CONST = {
            PENDING: 0,
            INIT: 1,
            START: 2,
            LOADING: 3,
            CREATING: 4,
            RUNNING: 5,
            PAUSED: 6,
            SLEEPING: 7,
            SHUTDOWN: 8,
            DESTROYED: 9
          };
          module2.exports = CONST;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Clone = __webpack_require__(77);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(70);
          var GameEvents = __webpack_require__(22);
          var NOOP = __webpack_require__(1);
          var GetAll = __webpack_require__(207);
          var GetFirst = __webpack_require__(428);
          var BaseSoundManager = new Class({
            Extends: EventEmitter,
            initialize: function BaseSoundManager2(game) {
              EventEmitter.call(this);
              this.game = game;
              this.jsonCache = game.cache.json;
              this.sounds = [];
              this.mute = false;
              this.volume = 1;
              this.pauseOnBlur = true;
              this._rate = 1;
              this._detune = 0;
              this.locked = this.locked || false;
              this.unlocked = false;
              game.events.on(GameEvents.BLUR, this.onGameBlur, this);
              game.events.on(GameEvents.FOCUS, this.onGameFocus, this);
              game.events.on(GameEvents.PRE_STEP, this.update, this);
              game.events.once(GameEvents.DESTROY, this.destroy, this);
            },
            add: NOOP,
            addAudioSprite: function (key, config) {
              if (config === void 0) {
                config = {};
              }
              var sound = this.add(key, config);
              sound.spritemap = this.jsonCache.get(key).spritemap;
              for (var markerName in sound.spritemap) {
                if (!sound.spritemap.hasOwnProperty(markerName)) {
                  continue;
                }
                var markerConfig = Clone(config);
                var marker = sound.spritemap[markerName];
                markerConfig.loop = marker.hasOwnProperty("loop") ? marker.loop : false;
                sound.addMarker({
                  name: markerName,
                  start: marker.start,
                  duration: marker.end - marker.start,
                  config: markerConfig
                });
              }
              return sound;
            },
            get: function (key) {
              return GetFirst(this.sounds, "key", key);
            },
            getAll: function (key) {
              return GetAll(this.sounds, "key", key);
            },
            play: function (key, extra) {
              var sound = this.add(key);
              sound.once(Events.COMPLETE, sound.destroy, sound);
              if (extra) {
                if (extra.name) {
                  sound.addMarker(extra);
                  return sound.play(extra.name);
                } else {
                  return sound.play(extra);
                }
              } else {
                return sound.play();
              }
            },
            playAudioSprite: function (key, spriteName, config) {
              var sound = this.addAudioSprite(key);
              sound.once(Events.COMPLETE, sound.destroy, sound);
              return sound.play(spriteName, config);
            },
            remove: function (sound) {
              var index = this.sounds.indexOf(sound);
              if (index !== -1) {
                sound.destroy();
                this.sounds.splice(index, 1);
                return true;
              }
              return false;
            },
            removeAll: function () {
              this.sounds.forEach(function (sound) {
                sound.destroy();
              });
              this.sounds.length = 0;
            },
            removeByKey: function (key) {
              var removed = 0;
              for (var i = this.sounds.length - 1; i >= 0; i--) {
                var sound = this.sounds[i];
                if (sound.key === key) {
                  sound.destroy();
                  this.sounds.splice(i, 1);
                  removed++;
                }
              }
              return removed;
            },
            pauseAll: function () {
              this.forEachActiveSound(function (sound) {
                sound.pause();
              });
              this.emit(Events.PAUSE_ALL, this);
            },
            resumeAll: function () {
              this.forEachActiveSound(function (sound) {
                sound.resume();
              });
              this.emit(Events.RESUME_ALL, this);
            },
            stopAll: function () {
              this.forEachActiveSound(function (sound) {
                sound.stop();
              });
              this.emit(Events.STOP_ALL, this);
            },
            stopByKey: function (key) {
              var stopped = 0;
              this.getAll(key).forEach(function (sound) {
                if (sound.stop()) {
                  stopped++;
                }
              });
              return stopped;
            },
            unlock: NOOP,
            onBlur: NOOP,
            onFocus: NOOP,
            onGameBlur: function () {
              if (this.pauseOnBlur) {
                this.onBlur();
              }
            },
            onGameFocus: function () {
              if (this.pauseOnBlur) {
                this.onFocus();
              }
            },
            update: function (time, delta) {
              if (this.unlocked) {
                this.unlocked = false;
                this.locked = false;
                this.emit(Events.UNLOCKED, this);
              }
              for (var i = this.sounds.length - 1; i >= 0; i--) {
                if (this.sounds[i].pendingRemove) {
                  this.sounds.splice(i, 1);
                }
              }
              this.sounds.forEach(function (sound) {
                sound.update(time, delta);
              });
            },
            destroy: function () {
              this.game.events.off(GameEvents.BLUR, this.onGameBlur, this);
              this.game.events.off(GameEvents.FOCUS, this.onGameFocus, this);
              this.game.events.off(GameEvents.PRE_STEP, this.update, this);
              this.removeAllListeners();
              this.removeAll();
              this.sounds.length = 0;
              this.sounds = null;
              this.game = null;
            },
            forEachActiveSound: function (callback, scope) {
              var _this = this;
              this.sounds.forEach(function (sound, index) {
                if (sound && !sound.pendingRemove) {
                  callback.call(scope || _this, sound, index, _this.sounds);
                }
              });
            },
            setRate: function (value) {
              this.rate = value;
              return this;
            },
            rate: {
              get: function () {
                return this._rate;
              },
              set: function (value) {
                this._rate = value;
                this.forEachActiveSound(function (sound) {
                  sound.calculateRate();
                });
                this.emit(Events.GLOBAL_RATE, this, value);
              }
            },
            setDetune: function (value) {
              this.detune = value;
              return this;
            },
            detune: {
              get: function () {
                return this._detune;
              },
              set: function (value) {
                this._detune = value;
                this.forEachActiveSound(function (sound) {
                  sound.calculateRate();
                });
                this.emit(Events.GLOBAL_DETUNE, this, value);
              }
            }
          });
          module2.exports = BaseSoundManager;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(70);
          var Extend = __webpack_require__(17);
          var NOOP = __webpack_require__(1);
          var BaseSound = new Class({
            Extends: EventEmitter,
            initialize: function BaseSound2(manager, key, config) {
              EventEmitter.call(this);
              this.manager = manager;
              this.key = key;
              this.isPlaying = false;
              this.isPaused = false;
              this.totalRate = 1;
              this.duration = this.duration || 0;
              this.totalDuration = this.totalDuration || 0;
              this.config = {
                mute: false,
                volume: 1,
                rate: 1,
                detune: 0,
                seek: 0,
                loop: false,
                delay: 0,
                pan: 0
              };
              this.currentConfig = this.config;
              this.config = Extend(this.config, config);
              this.markers = {};
              this.currentMarker = null;
              this.pendingRemove = false;
            },
            addMarker: function (marker) {
              if (!marker || !marker.name || typeof marker.name !== "string") {
                return false;
              }
              if (this.markers[marker.name]) {
                console.error("addMarker " + marker.name + " already exists in Sound");
                return false;
              }
              marker = Extend(true, {
                name: "",
                start: 0,
                duration: this.totalDuration - (marker.start || 0),
                config: {
                  mute: false,
                  volume: 1,
                  rate: 1,
                  detune: 0,
                  seek: 0,
                  loop: false,
                  delay: 0,
                  pan: 0
                }
              }, marker);
              this.markers[marker.name] = marker;
              return true;
            },
            updateMarker: function (marker) {
              if (!marker || !marker.name || typeof marker.name !== "string") {
                return false;
              }
              if (!this.markers[marker.name]) {
                console.warn("Audio Marker: " + marker.name + " missing in Sound: " + this.key);
                return false;
              }
              this.markers[marker.name] = Extend(true, this.markers[marker.name], marker);
              return true;
            },
            removeMarker: function (markerName) {
              var marker = this.markers[markerName];
              if (!marker) {
                return null;
              }
              this.markers[markerName] = null;
              return marker;
            },
            play: function (markerName, config) {
              if (markerName === void 0) {
                markerName = "";
              }
              if (typeof markerName === "object") {
                config = markerName;
                markerName = "";
              }
              if (typeof markerName !== "string") {
                return false;
              }
              if (!markerName) {
                this.currentMarker = null;
                this.currentConfig = this.config;
                this.duration = this.totalDuration;
              } else {
                if (!this.markers[markerName]) {
                  console.warn("Marker: " + markerName + " missing in Sound: " + this.key);
                  return false;
                }
                this.currentMarker = this.markers[markerName];
                this.currentConfig = this.currentMarker.config;
                this.duration = this.currentMarker.duration;
              }
              this.resetConfig();
              this.currentConfig = Extend(this.currentConfig, config);
              this.isPlaying = true;
              this.isPaused = false;
              return true;
            },
            pause: function () {
              if (this.isPaused || !this.isPlaying) {
                return false;
              }
              this.isPlaying = false;
              this.isPaused = true;
              return true;
            },
            resume: function () {
              if (!this.isPaused || this.isPlaying) {
                return false;
              }
              this.isPlaying = true;
              this.isPaused = false;
              return true;
            },
            stop: function () {
              if (!this.isPaused && !this.isPlaying) {
                return false;
              }
              this.isPlaying = false;
              this.isPaused = false;
              this.resetConfig();
              return true;
            },
            applyConfig: function () {
              this.mute = this.currentConfig.mute;
              this.volume = this.currentConfig.volume;
              this.rate = this.currentConfig.rate;
              this.detune = this.currentConfig.detune;
              this.loop = this.currentConfig.loop;
              this.pan = this.currentConfig.pan;
            },
            resetConfig: function () {
              this.currentConfig.seek = 0;
              this.currentConfig.delay = 0;
            },
            update: NOOP,
            calculateRate: function () {
              var cent = 1.0005777895065548;
              var totalDetune = this.currentConfig.detune + this.manager.detune;
              var detuneRate = Math.pow(cent, totalDetune);
              this.totalRate = this.currentConfig.rate * this.manager.rate * detuneRate;
            },
            destroy: function () {
              if (this.pendingRemove) {
                return;
              }
              this.emit(Events.DESTROY, this);
              this.pendingRemove = true;
              this.manager = null;
              this.key = "";
              this.removeAllListeners();
              this.isPlaying = false;
              this.isPaused = false;
              this.config = null;
              this.currentConfig = null;
              this.markers = null;
              this.currentMarker = null;
            }
          });
          module2.exports = BaseSound;
        }, function (module2, exports2, __webpack_require__) {
          var CheckMatrix = __webpack_require__(209);
          var TransposeMatrix = __webpack_require__(435);
          var RotateMatrix = function (matrix, direction) {
            if (direction === void 0) {
              direction = 90;
            }
            if (!CheckMatrix(matrix)) {
              return null;
            }
            if (typeof direction !== "string") {
              direction = (direction % 360 + 360) % 360;
            }
            if (direction === 90 || direction === -270 || direction === "rotateLeft") {
              matrix = TransposeMatrix(matrix);
              matrix.reverse();
            } else if (direction === -90 || direction === 270 || direction === "rotateRight") {
              matrix.reverse();
              matrix = TransposeMatrix(matrix);
            } else if (Math.abs(direction) === 180 || direction === "rotate180") {
              for (var i = 0; i < matrix.length; i++) {
                matrix[i].reverse();
              }
              matrix.reverse();
            }
            return matrix;
          };
          module2.exports = RotateMatrix;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Clamp = __webpack_require__(18);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var GetBitmapTextSize = __webpack_require__(1043);
          var ParseFromAtlas = __webpack_require__(1044);
          var ParseXMLBitmapFont = __webpack_require__(212);
          var Rectangle = __webpack_require__(10);
          var Render = __webpack_require__(1045);
          var BitmapText = new Class({
            Extends: GameObject,
            Mixins: [Components.Alpha, Components.BlendMode, Components.Depth, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Texture, Components.Tint, Components.Transform, Components.Visible, Render],
            initialize: function BitmapText2(scene, x, y, font, text, size, align) {
              if (text === void 0) {
                text = "";
              }
              if (align === void 0) {
                align = 0;
              }
              GameObject.call(this, scene, "BitmapText");
              this.font = font;
              var entry = this.scene.sys.cache.bitmapFont.get(font);
              if (!entry) {
                console.warn("Invalid BitmapText key: " + font);
              }
              this.fontData = entry.data;
              this._text = "";
              this._fontSize = size || this.fontData.size;
              this._letterSpacing = 0;
              this._align = align;
              this._bounds = GetBitmapTextSize();
              this._dirty = true;
              this._maxWidth = 0;
              this.wordWrapCharCode = 32;
              this.charColors = [];
              this.dropShadowX = 0;
              this.dropShadowY = 0;
              this.dropShadowColor = 0;
              this.dropShadowAlpha = 0.5;
              this.fromAtlas = entry.fromAtlas;
              this.setTexture(entry.texture, entry.frame);
              this.setPosition(x, y);
              this.setOrigin(0, 0);
              this.initPipeline();
              this.setText(text);
            },
            setLeftAlign: function () {
              this._align = BitmapText.ALIGN_LEFT;
              this._dirty = true;
              return this;
            },
            setCenterAlign: function () {
              this._align = BitmapText.ALIGN_CENTER;
              this._dirty = true;
              return this;
            },
            setRightAlign: function () {
              this._align = BitmapText.ALIGN_RIGHT;
              this._dirty = true;
              return this;
            },
            setFontSize: function (size) {
              this._fontSize = size;
              this._dirty = true;
              return this;
            },
            setLetterSpacing: function (spacing) {
              if (spacing === void 0) {
                spacing = 0;
              }
              this._letterSpacing = spacing;
              this._dirty = true;
              return this;
            },
            setText: function (value) {
              if (!value && value !== 0) {
                value = "";
              }
              if (Array.isArray(value)) {
                value = value.join("\n");
              }
              if (value !== this.text) {
                this._text = value.toString();
                this._dirty = true;
                this.updateDisplayOrigin();
              }
              return this;
            },
            setDropShadow: function (x, y, color, alpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (color === void 0) {
                color = 0;
              }
              if (alpha === void 0) {
                alpha = 0.5;
              }
              this.dropShadowX = x;
              this.dropShadowY = y;
              this.dropShadowColor = color;
              this.dropShadowAlpha = alpha;
              return this;
            },
            setCharacterTint: function (start, length, tintFill, topLeft, topRight, bottomLeft, bottomRight) {
              if (start === void 0) {
                start = 0;
              }
              if (length === void 0) {
                length = 1;
              }
              if (tintFill === void 0) {
                tintFill = false;
              }
              if (topLeft === void 0) {
                topLeft = -1;
              }
              if (topRight === void 0) {
                topRight = topLeft;
                bottomLeft = topLeft;
                bottomRight = topLeft;
              }
              var len = this.text.length;
              if (length === -1) {
                length = len;
              }
              if (start < 0) {
                start = len + start;
              }
              start = Clamp(start, 0, len - 1);
              var end = Clamp(start + length, start, len);
              var charColors = this.charColors;
              for (var i = start; i < end; i++) {
                var color = charColors[i];
                if (topLeft === -1) {
                  charColors[i] = null;
                } else {
                  var tintEffect = tintFill ? 1 : 0;
                  if (color) {
                    color.tintEffect = tintEffect;
                    color.tintTL = topLeft;
                    color.tintTR = topRight;
                    color.tintBL = bottomLeft;
                    color.tintBR = bottomRight;
                  } else {
                    charColors[i] = {
                      tintEffect,
                      tintTL: topLeft,
                      tintTR: topRight,
                      tintBL: bottomLeft,
                      tintBR: bottomRight
                    };
                  }
                }
              }
              return this;
            },
            setWordTint: function (word, count, tintFill, topLeft, topRight, bottomLeft, bottomRight) {
              if (count === void 0) {
                count = 1;
              }
              var bounds = this.getTextBounds();
              var words = bounds.words;
              var wordIsNumber = typeof word === "number";
              var total = 0;
              for (var i = 0; i < words.length; i++) {
                var lineword = words[i];
                if (wordIsNumber && i === word || !wordIsNumber && lineword.word === word) {
                  this.setCharacterTint(lineword.i, lineword.word.length, tintFill, topLeft, topRight, bottomLeft, bottomRight);
                  total++;
                  if (total === count) {
                    return this;
                  }
                }
              }
              return this;
            },
            getTextBounds: function (round) {
              var bounds = this._bounds;
              if (this._dirty || round || this.scaleX !== bounds.scaleX || this.scaleY !== bounds.scaleY) {
                GetBitmapTextSize(this, round, true, bounds);
                this._dirty = false;
              }
              return bounds;
            },
            getCharacterAt: function (x, y, camera) {
              var point = this.getLocalPoint(x, y, null, camera);
              var bounds = this.getTextBounds();
              var chars = bounds.characters;
              var tempRect = new Rectangle();
              for (var i = 0; i < chars.length; i++) {
                var char2 = chars[i];
                tempRect.setTo(char2.x, char2.t, char2.r - char2.x, char2.b);
                if (tempRect.contains(point.x, point.y)) {
                  return char2;
                }
              }
              return null;
            },
            updateDisplayOrigin: function () {
              this._dirty = true;
              this.getTextBounds(false);
              return this;
            },
            setFont: function (key, size, align) {
              if (size === void 0) {
                size = this._fontSize;
              }
              if (align === void 0) {
                align = this._align;
              }
              if (key !== this.font) {
                var entry = this.scene.sys.cache.bitmapFont.get(key);
                if (entry) {
                  this.font = key;
                  this.fontData = entry.data;
                  this._fontSize = size;
                  this._align = align;
                  this.fromAtlas = entry.fromAtlas === true;
                  this.setTexture(entry.texture, entry.frame);
                  GetBitmapTextSize(this, false, true, this._bounds);
                }
              }
              return this;
            },
            setMaxWidth: function (value, wordWrapCharCode) {
              this._maxWidth = value;
              this._dirty = true;
              if (wordWrapCharCode !== void 0) {
                this.wordWrapCharCode = wordWrapCharCode;
              }
              return this;
            },
            align: {
              set: function (value) {
                this._align = value;
                this._dirty = true;
              },
              get: function () {
                return this._align;
              }
            },
            text: {
              set: function (value) {
                this.setText(value);
              },
              get: function () {
                return this._text;
              }
            },
            fontSize: {
              set: function (value) {
                this._fontSize = value;
                this._dirty = true;
              },
              get: function () {
                return this._fontSize;
              }
            },
            letterSpacing: {
              set: function (value) {
                this._letterSpacing = value;
                this._dirty = true;
              },
              get: function () {
                return this._letterSpacing;
              }
            },
            maxWidth: {
              set: function (value) {
                this._maxWidth = value;
                this._dirty = true;
              },
              get: function () {
                return this._maxWidth;
              }
            },
            width: {
              get: function () {
                this.getTextBounds(false);
                return this._bounds.global.width;
              }
            },
            height: {
              get: function () {
                this.getTextBounds(false);
                return this._bounds.global.height;
              }
            },
            toJSON: function () {
              var out = Components.ToJSON(this);
              var data = {
                font: this.font,
                text: this.text,
                fontSize: this.fontSize,
                letterSpacing: this.letterSpacing,
                align: this.align
              };
              out.data = data;
              return out;
            },
            preDestroy: function () {
              this.charColors.length = 0;
              this._bounds = null;
              this.fontData = null;
            }
          });
          BitmapText.ALIGN_LEFT = 0;
          BitmapText.ALIGN_CENTER = 1;
          BitmapText.ALIGN_RIGHT = 2;
          BitmapText.ParseFromAtlas = ParseFromAtlas;
          BitmapText.ParseXMLBitmapFont = ParseXMLBitmapFont;
          module2.exports = BitmapText;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Set = new Class({
            initialize: function Set2(elements) {
              this.entries = [];
              if (Array.isArray(elements)) {
                for (var i = 0; i < elements.length; i++) {
                  this.set(elements[i]);
                }
              }
            },
            set: function (value) {
              if (this.entries.indexOf(value) === -1) {
                this.entries.push(value);
              }
              return this;
            },
            get: function (property, value) {
              for (var i = 0; i < this.entries.length; i++) {
                var entry = this.entries[i];
                if (entry[property] === value) {
                  return entry;
                }
              }
            },
            getArray: function () {
              return this.entries.slice(0);
            },
            delete: function (value) {
              var index = this.entries.indexOf(value);
              if (index > -1) {
                this.entries.splice(index, 1);
              }
              return this;
            },
            dump: function () {
              console.group("Set");
              for (var i = 0; i < this.entries.length; i++) {
                var entry = this.entries[i];
                console.log(entry);
              }
              console.groupEnd();
            },
            each: function (callback, callbackScope) {
              var i;
              var temp = this.entries.slice();
              var len = temp.length;
              if (callbackScope) {
                for (i = 0; i < len; i++) {
                  if (callback.call(callbackScope, temp[i], i) === false) {
                    break;
                  }
                }
              } else {
                for (i = 0; i < len; i++) {
                  if (callback(temp[i], i) === false) {
                    break;
                  }
                }
              }
              return this;
            },
            iterate: function (callback, callbackScope) {
              var i;
              var len = this.entries.length;
              if (callbackScope) {
                for (i = 0; i < len; i++) {
                  if (callback.call(callbackScope, this.entries[i], i) === false) {
                    break;
                  }
                }
              } else {
                for (i = 0; i < len; i++) {
                  if (callback(this.entries[i], i) === false) {
                    break;
                  }
                }
              }
              return this;
            },
            iterateLocal: function (callbackKey) {
              var i;
              var args = [];
              for (i = 1; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              var len = this.entries.length;
              for (i = 0; i < len; i++) {
                var entry = this.entries[i];
                entry[callbackKey].apply(entry, args);
              }
              return this;
            },
            clear: function () {
              this.entries.length = 0;
              return this;
            },
            contains: function (value) {
              return this.entries.indexOf(value) > -1;
            },
            union: function (set) {
              var newSet = new Set();
              set.entries.forEach(function (value) {
                newSet.set(value);
              });
              this.entries.forEach(function (value) {
                newSet.set(value);
              });
              return newSet;
            },
            intersect: function (set) {
              var newSet = new Set();
              this.entries.forEach(function (value) {
                if (set.contains(value)) {
                  newSet.set(value);
                }
              });
              return newSet;
            },
            difference: function (set) {
              var newSet = new Set();
              this.entries.forEach(function (value) {
                if (!set.contains(value)) {
                  newSet.set(value);
                }
              });
              return newSet;
            },
            size: {
              get: function () {
                return this.entries.length;
              },
              set: function (value) {
                if (value < this.entries.length) {
                  return this.entries.length = value;
                } else {
                  return this.entries.length;
                }
              }
            }
          });
          module2.exports = Set;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var IntegerToColor = __webpack_require__(189);
          var PIPELINES_CONST = __webpack_require__(92);
          var Render = __webpack_require__(1182);
          var PointLight = new Class({
            Extends: GameObject,
            Mixins: [Components.AlphaSingle, Components.BlendMode, Components.Depth, Components.GetBounds, Components.Mask, Components.Pipeline, Components.ScrollFactor, Components.Transform, Components.Visible, Render],
            initialize: function PointLight2(scene, x, y, color, radius, intensity, attenuation) {
              if (color === void 0) {
                color = 16777215;
              }
              if (radius === void 0) {
                radius = 128;
              }
              if (intensity === void 0) {
                intensity = 1;
              }
              if (attenuation === void 0) {
                attenuation = 0.1;
              }
              GameObject.call(this, scene, "PointLight");
              this.initPipeline(PIPELINES_CONST.POINTLIGHT_PIPELINE);
              this.setPosition(x, y);
              this.color = IntegerToColor(color);
              this.intensity = intensity;
              this.attenuation = attenuation;
              this.width = radius * 2;
              this.height = radius * 2;
              this._radius = radius;
            },
            radius: {
              get: function () {
                return this._radius;
              },
              set: function (value) {
                this._radius = value;
                this.width = value * 2;
                this.height = value * 2;
              }
            },
            originX: {
              get: function () {
                return 0.5;
              }
            },
            originY: {
              get: function () {
                return 0.5;
              }
            },
            displayOriginX: {
              get: function () {
                return this._radius;
              }
            },
            displayOriginY: {
              get: function () {
                return this._radius;
              }
            }
          });
          module2.exports = PointLight;
        }, function (module2, exports2) {
          var CircleToRectangle = function (circle, rect) {
            var halfWidth = rect.width / 2;
            var halfHeight = rect.height / 2;
            var cx = Math.abs(circle.x - rect.x - halfWidth);
            var cy = Math.abs(circle.y - rect.y - halfHeight);
            var xDist = halfWidth + circle.radius;
            var yDist = halfHeight + circle.radius;
            if (cx > xDist || cy > yDist) {
              return false;
            } else if (cx <= halfWidth || cy <= halfHeight) {
              return true;
            } else {
              var xCornerDist = cx - halfWidth;
              var yCornerDist = cy - halfHeight;
              var xCornerDistSq = xCornerDist * xCornerDist;
              var yCornerDistSq = yCornerDist * yCornerDist;
              var maxCornerDistSq = circle.radius * circle.radius;
              return xCornerDistSq + yCornerDistSq <= maxCornerDistSq;
            }
          };
          module2.exports = CircleToRectangle;
        }, function (module2, exports2) {
          var RectangleToRectangle = function (rectA, rectB) {
            if (rectA.width <= 0 || rectA.height <= 0 || rectB.width <= 0 || rectB.height <= 0) {
              return false;
            }
            return !(rectA.right < rectB.x || rectA.bottom < rectB.y || rectA.x > rectB.right || rectA.y > rectB.bottom);
          };
          module2.exports = RectangleToRectangle;
        }, function (module2, exports2, __webpack_require__) {
          var GetValue = __webpack_require__(6);
          var inputPlugins = {};
          var InputPluginCache = {};
          InputPluginCache.register = function (key, plugin, mapping, settingsKey, configKey) {
            inputPlugins[key] = {
              plugin,
              mapping,
              settingsKey,
              configKey
            };
          };
          InputPluginCache.getPlugin = function (key) {
            return inputPlugins[key];
          };
          InputPluginCache.install = function (target) {
            var sys = target.scene.sys;
            var settings = sys.settings.input;
            var config = sys.game.config;
            for (var key in inputPlugins) {
              var source = inputPlugins[key].plugin;
              var mapping = inputPlugins[key].mapping;
              var settingsKey = inputPlugins[key].settingsKey;
              var configKey = inputPlugins[key].configKey;
              if (GetValue(settings, settingsKey, config[configKey])) {
                target[mapping] = new source(target);
              }
            }
          };
          InputPluginCache.remove = function (key) {
            if (inputPlugins.hasOwnProperty(key)) {
              delete inputPlugins[key];
            }
          };
          module2.exports = InputPluginCache;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            ANY_KEY_DOWN: __webpack_require__(1323),
            ANY_KEY_UP: __webpack_require__(1324),
            COMBO_MATCH: __webpack_require__(1325),
            DOWN: __webpack_require__(1326),
            KEY_DOWN: __webpack_require__(1327),
            KEY_UP: __webpack_require__(1328),
            UP: __webpack_require__(1329)
          };
        }, function (module2, exports2) {
          var GetURL = function (file, baseURL) {
            if (!file.url) {
              return false;
            }
            if (file.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/)) {
              return file.url;
            } else {
              return baseURL + file.url;
            }
          };
          module2.exports = GetURL;
        }, function (module2, exports2) {
          var XHRSettings = function (responseType, async, user, password, timeout, withCredentials) {
            if (responseType === void 0) {
              responseType = "";
            }
            if (async === void 0) {
              async = true;
            }
            if (user === void 0) {
              user = "";
            }
            if (password === void 0) {
              password = "";
            }
            if (timeout === void 0) {
              timeout = 0;
            }
            if (withCredentials === void 0) {
              withCredentials = false;
            }
            return {
              responseType,
              async,
              user,
              password,
              timeout,
              headers: void 0,
              header: void 0,
              headerValue: void 0,
              requestedWith: false,
              overrideMimeType: void 0,
              withCredentials
            };
          };
          module2.exports = XHRSettings;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(243);
          var Sprite = __webpack_require__(73);
          var ArcadeSprite = new Class({
            Extends: Sprite,
            Mixins: [Components.Acceleration, Components.Angular, Components.Bounce, Components.Debug, Components.Drag, Components.Enable, Components.Friction, Components.Gravity, Components.Immovable, Components.Mass, Components.Pushable, Components.Size, Components.Velocity],
            initialize: function ArcadeSprite2(scene, x, y, texture, frame) {
              Sprite.call(this, scene, x, y, texture, frame);
              this.body = null;
            }
          });
          module2.exports = ArcadeSprite;
        }, function (module2, exports2, __webpack_require__) {
          var IsInLayerBounds = __webpack_require__(119);
          var GetTileAt = function (tileX, tileY, nonNull, layer) {
            if (nonNull === void 0) {
              nonNull = false;
            }
            if (IsInLayerBounds(tileX, tileY, layer)) {
              var tile = layer.data[tileY][tileX] || null;
              if (!tile) {
                return null;
              } else if (tile.index === -1) {
                return nonNull ? tile : null;
              } else {
                return tile;
              }
            } else {
              return null;
            }
          };
          module2.exports = GetTileAt;
        }, function (module2, exports2) {
          var RunCull = function (layer, bounds, renderOrder, outputArray) {
            var mapData = layer.data;
            var mapWidth = layer.width;
            var mapHeight = layer.height;
            var tilemapLayer = layer.tilemapLayer;
            var drawLeft = Math.max(0, bounds.left);
            var drawRight = Math.min(mapWidth, bounds.right);
            var drawTop = Math.max(0, bounds.top);
            var drawBottom = Math.min(mapHeight, bounds.bottom);
            var x;
            var y;
            var tile;
            if (renderOrder === 0) {
              for (y = drawTop; y < drawBottom; y++) {
                for (x = drawLeft; mapData[y] && x < drawRight; x++) {
                  tile = mapData[y][x];
                  if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                    continue;
                  }
                  outputArray.push(tile);
                }
              }
            } else if (renderOrder === 1) {
              for (y = drawTop; y < drawBottom; y++) {
                for (x = drawRight; mapData[y] && x >= drawLeft; x--) {
                  tile = mapData[y][x];
                  if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                    continue;
                  }
                  outputArray.push(tile);
                }
              }
            } else if (renderOrder === 2) {
              for (y = drawBottom; y >= drawTop; y--) {
                for (x = drawLeft; mapData[y] && x < drawRight; x++) {
                  tile = mapData[y][x];
                  if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                    continue;
                  }
                  outputArray.push(tile);
                }
              }
            } else if (renderOrder === 3) {
              for (y = drawBottom; y >= drawTop; y--) {
                for (x = drawRight; mapData[y] && x >= drawLeft; x--) {
                  tile = mapData[y][x];
                  if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                    continue;
                  }
                  outputArray.push(tile);
                }
              }
            }
            tilemapLayer.tilesDrawn = outputArray.length;
            tilemapLayer.tilesTotal = mapWidth * mapHeight;
            return outputArray;
          };
          module2.exports = RunCull;
        }, function (module2, exports2) {
          var SetLayerCollisionIndex = function (tileIndex, collides, layer) {
            var loc = layer.collideIndexes.indexOf(tileIndex);
            if (collides && loc === -1) {
              layer.collideIndexes.push(tileIndex);
            } else if (!collides && loc !== -1) {
              layer.collideIndexes.splice(loc, 1);
            }
          };
          module2.exports = SetLayerCollisionIndex;
        }, function (module2, exports2, __webpack_require__) {
          var GetFastValue = __webpack_require__(2);
          var CreateGroupLayer = function (json, groupl, parentstate) {
            if (!groupl) {
              return {
                i: 0,
                layers: json.layers,
                name: "",
                opacity: 1,
                visible: true,
                x: 0,
                y: 0
              };
            }
            var layerX = groupl.x + GetFastValue(groupl, "startx", 0) * json.tilewidth + GetFastValue(groupl, "offsetx", 0);
            var layerY = groupl.y + GetFastValue(groupl, "starty", 0) * json.tileheight + GetFastValue(groupl, "offsety", 0);
            return {
              i: 0,
              layers: groupl.layers,
              name: parentstate.name + groupl.name + "/",
              opacity: parentstate.opacity * groupl.opacity,
              visible: parentstate.visible && groupl.visible,
              x: parentstate.x + layerX,
              y: parentstate.y + layerY
            };
          };
          module2.exports = CreateGroupLayer;
        }, function (module2, exports2) {
          var GetNewValue = function (source, key, defaultValue) {
            var valueCallback;
            if (source.hasOwnProperty(key)) {
              var t = typeof source[key];
              if (t === "function") {
                valueCallback = function (target, targetKey, value, targetIndex, totalTargets, tween) {
                  return source[key](target, targetKey, value, targetIndex, totalTargets, tween);
                };
              } else {
                valueCallback = function () {
                  return source[key];
                };
              }
            } else if (typeof defaultValue === "function") {
              valueCallback = defaultValue;
            } else {
              valueCallback = function () {
                return defaultValue;
              };
            }
            return valueCallback;
          };
          module2.exports = GetNewValue;
        }, function (module2, exports2, __webpack_require__) {
          var Defaults = __webpack_require__(265);
          var GetAdvancedValue = __webpack_require__(13);
          var GetBoolean = __webpack_require__(99);
          var GetEaseFunction = __webpack_require__(80);
          var GetNewValue = __webpack_require__(162);
          var GetProps = __webpack_require__(583);
          var GetTargets = __webpack_require__(263);
          var GetValue = __webpack_require__(6);
          var GetValueOp = __webpack_require__(264);
          var Tween = __webpack_require__(266);
          var TweenData = __webpack_require__(268);
          var TweenBuilder = function (parent, config, defaults) {
            if (defaults === void 0) {
              defaults = Defaults;
            }
            var targets = defaults.targets ? defaults.targets : GetTargets(config);
            var props = GetProps(config);
            var delay = GetNewValue(config, "delay", defaults.delay);
            var duration = GetNewValue(config, "duration", defaults.duration);
            var easeParams = GetValue(config, "easeParams", defaults.easeParams);
            var ease = GetEaseFunction(GetValue(config, "ease", defaults.ease), easeParams);
            var hold = GetNewValue(config, "hold", defaults.hold);
            var repeat = GetNewValue(config, "repeat", defaults.repeat);
            var repeatDelay = GetNewValue(config, "repeatDelay", defaults.repeatDelay);
            var yoyo = GetBoolean(config, "yoyo", defaults.yoyo);
            var flipX = GetBoolean(config, "flipX", defaults.flipX);
            var flipY = GetBoolean(config, "flipY", defaults.flipY);
            var data = [];
            for (var p3 = 0; p3 < props.length; p3++) {
              var key = props[p3].key;
              var value = props[p3].value;
              for (var t = 0; t < targets.length; t++) {
                var ops = GetValueOp(key, value);
                var tweenData = TweenData(targets[t], t, key, ops.getEnd, ops.getStart, ops.getActive, GetEaseFunction(GetValue(value, "ease", ease), GetValue(value, "easeParams", easeParams)), GetNewValue(value, "delay", delay), GetNewValue(value, "duration", duration), GetBoolean(value, "yoyo", yoyo), GetNewValue(value, "hold", hold), GetNewValue(value, "repeat", repeat), GetNewValue(value, "repeatDelay", repeatDelay), GetBoolean(value, "flipX", flipX), GetBoolean(value, "flipY", flipY));
                data.push(tweenData);
              }
            }
            var tween = new Tween(parent, data, targets);
            tween.offset = GetAdvancedValue(config, "offset", null);
            tween.completeDelay = GetAdvancedValue(config, "completeDelay", 0);
            tween.loop = Math.round(GetAdvancedValue(config, "loop", 0));
            tween.loopDelay = Math.round(GetAdvancedValue(config, "loopDelay", 0));
            tween.paused = GetBoolean(config, "paused", false);
            tween.useFrames = GetBoolean(config, "useFrames", false);
            var scope = GetValue(config, "callbackScope", tween);
            var tweenArray = [tween, null];
            var callbacks = Tween.TYPES;
            for (var i = 0; i < callbacks.length; i++) {
              var type = callbacks[i];
              var callback = GetValue(config, type, false);
              if (callback) {
                var callbackScope = GetValue(config, type + "Scope", scope);
                var callbackParams = GetValue(config, type + "Params", []);
                tween.setCallback(type, callback, tweenArray.concat(callbackParams), callbackScope);
              }
            }
            return tween;
          };
          module2.exports = TweenBuilder;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CustomMap = __webpack_require__(102);
          var GetFastValue = __webpack_require__(2);
          var Events = __webpack_require__(132);
          var Animation = __webpack_require__(185);
          var AnimationState = new Class({
            initialize: function AnimationState2(parent) {
              this.parent = parent;
              this.animationManager = parent.scene.sys.anims;
              this.animationManager.on(Events.REMOVE_ANIMATION, this.globalRemove, this);
              this.textureManager = this.animationManager.textureManager;
              this.anims = null;
              this.isPlaying = false;
              this.hasStarted = false;
              this.currentAnim = null;
              this.currentFrame = null;
              this.nextAnim = null;
              this.nextAnimsQueue = [];
              this.timeScale = 1;
              this.frameRate = 0;
              this.duration = 0;
              this.msPerFrame = 0;
              this.skipMissedFrames = true;
              this.delay = 0;
              this.repeat = 0;
              this.repeatDelay = 0;
              this.yoyo = false;
              this.showOnStart = false;
              this.hideOnComplete = false;
              this.forward = true;
              this.inReverse = false;
              this.accumulator = 0;
              this.nextTick = 0;
              this.delayCounter = 0;
              this.repeatCounter = 0;
              this.pendingRepeat = false;
              this._paused = false;
              this._wasPlaying = false;
              this._pendingStop = 0;
              this._pendingStopValue;
            },
            chain: function (key) {
              var parent = this.parent;
              if (key === void 0) {
                this.nextAnimsQueue.length = 0;
                this.nextAnim = null;
                return parent;
              }
              if (!Array.isArray(key)) {
                key = [key];
              }
              for (var i = 0; i < key.length; i++) {
                var anim = key[i];
                if (this.nextAnim === null) {
                  this.nextAnim = anim;
                } else {
                  this.nextAnimsQueue.push(anim);
                }
              }
              return this.parent;
            },
            getName: function () {
              return this.currentAnim ? this.currentAnim.key : "";
            },
            getFrameName: function () {
              return this.currentFrame ? this.currentFrame.textureFrame : "";
            },
            load: function (key) {
              if (this.isPlaying) {
                this.stop();
              }
              var manager = this.animationManager;
              var animKey = typeof key === "string" ? key : GetFastValue(key, "key", null);
              var anim = this.exists(animKey) ? this.get(animKey) : manager.get(animKey);
              if (!anim) {
                console.warn("Missing animation: " + animKey);
              } else {
                this.currentAnim = anim;
                var totalFrames = anim.getTotalFrames();
                var frameRate = GetFastValue(key, "frameRate", anim.frameRate);
                var duration = GetFastValue(key, "duration", anim.duration);
                anim.calculateDuration(this, totalFrames, duration, frameRate);
                this.delay = GetFastValue(key, "delay", anim.delay);
                this.repeat = GetFastValue(key, "repeat", anim.repeat);
                this.repeatDelay = GetFastValue(key, "repeatDelay", anim.repeatDelay);
                this.yoyo = GetFastValue(key, "yoyo", anim.yoyo);
                this.showOnStart = GetFastValue(key, "showOnStart", anim.showOnStart);
                this.hideOnComplete = GetFastValue(key, "hideOnComplete", anim.hideOnComplete);
                this.skipMissedFrames = GetFastValue(key, "skipMissedFrames", anim.skipMissedFrames);
                this.timeScale = GetFastValue(key, "timeScale", this.timeScale);
                var startFrame = GetFastValue(key, "startFrame", 0);
                if (startFrame > anim.getTotalFrames()) {
                  startFrame = 0;
                }
                var frame = anim.frames[startFrame];
                if (startFrame === 0 && !this.forward) {
                  frame = anim.getLastFrame();
                }
                this.currentFrame = frame;
              }
              return this.parent;
            },
            pause: function (atFrame) {
              if (!this._paused) {
                this._paused = true;
                this._wasPlaying = this.isPlaying;
                this.isPlaying = false;
              }
              if (atFrame !== void 0) {
                this.setCurrentFrame(atFrame);
              }
              return this.parent;
            },
            resume: function (fromFrame) {
              if (this._paused) {
                this._paused = false;
                this.isPlaying = this._wasPlaying;
              }
              if (fromFrame !== void 0) {
                this.setCurrentFrame(fromFrame);
              }
              return this.parent;
            },
            playAfterDelay: function (key, delay) {
              if (!this.isPlaying) {
                this.delayCounter = delay;
                this.play(key, true);
              } else {
                var nextAnim = this.nextAnim;
                var queue = this.nextAnimsQueue;
                if (nextAnim) {
                  queue.unshift(nextAnim);
                }
                this.nextAnim = key;
                this._pendingStop = 1;
                this._pendingStopValue = delay;
              }
              return this.parent;
            },
            playAfterRepeat: function (key, repeatCount) {
              if (repeatCount === void 0) {
                repeatCount = 1;
              }
              if (!this.isPlaying) {
                this.play(key);
              } else {
                var nextAnim = this.nextAnim;
                var queue = this.nextAnimsQueue;
                if (nextAnim) {
                  queue.unshift(nextAnim);
                }
                if (this.repeatCounter !== -1 && repeatCount > this.repeatCounter) {
                  repeatCount = this.repeatCounter;
                }
                this.nextAnim = key;
                this._pendingStop = 2;
                this._pendingStopValue = repeatCount;
              }
              return this.parent;
            },
            play: function (key, ignoreIfPlaying) {
              if (ignoreIfPlaying === void 0) {
                ignoreIfPlaying = false;
              }
              var currentAnim = this.currentAnim;
              var parent = this.parent;
              var animKey = typeof key === "string" ? key : key.key;
              if (ignoreIfPlaying && this.isPlaying && currentAnim.key === animKey) {
                return parent;
              }
              if (currentAnim && this.isPlaying) {
                var mix = this.animationManager.getMix(currentAnim.key, key);
                if (mix > 0) {
                  return this.playAfterDelay(key, mix);
                }
              }
              this.forward = true;
              this.inReverse = false;
              this._paused = false;
              this._wasPlaying = true;
              return this.startAnimation(key);
            },
            playReverse: function (key, ignoreIfPlaying) {
              if (ignoreIfPlaying === void 0) {
                ignoreIfPlaying = false;
              }
              var animKey = typeof key === "string" ? key : key.key;
              if (ignoreIfPlaying && this.isPlaying && this.currentAnim.key === animKey) {
                return this.parent;
              }
              this.forward = false;
              this.inReverse = true;
              this._paused = false;
              this._wasPlaying = true;
              return this.startAnimation(key);
            },
            startAnimation: function (key) {
              this.load(key);
              var anim = this.currentAnim;
              var gameObject = this.parent;
              if (!anim) {
                return gameObject;
              }
              this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat;
              anim.getFirstTick(this);
              this.isPlaying = true;
              this.pendingRepeat = false;
              this.hasStarted = false;
              this._pendingStop = 0;
              this._pendingStopValue = 0;
              this._paused = false;
              this.delayCounter += this.delay;
              if (this.delayCounter === 0) {
                this.handleStart();
              }
              return gameObject;
            },
            handleStart: function () {
              if (this.showOnStart) {
                this.parent.setVisible(true);
              }
              this.setCurrentFrame(this.currentFrame);
              this.hasStarted = true;
              this.emitEvents(Events.ANIMATION_START);
            },
            handleRepeat: function () {
              this.pendingRepeat = false;
              this.emitEvents(Events.ANIMATION_REPEAT);
            },
            handleStop: function () {
              this._pendingStop = 0;
              this.isPlaying = false;
              this.emitEvents(Events.ANIMATION_STOP);
            },
            handleComplete: function () {
              this._pendingStop = 0;
              this.isPlaying = false;
              if (this.hideOnComplete) {
                this.parent.setVisible(false);
              }
              this.emitEvents(Events.ANIMATION_COMPLETE, Events.ANIMATION_COMPLETE_KEY);
            },
            emitEvents: function (event, keyEvent) {
              var anim = this.currentAnim;
              var frame = this.currentFrame;
              var gameObject = this.parent;
              var frameKey = frame.textureFrame;
              gameObject.emit(event, anim, frame, gameObject, frameKey);
              if (keyEvent) {
                gameObject.emit(keyEvent + anim.key, anim, frame, gameObject, frameKey);
              }
            },
            reverse: function () {
              if (this.isPlaying) {
                this.inReverse = !this.inReverse;
                this.forward = !this.forward;
              }
              return this.parent;
            },
            getProgress: function () {
              var frame = this.currentFrame;
              if (!frame) {
                return 0;
              }
              var p3 = frame.progress;
              if (this.inReverse) {
                p3 *= -1;
              }
              return p3;
            },
            setProgress: function (value) {
              if (!this.forward) {
                value = 1 - value;
              }
              this.setCurrentFrame(this.currentAnim.getFrameByProgress(value));
              return this.parent;
            },
            setRepeat: function (value) {
              this.repeatCounter = value === -1 ? Number.MAX_VALUE : value;
              return this.parent;
            },
            globalRemove: function (key, animation) {
              if (animation === void 0) {
                animation = this.currentAnim;
              }
              if (this.isPlaying && animation.key === this.currentAnim.key) {
                this.stop();
                this.setCurrentFrame(this.currentAnim.frames[0]);
              }
            },
            restart: function (includeDelay, resetRepeats) {
              if (includeDelay === void 0) {
                includeDelay = false;
              }
              if (resetRepeats === void 0) {
                resetRepeats = false;
              }
              var anim = this.currentAnim;
              var gameObject = this.parent;
              if (!anim) {
                return gameObject;
              }
              if (resetRepeats) {
                this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat;
              }
              anim.getFirstTick(this);
              this.emitEvents(Events.ANIMATION_RESTART);
              this.isPlaying = true;
              this.pendingRepeat = false;
              this.hasStarted = !includeDelay;
              this._pendingStop = 0;
              this._pendingStopValue = 0;
              this._paused = false;
              this.setCurrentFrame(anim.frames[0]);
              return this.parent;
            },
            complete: function () {
              this._pendingStop = 0;
              this.isPlaying = false;
              if (this.currentAnim) {
                this.handleComplete();
              }
              if (this.nextAnim) {
                var key = this.nextAnim;
                this.nextAnim = this.nextAnimsQueue.length > 0 ? this.nextAnimsQueue.shift() : null;
                this.play(key);
              }
              return this.parent;
            },
            stop: function () {
              this._pendingStop = 0;
              this.isPlaying = false;
              if (this.currentAnim) {
                this.handleStop();
              }
              if (this.nextAnim) {
                var key = this.nextAnim;
                this.nextAnim = this.nextAnimsQueue.shift();
                this.play(key);
              }
              return this.parent;
            },
            stopAfterDelay: function (delay) {
              this._pendingStop = 1;
              this._pendingStopValue = delay;
              return this.parent;
            },
            stopAfterRepeat: function (repeatCount) {
              if (repeatCount === void 0) {
                repeatCount = 1;
              }
              if (this.repeatCounter !== -1 && repeatCount > this.repeatCounter) {
                repeatCount = this.repeatCounter;
              }
              this._pendingStop = 2;
              this._pendingStopValue = repeatCount;
              return this.parent;
            },
            stopOnFrame: function (frame) {
              this._pendingStop = 3;
              this._pendingStopValue = frame;
              return this.parent;
            },
            getTotalFrames: function () {
              return this.currentAnim ? this.currentAnim.getTotalFrames() : 0;
            },
            update: function (time, delta) {
              var anim = this.currentAnim;
              if (!this.isPlaying || !anim || anim.paused) {
                return;
              }
              this.accumulator += delta * this.timeScale;
              if (this._pendingStop === 1) {
                this._pendingStopValue -= delta;
                if (this._pendingStopValue <= 0) {
                  return this.stop();
                }
              }
              if (!this.hasStarted) {
                if (this.accumulator >= this.delayCounter) {
                  this.accumulator -= this.delayCounter;
                  this.handleStart();
                }
              } else if (this.accumulator >= this.nextTick) {
                if (this.forward) {
                  anim.nextFrame(this);
                } else {
                  anim.previousFrame(this);
                }
                if (this.isPlaying && this._pendingStop === 0 && this.skipMissedFrames && this.accumulator > this.nextTick) {
                  var safetyNet = 0;
                  do {
                    if (this.forward) {
                      anim.nextFrame(this);
                    } else {
                      anim.previousFrame(this);
                    }
                    safetyNet++;
                  } while (this.isPlaying && this.accumulator > this.nextTick && safetyNet < 60);
                }
              }
            },
            setCurrentFrame: function (animationFrame) {
              var gameObject = this.parent;
              this.currentFrame = animationFrame;
              gameObject.texture = animationFrame.frame.texture;
              gameObject.frame = animationFrame.frame;
              if (gameObject.isCropped) {
                gameObject.frame.updateCropUVs(gameObject._crop, gameObject.flipX, gameObject.flipY);
              }
              if (animationFrame.setAlpha) {
                gameObject.alpha = animationFrame.alpha;
              }
              gameObject.setSizeToFrame();
              if (gameObject._originComponent) {
                if (animationFrame.frame.customPivot) {
                  gameObject.setOrigin(animationFrame.frame.pivotX, animationFrame.frame.pivotY);
                } else {
                  gameObject.updateDisplayOrigin();
                }
              }
              if (this.isPlaying && this.hasStarted) {
                this.emitEvents(Events.ANIMATION_UPDATE);
                if (this._pendingStop === 3 && this._pendingStopValue === animationFrame) {
                  this.stop();
                }
              }
              return gameObject;
            },
            nextFrame: function () {
              if (this.currentAnim) {
                this.currentAnim.nextFrame(this);
              }
              return this.parent;
            },
            previousFrame: function () {
              if (this.currentAnim) {
                this.currentAnim.previousFrame(this);
              }
              return this.parent;
            },
            get: function (key) {
              return this.anims ? this.anims.get(key) : null;
            },
            exists: function (key) {
              return this.anims ? this.anims.has(key) : false;
            },
            create: function (config) {
              var key = config.key;
              var anim = false;
              if (key) {
                anim = this.get(key);
                if (!anim) {
                  anim = new Animation(this, key, config);
                  if (!this.anims) {
                    this.anims = new CustomMap();
                  }
                  this.anims.set(key, anim);
                }
              }
              return anim;
            },
            generateFrameNames: function (key, config) {
              return this.animationManager.generateFrameNames(key, config);
            },
            generateFrameNumbers: function (key, config) {
              return this.animationManager.generateFrameNumbers(key, config);
            },
            remove: function (key) {
              var anim = this.get(key);
              if (anim) {
                if (this.currentAnim === anim) {
                  this.stop();
                }
                this.anims.delete(key);
              }
              return anim;
            },
            destroy: function () {
              this.animationManager.off(Events.REMOVE_ANIMATION, this.globalRemove, this);
              if (this.anims) {
                this.anims.clear();
              }
              this.animationManager = null;
              this.parent = null;
              this.nextAnim = null;
              this.nextAnimsQueue.length = 0;
              this.currentAnim = null;
              this.currentFrame = null;
            },
            isPaused: {
              get: function () {
                return this._paused;
              }
            }
          });
          module2.exports = AnimationState;
        }, function (module2, exports2, __webpack_require__) {
          var Sleeping = {};
          module2.exports = Sleeping;
          var Events = __webpack_require__(166);
          (function () {
            Sleeping._motionWakeThreshold = 0.18;
            Sleeping._motionSleepThreshold = 0.08;
            Sleeping._minBias = 0.9;
            Sleeping.update = function (bodies, timeScale) {
              var timeFactor = timeScale * timeScale * timeScale;
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i], motion = body.speed * body.speed + body.angularSpeed * body.angularSpeed;
                if (body.force.x !== 0 || body.force.y !== 0) {
                  Sleeping.set(body, false);
                  continue;
                }
                var minMotion = Math.min(body.motion, motion), maxMotion = Math.max(body.motion, motion);
                body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;
                if (body.sleepThreshold > 0 && body.motion < Sleeping._motionSleepThreshold * timeFactor) {
                  body.sleepCounter += 1;
                  if (body.sleepCounter >= body.sleepThreshold) Sleeping.set(body, true);
                } else if (body.sleepCounter > 0) {
                  body.sleepCounter -= 1;
                }
              }
            };
            Sleeping.afterCollisions = function (pairs, timeScale) {
              var timeFactor = timeScale * timeScale * timeScale;
              for (var i = 0; i < pairs.length; i++) {
                var pair = pairs[i];
                if (!pair.isActive) continue;
                var collision = pair.collision, bodyA = collision.bodyA.parent, bodyB = collision.bodyB.parent;
                if (bodyA.isSleeping && bodyB.isSleeping || bodyA.isStatic || bodyB.isStatic) continue;
                if (bodyA.isSleeping || bodyB.isSleeping) {
                  var sleepingBody = bodyA.isSleeping && !bodyA.isStatic ? bodyA : bodyB, movingBody = sleepingBody === bodyA ? bodyB : bodyA;
                  if (!sleepingBody.isStatic && movingBody.motion > Sleeping._motionWakeThreshold * timeFactor) {
                    Sleeping.set(sleepingBody, false);
                  }
                }
              }
            };
            Sleeping.set = function (body, isSleeping) {
              var wasSleeping = body.isSleeping;
              if (isSleeping) {
                body.isSleeping = true;
                body.sleepCounter = body.sleepThreshold;
                body.positionImpulse.x = 0;
                body.positionImpulse.y = 0;
                body.positionPrev.x = body.position.x;
                body.positionPrev.y = body.position.y;
                body.anglePrev = body.angle;
                body.speed = 0;
                body.angularSpeed = 0;
                body.motion = 0;
                if (!wasSleeping) {
                  Events.trigger(body, "sleepStart");
                }
              } else {
                body.isSleeping = false;
                body.sleepCounter = 0;
                if (wasSleeping) {
                  Events.trigger(body, "sleepEnd");
                }
              }
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          var Events = {};
          module2.exports = Events;
          var Common = __webpack_require__(32);
          (function () {
            Events.on = function (object, eventNames, callback) {
              var names = eventNames.split(" "), name;
              for (var i = 0; i < names.length; i++) {
                name = names[i];
                object.events = object.events || ({});
                object.events[name] = object.events[name] || [];
                object.events[name].push(callback);
              }
              return callback;
            };
            Events.off = function (object, eventNames, callback) {
              if (!eventNames) {
                object.events = {};
                return;
              }
              if (typeof eventNames === "function") {
                callback = eventNames;
                eventNames = Common.keys(object.events).join(" ");
              }
              var names = eventNames.split(" ");
              for (var i = 0; i < names.length; i++) {
                var callbacks = object.events[names[i]], newCallbacks = [];
                if (callback && callbacks) {
                  for (var j = 0; j < callbacks.length; j++) {
                    if (callbacks[j] !== callback) newCallbacks.push(callbacks[j]);
                  }
                }
                object.events[names[i]] = newCallbacks;
              }
            };
            Events.trigger = function (object, eventNames, event) {
              var names, name, callbacks, eventClone;
              var events = object.events;
              if (events && Common.keys(events).length > 0) {
                if (!event) event = {};
                names = eventNames.split(" ");
                for (var i = 0; i < names.length; i++) {
                  name = names[i];
                  callbacks = events[name];
                  if (callbacks) {
                    eventClone = Common.clone(event, false);
                    eventClone.name = name;
                    eventClone.source = object;
                    for (var j = 0; j < callbacks.length; j++) {
                      callbacks[j].apply(object, [eventClone]);
                    }
                  }
                }
              }
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          var DeepCopy = __webpack_require__(175);
          var PIPELINE_CONST = __webpack_require__(92);
          var SpliceOne = __webpack_require__(74);
          var Pipeline = {
            defaultPipeline: null,
            pipeline: null,
            hasPostPipeline: false,
            postPipelines: null,
            pipelineData: null,
            initPipeline: function (pipeline) {
              if (pipeline === void 0) {
                pipeline = PIPELINE_CONST.MULTI_PIPELINE;
              }
              var renderer = this.scene.sys.renderer;
              if (!renderer) {
                return false;
              }
              var pipelines = renderer.pipelines;
              this.postPipelines = [];
              this.pipelineData = {};
              if (pipelines) {
                var instance = pipelines.get(pipeline);
                if (instance) {
                  this.defaultPipeline = instance;
                  this.pipeline = instance;
                  return true;
                }
              }
              return false;
            },
            setPipeline: function (pipeline, pipelineData, copyData) {
              var renderer = this.scene.sys.renderer;
              if (!renderer) {
                return this;
              }
              var pipelines = renderer.pipelines;
              if (pipelines) {
                var instance = pipelines.get(pipeline);
                if (instance) {
                  this.pipeline = instance;
                }
                if (pipelineData) {
                  this.pipelineData = copyData ? DeepCopy(pipelineData) : pipelineData;
                }
              }
              return this;
            },
            setPostPipeline: function (pipelines, pipelineData, copyData) {
              var renderer = this.scene.sys.renderer;
              if (!renderer) {
                return this;
              }
              var pipelineManager = renderer.pipelines;
              if (pipelineManager) {
                if (!Array.isArray(pipelines)) {
                  pipelines = [pipelines];
                }
                for (var i = 0; i < pipelines.length; i++) {
                  var instance = pipelineManager.getPostPipeline(pipelines[i], this);
                  if (instance) {
                    this.postPipelines.push(instance);
                  }
                }
                if (pipelineData) {
                  this.pipelineData = copyData ? DeepCopy(pipelineData) : pipelineData;
                }
              }
              this.hasPostPipeline = this.postPipelines.length > 0;
              return this;
            },
            setPipelineData: function (key, value) {
              var data = this.pipelineData;
              if (value === void 0) {
                delete data[key];
              } else {
                data[key] = value;
              }
              return this;
            },
            getPostPipeline: function (pipeline) {
              var pipelines = this.postPipelines;
              var results = [];
              for (var i = 0; i < pipelines.length; i++) {
                var instance = pipelines[i];
                if (typeof pipeline === "string" && instance.name === pipeline || instance instanceof pipeline) {
                  results.push(instance);
                }
              }
              return results.length === 1 ? results[0] : results;
            },
            resetPipeline: function (resetPostPipelines, resetData) {
              if (resetPostPipelines === void 0) {
                resetPostPipelines = false;
              }
              if (resetData === void 0) {
                resetData = false;
              }
              this.pipeline = this.defaultPipeline;
              if (resetPostPipelines) {
                this.postPipelines = [];
                this.hasPostPipeline = false;
              }
              if (resetData) {
                this.pipelineData = {};
              }
              return this.pipeline !== null;
            },
            resetPostPipeline: function (resetData) {
              if (resetData === void 0) {
                resetData = false;
              }
              var pipelines = this.postPipelines;
              for (var i = 0; i < pipelines.length; i++) {
                pipelines[i].destroy();
              }
              this.postPipelines = [];
              this.hasPostPipeline = false;
              if (resetData) {
                this.pipelineData = {};
              }
            },
            removePostPipeline: function (pipeline) {
              var pipelines = this.postPipelines;
              for (var i = pipelines.length - 1; i >= 0; i--) {
                var instance = pipelines[i];
                if (typeof pipeline === "string" && instance.name === pipeline || typeof pipeline !== "string" && instance instanceof pipeline) {
                  instance.destroy();
                  SpliceOne(pipelines, i);
                }
              }
              this.hasPostPipeline = this.postPipelines.length > 0;
              return this;
            },
            getPipelineName: function () {
              return this.pipeline.name;
            }
          };
          module2.exports = Pipeline;
        }, function (module2, exports2) {
          var ScaleModes = {
            DEFAULT: 0,
            LINEAR: 0,
            NEAREST: 1
          };
          module2.exports = ScaleModes;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var CircumferencePoint = function (circle, angle, out) {
            if (out === void 0) {
              out = new Point();
            }
            out.x = circle.x + circle.radius * Math.cos(angle);
            out.y = circle.y + circle.radius * Math.sin(angle);
            return out;
          };
          module2.exports = CircumferencePoint;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var Random = function (circle, out) {
            if (out === void 0) {
              out = new Point();
            }
            var t = 2 * Math.PI * Math.random();
            var u = Math.random() + Math.random();
            var r = u > 1 ? 2 - u : u;
            var x = r * Math.cos(t);
            var y = r * Math.sin(t);
            out.x = circle.x + x * circle.radius;
            out.y = circle.y + y * circle.radius;
            return out;
          };
          module2.exports = Random;
        }, function (module2, exports2, __webpack_require__) {
          var Perimeter = __webpack_require__(130);
          var Point = __webpack_require__(4);
          var GetPoint = function (rectangle, position, out) {
            if (out === void 0) {
              out = new Point();
            }
            if (position <= 0 || position >= 1) {
              out.x = rectangle.x;
              out.y = rectangle.y;
              return out;
            }
            var p3 = Perimeter(rectangle) * position;
            if (position > 0.5) {
              p3 -= rectangle.width + rectangle.height;
              if (p3 <= rectangle.width) {
                out.x = rectangle.right - p3;
                out.y = rectangle.bottom;
              } else {
                out.x = rectangle.x;
                out.y = rectangle.bottom - (p3 - rectangle.width);
              }
            } else if (p3 <= rectangle.width) {
              out.x = rectangle.x + p3;
              out.y = rectangle.y;
            } else {
              out.x = rectangle.right;
              out.y = rectangle.y + (p3 - rectangle.width);
            }
            return out;
          };
          module2.exports = GetPoint;
        }, function (module2, exports2, __webpack_require__) {
          var Length = __webpack_require__(67);
          var Point = __webpack_require__(4);
          var GetPoints = function (line, quantity, stepRate, out) {
            if (out === void 0) {
              out = [];
            }
            if (!quantity && stepRate > 0) {
              quantity = Length(line) / stepRate;
            }
            var x1 = line.x1;
            var y1 = line.y1;
            var x2 = line.x2;
            var y2 = line.y2;
            for (var i = 0; i < quantity; i++) {
              var position = i / quantity;
              var x = x1 + (x2 - x1) * position;
              var y = y1 + (y2 - y1) * position;
              out.push(new Point(x, y));
            }
            return out;
          };
          module2.exports = GetPoints;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var Random = function (line, out) {
            if (out === void 0) {
              out = new Point();
            }
            var t = Math.random();
            out.x = line.x1 + t * (line.x2 - line.x1);
            out.y = line.y1 + t * (line.y2 - line.y1);
            return out;
          };
          module2.exports = Random;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var Random = function (rect, out) {
            if (out === void 0) {
              out = new Point();
            }
            out.x = rect.x + Math.random() * rect.width;
            out.y = rect.y + Math.random() * rect.height;
            return out;
          };
          module2.exports = Random;
        }, function (module2, exports2) {
          var DeepCopy = function (inObject) {
            var outObject;
            var value;
            var key;
            if (typeof inObject !== "object" || inObject === null) {
              return inObject;
            }
            outObject = Array.isArray(inObject) ? [] : {};
            for (key in inObject) {
              value = inObject[key];
              outObject[key] = DeepCopy(value);
            }
            return outObject;
          };
          module2.exports = DeepCopy;
        }, function (module2, exports2) {
          var ToJSON = function (gameObject) {
            var out = {
              name: gameObject.name,
              type: gameObject.type,
              x: gameObject.x,
              y: gameObject.y,
              depth: gameObject.depth,
              scale: {
                x: gameObject.scaleX,
                y: gameObject.scaleY
              },
              origin: {
                x: gameObject.originX,
                y: gameObject.originY
              },
              flipX: gameObject.flipX,
              flipY: gameObject.flipY,
              rotation: gameObject.rotation,
              alpha: gameObject.alpha,
              visible: gameObject.visible,
              blendMode: gameObject.blendMode,
              textureKey: "",
              frameKey: "",
              data: {}
            };
            if (gameObject.texture) {
              out.textureKey = gameObject.texture.key;
              out.frameKey = gameObject.frame.name;
            }
            return out;
          };
          module2.exports = ToJSON;
        }, function (module2, exports2, __webpack_require__) {
          var Vector2 = __webpack_require__(3);
          var TransformXY = function (x, y, positionX, positionY, rotation, scaleX, scaleY, output) {
            if (output === void 0) {
              output = new Vector2();
            }
            var radianSin = Math.sin(rotation);
            var radianCos = Math.cos(rotation);
            var a = radianCos * scaleX;
            var b = radianSin * scaleX;
            var c = -radianSin * scaleY;
            var d = radianCos * scaleY;
            var id = 1 / (a * d + c * -b);
            output.x = d * id * x + -c * id * y + (positionY * c - positionX * d) * id;
            output.y = a * id * y + -b * id * x + (-positionY * a + positionX * b) * id;
            return output;
          };
          module2.exports = TransformXY;
        }, function (module2, exports2) {
          var RotateLeft = function (array, total) {
            if (total === void 0) {
              total = 1;
            }
            var element = null;
            for (var i = 0; i < total; i++) {
              element = array.shift();
              array.push(element);
            }
            return element;
          };
          module2.exports = RotateLeft;
        }, function (module2, exports2) {
          var RotateRight = function (array, total) {
            if (total === void 0) {
              total = 1;
            }
            var element = null;
            for (var i = 0; i < total; i++) {
              element = array.pop();
              array.unshift(element);
            }
            return element;
          };
          module2.exports = RotateRight;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var Random = function (ellipse, out) {
            if (out === void 0) {
              out = new Point();
            }
            var p3 = Math.random() * Math.PI * 2;
            var s = Math.sqrt(Math.random());
            out.x = ellipse.x + s * Math.cos(p3) * ellipse.width / 2;
            out.y = ellipse.y + s * Math.sin(p3) * ellipse.height / 2;
            return out;
          };
          module2.exports = Random;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var Random = function (triangle, out) {
            if (out === void 0) {
              out = new Point();
            }
            var ux = triangle.x2 - triangle.x1;
            var uy = triangle.y2 - triangle.y1;
            var vx = triangle.x3 - triangle.x1;
            var vy = triangle.y3 - triangle.y1;
            var r = Math.random();
            var s = Math.random();
            if (r + s >= 1) {
              r = 1 - r;
              s = 1 - s;
            }
            out.x = triangle.x1 + (ux * r + vx * s);
            out.y = triangle.y1 + (uy * r + vy * s);
            return out;
          };
          module2.exports = Random;
        }, function (module2, exports2) {
          var RotateAroundDistance = function (point, x, y, angle, distance) {
            var t = angle + Math.atan2(point.y - y, point.x - x);
            point.x = x + distance * Math.cos(t);
            point.y = y + distance * Math.sin(t);
            return point;
          };
          module2.exports = RotateAroundDistance;
        }, function (module2, exports2) {
          var SmootherStep = function (x, min, max) {
            x = Math.max(0, Math.min(1, (x - min) / (max - min)));
            return x * x * x * (x * (x * 6 - 15) + 10);
          };
          module2.exports = SmootherStep;
        }, function (module2, exports2) {
          var SmoothStep = function (x, min, max) {
            if (x <= min) {
              return 0;
            }
            if (x >= max) {
              return 1;
            }
            x = (x - min) / (max - min);
            return x * x * (3 - 2 * x);
          };
          module2.exports = SmoothStep;
        }, function (module2, exports2, __webpack_require__) {
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(132);
          var FindClosestInSorted = __webpack_require__(318);
          var Frame = __webpack_require__(319);
          var GetValue = __webpack_require__(6);
          var SortByDigits = __webpack_require__(320);
          var Animation = new Class({
            initialize: function Animation2(manager, key, config) {
              this.manager = manager;
              this.key = key;
              this.type = "frame";
              this.frames = this.getFrames(manager.textureManager, GetValue(config, "frames", []), GetValue(config, "defaultTextureKey", null), GetValue(config, "sortFrames", true));
              this.frameRate = GetValue(config, "frameRate", null);
              this.duration = GetValue(config, "duration", null);
              this.msPerFrame;
              this.skipMissedFrames = GetValue(config, "skipMissedFrames", true);
              this.delay = GetValue(config, "delay", 0);
              this.repeat = GetValue(config, "repeat", 0);
              this.repeatDelay = GetValue(config, "repeatDelay", 0);
              this.yoyo = GetValue(config, "yoyo", false);
              this.showOnStart = GetValue(config, "showOnStart", false);
              this.hideOnComplete = GetValue(config, "hideOnComplete", false);
              this.paused = false;
              this.calculateDuration(this, this.getTotalFrames(), this.duration, this.frameRate);
              if (this.manager.on) {
                this.manager.on(Events.PAUSE_ALL, this.pause, this);
                this.manager.on(Events.RESUME_ALL, this.resume, this);
              }
            },
            getTotalFrames: function () {
              return this.frames.length;
            },
            calculateDuration: function (target, totalFrames, duration, frameRate) {
              if (duration === null && frameRate === null) {
                target.frameRate = 24;
                target.duration = 24 / totalFrames * 1e3;
              } else if (duration && frameRate === null) {
                target.duration = duration;
                target.frameRate = totalFrames / (duration / 1e3);
              } else {
                target.frameRate = frameRate;
                target.duration = totalFrames / frameRate * 1e3;
              }
              target.msPerFrame = 1e3 / target.frameRate;
            },
            addFrame: function (config) {
              return this.addFrameAt(this.frames.length, config);
            },
            addFrameAt: function (index, config) {
              var newFrames = this.getFrames(this.manager.textureManager, config);
              if (newFrames.length > 0) {
                if (index === 0) {
                  this.frames = newFrames.concat(this.frames);
                } else if (index === this.frames.length) {
                  this.frames = this.frames.concat(newFrames);
                } else {
                  var pre = this.frames.slice(0, index);
                  var post = this.frames.slice(index);
                  this.frames = pre.concat(newFrames, post);
                }
                this.updateFrameSequence();
              }
              return this;
            },
            checkFrame: function (index) {
              return index >= 0 && index < this.frames.length;
            },
            getFirstTick: function (state) {
              state.accumulator = 0;
              state.nextTick = state.msPerFrame + state.currentFrame.duration;
            },
            getFrameAt: function (index) {
              return this.frames[index];
            },
            getFrames: function (textureManager, frames, defaultTextureKey, sortFrames) {
              if (sortFrames === void 0) {
                sortFrames = true;
              }
              var out = [];
              var prev;
              var animationFrame;
              var index = 1;
              var i;
              var textureKey;
              if (typeof frames === "string") {
                textureKey = frames;
                var texture = textureManager.get(textureKey);
                var frameKeys = texture.getFrameNames();
                if (sortFrames) {
                  SortByDigits(frameKeys);
                }
                frames = [];
                frameKeys.forEach(function (value) {
                  frames.push({
                    key: textureKey,
                    frame: value
                  });
                });
              }
              if (!Array.isArray(frames) || frames.length === 0) {
                return out;
              }
              for (i = 0; i < frames.length; i++) {
                var item = frames[i];
                var key = GetValue(item, "key", defaultTextureKey);
                if (!key) {
                  continue;
                }
                var frame = GetValue(item, "frame", 0);
                var textureFrame = textureManager.getFrame(key, frame);
                animationFrame = new Frame(key, frame, index, textureFrame);
                animationFrame.duration = GetValue(item, "duration", 0);
                animationFrame.isFirst = !prev;
                if (prev) {
                  prev.nextFrame = animationFrame;
                  animationFrame.prevFrame = prev;
                }
                out.push(animationFrame);
                prev = animationFrame;
                index++;
              }
              if (out.length > 0) {
                animationFrame.isLast = true;
                animationFrame.nextFrame = out[0];
                out[0].prevFrame = animationFrame;
                var slice = 1 / (out.length - 1);
                for (i = 0; i < out.length; i++) {
                  out[i].progress = i * slice;
                }
              }
              return out;
            },
            getNextTick: function (state) {
              state.accumulator -= state.nextTick;
              state.nextTick = state.msPerFrame + state.currentFrame.duration;
            },
            getFrameByProgress: function (value) {
              value = Clamp(value, 0, 1);
              return FindClosestInSorted(value, this.frames, "progress");
            },
            nextFrame: function (state) {
              var frame = state.currentFrame;
              if (frame.isLast) {
                if (state.yoyo) {
                  this.handleYoyoFrame(state, false);
                } else if (state.repeatCounter > 0) {
                  if (state.inReverse && state.forward) {
                    state.forward = false;
                  } else {
                    this.repeatAnimation(state);
                  }
                } else {
                  state.complete();
                }
              } else {
                this.updateAndGetNextTick(state, frame.nextFrame);
              }
            },
            handleYoyoFrame: function (state, isReverse) {
              if (!isReverse) {
                isReverse = false;
              }
              if (state.inReverse === !isReverse && state.repeatCounter > 0) {
                if (state.repeatDelay === 0 || state.pendingRepeat) {
                  state.forward = isReverse;
                }
                this.repeatAnimation(state);
                return;
              }
              if (state.inReverse !== isReverse && state.repeatCounter === 0) {
                state.complete();
                return;
              }
              state.forward = isReverse;
              var frame = isReverse ? state.currentFrame.nextFrame : state.currentFrame.prevFrame;
              this.updateAndGetNextTick(state, frame);
            },
            getLastFrame: function () {
              return this.frames[this.frames.length - 1];
            },
            previousFrame: function (state) {
              var frame = state.currentFrame;
              if (frame.isFirst) {
                if (state.yoyo) {
                  this.handleYoyoFrame(state, true);
                } else if (state.repeatCounter > 0) {
                  if (state.inReverse && !state.forward) {
                    this.repeatAnimation(state);
                  } else {
                    state.forward = true;
                    this.repeatAnimation(state);
                  }
                } else {
                  state.complete();
                }
              } else {
                this.updateAndGetNextTick(state, frame.prevFrame);
              }
            },
            updateAndGetNextTick: function (state, frame) {
              state.setCurrentFrame(frame);
              this.getNextTick(state);
            },
            removeFrame: function (frame) {
              var index = this.frames.indexOf(frame);
              if (index !== -1) {
                this.removeFrameAt(index);
              }
              return this;
            },
            removeFrameAt: function (index) {
              this.frames.splice(index, 1);
              this.updateFrameSequence();
              return this;
            },
            repeatAnimation: function (state) {
              if (state._pendingStop === 2) {
                if (state._pendingStopValue === 0) {
                  return state.stop();
                } else {
                  state._pendingStopValue--;
                }
              }
              if (state.repeatDelay > 0 && !state.pendingRepeat) {
                state.pendingRepeat = true;
                state.accumulator -= state.nextTick;
                state.nextTick += state.repeatDelay;
              } else {
                state.repeatCounter--;
                if (state.forward) {
                  state.setCurrentFrame(state.currentFrame.nextFrame);
                } else {
                  state.setCurrentFrame(state.currentFrame.prevFrame);
                }
                if (state.isPlaying) {
                  this.getNextTick(state);
                  state.handleRepeat();
                }
              }
            },
            toJSON: function () {
              var output = {
                key: this.key,
                type: this.type,
                frames: [],
                frameRate: this.frameRate,
                duration: this.duration,
                skipMissedFrames: this.skipMissedFrames,
                delay: this.delay,
                repeat: this.repeat,
                repeatDelay: this.repeatDelay,
                yoyo: this.yoyo,
                showOnStart: this.showOnStart,
                hideOnComplete: this.hideOnComplete
              };
              this.frames.forEach(function (frame) {
                output.frames.push(frame.toJSON());
              });
              return output;
            },
            updateFrameSequence: function () {
              var len = this.frames.length;
              var slice = 1 / (len - 1);
              var frame;
              for (var i = 0; i < len; i++) {
                frame = this.frames[i];
                frame.index = i + 1;
                frame.isFirst = false;
                frame.isLast = false;
                frame.progress = i * slice;
                if (i === 0) {
                  frame.isFirst = true;
                  if (len === 1) {
                    frame.isLast = true;
                    frame.nextFrame = frame;
                    frame.prevFrame = frame;
                  } else {
                    frame.isLast = false;
                    frame.prevFrame = this.frames[len - 1];
                    frame.nextFrame = this.frames[i + 1];
                  }
                } else if (i === len - 1 && len > 1) {
                  frame.isLast = true;
                  frame.prevFrame = this.frames[len - 2];
                  frame.nextFrame = this.frames[0];
                } else if (len > 1) {
                  frame.prevFrame = this.frames[i - 1];
                  frame.nextFrame = this.frames[i + 1];
                }
              }
              return this;
            },
            pause: function () {
              this.paused = true;
              return this;
            },
            resume: function () {
              this.paused = false;
              return this;
            },
            destroy: function () {
              if (this.manager.off) {
                this.manager.off(Events.PAUSE_ALL, this.pause, this);
                this.manager.off(Events.RESUME_ALL, this.resume, this);
              }
              this.manager.remove(this.key);
              for (var i = 0; i < this.frames.length; i++) {
                this.frames[i].destroy();
              }
              this.frames = [];
              this.manager = null;
            }
          });
          module2.exports = Animation;
        }, function (module2, exports2) {
          var Pad = function (str, len, pad, dir) {
            if (len === void 0) {
              len = 0;
            }
            if (pad === void 0) {
              pad = " ";
            }
            if (dir === void 0) {
              dir = 3;
            }
            str = str.toString();
            var padlen = 0;
            if (len + 1 >= str.length) {
              switch (dir) {
                case 1:
                  str = new Array(len + 1 - str.length).join(pad) + str;
                  break;
                case 3:
                  var right = Math.ceil((padlen = len - str.length) / 2);
                  var left = padlen - right;
                  str = new Array(left + 1).join(pad) + str + new Array(right + 1).join(pad);
                  break;
                default:
                  str = str + new Array(len + 1 - str.length).join(pad);
                  break;
              }
            }
            return str;
          };
          module2.exports = Pad;
        }, function (module2, exports2, __webpack_require__) {
          var HexStringToColor = __webpack_require__(327);
          var IntegerToColor = __webpack_require__(189);
          var ObjectToColor = __webpack_require__(331);
          var RGBStringToColor = __webpack_require__(332);
          var ValueToColor = function (input) {
            var t = typeof input;
            switch (t) {
              case "string":
                if (input.substr(0, 3).toLowerCase() === "rgb") {
                  return RGBStringToColor(input);
                } else {
                  return HexStringToColor(input);
                }
              case "number":
                return IntegerToColor(input);
              case "object":
                return ObjectToColor(input);
            }
          };
          module2.exports = ValueToColor;
        }, function (module2, exports2, __webpack_require__) {
          var GetColor = __webpack_require__(103);
          function ConvertValue(n, h, s, v) {
            var k = (n + h * 6) % 6;
            var min = Math.min(k, 4 - k, 1);
            return Math.round(255 * (v - v * s * Math.max(0, min)));
          }
          var HSVToRGB = function (h, s, v, out) {
            if (s === void 0) {
              s = 1;
            }
            if (v === void 0) {
              v = 1;
            }
            var r = ConvertValue(5, h, s, v);
            var g = ConvertValue(3, h, s, v);
            var b = ConvertValue(1, h, s, v);
            if (!out) {
              return {
                r,
                g,
                b,
                color: GetColor(r, g, b)
              };
            } else if (out.setTo) {
              return out.setTo(r, g, b, out.alpha, false);
            } else {
              out.r = r;
              out.g = g;
              out.b = b;
              out.color = GetColor(r, g, b);
              return out;
            }
          };
          module2.exports = HSVToRGB;
        }, function (module2, exports2, __webpack_require__) {
          var Color = __webpack_require__(38);
          var IntegerToRGB = __webpack_require__(330);
          var IntegerToColor = function (input) {
            var rgb = IntegerToRGB(input);
            return new Color(rgb.r, rgb.g, rgb.b, rgb.a);
          };
          module2.exports = IntegerToColor;
        }, function (module2, exports2) {
          var CenterOn = function (rect, x, y) {
            rect.x = x - rect.width / 2;
            rect.y = y - rect.height / 2;
            return rect;
          };
          module2.exports = CenterOn;
        }, function (module2, exports2, __webpack_require__) {
          var OS = __webpack_require__(105);
          var Browser = __webpack_require__(136);
          var CanvasPool = __webpack_require__(31);
          var Features = {
            canvas: false,
            canvasBitBltShift: null,
            file: false,
            fileSystem: false,
            getUserMedia: true,
            littleEndian: false,
            localStorage: false,
            pointerLock: false,
            support32bit: false,
            vibration: false,
            webGL: false,
            worker: false
          };
          function checkIsLittleEndian() {
            var a = new ArrayBuffer(4);
            var b = new Uint8Array(a);
            var c = new Uint32Array(a);
            b[0] = 161;
            b[1] = 178;
            b[2] = 195;
            b[3] = 212;
            if (c[0] === 3569595041) {
              return true;
            }
            if (c[0] === 2712847316) {
              return false;
            } else {
              return null;
            }
          }
          function init() {
            if (typeof importScripts === "function") {
              return Features;
            }
            Features.canvas = !!window["CanvasRenderingContext2D"];
            try {
              Features.localStorage = !!localStorage.getItem;
            } catch (error) {
              Features.localStorage = false;
            }
            Features.file = !!window["File"] && !!window["FileReader"] && !!window["FileList"] && !!window["Blob"];
            Features.fileSystem = !!window["requestFileSystem"];
            var isUint8 = false;
            var testWebGL = function () {
              if (window["WebGLRenderingContext"]) {
                try {
                  var canvas = CanvasPool.createWebGL(this);
                  var ctx = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
                  var canvas2D = CanvasPool.create2D(this);
                  var ctx2D = canvas2D.getContext("2d");
                  var image = ctx2D.createImageData(1, 1);
                  isUint8 = image.data instanceof Uint8ClampedArray;
                  CanvasPool.remove(canvas);
                  CanvasPool.remove(canvas2D);
                  return !!ctx;
                } catch (e) {
                  return false;
                }
              }
              return false;
            };
            Features.webGL = testWebGL();
            Features.worker = !!window["Worker"];
            Features.pointerLock = ("pointerLockElement" in document) || ("mozPointerLockElement" in document) || ("webkitPointerLockElement" in document);
            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;
            window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
            Features.getUserMedia = Features.getUserMedia && !!navigator.getUserMedia && !!window.URL;
            if (Browser.firefox && Browser.firefoxVersion < 21) {
              Features.getUserMedia = false;
            }
            if (!OS.iOS && (Browser.ie || Browser.firefox || Browser.chrome)) {
              Features.canvasBitBltShift = true;
            }
            if (Browser.safari || Browser.mobileSafari) {
              Features.canvasBitBltShift = false;
            }
            navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;
            if (navigator.vibrate) {
              Features.vibration = true;
            }
            if (typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint32Array !== "undefined") {
              Features.littleEndian = checkIsLittleEndian();
            }
            Features.support32bit = typeof ArrayBuffer !== "undefined" && typeof Uint8ClampedArray !== "undefined" && typeof Int32Array !== "undefined" && Features.littleEndian !== null && isUint8;
            return Features;
          }
          module2.exports = init();
        }, function (module2, exports2) {
          var prefix = "";
          var Smoothing = function () {
            var getPrefix = function (context) {
              var vendors = ["i", "webkitI", "msI", "mozI", "oI"];
              for (var i = 0; i < vendors.length; i++) {
                var s = vendors[i] + "mageSmoothingEnabled";
                if ((s in context)) {
                  return s;
                }
              }
              return null;
            };
            var enable = function (context) {
              if (prefix === "") {
                prefix = getPrefix(context);
              }
              if (prefix) {
                context[prefix] = true;
              }
              return context;
            };
            var disable = function (context) {
              if (prefix === "") {
                prefix = getPrefix(context);
              }
              if (prefix) {
                context[prefix] = false;
              }
              return context;
            };
            var isEnabled = function (context) {
              return prefix !== null ? context[prefix] : null;
            };
            return {
              disable,
              enable,
              getPrefix,
              isEnabled
            };
          };
          module2.exports = Smoothing();
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(14);
          var Extend = __webpack_require__(17);
          var PhaserMath = {
            Angle: __webpack_require__(812),
            Distance: __webpack_require__(821),
            Easing: __webpack_require__(826),
            Fuzzy: __webpack_require__(827),
            Interpolation: __webpack_require__(830),
            Pow2: __webpack_require__(835),
            Snap: __webpack_require__(837),
            RandomDataGenerator: __webpack_require__(839),
            Average: __webpack_require__(840),
            Bernstein: __webpack_require__(356),
            Between: __webpack_require__(195),
            CatmullRom: __webpack_require__(194),
            CeilTo: __webpack_require__(841),
            Clamp: __webpack_require__(18),
            DegToRad: __webpack_require__(36),
            Difference: __webpack_require__(842),
            Euler: __webpack_require__(843),
            Factorial: __webpack_require__(357),
            FloatBetween: __webpack_require__(137),
            FloorTo: __webpack_require__(844),
            FromPercent: __webpack_require__(98),
            GetSpeed: __webpack_require__(845),
            IsEven: __webpack_require__(846),
            IsEvenStrict: __webpack_require__(847),
            Linear: __webpack_require__(135),
            MaxAdd: __webpack_require__(848),
            Median: __webpack_require__(849),
            MinSub: __webpack_require__(850),
            Percent: __webpack_require__(851),
            RadToDeg: __webpack_require__(196),
            RandomXY: __webpack_require__(852),
            RandomXYZ: __webpack_require__(853),
            RandomXYZW: __webpack_require__(854),
            Rotate: __webpack_require__(362),
            RotateAround: __webpack_require__(308),
            RotateAroundDistance: __webpack_require__(182),
            RotateTo: __webpack_require__(855),
            RoundAwayFromZero: __webpack_require__(363),
            RoundTo: __webpack_require__(856),
            SinCosTableGenerator: __webpack_require__(857),
            SmootherStep: __webpack_require__(183),
            SmoothStep: __webpack_require__(184),
            ToXY: __webpack_require__(858),
            TransformXY: __webpack_require__(177),
            Within: __webpack_require__(859),
            Wrap: __webpack_require__(68),
            Vector2: __webpack_require__(3),
            Vector3: __webpack_require__(39),
            Vector4: __webpack_require__(140),
            Matrix3: __webpack_require__(364),
            Matrix4: __webpack_require__(69),
            Quaternion: __webpack_require__(365),
            RotateVec3: __webpack_require__(860)
          };
          PhaserMath = Extend(false, PhaserMath, CONST);
          module2.exports = PhaserMath;
        }, function (module2, exports2) {
          var CatmullRom = function (t, p0, p1, p22, p3) {
            var v0 = (p22 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            var t2 = t * t;
            var t3 = t * t2;
            return (2 * p1 - 2 * p22 + v0 + v1) * t3 + (-3 * p1 + 3 * p22 - 2 * v0 - v1) * t2 + v0 * t + p1;
          };
          module2.exports = CatmullRom;
        }, function (module2, exports2) {
          var Between = function (min, max) {
            return Math.floor(Math.random() * (max - min + 1) + min);
          };
          module2.exports = Between;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(14);
          var RadToDeg = function (radians) {
            return radians * CONST.RAD_TO_DEG;
          };
          module2.exports = RadToDeg;
        }, function (module2, exports2, __webpack_require__) {
          var DefaultPlugins = {
            Global: ["game", "anims", "cache", "plugins", "registry", "scale", "sound", "textures", "renderer"],
            CoreScene: ["EventEmitter", "CameraManager", "GameObjectCreator", "GameObjectFactory", "ScenePlugin", "DisplayList", "UpdateList"],
            DefaultScene: ["Clock", "DataManagerPlugin", "InputPlugin", "Loader", "TweenManager", "LightsPlugin"]
          };
          if (false) {}
          if (false) {}
          module2.exports = DefaultPlugins;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var ColorMatrix = new Class({
            initialize: function ColorMatrix2() {
              this._matrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
              this.alpha = 1;
              this._dirty = true;
              this._data;
            },
            set: function (value) {
              this._matrix = value;
              this._dirty = true;
              return this;
            },
            reset: function () {
              var m = this._matrix;
              m[0] = 1;
              m[1] = 0;
              m[2] = 0;
              m[3] = 0;
              m[4] = 0;
              m[5] = 0;
              m[6] = 1;
              m[7] = 0;
              m[8] = 0;
              m[9] = 0;
              m[10] = 0;
              m[11] = 0;
              m[12] = 1;
              m[13] = 0;
              m[14] = 0;
              m[15] = 0;
              m[16] = 0;
              m[17] = 0;
              m[18] = 1;
              m[19] = 0;
              this._dirty = true;
              return this;
            },
            getData: function () {
              if (this._dirty) {
                var f32 = new Float32Array(this._matrix);
                f32[4] /= 255;
                f32[9] /= 255;
                f32[14] /= 255;
                f32[19] /= 255;
                this._data = f32;
                this._dirty = false;
              }
              return this._data;
            },
            brightness: function (value, multiply) {
              if (value === void 0) {
                value = 0;
              }
              if (multiply === void 0) {
                multiply = false;
              }
              var b = value;
              return this.multiply([b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, 1, 0], multiply);
            },
            saturate: function (value, multiply) {
              if (value === void 0) {
                value = 0;
              }
              if (multiply === void 0) {
                multiply = false;
              }
              var x = value * 2 / 3 + 1;
              var y = (x - 1) * -0.5;
              return this.multiply([x, y, y, 0, 0, y, x, y, 0, 0, y, y, x, 0, 0, 0, 0, 0, 1, 0], multiply);
            },
            desaturate: function (multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.saturate(-1, multiply);
            },
            hue: function (rotation, multiply) {
              if (rotation === void 0) {
                rotation = 0;
              }
              if (multiply === void 0) {
                multiply = false;
              }
              rotation = rotation / 180 * Math.PI;
              var cos = Math.cos(rotation);
              var sin = Math.sin(rotation);
              var lumR = 0.213;
              var lumG = 0.715;
              var lumB = 0.072;
              return this.multiply([lumR + cos * (1 - lumR) + sin * -lumR, lumG + cos * -lumG + sin * -lumG, lumB + cos * -lumB + sin * (1 - lumB), 0, 0, lumR + cos * -lumR + sin * 0.143, lumG + cos * (1 - lumG) + sin * 0.14, lumB + cos * -lumB + sin * -0.283, 0, 0, lumR + cos * -lumR + sin * -(1 - lumR), lumG + cos * -lumG + sin * lumG, lumB + cos * (1 - lumB) + sin * lumB, 0, 0, 0, 0, 0, 1, 0], multiply);
            },
            grayscale: function (value, multiply) {
              if (value === void 0) {
                value = 1;
              }
              if (multiply === void 0) {
                multiply = false;
              }
              return this.saturate(-value, multiply);
            },
            blackWhite: function (multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1, 0], multiply);
            },
            contrast: function (value, multiply) {
              if (value === void 0) {
                value = 0;
              }
              if (multiply === void 0) {
                multiply = false;
              }
              var v = value + 1;
              var o = -0.5 * (v - 1);
              return this.multiply([v, 0, 0, 0, o, 0, v, 0, 0, o, 0, 0, v, 0, o, 0, 0, 0, 1, 0], multiply);
            },
            negative: function (multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], multiply);
            },
            desaturateLuminance: function (multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([0.2764723, 0.929708, 0.0938197, 0, -37.1, 0.2764723, 0.929708, 0.0938197, 0, -37.1, 0.2764723, 0.929708, 0.0938197, 0, -37.1, 0, 0, 0, 1, 0], multiply);
            },
            sepia: function (multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0], multiply);
            },
            night: function (intensity, multiply) {
              if (intensity === void 0) {
                intensity = 0.1;
              }
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([intensity * -2, -intensity, 0, 0, 0, -intensity, 0, intensity, 0, 0, 0, intensity, intensity * 2, 0, 0, 0, 0, 0, 1, 0], multiply);
            },
            lsd: function (multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1, 0], multiply);
            },
            brown: function (multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0], multiply);
            },
            vintagePinhole: function (multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123, 0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], multiply);
            },
            kodachrome: function (multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0], multiply);
            },
            technicolor: function (multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], multiply);
            },
            polaroid: function (multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0], multiply);
            },
            shiftToBGR: function (multiply) {
              if (multiply === void 0) {
                multiply = false;
              }
              return this.multiply([0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], multiply);
            },
            multiply: function (a, multiply) {
              if (!multiply) {
                this.reset();
              }
              var m = this._matrix;
              var c = [];
              for (var i = 0; i < 20; i++) {
                c[i] = m[i];
              }
              m[0] = c[0] * a[0] + c[1] * a[5] + c[2] * a[10] + c[3] * a[15];
              m[1] = c[0] * a[1] + c[1] * a[6] + c[2] * a[11] + c[3] * a[16];
              m[2] = c[0] * a[2] + c[1] * a[7] + c[2] * a[12] + c[3] * a[17];
              m[3] = c[0] * a[3] + c[1] * a[8] + c[2] * a[13] + c[3] * a[18];
              m[4] = c[0] * a[4] + c[1] * a[9] + c[2] * a[14] + c[3] * a[19] + c[4];
              m[5] = c[5] * a[0] + c[6] * a[5] + c[7] * a[10] + c[8] * a[15];
              m[6] = c[5] * a[1] + c[6] * a[6] + c[7] * a[11] + c[8] * a[16];
              m[7] = c[5] * a[2] + c[6] * a[7] + c[7] * a[12] + c[8] * a[17];
              m[8] = c[5] * a[3] + c[6] * a[8] + c[7] * a[13] + c[8] * a[18];
              m[9] = c[5] * a[4] + c[6] * a[9] + c[7] * a[14] + c[8] * a[19] + c[9];
              m[10] = c[10] * a[0] + c[11] * a[5] + c[12] * a[10] + c[13] * a[15];
              m[11] = c[10] * a[1] + c[11] * a[6] + c[12] * a[11] + c[13] * a[16];
              m[12] = c[10] * a[2] + c[11] * a[7] + c[12] * a[12] + c[13] * a[17];
              m[13] = c[10] * a[3] + c[11] * a[8] + c[12] * a[13] + c[13] * a[18];
              m[14] = c[10] * a[4] + c[11] * a[9] + c[12] * a[14] + c[13] * a[19] + c[14];
              m[15] = c[15] * a[0] + c[16] * a[5] + c[17] * a[10] + c[18] * a[15];
              m[16] = c[15] * a[1] + c[16] * a[6] + c[17] * a[11] + c[18] * a[16];
              m[17] = c[15] * a[2] + c[16] * a[7] + c[17] * a[12] + c[18] * a[17];
              m[18] = c[15] * a[3] + c[16] * a[8] + c[17] * a[13] + c[18] * a[18];
              m[19] = c[15] * a[4] + c[16] * a[9] + c[17] * a[14] + c[18] * a[19] + c[19];
              this._dirty = true;
              return this;
            }
          });
          module2.exports = ColorMatrix;
        }, function (module2, exports2, __webpack_require__) {
          var Rectangle = __webpack_require__(10);
          var MATH_CONST = __webpack_require__(14);
          var FromPoints = function (points, out) {
            if (out === void 0) {
              out = new Rectangle();
            }
            if (points.length === 0) {
              return out;
            }
            var minX = Number.MAX_VALUE;
            var minY = Number.MAX_VALUE;
            var maxX = MATH_CONST.MIN_SAFE_INTEGER;
            var maxY = MATH_CONST.MIN_SAFE_INTEGER;
            var p3;
            var px;
            var py;
            for (var i = 0; i < points.length; i++) {
              p3 = points[i];
              if (Array.isArray(p3)) {
                px = p3[0];
                py = p3[1];
              } else {
                px = p3.x;
                py = p3.y;
              }
              minX = Math.min(minX, px);
              minY = Math.min(minY, py);
              maxX = Math.max(maxX, px);
              maxY = Math.max(maxY, py);
            }
            out.x = minX;
            out.y = minY;
            out.width = maxX - minX;
            out.height = maxY - minY;
            return out;
          };
          module2.exports = FromPoints;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var NOOP = __webpack_require__(1);
          var RGB = new Class({
            initialize: function RGB2(red, green, blue) {
              this._rgb = [0, 0, 0];
              this.onChangeCallback = NOOP;
              this.dirty = false;
              this.set(red, green, blue);
            },
            set: function (red, green, blue) {
              if (red === void 0) {
                red = 0;
              }
              if (green === void 0) {
                green = 0;
              }
              if (blue === void 0) {
                blue = 0;
              }
              this._rgb = [red, green, blue];
              this.onChange();
              return this;
            },
            equals: function (red, green, blue) {
              var rgb = this._rgb;
              return rgb.r === red && rgb.g === green && rgb.b === blue;
            },
            onChange: function () {
              this.dirty = true;
              var rgb = this._rgb;
              this.onChangeCallback.call(this, rgb[0], rgb[1], rgb[2]);
            },
            r: {
              get: function () {
                return this._rgb[0];
              },
              set: function (value) {
                this._rgb[0] = value;
                this.onChange();
              }
            },
            g: {
              get: function () {
                return this._rgb[1];
              },
              set: function (value) {
                this._rgb[1] = value;
                this.onChange();
              }
            },
            b: {
              get: function () {
                return this._rgb[2];
              },
              set: function (value) {
                this._rgb[2] = value;
                this.onChange();
              }
            },
            destroy: function () {
              this.onChangeCallback = null;
            }
          });
          module2.exports = RGB;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = {
            CENTER: __webpack_require__(403),
            ORIENTATION: __webpack_require__(404),
            SCALE_MODE: __webpack_require__(405),
            ZOOM: __webpack_require__(406)
          };
          module2.exports = CONST;
        }, function (module2, exports2) {
          var RemoveFromDOM = function (element) {
            if (element.parentNode) {
              element.parentNode.removeChild(element);
            }
          };
          module2.exports = RemoveFromDOM;
        }, function (module2, exports2) {
          var INPUT_CONST = {
            MOUSE_DOWN: 0,
            MOUSE_MOVE: 1,
            MOUSE_UP: 2,
            TOUCH_START: 3,
            TOUCH_MOVE: 4,
            TOUCH_END: 5,
            POINTER_LOCK_CHANGE: 6,
            TOUCH_CANCEL: 7,
            MOUSE_WHEEL: 8
          };
          module2.exports = INPUT_CONST;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(144);
          var DefaultPlugins = __webpack_require__(197);
          var Events = __webpack_require__(20);
          var GetPhysicsPlugins = __webpack_require__(419);
          var GetScenePlugins = __webpack_require__(420);
          var GLOBAL_CONST = __webpack_require__(33);
          var NOOP = __webpack_require__(1);
          var Settings = __webpack_require__(421);
          var Systems = new Class({
            initialize: function Systems2(scene, config) {
              this.scene = scene;
              this.game;
              this.renderer;
              if (false) {}
              this.config = config;
              this.settings = Settings.create(config);
              this.canvas;
              this.context;
              this.anims;
              this.cache;
              this.plugins;
              this.registry;
              this.scale;
              this.sound;
              this.textures;
              this.add;
              this.cameras;
              this.displayList;
              this.events;
              this.make;
              this.scenePlugin;
              this.updateList;
              this.sceneUpdate = NOOP;
            },
            init: function (game) {
              this.settings.status = CONST.INIT;
              this.sceneUpdate = NOOP;
              this.game = game;
              this.renderer = game.renderer;
              this.canvas = game.canvas;
              this.context = game.context;
              var pluginManager = game.plugins;
              this.plugins = pluginManager;
              pluginManager.addToScene(this, DefaultPlugins.Global, [DefaultPlugins.CoreScene, GetScenePlugins(this), GetPhysicsPlugins(this)]);
              this.events.emit(Events.BOOT, this);
              this.settings.isBooted = true;
            },
            step: function (time, delta) {
              var events = this.events;
              events.emit(Events.PRE_UPDATE, time, delta);
              events.emit(Events.UPDATE, time, delta);
              this.sceneUpdate.call(this.scene, time, delta);
              events.emit(Events.POST_UPDATE, time, delta);
            },
            render: function (renderer) {
              var displayList = this.displayList;
              displayList.depthSort();
              this.events.emit(Events.PRE_RENDER, renderer);
              this.cameras.render(renderer, displayList);
              this.events.emit(Events.RENDER, renderer);
            },
            queueDepthSort: function () {
              this.displayList.queueDepthSort();
            },
            depthSort: function () {
              this.displayList.depthSort();
            },
            pause: function (data) {
              var events = this.events;
              var settings = this.settings;
              if (this.settings.active) {
                settings.status = CONST.PAUSED;
                settings.active = false;
                events.emit(Events.PAUSE, this, data);
              }
              return this;
            },
            resume: function (data) {
              var events = this.events;
              var settings = this.settings;
              if (!this.settings.active) {
                settings.status = CONST.RUNNING;
                settings.active = true;
                events.emit(Events.RESUME, this, data);
              }
              return this;
            },
            sleep: function (data) {
              var events = this.events;
              var settings = this.settings;
              settings.status = CONST.SLEEPING;
              settings.active = false;
              settings.visible = false;
              events.emit(Events.SLEEP, this, data);
              return this;
            },
            wake: function (data) {
              var events = this.events;
              var settings = this.settings;
              settings.status = CONST.RUNNING;
              settings.active = true;
              settings.visible = true;
              events.emit(Events.WAKE, this, data);
              if (settings.isTransition) {
                events.emit(Events.TRANSITION_WAKE, settings.transitionFrom, settings.transitionDuration);
              }
              return this;
            },
            getData: function () {
              return this.settings.data;
            },
            isSleeping: function () {
              return this.settings.status === CONST.SLEEPING;
            },
            isActive: function () {
              return this.settings.status === CONST.RUNNING;
            },
            isPaused: function () {
              return this.settings.status === CONST.PAUSED;
            },
            isTransitioning: function () {
              return this.settings.isTransition || this.scenePlugin._target !== null;
            },
            isTransitionOut: function () {
              return this.scenePlugin._target !== null && this.scenePlugin._duration > 0;
            },
            isTransitionIn: function () {
              return this.settings.isTransition;
            },
            isVisible: function () {
              return this.settings.visible;
            },
            setVisible: function (value) {
              this.settings.visible = value;
              return this;
            },
            setActive: function (value, data) {
              if (value) {
                return this.resume(data);
              } else {
                return this.pause(data);
              }
            },
            start: function (data) {
              var events = this.events;
              var settings = this.settings;
              if (data) {
                settings.data = data;
              }
              settings.status = CONST.START;
              settings.active = true;
              settings.visible = true;
              events.emit(Events.START, this);
              events.emit(Events.READY, this, data);
            },
            shutdown: function (data) {
              var events = this.events;
              var settings = this.settings;
              events.off(Events.TRANSITION_INIT);
              events.off(Events.TRANSITION_START);
              events.off(Events.TRANSITION_COMPLETE);
              events.off(Events.TRANSITION_OUT);
              settings.status = CONST.SHUTDOWN;
              settings.active = false;
              settings.visible = false;
              if (this.renderer === GLOBAL_CONST.WEBGL) {
                this.renderer.resetTextures(true);
              }
              events.emit(Events.SHUTDOWN, this, data);
            },
            destroy: function () {
              var events = this.events;
              var settings = this.settings;
              settings.status = CONST.DESTROYED;
              settings.active = false;
              settings.visible = false;
              events.emit(Events.DESTROY, this);
              events.removeAllListeners();
              var props = ["scene", "game", "anims", "cache", "plugins", "registry", "sound", "textures", "add", "camera", "displayList", "events", "make", "scenePlugin", "updateList"];
              for (var i = 0; i < props.length; i++) {
                this[props[i]] = null;
              }
            }
          });
          module2.exports = Systems;
        }, function (module2, exports2) {
          var UppercaseFirst = function (str) {
            return str && str[0].toUpperCase() + str.slice(1);
          };
          module2.exports = UppercaseFirst;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(33);
          var Class = __webpack_require__(0);
          var Frame = __webpack_require__(109);
          var TextureSource = __webpack_require__(424);
          var TEXTURE_MISSING_ERROR = "Texture.frame missing: ";
          var Texture = new Class({
            initialize: function Texture2(manager, key, source, width, height) {
              if (!Array.isArray(source)) {
                source = [source];
              }
              this.manager = manager;
              this.key = key;
              this.source = [];
              this.dataSource = [];
              this.frames = {};
              this.customData = {};
              this.firstFrame = "__BASE";
              this.frameTotal = 0;
              for (var i = 0; i < source.length; i++) {
                this.source.push(new TextureSource(this, source[i], width, height));
              }
            },
            add: function (name, sourceIndex, x, y, width, height) {
              if (this.has(name)) {
                return null;
              }
              var frame = new Frame(this, name, sourceIndex, x, y, width, height);
              this.frames[name] = frame;
              if (this.firstFrame === "__BASE") {
                this.firstFrame = name;
              }
              this.frameTotal++;
              return frame;
            },
            remove: function (name) {
              if (this.has(name)) {
                var frame = this.get(name);
                frame.destroy();
                delete this.frames[name];
                return true;
              }
              return false;
            },
            has: function (name) {
              return this.frames[name];
            },
            get: function (name) {
              if (!name) {
                name = this.firstFrame;
              }
              var frame = this.frames[name];
              if (!frame) {
                console.warn(TEXTURE_MISSING_ERROR + name);
                frame = this.frames[this.firstFrame];
              }
              return frame;
            },
            getTextureSourceIndex: function (source) {
              for (var i = 0; i < this.source.length; i++) {
                if (this.source[i] === source) {
                  return i;
                }
              }
              return -1;
            },
            getFramesFromTextureSource: function (sourceIndex, includeBase) {
              if (includeBase === void 0) {
                includeBase = false;
              }
              var out = [];
              for (var frameName in this.frames) {
                if (frameName === "__BASE" && !includeBase) {
                  continue;
                }
                var frame = this.frames[frameName];
                if (frame.sourceIndex === sourceIndex) {
                  out.push(frame);
                }
              }
              return out;
            },
            getFrameNames: function (includeBase) {
              if (includeBase === void 0) {
                includeBase = false;
              }
              var out = Object.keys(this.frames);
              if (!includeBase) {
                var idx = out.indexOf("__BASE");
                if (idx !== -1) {
                  out.splice(idx, 1);
                }
              }
              return out;
            },
            getSourceImage: function (name) {
              if (name === void 0 || name === null || this.frameTotal === 1) {
                name = "__BASE";
              }
              var frame = this.frames[name];
              if (frame) {
                return frame.source.image;
              } else {
                console.warn(TEXTURE_MISSING_ERROR + name);
                return this.frames["__BASE"].source.image;
              }
            },
            getDataSourceImage: function (name) {
              if (name === void 0 || name === null || this.frameTotal === 1) {
                name = "__BASE";
              }
              var frame = this.frames[name];
              var idx;
              if (!frame) {
                console.warn(TEXTURE_MISSING_ERROR + name);
                idx = this.frames["__BASE"].sourceIndex;
              } else {
                idx = frame.sourceIndex;
              }
              return this.dataSource[idx].image;
            },
            setDataSource: function (data) {
              if (!Array.isArray(data)) {
                data = [data];
              }
              for (var i = 0; i < data.length; i++) {
                var source = this.source[i];
                this.dataSource.push(new TextureSource(this, data[i], source.width, source.height));
              }
            },
            setFilter: function (filterMode) {
              var i;
              for (i = 0; i < this.source.length; i++) {
                this.source[i].setFilter(filterMode);
              }
              for (i = 0; i < this.dataSource.length; i++) {
                this.dataSource[i].setFilter(filterMode);
              }
            },
            destroy: function () {
              var i;
              for (i = 0; i < this.source.length; i++) {
                this.source[i].destroy();
              }
              for (i = 0; i < this.dataSource.length; i++) {
                this.dataSource[i].destroy();
              }
              for (var frameName in this.frames) {
                var frame = this.frames[frameName];
                frame.destroy();
              }
              this.source = [];
              this.dataSource = [];
              this.frames = {};
              this.manager.removeKey(this.key);
              var renderer = this.manager.game.renderer;
              if (renderer && renderer.type === CONST.WEBGL) {
                renderer.resetTextures(true);
              }
              this.manager = null;
            }
          });
          module2.exports = Texture;
        }, function (module2, exports2, __webpack_require__) {
          var SafeRange = __webpack_require__(78);
          var GetAll = function (array, property, value, startIndex, endIndex) {
            if (startIndex === void 0) {
              startIndex = 0;
            }
            if (endIndex === void 0) {
              endIndex = array.length;
            }
            var output = [];
            if (SafeRange(array, startIndex, endIndex)) {
              for (var i = startIndex; i < endIndex; i++) {
                var child = array[i];
                if (!property || property && value === void 0 && child.hasOwnProperty(property) || property && value !== void 0 && child[property] === value) {
                  output.push(child);
                }
              }
            }
            return output;
          };
          module2.exports = GetAll;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Matrix: __webpack_require__(1013),
            Add: __webpack_require__(1021),
            AddAt: __webpack_require__(1022),
            BringToTop: __webpack_require__(1023),
            CountAllMatching: __webpack_require__(1024),
            Each: __webpack_require__(1025),
            EachInRange: __webpack_require__(1026),
            FindClosestInSorted: __webpack_require__(318),
            GetAll: __webpack_require__(207),
            GetFirst: __webpack_require__(428),
            GetRandom: __webpack_require__(210),
            MoveDown: __webpack_require__(1027),
            MoveTo: __webpack_require__(1028),
            MoveUp: __webpack_require__(1029),
            MoveAbove: __webpack_require__(1030),
            MoveBelow: __webpack_require__(1031),
            NumberArray: __webpack_require__(322),
            NumberArrayStep: __webpack_require__(1032),
            QuickSelect: __webpack_require__(436),
            Range: __webpack_require__(437),
            Remove: __webpack_require__(93),
            RemoveAt: __webpack_require__(1033),
            RemoveBetween: __webpack_require__(1034),
            RemoveRandomElement: __webpack_require__(1035),
            Replace: __webpack_require__(1036),
            RotateLeft: __webpack_require__(178),
            RotateRight: __webpack_require__(179),
            SafeRange: __webpack_require__(78),
            SendToBack: __webpack_require__(1037),
            SetAll: __webpack_require__(1038),
            Shuffle: __webpack_require__(131),
            SortByDigits: __webpack_require__(320),
            SpliceOne: __webpack_require__(74),
            StableSort: __webpack_require__(79),
            Swap: __webpack_require__(1039)
          };
        }, function (module2, exports2) {
          var CheckMatrix = function (matrix) {
            if (!Array.isArray(matrix) || matrix.length < 2 || !Array.isArray(matrix[0])) {
              return false;
            }
            var size = matrix[0].length;
            for (var i = 1; i < matrix.length; i++) {
              if (matrix[i].length !== size) {
                return false;
              }
            }
            return true;
          };
          module2.exports = CheckMatrix;
        }, function (module2, exports2) {
          var GetRandom = function (array, startIndex, length) {
            if (startIndex === void 0) {
              startIndex = 0;
            }
            if (length === void 0) {
              length = array.length;
            }
            var randomIndex = startIndex + Math.floor(Math.random() * length);
            return array[randomIndex] === void 0 ? null : array[randomIndex];
          };
          module2.exports = GetRandom;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(438);
          var ProcessQueue = new Class({
            Extends: EventEmitter,
            initialize: function ProcessQueue2() {
              EventEmitter.call(this);
              this._pending = [];
              this._active = [];
              this._destroy = [];
              this._toProcess = 0;
              this.checkQueue = false;
            },
            add: function (item) {
              this._pending.push(item);
              this._toProcess++;
              return item;
            },
            remove: function (item) {
              this._destroy.push(item);
              this._toProcess++;
              return item;
            },
            removeAll: function () {
              var list = this._active;
              var destroy = this._destroy;
              var i = list.length;
              while (i--) {
                destroy.push(list[i]);
                this._toProcess++;
              }
              return this;
            },
            update: function () {
              if (this._toProcess === 0) {
                return this._active;
              }
              var list = this._destroy;
              var active = this._active;
              var i;
              var item;
              for (i = 0; i < list.length; i++) {
                item = list[i];
                var idx = active.indexOf(item);
                if (idx !== -1) {
                  active.splice(idx, 1);
                  this.emit(Events.PROCESS_QUEUE_REMOVE, item);
                }
              }
              list.length = 0;
              list = this._pending;
              for (i = 0; i < list.length; i++) {
                item = list[i];
                if (!this.checkQueue || this.checkQueue && active.indexOf(item) === -1) {
                  active.push(item);
                  this.emit(Events.PROCESS_QUEUE_ADD, item);
                }
              }
              list.length = 0;
              this._toProcess = 0;
              return active;
            },
            getActive: function () {
              return this._active;
            },
            length: {
              get: function () {
                return this._active.length;
              }
            },
            destroy: function () {
              this._toProcess = 0;
              this._pending = [];
              this._active = [];
              this._destroy = [];
            }
          });
          module2.exports = ProcessQueue;
        }, function (module2, exports2) {
          function getValue(node, attribute) {
            return parseInt(node.getAttribute(attribute), 10);
          }
          var ParseXMLBitmapFont = function (xml, frame, xSpacing, ySpacing, texture) {
            if (xSpacing === void 0) {
              xSpacing = 0;
            }
            if (ySpacing === void 0) {
              ySpacing = 0;
            }
            var textureX = frame.cutX;
            var textureY = frame.cutY;
            var textureWidth = frame.source.width;
            var textureHeight = frame.source.height;
            var sourceIndex = frame.sourceIndex;
            var data = {};
            var info = xml.getElementsByTagName("info")[0];
            var common = xml.getElementsByTagName("common")[0];
            data.font = info.getAttribute("face");
            data.size = getValue(info, "size");
            data.lineHeight = getValue(common, "lineHeight") + ySpacing;
            data.chars = {};
            var letters = xml.getElementsByTagName("char");
            var adjustForTrim = frame !== void 0 && frame.trimmed;
            if (adjustForTrim) {
              var top = frame.height;
              var left = frame.width;
            }
            for (var i = 0; i < letters.length; i++) {
              var node = letters[i];
              var charCode = getValue(node, "id");
              var letter = String.fromCharCode(charCode);
              var gx = getValue(node, "x");
              var gy = getValue(node, "y");
              var gw = getValue(node, "width");
              var gh = getValue(node, "height");
              if (adjustForTrim) {
                if (gx < left) {
                  left = gx;
                }
                if (gy < top) {
                  top = gy;
                }
              }
              if (adjustForTrim && top !== 0 && left !== 0) {
                gx -= frame.x;
                gy -= frame.y;
              }
              var u0 = (textureX + gx) / textureWidth;
              var v0 = (textureY + gy) / textureHeight;
              var u1 = (textureX + gx + gw) / textureWidth;
              var v1 = (textureY + gy + gh) / textureHeight;
              data.chars[charCode] = {
                x: gx,
                y: gy,
                width: gw,
                height: gh,
                centerX: Math.floor(gw / 2),
                centerY: Math.floor(gh / 2),
                xOffset: getValue(node, "xoffset"),
                yOffset: getValue(node, "yoffset"),
                xAdvance: getValue(node, "xadvance") + xSpacing,
                data: {},
                kerning: {},
                u0,
                v0,
                u1,
                v1
              };
              if (texture && gw !== 0 && gh !== 0) {
                var charFrame = texture.add(letter, sourceIndex, gx, gy, gw, gh);
                if (charFrame) {
                  charFrame.setUVs(gw, gh, u0, v0, u1, v1);
                }
              }
            }
            var kernings = xml.getElementsByTagName("kerning");
            for (i = 0; i < kernings.length; i++) {
              var kern = kernings[i];
              var first = getValue(kern, "first");
              var second = getValue(kern, "second");
              var amount = getValue(kern, "amount");
              data.chars[second].kerning[first] = amount;
            }
            return data;
          };
          module2.exports = ParseXMLBitmapFont;
        }, function (module2, exports2, __webpack_require__) {
          var BlitterRender = __webpack_require__(1049);
          var Bob = __webpack_require__(440);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var Frame = __webpack_require__(109);
          var GameObject = __webpack_require__(15);
          var List = __webpack_require__(110);
          var Blitter = new Class({
            Extends: GameObject,
            Mixins: [Components.Alpha, Components.BlendMode, Components.Depth, Components.Mask, Components.Pipeline, Components.ScrollFactor, Components.Size, Components.Texture, Components.Transform, Components.Visible, BlitterRender],
            initialize: function Blitter2(scene, x, y, texture, frame) {
              GameObject.call(this, scene, "Blitter");
              this.setTexture(texture, frame);
              this.setPosition(x, y);
              this.initPipeline();
              this.children = new List();
              this.renderList = [];
              this.dirty = false;
            },
            create: function (x, y, frame, visible, index) {
              if (visible === void 0) {
                visible = true;
              }
              if (index === void 0) {
                index = this.children.length;
              }
              if (frame === void 0) {
                frame = this.frame;
              } else if (!(frame instanceof Frame)) {
                frame = this.texture.get(frame);
              }
              var bob = new Bob(this, x, y, frame, visible);
              this.children.addAt(bob, index, false);
              this.dirty = true;
              return bob;
            },
            createFromCallback: function (callback, quantity, frame, visible) {
              var bobs = this.createMultiple(quantity, frame, visible);
              for (var i = 0; i < bobs.length; i++) {
                var bob = bobs[i];
                callback.call(this, bob, i);
              }
              return bobs;
            },
            createMultiple: function (quantity, frame, visible) {
              if (frame === void 0) {
                frame = this.frame.name;
              }
              if (visible === void 0) {
                visible = true;
              }
              if (!Array.isArray(frame)) {
                frame = [frame];
              }
              var bobs = [];
              var _this = this;
              frame.forEach(function (singleFrame) {
                for (var i = 0; i < quantity; i++) {
                  bobs.push(_this.create(0, 0, singleFrame, visible));
                }
              });
              return bobs;
            },
            childCanRender: function (child) {
              return child.visible && child.alpha > 0;
            },
            getRenderList: function () {
              if (this.dirty) {
                this.renderList = this.children.list.filter(this.childCanRender, this);
                this.dirty = false;
              }
              return this.renderList;
            },
            clear: function () {
              this.children.removeAll();
              this.dirty = true;
            },
            preDestroy: function () {
              this.children.destroy();
              this.renderList = [];
            }
          });
          module2.exports = Blitter;
        }, function (module2, exports2, __webpack_require__) {
          var ArrayUtils = __webpack_require__(208);
          var BlendModes = __webpack_require__(35);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var Events = __webpack_require__(75);
          var GameObject = __webpack_require__(15);
          var Rectangle = __webpack_require__(10);
          var Render = __webpack_require__(1052);
          var Union = __webpack_require__(441);
          var Vector2 = __webpack_require__(3);
          var Container = new Class({
            Extends: GameObject,
            Mixins: [Components.AlphaSingle, Components.BlendMode, Components.ComputedSize, Components.Depth, Components.Mask, Components.Pipeline, Components.Transform, Components.Visible, Render],
            initialize: function Container2(scene, x, y, children) {
              GameObject.call(this, scene, "Container");
              this.list = [];
              this.exclusive = true;
              this.maxSize = -1;
              this.position = 0;
              this.localTransform = new Components.TransformMatrix();
              this.tempTransformMatrix = new Components.TransformMatrix();
              this._sortKey = "";
              this._sysEvents = scene.sys.events;
              this.scrollFactorX = 1;
              this.scrollFactorY = 1;
              this.initPipeline();
              this.setPosition(x, y);
              this.clearAlpha();
              this.setBlendMode(BlendModes.SKIP_CHECK);
              if (children) {
                this.add(children);
              }
            },
            originX: {
              get: function () {
                return 0.5;
              }
            },
            originY: {
              get: function () {
                return 0.5;
              }
            },
            displayOriginX: {
              get: function () {
                return this.width * 0.5;
              }
            },
            displayOriginY: {
              get: function () {
                return this.height * 0.5;
              }
            },
            setExclusive: function (value) {
              if (value === void 0) {
                value = true;
              }
              this.exclusive = value;
              return this;
            },
            getBounds: function (output) {
              if (output === void 0) {
                output = new Rectangle();
              }
              output.setTo(this.x, this.y, 0, 0);
              if (this.parentContainer) {
                var parentMatrix = this.parentContainer.getBoundsTransformMatrix();
                var transformedPosition = parentMatrix.transformPoint(this.x, this.y);
                output.setTo(transformedPosition.x, transformedPosition.y, 0, 0);
              }
              if (this.list.length > 0) {
                var children = this.list;
                var tempRect = new Rectangle();
                var hasSetFirst = false;
                output.setEmpty();
                for (var i = 0; i < children.length; i++) {
                  var entry = children[i];
                  if (entry.getBounds) {
                    entry.getBounds(tempRect);
                    if (!hasSetFirst) {
                      output.setTo(tempRect.x, tempRect.y, tempRect.width, tempRect.height);
                      hasSetFirst = true;
                    } else {
                      Union(tempRect, output, output);
                    }
                  }
                }
              }
              return output;
            },
            addHandler: function (gameObject) {
              gameObject.once(Events.DESTROY, this.remove, this);
              if (this.exclusive) {
                if (gameObject.parentContainer) {
                  gameObject.parentContainer.remove(gameObject);
                }
                gameObject.removeFromDisplayList();
                gameObject.parentContainer = this;
              }
            },
            removeHandler: function (gameObject) {
              gameObject.off(Events.DESTROY, this.remove);
              if (this.exclusive) {
                gameObject.parentContainer = null;
                gameObject.addToDisplayList();
              }
            },
            pointToContainer: function (source, output) {
              if (output === void 0) {
                output = new Vector2();
              }
              if (this.parentContainer) {
                this.parentContainer.pointToContainer(source, output);
              } else {
                output = new Vector2(source.x, source.y);
              }
              var tempMatrix = this.tempTransformMatrix;
              tempMatrix.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY);
              tempMatrix.invert();
              tempMatrix.transformPoint(source.x, source.y, output);
              return output;
            },
            getBoundsTransformMatrix: function () {
              return this.getWorldTransformMatrix(this.tempTransformMatrix, this.localTransform);
            },
            add: function (child) {
              ArrayUtils.Add(this.list, child, this.maxSize, this.addHandler, this);
              return this;
            },
            addAt: function (child, index) {
              ArrayUtils.AddAt(this.list, child, index, this.maxSize, this.addHandler, this);
              return this;
            },
            getAt: function (index) {
              return this.list[index];
            },
            getIndex: function (child) {
              return this.list.indexOf(child);
            },
            sort: function (property, handler) {
              if (!property) {
                return this;
              }
              if (handler === void 0) {
                handler = function (childA, childB) {
                  return childA[property] - childB[property];
                };
              }
              ArrayUtils.StableSort(this.list, handler);
              return this;
            },
            getByName: function (name) {
              return ArrayUtils.GetFirst(this.list, "name", name);
            },
            getRandom: function (startIndex, length) {
              return ArrayUtils.GetRandom(this.list, startIndex, length);
            },
            getFirst: function (property, value, startIndex, endIndex) {
              return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);
            },
            getAll: function (property, value, startIndex, endIndex) {
              return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);
            },
            count: function (property, value, startIndex, endIndex) {
              return ArrayUtils.CountAllMatching(this.list, property, value, startIndex, endIndex);
            },
            swap: function (child1, child2) {
              ArrayUtils.Swap(this.list, child1, child2);
              return this;
            },
            moveTo: function (child, index) {
              ArrayUtils.MoveTo(this.list, child, index);
              return this;
            },
            moveAbove: function (child1, child2) {
              ArrayUtils.MoveAbove(this.list, child1, child2);
              return this;
            },
            moveBelow: function (child1, child2) {
              ArrayUtils.MoveBelow(this.list, child1, child2);
              return this;
            },
            remove: function (child, destroyChild) {
              var removed = ArrayUtils.Remove(this.list, child, this.removeHandler, this);
              if (destroyChild && removed) {
                if (!Array.isArray(removed)) {
                  removed = [removed];
                }
                for (var i = 0; i < removed.length; i++) {
                  removed[i].destroy();
                }
              }
              return this;
            },
            removeAt: function (index, destroyChild) {
              var removed = ArrayUtils.RemoveAt(this.list, index, this.removeHandler, this);
              if (destroyChild && removed) {
                removed.destroy();
              }
              return this;
            },
            removeBetween: function (startIndex, endIndex, destroyChild) {
              var removed = ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeHandler, this);
              if (destroyChild) {
                for (var i = 0; i < removed.length; i++) {
                  removed[i].destroy();
                }
              }
              return this;
            },
            removeAll: function (destroyChild) {
              var removed = ArrayUtils.RemoveBetween(this.list, 0, this.list.length, this.removeHandler, this);
              if (destroyChild) {
                for (var i = 0; i < removed.length; i++) {
                  removed[i].destroy();
                }
              }
              return this;
            },
            bringToTop: function (child) {
              ArrayUtils.BringToTop(this.list, child);
              return this;
            },
            sendToBack: function (child) {
              ArrayUtils.SendToBack(this.list, child);
              return this;
            },
            moveUp: function (child) {
              ArrayUtils.MoveUp(this.list, child);
              return this;
            },
            moveDown: function (child) {
              ArrayUtils.MoveDown(this.list, child);
              return this;
            },
            reverse: function () {
              this.list.reverse();
              return this;
            },
            shuffle: function () {
              ArrayUtils.Shuffle(this.list);
              return this;
            },
            replace: function (oldChild, newChild, destroyChild) {
              var moved = ArrayUtils.Replace(this.list, oldChild, newChild);
              if (moved) {
                this.addHandler(newChild);
                this.removeHandler(oldChild);
                if (destroyChild) {
                  oldChild.destroy();
                }
              }
              return this;
            },
            exists: function (child) {
              return this.list.indexOf(child) > -1;
            },
            setAll: function (property, value, startIndex, endIndex) {
              ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);
              return this;
            },
            each: function (callback, context) {
              var args = [null];
              var i;
              var temp = this.list.slice();
              var len = temp.length;
              for (i = 2; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              for (i = 0; i < len; i++) {
                args[0] = temp[i];
                callback.apply(context, args);
              }
              return this;
            },
            iterate: function (callback, context) {
              var args = [null];
              var i;
              for (i = 2; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              for (i = 0; i < this.list.length; i++) {
                args[0] = this.list[i];
                callback.apply(context, args);
              }
              return this;
            },
            setScrollFactor: function (x, y, updateChildren) {
              if (y === void 0) {
                y = x;
              }
              if (updateChildren === void 0) {
                updateChildren = false;
              }
              this.scrollFactorX = x;
              this.scrollFactorY = y;
              if (updateChildren) {
                ArrayUtils.SetAll(this.list, "scrollFactorX", x);
                ArrayUtils.SetAll(this.list, "scrollFactorY", y);
              }
              return this;
            },
            length: {
              get: function () {
                return this.list.length;
              }
            },
            first: {
              get: function () {
                this.position = 0;
                if (this.list.length > 0) {
                  return this.list[0];
                } else {
                  return null;
                }
              }
            },
            last: {
              get: function () {
                if (this.list.length > 0) {
                  this.position = this.list.length - 1;
                  return this.list[this.position];
                } else {
                  return null;
                }
              }
            },
            next: {
              get: function () {
                if (this.position < this.list.length) {
                  this.position++;
                  return this.list[this.position];
                } else {
                  return null;
                }
              }
            },
            previous: {
              get: function () {
                if (this.position > 0) {
                  this.position--;
                  return this.list[this.position];
                } else {
                  return null;
                }
              }
            },
            preDestroy: function () {
              this.removeAll(!!this.exclusive);
              this.localTransform.destroy();
              this.tempTransformMatrix.destroy();
              this.list = [];
            }
          });
          module2.exports = Container;
        }, function (module2, exports2, __webpack_require__) {
          var BitmapText = __webpack_require__(148);
          var Class = __webpack_require__(0);
          var Render = __webpack_require__(1057);
          var DynamicBitmapText = new Class({
            Extends: BitmapText,
            Mixins: [Render],
            initialize: function DynamicBitmapText2(scene, x, y, font, text, size, align) {
              BitmapText.call(this, scene, x, y, font, text, size, align);
              this.type = "DynamicBitmapText";
              this.scrollX = 0;
              this.scrollY = 0;
              this.cropWidth = 0;
              this.cropHeight = 0;
              this.displayCallback;
              this.callbackData = {
                parent: this,
                color: 0,
                tint: {
                  topLeft: 0,
                  topRight: 0,
                  bottomLeft: 0,
                  bottomRight: 0
                },
                index: 0,
                charCode: 0,
                x: 0,
                y: 0,
                scale: 0,
                rotation: 0,
                data: 0
              };
            },
            setSize: function (width, height) {
              this.cropWidth = width;
              this.cropHeight = height;
              return this;
            },
            setDisplayCallback: function (callback) {
              this.displayCallback = callback;
              return this;
            },
            setScrollX: function (value) {
              this.scrollX = value;
              return this;
            },
            setScrollY: function (value) {
              this.scrollY = value;
              return this;
            }
          });
          module2.exports = DynamicBitmapText;
        }, function (module2, exports2, __webpack_require__) {
          var BaseCamera = __webpack_require__(133);
          var Class = __webpack_require__(0);
          var Commands = __webpack_require__(217);
          var ComponentsAlpha = __webpack_require__(303);
          var ComponentsBlendMode = __webpack_require__(304);
          var ComponentsDepth = __webpack_require__(305);
          var ComponentsMask = __webpack_require__(309);
          var ComponentsPipeline = __webpack_require__(167);
          var ComponentsScrollFactor = __webpack_require__(312);
          var ComponentsTransform = __webpack_require__(313);
          var ComponentsVisible = __webpack_require__(314);
          var Ellipse = __webpack_require__(111);
          var GameObject = __webpack_require__(15);
          var GetFastValue = __webpack_require__(2);
          var GetValue = __webpack_require__(6);
          var MATH_CONST = __webpack_require__(14);
          var Render = __webpack_require__(1063);
          var Graphics = new Class({
            Extends: GameObject,
            Mixins: [ComponentsAlpha, ComponentsBlendMode, ComponentsDepth, ComponentsMask, ComponentsPipeline, ComponentsTransform, ComponentsVisible, ComponentsScrollFactor, Render],
            initialize: function Graphics2(scene, options) {
              var x = GetValue(options, "x", 0);
              var y = GetValue(options, "y", 0);
              GameObject.call(this, scene, "Graphics");
              this.setPosition(x, y);
              this.initPipeline();
              this.displayOriginX = 0;
              this.displayOriginY = 0;
              this.commandBuffer = [];
              this.defaultFillColor = -1;
              this.defaultFillAlpha = 1;
              this.defaultStrokeWidth = 1;
              this.defaultStrokeColor = -1;
              this.defaultStrokeAlpha = 1;
              this._lineWidth = 1;
              this.setDefaultStyles(options);
            },
            setDefaultStyles: function (options) {
              if (GetValue(options, "lineStyle", null)) {
                this.defaultStrokeWidth = GetValue(options, "lineStyle.width", 1);
                this.defaultStrokeColor = GetValue(options, "lineStyle.color", 16777215);
                this.defaultStrokeAlpha = GetValue(options, "lineStyle.alpha", 1);
                this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
              }
              if (GetValue(options, "fillStyle", null)) {
                this.defaultFillColor = GetValue(options, "fillStyle.color", 16777215);
                this.defaultFillAlpha = GetValue(options, "fillStyle.alpha", 1);
                this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
              }
              return this;
            },
            lineStyle: function (lineWidth, color, alpha) {
              if (alpha === void 0) {
                alpha = 1;
              }
              this.commandBuffer.push(Commands.LINE_STYLE, lineWidth, color, alpha);
              this._lineWidth = lineWidth;
              return this;
            },
            fillStyle: function (color, alpha) {
              if (alpha === void 0) {
                alpha = 1;
              }
              this.commandBuffer.push(Commands.FILL_STYLE, color, alpha);
              return this;
            },
            fillGradientStyle: function (topLeft, topRight, bottomLeft, bottomRight, alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight) {
              if (alphaTopLeft === void 0) {
                alphaTopLeft = 1;
              }
              if (alphaTopRight === void 0) {
                alphaTopRight = alphaTopLeft;
              }
              if (alphaBottomLeft === void 0) {
                alphaBottomLeft = alphaTopLeft;
              }
              if (alphaBottomRight === void 0) {
                alphaBottomRight = alphaTopLeft;
              }
              this.commandBuffer.push(Commands.GRADIENT_FILL_STYLE, alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight, topLeft, topRight, bottomLeft, bottomRight);
              return this;
            },
            lineGradientStyle: function (lineWidth, topLeft, topRight, bottomLeft, bottomRight, alpha) {
              if (alpha === void 0) {
                alpha = 1;
              }
              this.commandBuffer.push(Commands.GRADIENT_LINE_STYLE, lineWidth, alpha, topLeft, topRight, bottomLeft, bottomRight);
              return this;
            },
            beginPath: function () {
              this.commandBuffer.push(Commands.BEGIN_PATH);
              return this;
            },
            closePath: function () {
              this.commandBuffer.push(Commands.CLOSE_PATH);
              return this;
            },
            fillPath: function () {
              this.commandBuffer.push(Commands.FILL_PATH);
              return this;
            },
            fill: function () {
              this.commandBuffer.push(Commands.FILL_PATH);
              return this;
            },
            strokePath: function () {
              this.commandBuffer.push(Commands.STROKE_PATH);
              return this;
            },
            stroke: function () {
              this.commandBuffer.push(Commands.STROKE_PATH);
              return this;
            },
            fillCircleShape: function (circle) {
              return this.fillCircle(circle.x, circle.y, circle.radius);
            },
            strokeCircleShape: function (circle) {
              return this.strokeCircle(circle.x, circle.y, circle.radius);
            },
            fillCircle: function (x, y, radius) {
              this.beginPath();
              this.arc(x, y, radius, 0, MATH_CONST.PI2);
              this.fillPath();
              return this;
            },
            strokeCircle: function (x, y, radius) {
              this.beginPath();
              this.arc(x, y, radius, 0, MATH_CONST.PI2);
              this.strokePath();
              return this;
            },
            fillRectShape: function (rect) {
              return this.fillRect(rect.x, rect.y, rect.width, rect.height);
            },
            strokeRectShape: function (rect) {
              return this.strokeRect(rect.x, rect.y, rect.width, rect.height);
            },
            fillRect: function (x, y, width, height) {
              this.commandBuffer.push(Commands.FILL_RECT, x, y, width, height);
              return this;
            },
            strokeRect: function (x, y, width, height) {
              var lineWidthHalf = this._lineWidth / 2;
              var minx = x - lineWidthHalf;
              var maxx = x + lineWidthHalf;
              this.beginPath();
              this.moveTo(x, y);
              this.lineTo(x, y + height);
              this.strokePath();
              this.beginPath();
              this.moveTo(x + width, y);
              this.lineTo(x + width, y + height);
              this.strokePath();
              this.beginPath();
              this.moveTo(minx, y);
              this.lineTo(maxx + width, y);
              this.strokePath();
              this.beginPath();
              this.moveTo(minx, y + height);
              this.lineTo(maxx + width, y + height);
              this.strokePath();
              return this;
            },
            fillRoundedRect: function (x, y, width, height, radius) {
              if (radius === void 0) {
                radius = 20;
              }
              var tl = radius;
              var tr = radius;
              var bl = radius;
              var br = radius;
              if (typeof radius !== "number") {
                tl = GetFastValue(radius, "tl", 20);
                tr = GetFastValue(radius, "tr", 20);
                bl = GetFastValue(radius, "bl", 20);
                br = GetFastValue(radius, "br", 20);
              }
              this.beginPath();
              this.moveTo(x + tl, y);
              this.lineTo(x + width - tr, y);
              this.arc(x + width - tr, y + tr, tr, -MATH_CONST.TAU, 0);
              this.lineTo(x + width, y + height - br);
              this.arc(x + width - br, y + height - br, br, 0, MATH_CONST.TAU);
              this.lineTo(x + bl, y + height);
              this.arc(x + bl, y + height - bl, bl, MATH_CONST.TAU, Math.PI);
              this.lineTo(x, y + tl);
              this.arc(x + tl, y + tl, tl, -Math.PI, -MATH_CONST.TAU);
              this.fillPath();
              return this;
            },
            strokeRoundedRect: function (x, y, width, height, radius) {
              if (radius === void 0) {
                radius = 20;
              }
              var tl = radius;
              var tr = radius;
              var bl = radius;
              var br = radius;
              if (typeof radius !== "number") {
                tl = GetFastValue(radius, "tl", 20);
                tr = GetFastValue(radius, "tr", 20);
                bl = GetFastValue(radius, "bl", 20);
                br = GetFastValue(radius, "br", 20);
              }
              this.beginPath();
              this.moveTo(x + tl, y);
              this.lineTo(x + width - tr, y);
              this.moveTo(x + width - tr, y);
              this.arc(x + width - tr, y + tr, tr, -MATH_CONST.TAU, 0);
              this.lineTo(x + width, y + height - br);
              this.moveTo(x + width, y + height - br);
              this.arc(x + width - br, y + height - br, br, 0, MATH_CONST.TAU);
              this.lineTo(x + bl, y + height);
              this.moveTo(x + bl, y + height);
              this.arc(x + bl, y + height - bl, bl, MATH_CONST.TAU, Math.PI);
              this.lineTo(x, y + tl);
              this.moveTo(x, y + tl);
              this.arc(x + tl, y + tl, tl, -Math.PI, -MATH_CONST.TAU);
              this.strokePath();
              return this;
            },
            fillPointShape: function (point, size) {
              return this.fillPoint(point.x, point.y, size);
            },
            fillPoint: function (x, y, size) {
              if (!size || size < 1) {
                size = 1;
              } else {
                x -= size / 2;
                y -= size / 2;
              }
              this.commandBuffer.push(Commands.FILL_RECT, x, y, size, size);
              return this;
            },
            fillTriangleShape: function (triangle) {
              return this.fillTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
            },
            strokeTriangleShape: function (triangle) {
              return this.strokeTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
            },
            fillTriangle: function (x0, y0, x1, y1, x2, y2) {
              this.commandBuffer.push(Commands.FILL_TRIANGLE, x0, y0, x1, y1, x2, y2);
              return this;
            },
            strokeTriangle: function (x0, y0, x1, y1, x2, y2) {
              this.commandBuffer.push(Commands.STROKE_TRIANGLE, x0, y0, x1, y1, x2, y2);
              return this;
            },
            strokeLineShape: function (line) {
              return this.lineBetween(line.x1, line.y1, line.x2, line.y2);
            },
            lineBetween: function (x1, y1, x2, y2) {
              this.beginPath();
              this.moveTo(x1, y1);
              this.lineTo(x2, y2);
              this.strokePath();
              return this;
            },
            lineTo: function (x, y) {
              this.commandBuffer.push(Commands.LINE_TO, x, y);
              return this;
            },
            moveTo: function (x, y) {
              this.commandBuffer.push(Commands.MOVE_TO, x, y);
              return this;
            },
            strokePoints: function (points, closeShape, closePath, endIndex) {
              if (closeShape === void 0) {
                closeShape = false;
              }
              if (closePath === void 0) {
                closePath = false;
              }
              if (endIndex === void 0) {
                endIndex = points.length;
              }
              this.beginPath();
              this.moveTo(points[0].x, points[0].y);
              for (var i = 1; i < endIndex; i++) {
                this.lineTo(points[i].x, points[i].y);
              }
              if (closeShape) {
                this.lineTo(points[0].x, points[0].y);
              }
              if (closePath) {
                this.closePath();
              }
              this.strokePath();
              return this;
            },
            fillPoints: function (points, closeShape, closePath, endIndex) {
              if (closeShape === void 0) {
                closeShape = false;
              }
              if (closePath === void 0) {
                closePath = false;
              }
              if (endIndex === void 0) {
                endIndex = points.length;
              }
              this.beginPath();
              this.moveTo(points[0].x, points[0].y);
              for (var i = 1; i < endIndex; i++) {
                this.lineTo(points[i].x, points[i].y);
              }
              if (closeShape) {
                this.lineTo(points[0].x, points[0].y);
              }
              if (closePath) {
                this.closePath();
              }
              this.fillPath();
              return this;
            },
            strokeEllipseShape: function (ellipse, smoothness) {
              if (smoothness === void 0) {
                smoothness = 32;
              }
              var points = ellipse.getPoints(smoothness);
              return this.strokePoints(points, true);
            },
            strokeEllipse: function (x, y, width, height, smoothness) {
              if (smoothness === void 0) {
                smoothness = 32;
              }
              var ellipse = new Ellipse(x, y, width, height);
              var points = ellipse.getPoints(smoothness);
              return this.strokePoints(points, true);
            },
            fillEllipseShape: function (ellipse, smoothness) {
              if (smoothness === void 0) {
                smoothness = 32;
              }
              var points = ellipse.getPoints(smoothness);
              return this.fillPoints(points, true);
            },
            fillEllipse: function (x, y, width, height, smoothness) {
              if (smoothness === void 0) {
                smoothness = 32;
              }
              var ellipse = new Ellipse(x, y, width, height);
              var points = ellipse.getPoints(smoothness);
              return this.fillPoints(points, true);
            },
            arc: function (x, y, radius, startAngle, endAngle, anticlockwise, overshoot) {
              if (anticlockwise === void 0) {
                anticlockwise = false;
              }
              if (overshoot === void 0) {
                overshoot = 0;
              }
              this.commandBuffer.push(Commands.ARC, x, y, radius, startAngle, endAngle, anticlockwise, overshoot);
              return this;
            },
            slice: function (x, y, radius, startAngle, endAngle, anticlockwise, overshoot) {
              if (anticlockwise === void 0) {
                anticlockwise = false;
              }
              if (overshoot === void 0) {
                overshoot = 0;
              }
              this.commandBuffer.push(Commands.BEGIN_PATH);
              this.commandBuffer.push(Commands.MOVE_TO, x, y);
              this.commandBuffer.push(Commands.ARC, x, y, radius, startAngle, endAngle, anticlockwise, overshoot);
              this.commandBuffer.push(Commands.CLOSE_PATH);
              return this;
            },
            save: function () {
              this.commandBuffer.push(Commands.SAVE);
              return this;
            },
            restore: function () {
              this.commandBuffer.push(Commands.RESTORE);
              return this;
            },
            translateCanvas: function (x, y) {
              this.commandBuffer.push(Commands.TRANSLATE, x, y);
              return this;
            },
            scaleCanvas: function (x, y) {
              this.commandBuffer.push(Commands.SCALE, x, y);
              return this;
            },
            rotateCanvas: function (radians) {
              this.commandBuffer.push(Commands.ROTATE, radians);
              return this;
            },
            clear: function () {
              this.commandBuffer.length = 0;
              if (this.defaultFillColor > -1) {
                this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
              }
              if (this.defaultStrokeColor > -1) {
                this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
              }
              return this;
            },
            generateTexture: function (key, width, height) {
              var sys = this.scene.sys;
              var renderer = sys.game.renderer;
              if (width === void 0) {
                width = sys.scale.width;
              }
              if (height === void 0) {
                height = sys.scale.height;
              }
              Graphics.TargetCamera.setScene(this.scene);
              Graphics.TargetCamera.setViewport(0, 0, width, height);
              Graphics.TargetCamera.scrollX = this.x;
              Graphics.TargetCamera.scrollY = this.y;
              var texture;
              var ctx;
              if (typeof key === "string") {
                if (sys.textures.exists(key)) {
                  texture = sys.textures.get(key);
                  var src = texture.getSourceImage();
                  if (src instanceof HTMLCanvasElement) {
                    ctx = src.getContext("2d");
                  }
                } else {
                  texture = sys.textures.createCanvas(key, width, height);
                  ctx = texture.getSourceImage().getContext("2d");
                }
              } else if (key instanceof HTMLCanvasElement) {
                ctx = key.getContext("2d");
              }
              if (ctx) {
                this.renderCanvas(renderer, this, Graphics.TargetCamera, null, ctx, false);
                if (texture) {
                  texture.refresh();
                }
              }
              return this;
            },
            preDestroy: function () {
              this.commandBuffer = [];
            }
          });
          Graphics.TargetCamera = new BaseCamera();
          module2.exports = Graphics;
        }, function (module2, exports2) {
          module2.exports = {
            ARC: 0,
            BEGIN_PATH: 1,
            CLOSE_PATH: 2,
            FILL_RECT: 3,
            LINE_TO: 4,
            MOVE_TO: 5,
            LINE_STYLE: 6,
            FILL_STYLE: 7,
            FILL_PATH: 8,
            STROKE_PATH: 9,
            FILL_TRIANGLE: 10,
            STROKE_TRIANGLE: 11,
            SAVE: 14,
            RESTORE: 15,
            TRANSLATE: 16,
            SCALE: 17,
            ROTATE: 18,
            GRADIENT_FILL_STYLE: 21,
            GRADIENT_LINE_STYLE: 22
          };
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var CircumferencePoint = function (ellipse, angle, out) {
            if (out === void 0) {
              out = new Point();
            }
            var halfWidth = ellipse.width / 2;
            var halfHeight = ellipse.height / 2;
            out.x = ellipse.x + halfWidth * Math.cos(angle);
            out.y = ellipse.y + halfHeight * Math.sin(angle);
            return out;
          };
          module2.exports = CircumferencePoint;
        }, function (module2, exports2, __webpack_require__) {
          var BlendModes = __webpack_require__(35);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var ComponentsToJSON = __webpack_require__(176);
          var DataManager = __webpack_require__(101);
          var EventEmitter = __webpack_require__(9);
          var GameObjectEvents = __webpack_require__(75);
          var List = __webpack_require__(110);
          var Render = __webpack_require__(1071);
          var SceneEvents = __webpack_require__(20);
          var StableSort = __webpack_require__(79);
          var Layer = new Class({
            Extends: List,
            Mixins: [Components.AlphaSingle, Components.BlendMode, Components.Depth, Components.Mask, Components.Pipeline, Components.Visible, EventEmitter, Render],
            initialize: function Layer2(scene, children) {
              List.call(this, scene);
              EventEmitter.call(this);
              this.scene = scene;
              this.displayList = null;
              this.type = "Layer";
              this.state = 0;
              this.parentContainer = null;
              this.name = "";
              this.active = true;
              this.tabIndex = -1;
              this.data = null;
              this.renderFlags = 15;
              this.cameraFilter = 0;
              this.input = null;
              this.body = null;
              this.ignoreDestroy = false;
              this.systems = scene.sys;
              this.events = scene.sys.events;
              this.sortChildrenFlag = false;
              this.addCallback = this.addChildCallback;
              this.removeCallback = this.removeChildCallback;
              this.initPipeline();
              this.clearAlpha();
              this.setBlendMode(BlendModes.SKIP_CHECK);
              if (children) {
                this.add(children);
              }
              scene.sys.queueDepthSort();
            },
            setActive: function (value) {
              this.active = value;
              return this;
            },
            setName: function (value) {
              this.name = value;
              return this;
            },
            setState: function (value) {
              this.state = value;
              return this;
            },
            setDataEnabled: function () {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              return this;
            },
            setData: function (key, value) {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              this.data.set(key, value);
              return this;
            },
            incData: function (key, value) {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              this.data.inc(key, value);
              return this;
            },
            toggleData: function (key) {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              this.data.toggle(key);
              return this;
            },
            getData: function (key) {
              if (!this.data) {
                this.data = new DataManager(this);
              }
              return this.data.get(key);
            },
            setInteractive: function () {
              return this;
            },
            disableInteractive: function () {
              return this;
            },
            removeInteractive: function () {
              return this;
            },
            addedToScene: function () {},
            removedFromScene: function () {},
            update: function () {},
            toJSON: function () {
              return ComponentsToJSON(this);
            },
            willRender: function (camera) {
              return !(this.renderFlags !== 15 || this.list.length === 0 || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
            },
            getIndexList: function () {
              var child = this;
              var parent = this.parentContainer;
              var indexes = [];
              while (parent) {
                indexes.unshift(parent.getIndex(child));
                child = parent;
                if (!parent.parentContainer) {
                  break;
                } else {
                  parent = parent.parentContainer;
                }
              }
              indexes.unshift(this.displayList.getIndex(child));
              return indexes;
            },
            addChildCallback: function (gameObject) {
              if (gameObject.displayList && gameObject.displayList !== this) {
                gameObject.removeFromDisplayList();
              }
              if (!gameObject.displayList) {
                this.queueDepthSort();
                gameObject.displayList = this;
                gameObject.emit(GameObjectEvents.ADDED_TO_SCENE, gameObject, this.scene);
                this.events.emit(SceneEvents.ADDED_TO_SCENE, gameObject, this.scene);
              }
            },
            removeChildCallback: function (gameObject) {
              this.queueDepthSort();
              gameObject.displayList = null;
              gameObject.emit(GameObjectEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
              this.events.emit(SceneEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
            },
            queueDepthSort: function () {
              this.sortChildrenFlag = true;
            },
            depthSort: function () {
              if (this.sortChildrenFlag) {
                StableSort(this.list, this.sortByDepth);
                this.sortChildrenFlag = false;
              }
            },
            sortByDepth: function (childA, childB) {
              return childA._depth - childB._depth;
            },
            getChildren: function () {
              return this.list;
            },
            destroy: function () {
              if (!this.scene || this.ignoreDestroy) {
                return;
              }
              this.emit(GameObjectEvents.DESTROY, this);
              var i = this.list.length;
              while (i--) {
                this.list[i].destroy();
              }
              this.removeAllListeners();
              this.resetPostPipeline(true);
              if (this.displayList) {
                this.displayList.remove(this, true);
                this.displayList.queueDepthSort();
              }
              if (this.data) {
                this.data.destroy();
                this.data = void 0;
              }
              this.active = false;
              this.visible = false;
              this.list = void 0;
              this.scene = void 0;
              this.displayList = void 0;
              this.systems = void 0;
              this.events = void 0;
            }
          });
          module2.exports = Layer;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var GravityWell = __webpack_require__(450);
          var List = __webpack_require__(110);
          var ParticleEmitter = __webpack_require__(452);
          var Render = __webpack_require__(1075);
          var ParticleEmitterManager = new Class({
            Extends: GameObject,
            Mixins: [Components.Depth, Components.Mask, Components.Pipeline, Components.Transform, Components.Visible, Render],
            initialize: function ParticleEmitterManager2(scene, texture, frame, emitters) {
              GameObject.call(this, scene, "ParticleEmitterManager");
              this.blendMode = -1;
              this.timeScale = 1;
              this.texture = null;
              this.frame = null;
              this.frameNames = [];
              if (frame !== null && (typeof frame === "object" || Array.isArray(frame))) {
                emitters = frame;
                frame = null;
              }
              this.setTexture(texture, frame);
              this.initPipeline();
              this.emitters = new List(this);
              this.wells = new List(this);
              if (emitters) {
                if (!Array.isArray(emitters)) {
                  emitters = [emitters];
                }
                for (var i = 0; i < emitters.length; i++) {
                  this.createEmitter(emitters[i]);
                }
              }
            },
            addedToScene: function () {
              this.scene.sys.updateList.add(this);
            },
            removedFromScene: function () {
              this.scene.sys.updateList.remove(this);
            },
            setTexture: function (key, frame) {
              this.texture = this.scene.sys.textures.get(key);
              return this.setFrame(frame);
            },
            setFrame: function (frame) {
              this.frame = this.texture.get(frame);
              var frames = this.texture.getFramesFromTextureSource(this.frame.sourceIndex);
              var names = [];
              frames.forEach(function (sourceFrame) {
                names.push(sourceFrame.name);
              });
              this.frameNames = names;
              this.defaultFrame = this.frame;
              return this;
            },
            setEmitterFrames: function (frames, emitter) {
              if (!Array.isArray(frames)) {
                frames = [frames];
              }
              var out = emitter.frames;
              out.length = 0;
              for (var i = 0; i < frames.length; i++) {
                var frame = frames[i];
                if (this.frameNames.indexOf(frame) !== -1) {
                  out.push(this.texture.get(frame));
                }
              }
              if (out.length > 0) {
                emitter.defaultFrame = out[0];
              } else {
                emitter.defaultFrame = this.defaultFrame;
              }
              return this;
            },
            addEmitter: function (emitter) {
              return this.emitters.add(emitter);
            },
            createEmitter: function (config) {
              return this.addEmitter(new ParticleEmitter(this, config));
            },
            removeEmitter: function (emitter) {
              return this.emitters.remove(emitter, true);
            },
            addGravityWell: function (well) {
              return this.wells.add(well);
            },
            createGravityWell: function (config) {
              return this.addGravityWell(new GravityWell(config));
            },
            emitParticle: function (count, x, y) {
              var emitters = this.emitters.list;
              for (var i = 0; i < emitters.length; i++) {
                var emitter = emitters[i];
                if (emitter.active) {
                  emitter.emitParticle(count, x, y);
                }
              }
              return this;
            },
            emitParticleAt: function (x, y, count) {
              return this.emitParticle(count, x, y);
            },
            pause: function () {
              this.active = false;
              return this;
            },
            resume: function () {
              this.active = true;
              return this;
            },
            getProcessors: function () {
              return this.wells.getAll("active", true);
            },
            preUpdate: function (time, delta) {
              delta *= this.timeScale;
              var emitters = this.emitters.list;
              for (var i = 0; i < emitters.length; i++) {
                var emitter = emitters[i];
                if (emitter.active) {
                  emitter.preUpdate(time, delta);
                }
              }
            },
            setAlpha: function () {},
            setScrollFactor: function () {},
            setBlendMode: function () {}
          });
          module2.exports = ParticleEmitterManager;
        }, function (module2, exports2, __webpack_require__) {
          var BlendModes = __webpack_require__(35);
          var Camera = __webpack_require__(133);
          var CanvasPool = __webpack_require__(31);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var CONST = __webpack_require__(33);
          var Frame = __webpack_require__(109);
          var GameObject = __webpack_require__(15);
          var NOOP = __webpack_require__(1);
          var PIPELINE_CONST = __webpack_require__(92);
          var Render = __webpack_require__(1079);
          var RenderTarget = __webpack_require__(141);
          var Utils = __webpack_require__(12);
          var UUID = __webpack_require__(222);
          var RenderTexture = new Class({
            Extends: GameObject,
            Mixins: [Components.Alpha, Components.BlendMode, Components.ComputedSize, Components.Crop, Components.Depth, Components.Flip, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Tint, Components.Transform, Components.Visible, Render],
            initialize: function RenderTexture2(scene, x, y, width, height, key, frame) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = 32;
              }
              if (height === void 0) {
                height = 32;
              }
              GameObject.call(this, scene, "RenderTexture");
              this.renderer = scene.sys.renderer;
              this.textureManager = scene.sys.textures;
              this.globalTint = 16777215;
              this.globalAlpha = 1;
              this.canvas = null;
              this.dirty = false;
              this._crop = this.resetCropObject();
              this.texture = null;
              this.frame = null;
              this._saved = false;
              if (key === void 0) {
                this.canvas = CanvasPool.create2D(this, width, height);
                this.texture = scene.sys.textures.addCanvas(UUID(), this.canvas);
                this.frame = this.texture.get();
              } else {
                this.texture = scene.sys.textures.get(key);
                this.frame = this.texture.get(frame);
                this.canvas = this.frame.source.image;
                this._saved = true;
                this.dirty = true;
                this.width = this.frame.cutWidth;
                this.height = this.frame.cutHeight;
              }
              this.context = this.canvas.getContext("2d");
              this._eraseMode = false;
              this.camera = new Camera(0, 0, width, height);
              this.renderTarget = null;
              var renderer = this.renderer;
              if (!renderer) {
                this.drawGameObject = NOOP;
              } else if (renderer.type === CONST.WEBGL) {
                this.drawGameObject = this.batchGameObjectWebGL;
                this.renderTarget = new RenderTarget(renderer, width, height, 1, 0, false);
              } else if (renderer.type === CONST.CANVAS) {
                this.drawGameObject = this.batchGameObjectCanvas;
              }
              this.camera.setScene(scene);
              this.setPosition(x, y);
              if (key === void 0) {
                this.setSize(width, height);
              }
              this.setOrigin(0, 0);
              this.initPipeline(PIPELINE_CONST.SINGLE_PIPELINE);
            },
            setSize: function (width, height) {
              return this.resize(width, height);
            },
            resize: function (width, height) {
              if (height === void 0) {
                height = width;
              }
              var frame = this.frame;
              if (width !== this.width || height !== this.height) {
                if (frame.name === "__BASE") {
                  this.canvas.width = width;
                  this.canvas.height = height;
                  this.texture.width = width;
                  this.texture.height = height;
                  var renderTarget = this.renderTarget;
                  if (renderTarget) {
                    renderTarget.resize(width, height);
                    frame.glTexture = renderTarget.texture;
                    frame.source.isRenderTexture = true;
                    frame.source.isGLTexture = true;
                    frame.source.glTexture = renderTarget.texture;
                  }
                  this.camera.setSize(width, height);
                  frame.source.width = width;
                  frame.source.height = height;
                  frame.setSize(width, height);
                  this.width = width;
                  this.height = height;
                }
              } else {
                var baseFrame = this.texture.getSourceImage();
                if (frame.cutX + width > baseFrame.width) {
                  width = baseFrame.width - frame.cutX;
                }
                if (frame.cutY + height > baseFrame.height) {
                  height = baseFrame.height - frame.cutY;
                }
                frame.setSize(width, height, frame.cutX, frame.cutY);
              }
              this.updateDisplayOrigin();
              var input = this.input;
              if (input && !input.customHitArea) {
                input.hitArea.width = width;
                input.hitArea.height = height;
              }
              return this;
            },
            setGlobalTint: function (tint) {
              this.globalTint = tint;
              return this;
            },
            setGlobalAlpha: function (alpha) {
              this.globalAlpha = alpha;
              return this;
            },
            saveTexture: function (key) {
              this.textureManager.renameTexture(this.texture.key, key);
              this._saved = true;
              return this.texture;
            },
            fill: function (rgb, alpha, x, y, width, height) {
              var frame = this.frame;
              var camera = this.camera;
              var renderer = this.renderer;
              if (alpha === void 0) {
                alpha = 1;
              }
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = frame.cutWidth;
              }
              if (height === void 0) {
                height = frame.cutHeight;
              }
              var r = (rgb >> 16 & 255) / 255;
              var g = (rgb >> 8 & 255) / 255;
              var b = (rgb & 255) / 255;
              var renderTarget = this.renderTarget;
              camera.preRender();
              if (renderTarget) {
                renderTarget.bind(true);
                var pipeline = this.pipeline;
                pipeline.manager.set(pipeline);
                var tw = renderTarget.width;
                var th = renderTarget.height;
                var rw = renderer.width;
                var rh = renderer.height;
                var sx = rw / tw;
                var sy = rh / th;
                pipeline.drawFillRect(x * sx, y * sy, width * sx, height * sy, Utils.getTintFromFloats(b, g, r, 1), alpha);
                renderTarget.unbind(true);
              } else {
                var ctx = this.context;
                renderer.setContext(ctx);
                ctx.fillStyle = "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
                ctx.fillRect(x + frame.cutX, y + frame.cutY, width, height);
                renderer.setContext();
              }
              this.dirty = true;
              return this;
            },
            clear: function () {
              if (this.dirty) {
                var renderTarget = this.renderTarget;
                if (renderTarget) {
                  renderTarget.clear();
                } else {
                  var ctx = this.context;
                  ctx.save();
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  ctx.clearRect(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight);
                  ctx.restore();
                }
                this.dirty = false;
              }
              return this;
            },
            erase: function (entries, x, y) {
              this._eraseMode = true;
              this.draw(entries, x, y, 1, 16777215);
              this._eraseMode = false;
              return this;
            },
            draw: function (entries, x, y, alpha, tint) {
              this.beginDraw();
              this.batchDraw(entries, x, y, alpha, tint);
              this.endDraw();
              return this;
            },
            drawFrame: function (key, frame, x, y, alpha, tint) {
              this.beginDraw();
              this.batchDrawFrame(key, frame, x, y, alpha, tint);
              this.endDraw();
              return this;
            },
            beginDraw: function () {
              var camera = this.camera;
              var renderer = this.renderer;
              var renderTarget = this.renderTarget;
              camera.preRender();
              if (renderTarget) {
                renderer.beginCapture(renderTarget.width, renderTarget.height);
              } else {
                renderer.setContext(this.context);
              }
              return this;
            },
            batchDraw: function (entries, x, y, alpha, tint) {
              if (alpha === void 0) {
                alpha = this.globalAlpha;
              }
              if (tint === void 0) {
                tint = (this.globalTint >> 16) + (this.globalTint & 65280) + ((this.globalTint & 255) << 16);
              } else {
                tint = (tint >> 16) + (tint & 65280) + ((tint & 255) << 16);
              }
              if (!Array.isArray(entries)) {
                entries = [entries];
              }
              this.batchList(entries, x, y, alpha, tint);
              return this;
            },
            batchDrawFrame: function (key, frame, x, y, alpha, tint) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (alpha === void 0) {
                alpha = this.globalAlpha;
              }
              if (tint === void 0) {
                tint = (this.globalTint >> 16) + (this.globalTint & 65280) + ((this.globalTint & 255) << 16);
              } else {
                tint = (tint >> 16) + (tint & 65280) + ((tint & 255) << 16);
              }
              var textureFrame = this.textureManager.getFrame(key, frame);
              if (textureFrame) {
                if (this.renderTarget) {
                  this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, this.camera.matrix, null);
                } else {
                  this.batchTextureFrame(textureFrame, x + this.frame.cutX, y + this.frame.cutY, alpha, tint);
                }
              }
              return this;
            },
            endDraw: function (erase) {
              if (erase === void 0) {
                erase = this._eraseMode;
              }
              var renderer = this.renderer;
              var renderTarget = this.renderTarget;
              if (renderTarget) {
                var canvasTarget = renderer.endCapture();
                var util = renderer.pipelines.setUtility();
                util.blitFrame(canvasTarget, renderTarget, 1, false, false, erase);
                renderer.resetScissor();
                renderer.resetViewport();
              } else {
                renderer.setContext();
              }
              this.dirty = true;
              return this;
            },
            batchList: function (children, x, y, alpha, tint) {
              for (var i = 0; i < children.length; i++) {
                var entry = children[i];
                if (!entry || entry === this) {
                  continue;
                }
                if (entry.renderWebGL || entry.renderCanvas) {
                  this.drawGameObject(entry, x, y);
                } else if (entry.isParent || entry.list) {
                  this.batchGroup(entry.getChildren(), x, y);
                } else if (typeof entry === "string") {
                  this.batchTextureFrameKey(entry, null, x, y, alpha, tint);
                } else if (entry instanceof Frame) {
                  this.batchTextureFrame(entry, x, y, alpha, tint);
                } else if (Array.isArray(entry)) {
                  this.batchList(entry, x, y, alpha, tint);
                }
              }
            },
            batchGroup: function (children, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              x += this.frame.cutX;
              y += this.frame.cutY;
              for (var i = 0; i < children.length; i++) {
                var entry = children[i];
                if (entry.willRender(this.camera)) {
                  var tx = entry.x + x;
                  var ty = entry.y + y;
                  this.drawGameObject(entry, tx, ty);
                }
              }
            },
            batchGameObjectWebGL: function (gameObject, x, y) {
              if (x === void 0) {
                x = gameObject.x;
              }
              if (y === void 0) {
                y = gameObject.y;
              }
              var prevX = gameObject.x;
              var prevY = gameObject.y;
              gameObject.setPosition(x + this.frame.cutX, y + this.frame.cutY);
              if (gameObject.renderDirect) {
                gameObject.renderDirect(this.renderer, gameObject, this.camera);
              } else {
                gameObject.renderWebGL(this.renderer, gameObject, this.camera);
              }
              gameObject.setPosition(prevX, prevY);
            },
            batchGameObjectCanvas: function (gameObject, x, y) {
              if (x === void 0) {
                x = gameObject.x;
              }
              if (y === void 0) {
                y = gameObject.y;
              }
              var prevX = gameObject.x;
              var prevY = gameObject.y;
              if (this._eraseMode) {
                var blendMode = gameObject.blendMode;
                gameObject.blendMode = BlendModes.ERASE;
              }
              gameObject.setPosition(x + this.frame.cutX, y + this.frame.cutY);
              gameObject.renderCanvas(this.renderer, gameObject, this.camera, null);
              gameObject.setPosition(prevX, prevY);
              if (this._eraseMode) {
                gameObject.blendMode = blendMode;
              }
            },
            batchTextureFrameKey: function (key, frame, x, y, alpha, tint) {
              var textureFrame = this.textureManager.getFrame(key, frame);
              if (textureFrame) {
                this.batchTextureFrame(textureFrame, x, y, alpha, tint);
              }
            },
            batchTextureFrame: function (textureFrame, x, y, alpha, tint) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              x += this.frame.cutX;
              y += this.frame.cutY;
              var renderTarget = this.renderTarget;
              if (renderTarget) {
                this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, this.camera.matrix, null);
              } else {
                var ctx = this.context;
                var cd = textureFrame.canvasData;
                var source = textureFrame.source.image;
                var matrix = this.camera.matrix;
                ctx.save();
                ctx.globalCompositeOperation = this._eraseMode ? "destination-out" : "source-over";
                ctx.globalAlpha = alpha;
                matrix.setToContext(ctx);
                ctx.drawImage(source, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);
                ctx.restore();
              }
            },
            snapshotArea: function (x, y, width, height, callback, type, encoderOptions) {
              if (this.renderTarget) {
                this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, false, x, y, width, height, type, encoderOptions);
              } else {
                this.renderer.snapshotCanvas(this.canvas, callback, false, x, y, width, height, type, encoderOptions);
              }
              return this;
            },
            snapshot: function (callback, type, encoderOptions) {
              if (this.renderTarget) {
                this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, false, 0, 0, this.width, this.height, type, encoderOptions);
              } else {
                this.renderer.snapshotCanvas(this.canvas, callback, false, 0, 0, this.width, this.height, type, encoderOptions);
              }
              return this;
            },
            snapshotPixel: function (x, y, callback) {
              if (this.renderTarget) {
                this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, true, x, y);
              } else {
                this.renderer.snapshotCanvas(this.canvas, callback, true, x, y);
              }
              return this;
            },
            preDestroy: function () {
              if (!this._saved) {
                CanvasPool.remove(this.canvas);
                if (this.renderTarget) {
                  this.renderTarget.destroy();
                }
                this.texture.destroy();
                this.camera.destroy();
                this.canvas = null;
                this.context = null;
                this.texture = null;
              }
            }
          });
          module2.exports = RenderTexture;
        }, function (module2, exports2) {
          var UUID = function () {
            return ("xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx").replace(/[xy]/g, function (c) {
              var r = Math.random() * 16 | 0;
              var v = c === "x" ? r : r & 3 | 8;
              return v.toString(16);
            });
          };
          module2.exports = UUID;
        }, function (module2, exports2, __webpack_require__) {
          var AnimationState = __webpack_require__(164);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var PIPELINE_CONST = __webpack_require__(92);
          var RopeRender = __webpack_require__(1085);
          var Vector2 = __webpack_require__(3);
          var Rope = new Class({
            Extends: GameObject,
            Mixins: [Components.AlphaSingle, Components.BlendMode, Components.Depth, Components.Flip, Components.Mask, Components.Pipeline, Components.Size, Components.Texture, Components.Transform, Components.Visible, Components.ScrollFactor, RopeRender],
            initialize: function Rope2(scene, x, y, texture, frame, points, horizontal, colors, alphas) {
              if (texture === void 0) {
                texture = "__DEFAULT";
              }
              if (points === void 0) {
                points = 2;
              }
              if (horizontal === void 0) {
                horizontal = true;
              }
              GameObject.call(this, scene, "Rope");
              this.anims = new AnimationState(this);
              this.points = points;
              this.vertices;
              this.uv;
              this.colors;
              this.alphas;
              this.tintFill = texture === "__DEFAULT" ? true : false;
              this.dirty = false;
              this.horizontal = horizontal;
              this._flipX = false;
              this._flipY = false;
              this._perp = new Vector2();
              this.debugCallback = null;
              this.debugGraphic = null;
              this.setTexture(texture, frame);
              this.setPosition(x, y);
              this.setSizeToFrame();
              this.initPipeline(PIPELINE_CONST.ROPE_PIPELINE);
              if (Array.isArray(points)) {
                this.resizeArrays(points.length);
              }
              this.setPoints(points, colors, alphas);
              this.updateVertices();
            },
            addedToScene: function () {
              this.scene.sys.updateList.add(this);
            },
            removedFromScene: function () {
              this.scene.sys.updateList.remove(this);
            },
            preUpdate: function (time, delta) {
              var prevFrame = this.anims.currentFrame;
              this.anims.update(time, delta);
              if (this.anims.currentFrame !== prevFrame) {
                this.updateUVs();
                this.updateVertices();
              }
            },
            play: function (key, ignoreIfPlaying, startFrame) {
              this.anims.play(key, ignoreIfPlaying, startFrame);
              return this;
            },
            setDirty: function () {
              this.dirty = true;
              return this;
            },
            setHorizontal: function (points, colors, alphas) {
              if (points === void 0) {
                points = this.points.length;
              }
              if (this.horizontal) {
                return this;
              }
              this.horizontal = true;
              return this.setPoints(points, colors, alphas);
            },
            setVertical: function (points, colors, alphas) {
              if (points === void 0) {
                points = this.points.length;
              }
              if (!this.horizontal) {
                return this;
              }
              this.horizontal = false;
              return this.setPoints(points, colors, alphas);
            },
            setTintFill: function (value) {
              if (value === void 0) {
                value = false;
              }
              this.tintFill = value;
              return this;
            },
            setAlphas: function (alphas, bottomAlpha) {
              var total = this.points.length;
              if (total < 1) {
                return this;
              }
              var currentAlphas = this.alphas;
              if (alphas === void 0) {
                alphas = [1];
              } else if (!Array.isArray(alphas) && bottomAlpha === void 0) {
                alphas = [alphas];
              }
              var i;
              var index = 0;
              if (bottomAlpha !== void 0) {
                for (i = 0; i < total; i++) {
                  index = i * 2;
                  currentAlphas[index] = alphas;
                  currentAlphas[index + 1] = bottomAlpha;
                }
              } else if (alphas.length === total) {
                for (i = 0; i < total; i++) {
                  index = i * 2;
                  currentAlphas[index] = alphas[i];
                  currentAlphas[index + 1] = alphas[i];
                }
              } else {
                var prevAlpha = alphas[0];
                for (i = 0; i < total; i++) {
                  index = i * 2;
                  if (alphas.length > index) {
                    prevAlpha = alphas[index];
                  }
                  currentAlphas[index] = prevAlpha;
                  if (alphas.length > index + 1) {
                    prevAlpha = alphas[index + 1];
                  }
                  currentAlphas[index + 1] = prevAlpha;
                }
              }
              return this;
            },
            setColors: function (colors) {
              var total = this.points.length;
              if (total < 1) {
                return this;
              }
              var currentColors = this.colors;
              if (colors === void 0) {
                colors = [16777215];
              } else if (!Array.isArray(colors)) {
                colors = [colors];
              }
              var i;
              var index = 0;
              if (colors.length === total) {
                for (i = 0; i < total; i++) {
                  index = i * 2;
                  currentColors[index] = colors[i];
                  currentColors[index + 1] = colors[i];
                }
              } else {
                var prevColor = colors[0];
                for (i = 0; i < total; i++) {
                  index = i * 2;
                  if (colors.length > index) {
                    prevColor = colors[index];
                  }
                  currentColors[index] = prevColor;
                  if (colors.length > index + 1) {
                    prevColor = colors[index + 1];
                  }
                  currentColors[index + 1] = prevColor;
                }
              }
              return this;
            },
            setPoints: function (points, colors, alphas) {
              if (points === void 0) {
                points = 2;
              }
              if (typeof points === "number") {
                var segments = points;
                if (segments < 2) {
                  segments = 2;
                }
                points = [];
                var s;
                var frameSegment;
                var offset;
                if (this.horizontal) {
                  offset = -this.frame.halfWidth;
                  frameSegment = this.frame.width / (segments - 1);
                  for (s = 0; s < segments; s++) {
                    points.push({
                      x: offset + s * frameSegment,
                      y: 0
                    });
                  }
                } else {
                  offset = -this.frame.halfHeight;
                  frameSegment = this.frame.height / (segments - 1);
                  for (s = 0; s < segments; s++) {
                    points.push({
                      x: 0,
                      y: offset + s * frameSegment
                    });
                  }
                }
              }
              var total = points.length;
              var currentTotal = this.points.length;
              if (total < 1) {
                console.warn("Rope: Not enough points given");
                return this;
              } else if (total === 1) {
                points.unshift({
                  x: 0,
                  y: 0
                });
                total++;
              }
              if (currentTotal !== total) {
                this.resizeArrays(total);
              }
              this.points = points;
              this.updateUVs();
              if (colors !== void 0 && colors !== null) {
                this.setColors(colors);
              }
              if (alphas !== void 0 && alphas !== null) {
                this.setAlphas(alphas);
              }
              return this;
            },
            updateUVs: function () {
              var currentUVs = this.uv;
              var total = this.points.length;
              var u0 = this.frame.u0;
              var v0 = this.frame.v0;
              var u1 = this.frame.u1;
              var v1 = this.frame.v1;
              var partH = (u1 - u0) / (total - 1);
              var partV = (v1 - v0) / (total - 1);
              for (var i = 0; i < total; i++) {
                var index = i * 4;
                var uv0;
                var uv1;
                var uv2;
                var uv3;
                if (this.horizontal) {
                  if (this._flipX) {
                    uv0 = u1 - i * partH;
                    uv2 = u1 - i * partH;
                  } else {
                    uv0 = u0 + i * partH;
                    uv2 = u0 + i * partH;
                  }
                  if (this._flipY) {
                    uv1 = v1;
                    uv3 = v0;
                  } else {
                    uv1 = v0;
                    uv3 = v1;
                  }
                } else {
                  if (this._flipX) {
                    uv0 = u0;
                    uv2 = u1;
                  } else {
                    uv0 = u1;
                    uv2 = u0;
                  }
                  if (this._flipY) {
                    uv1 = v1 - i * partV;
                    uv3 = v1 - i * partV;
                  } else {
                    uv1 = v0 + i * partV;
                    uv3 = v0 + i * partV;
                  }
                }
                currentUVs[index + 0] = uv0;
                currentUVs[index + 1] = uv1;
                currentUVs[index + 2] = uv2;
                currentUVs[index + 3] = uv3;
              }
              return this;
            },
            resizeArrays: function (newSize) {
              var colors = this.colors;
              var alphas = this.alphas;
              this.vertices = new Float32Array(newSize * 4);
              this.uv = new Float32Array(newSize * 4);
              colors = new Uint32Array(newSize * 2);
              alphas = new Float32Array(newSize * 2);
              for (var i = 0; i < newSize * 2; i++) {
                colors[i] = 16777215;
                alphas[i] = 1;
              }
              this.colors = colors;
              this.alphas = alphas;
              this.dirty = true;
              return this;
            },
            updateVertices: function () {
              var perp = this._perp;
              var points = this.points;
              var vertices = this.vertices;
              var total = points.length;
              this.dirty = false;
              if (total < 1) {
                return;
              }
              var nextPoint;
              var lastPoint = points[0];
              var frameSize = this.horizontal ? this.frame.halfHeight : this.frame.halfWidth;
              for (var i = 0; i < total; i++) {
                var point = points[i];
                var index = i * 4;
                if (i < total - 1) {
                  nextPoint = points[i + 1];
                } else {
                  nextPoint = point;
                }
                perp.x = nextPoint.y - lastPoint.y;
                perp.y = -(nextPoint.x - lastPoint.x);
                var perpLength = perp.length();
                perp.x /= perpLength;
                perp.y /= perpLength;
                perp.x *= frameSize;
                perp.y *= frameSize;
                vertices[index] = point.x + perp.x;
                vertices[index + 1] = point.y + perp.y;
                vertices[index + 2] = point.x - perp.x;
                vertices[index + 3] = point.y - perp.y;
                lastPoint = point;
              }
              return this;
            },
            setDebug: function (graphic, callback) {
              this.debugGraphic = graphic;
              if (!graphic && !callback) {
                this.debugCallback = null;
              } else if (!callback) {
                this.debugCallback = this.renderDebugVerts;
              } else {
                this.debugCallback = callback;
              }
              return this;
            },
            renderDebugVerts: function (src, meshLength, verts) {
              var graphic = src.debugGraphic;
              var px0 = verts[0];
              var py0 = verts[1];
              var px1 = verts[2];
              var py1 = verts[3];
              graphic.lineBetween(px0, py0, px1, py1);
              for (var i = 4; i < meshLength; i += 4) {
                var x0 = verts[i + 0];
                var y0 = verts[i + 1];
                var x1 = verts[i + 2];
                var y1 = verts[i + 3];
                graphic.lineBetween(px0, py0, x0, y0);
                graphic.lineBetween(px1, py1, x1, y1);
                graphic.lineBetween(px1, py1, x0, y0);
                graphic.lineBetween(x0, y0, x1, y1);
                px0 = x0;
                py0 = y0;
                px1 = x1;
                py1 = y1;
              }
            },
            preDestroy: function () {
              this.anims.destroy();
              this.anims = void 0;
              this.points = null;
              this.vertices = null;
              this.uv = null;
              this.colors = null;
              this.alphas = null;
              this.debugCallback = null;
              this.debugGraphic = null;
            },
            flipX: {
              get: function () {
                return this._flipX;
              },
              set: function (value) {
                this._flipX = value;
                return this.updateUVs();
              }
            },
            flipY: {
              get: function () {
                return this._flipY;
              },
              set: function (value) {
                this._flipY = value;
                return this.updateUVs();
              }
            }
          });
          module2.exports = Rope;
        }, function (module2, exports2, __webpack_require__) {
          var AddToDOM = __webpack_require__(142);
          var CanvasPool = __webpack_require__(31);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameEvents = __webpack_require__(22);
          var GameObject = __webpack_require__(15);
          var GetTextSize = __webpack_require__(458);
          var GetValue = __webpack_require__(6);
          var RemoveFromDOM = __webpack_require__(202);
          var TextRender = __webpack_require__(1088);
          var TextStyle = __webpack_require__(459);
          var Text = new Class({
            Extends: GameObject,
            Mixins: [Components.Alpha, Components.BlendMode, Components.ComputedSize, Components.Crop, Components.Depth, Components.Flip, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Tint, Components.Transform, Components.Visible, TextRender],
            initialize: function Text2(scene, x, y, text, style) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              GameObject.call(this, scene, "Text");
              this.renderer = scene.sys.renderer;
              this.setPosition(x, y);
              this.setOrigin(0, 0);
              this.initPipeline();
              this.canvas = CanvasPool.create(this);
              this.context = this.canvas.getContext("2d");
              this.style = new TextStyle(this, style);
              this.autoRound = true;
              this.splitRegExp = /(?:\r\n|\r|\n)/;
              this._text = void 0;
              this.padding = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
              };
              this.width = 1;
              this.height = 1;
              this.lineSpacing = 0;
              this.dirty = false;
              if (this.style.resolution === 0) {
                this.style.resolution = 1;
              }
              this._crop = this.resetCropObject();
              this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);
              this.frame = this.texture.get();
              this.frame.source.resolution = this.style.resolution;
              if (this.renderer && this.renderer.gl) {
                this.renderer.deleteTexture(this.frame.source.glTexture);
                this.frame.source.glTexture = null;
              }
              this.initRTL();
              this.setText(text);
              if (style && style.padding) {
                this.setPadding(style.padding);
              }
              if (style && style.lineSpacing) {
                this.setLineSpacing(style.lineSpacing);
              }
              scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, function () {
                this.dirty = true;
              }, this);
            },
            initRTL: function () {
              if (!this.style.rtl) {
                return;
              }
              this.canvas.dir = "rtl";
              this.context.direction = "rtl";
              this.canvas.style.display = "none";
              AddToDOM(this.canvas, this.scene.sys.canvas);
              this.originX = 1;
            },
            runWordWrap: function (text) {
              var style = this.style;
              if (style.wordWrapCallback) {
                var wrappedLines = style.wordWrapCallback.call(style.wordWrapCallbackScope, text, this);
                if (Array.isArray(wrappedLines)) {
                  wrappedLines = wrappedLines.join("\n");
                }
                return wrappedLines;
              } else if (style.wordWrapWidth) {
                if (style.wordWrapUseAdvanced) {
                  return this.advancedWordWrap(text, this.context, this.style.wordWrapWidth);
                } else {
                  return this.basicWordWrap(text, this.context, this.style.wordWrapWidth);
                }
              } else {
                return text;
              }
            },
            advancedWordWrap: function (text, context, wordWrapWidth) {
              var output = "";
              var lines = text.replace(/ +/gi, " ").split(this.splitRegExp);
              var linesCount = lines.length;
              for (var i = 0; i < linesCount; i++) {
                var line = lines[i];
                var out = "";
                line = line.replace(/^ *|\s*$/gi, "");
                var lineWidth = context.measureText(line).width;
                if (lineWidth < wordWrapWidth) {
                  output += line + "\n";
                  continue;
                }
                var currentLineWidth = wordWrapWidth;
                var words = line.split(" ");
                for (var j = 0; j < words.length; j++) {
                  var word = words[j];
                  var wordWithSpace = word + " ";
                  var wordWidth = context.measureText(wordWithSpace).width;
                  if (wordWidth > currentLineWidth) {
                    if (j === 0) {
                      var newWord = wordWithSpace;
                      while (newWord.length) {
                        newWord = newWord.slice(0, -1);
                        wordWidth = context.measureText(newWord).width;
                        if (wordWidth <= currentLineWidth) {
                          break;
                        }
                      }
                      if (!newWord.length) {
                        throw new Error("This text's wordWrapWidth setting is less than a single character!");
                      }
                      var secondPart = word.substr(newWord.length);
                      words[j] = secondPart;
                      out += newWord;
                    }
                    var offset = words[j].length ? j : j + 1;
                    var remainder = words.slice(offset).join(" ").replace(/[ \n]*$/gi, "");
                    lines[i + 1] = remainder + " " + (lines[i + 1] || "");
                    linesCount = lines.length;
                    break;
                  } else {
                    out += wordWithSpace;
                    currentLineWidth -= wordWidth;
                  }
                }
                output += out.replace(/[ \n]*$/gi, "") + "\n";
              }
              output = output.replace(/[\s|\n]*$/gi, "");
              return output;
            },
            basicWordWrap: function (text, context, wordWrapWidth) {
              var result = "";
              var lines = text.split(this.splitRegExp);
              var lastLineIndex = lines.length - 1;
              var whiteSpaceWidth = context.measureText(" ").width;
              for (var i = 0; i <= lastLineIndex; i++) {
                var spaceLeft = wordWrapWidth;
                var words = lines[i].split(" ");
                var lastWordIndex = words.length - 1;
                for (var j = 0; j <= lastWordIndex; j++) {
                  var word = words[j];
                  var wordWidth = context.measureText(word).width;
                  var wordWidthWithSpace = wordWidth;
                  if (j < lastWordIndex) {
                    wordWidthWithSpace += whiteSpaceWidth;
                  }
                  if (wordWidthWithSpace > spaceLeft) {
                    if (j > 0) {
                      result += "\n";
                      spaceLeft = wordWrapWidth;
                    }
                  }
                  result += word;
                  if (j < lastWordIndex) {
                    result += " ";
                    spaceLeft -= wordWidthWithSpace;
                  } else {
                    spaceLeft -= wordWidth;
                  }
                }
                if (i < lastLineIndex) {
                  result += "\n";
                }
              }
              return result;
            },
            getWrappedText: function (text) {
              if (text === void 0) {
                text = this._text;
              }
              this.style.syncFont(this.canvas, this.context);
              var wrappedLines = this.runWordWrap(text);
              return wrappedLines.split(this.splitRegExp);
            },
            setText: function (value) {
              if (!value && value !== 0) {
                value = "";
              }
              if (Array.isArray(value)) {
                value = value.join("\n");
              }
              if (value !== this._text) {
                this._text = value.toString();
                this.updateText();
              }
              return this;
            },
            setStyle: function (style) {
              return this.style.setStyle(style);
            },
            setFont: function (font) {
              return this.style.setFont(font);
            },
            setFontFamily: function (family) {
              return this.style.setFontFamily(family);
            },
            setFontSize: function (size) {
              return this.style.setFontSize(size);
            },
            setFontStyle: function (style) {
              return this.style.setFontStyle(style);
            },
            setFixedSize: function (width, height) {
              return this.style.setFixedSize(width, height);
            },
            setBackgroundColor: function (color) {
              return this.style.setBackgroundColor(color);
            },
            setFill: function (fillStyle) {
              return this.style.setFill(fillStyle);
            },
            setColor: function (color) {
              return this.style.setColor(color);
            },
            setStroke: function (color, thickness) {
              return this.style.setStroke(color, thickness);
            },
            setShadow: function (x, y, color, blur, shadowStroke, shadowFill) {
              return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);
            },
            setShadowOffset: function (x, y) {
              return this.style.setShadowOffset(x, y);
            },
            setShadowColor: function (color) {
              return this.style.setShadowColor(color);
            },
            setShadowBlur: function (blur) {
              return this.style.setShadowBlur(blur);
            },
            setShadowStroke: function (enabled) {
              return this.style.setShadowStroke(enabled);
            },
            setShadowFill: function (enabled) {
              return this.style.setShadowFill(enabled);
            },
            setWordWrapWidth: function (width, useAdvancedWrap) {
              return this.style.setWordWrapWidth(width, useAdvancedWrap);
            },
            setWordWrapCallback: function (callback, scope) {
              return this.style.setWordWrapCallback(callback, scope);
            },
            setAlign: function (align) {
              return this.style.setAlign(align);
            },
            setResolution: function (value) {
              return this.style.setResolution(value);
            },
            setLineSpacing: function (value) {
              this.lineSpacing = value;
              return this.updateText();
            },
            setPadding: function (left, top, right, bottom) {
              if (typeof left === "object") {
                var config = left;
                var x = GetValue(config, "x", null);
                if (x !== null) {
                  left = x;
                  right = x;
                } else {
                  left = GetValue(config, "left", 0);
                  right = GetValue(config, "right", left);
                }
                var y = GetValue(config, "y", null);
                if (y !== null) {
                  top = y;
                  bottom = y;
                } else {
                  top = GetValue(config, "top", 0);
                  bottom = GetValue(config, "bottom", top);
                }
              } else {
                if (left === void 0) {
                  left = 0;
                }
                if (top === void 0) {
                  top = left;
                }
                if (right === void 0) {
                  right = left;
                }
                if (bottom === void 0) {
                  bottom = top;
                }
              }
              this.padding.left = left;
              this.padding.top = top;
              this.padding.right = right;
              this.padding.bottom = bottom;
              return this.updateText();
            },
            setMaxLines: function (max) {
              return this.style.setMaxLines(max);
            },
            updateText: function () {
              var canvas = this.canvas;
              var context = this.context;
              var style = this.style;
              var resolution = style.resolution;
              var size = style.metrics;
              style.syncFont(canvas, context);
              var outputText = this._text;
              if (style.wordWrapWidth || style.wordWrapCallback) {
                outputText = this.runWordWrap(this._text);
              }
              var lines = outputText.split(this.splitRegExp);
              var textSize = GetTextSize(this, size, lines);
              var padding = this.padding;
              var textWidth;
              if (style.fixedWidth === 0) {
                this.width = textSize.width + padding.left + padding.right;
                textWidth = textSize.width;
              } else {
                this.width = style.fixedWidth;
                textWidth = this.width - padding.left - padding.right;
                if (textWidth < textSize.width) {
                  textWidth = textSize.width;
                }
              }
              if (style.fixedHeight === 0) {
                this.height = textSize.height + padding.top + padding.bottom;
              } else {
                this.height = style.fixedHeight;
              }
              var w = this.width;
              var h = this.height;
              this.updateDisplayOrigin();
              w *= resolution;
              h *= resolution;
              w = Math.max(w, 1);
              h = Math.max(h, 1);
              if (canvas.width !== w || canvas.height !== h) {
                canvas.width = w;
                canvas.height = h;
                this.frame.setSize(w, h);
                style.syncFont(canvas, context);
              } else {
                context.clearRect(0, 0, w, h);
              }
              context.save();
              context.scale(resolution, resolution);
              if (style.backgroundColor) {
                context.fillStyle = style.backgroundColor;
                context.fillRect(0, 0, w, h);
              }
              style.syncStyle(canvas, context);
              context.textBaseline = "alphabetic";
              context.translate(padding.left, padding.top);
              var linePositionX;
              var linePositionY;
              for (var i = 0; i < textSize.lines; i++) {
                linePositionX = style.strokeThickness / 2;
                linePositionY = style.strokeThickness / 2 + i * textSize.lineHeight + size.ascent;
                if (i > 0) {
                  linePositionY += textSize.lineSpacing * i;
                }
                if (style.rtl) {
                  linePositionX = w - linePositionX;
                } else if (style.align === "right") {
                  linePositionX += textWidth - textSize.lineWidths[i];
                } else if (style.align === "center") {
                  linePositionX += (textWidth - textSize.lineWidths[i]) / 2;
                } else if (style.align === "justify") {
                  var minimumLengthToApplyJustification = 0.85;
                  if (textSize.lineWidths[i] / textSize.width >= minimumLengthToApplyJustification) {
                    var extraSpace = textSize.width - textSize.lineWidths[i];
                    var spaceSize = context.measureText(" ").width;
                    var trimmedLine = lines[i].trim();
                    var array = trimmedLine.split(" ");
                    extraSpace += (lines[i].length - trimmedLine.length) * spaceSize;
                    var extraSpaceCharacters = Math.floor(extraSpace / spaceSize);
                    var idx = 0;
                    while (extraSpaceCharacters > 0) {
                      array[idx] += " ";
                      idx = (idx + 1) % (array.length - 1 || 1);
                      --extraSpaceCharacters;
                    }
                    lines[i] = array.join(" ");
                  }
                }
                if (this.autoRound) {
                  linePositionX = Math.round(linePositionX);
                  linePositionY = Math.round(linePositionY);
                }
                if (style.strokeThickness) {
                  this.style.syncShadow(context, style.shadowStroke);
                  context.strokeText(lines[i], linePositionX, linePositionY);
                }
                if (style.color) {
                  this.style.syncShadow(context, style.shadowFill);
                  context.fillText(lines[i], linePositionX, linePositionY);
                }
              }
              context.restore();
              if (this.renderer && this.renderer.gl) {
                this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);
                this.frame.glTexture = this.frame.source.glTexture;
              }
              this.dirty = true;
              var input = this.input;
              if (input && !input.customHitArea) {
                input.hitArea.width = this.width;
                input.hitArea.height = this.height;
              }
              return this;
            },
            getTextMetrics: function () {
              return this.style.getTextMetrics();
            },
            text: {
              get: function () {
                return this._text;
              },
              set: function (value) {
                this.setText(value);
              }
            },
            toJSON: function () {
              var out = Components.ToJSON(this);
              var data = {
                autoRound: this.autoRound,
                text: this._text,
                style: this.style.toJSON(),
                padding: {
                  left: this.padding.left,
                  right: this.padding.right,
                  top: this.padding.top,
                  bottom: this.padding.bottom
                }
              };
              out.data = data;
              return out;
            },
            preDestroy: function () {
              if (this.style.rtl) {
                RemoveFromDOM(this.canvas);
              }
              CanvasPool.remove(this.canvas);
              this.texture.destroy();
            }
          });
          module2.exports = Text;
        }, function (module2, exports2, __webpack_require__) {
          var CanvasPool = __webpack_require__(31);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameEvents = __webpack_require__(22);
          var GameObject = __webpack_require__(15);
          var GetPowerOfTwo = __webpack_require__(361);
          var Smoothing = __webpack_require__(192);
          var TileSpriteRender = __webpack_require__(1091);
          var Vector2 = __webpack_require__(3);
          var _FLAG = 8;
          var TileSprite = new Class({
            Extends: GameObject,
            Mixins: [Components.Alpha, Components.BlendMode, Components.ComputedSize, Components.Crop, Components.Depth, Components.Flip, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Tint, Components.Transform, Components.Visible, TileSpriteRender],
            initialize: function TileSprite2(scene, x, y, width, height, textureKey, frameKey) {
              var renderer = scene.sys.renderer;
              GameObject.call(this, scene, "TileSprite");
              var displayTexture = scene.sys.textures.get(textureKey);
              var displayFrame = displayTexture.get(frameKey);
              if (!width || !height) {
                width = displayFrame.width;
                height = displayFrame.height;
              } else {
                width = Math.floor(width);
                height = Math.floor(height);
              }
              this._tilePosition = new Vector2();
              this._tileScale = new Vector2(1, 1);
              this.dirty = false;
              this.renderer = renderer;
              this.canvas = CanvasPool.create(this, width, height);
              this.context = this.canvas.getContext("2d");
              this.displayTexture = displayTexture;
              this.displayFrame = displayFrame;
              this._crop = this.resetCropObject();
              this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);
              this.frame = this.texture.get();
              this.potWidth = GetPowerOfTwo(displayFrame.width);
              this.potHeight = GetPowerOfTwo(displayFrame.height);
              this.fillCanvas = CanvasPool.create2D(this, this.potWidth, this.potHeight);
              this.fillContext = this.fillCanvas.getContext("2d");
              this.fillPattern = null;
              this.setPosition(x, y);
              this.setSize(width, height);
              this.setFrame(frameKey);
              this.setOriginFromFrame();
              this.initPipeline();
              scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, function (renderer2) {
                if (!renderer2) {
                  return;
                }
                var gl = renderer2.gl;
                this.dirty = true;
                this.fillPattern = null;
                this.fillPattern = renderer2.createTexture2D(0, gl.LINEAR, gl.LINEAR, gl.REPEAT, gl.REPEAT, gl.RGBA, this.fillCanvas, this.potWidth, this.potHeight);
              }, this);
            },
            setTexture: function (key, frame) {
              this.displayTexture = this.scene.sys.textures.get(key);
              return this.setFrame(frame);
            },
            setFrame: function (frame) {
              var newFrame = this.displayTexture.get(frame);
              this.potWidth = GetPowerOfTwo(newFrame.width);
              this.potHeight = GetPowerOfTwo(newFrame.height);
              this.canvas.width = 0;
              if (!newFrame.cutWidth || !newFrame.cutHeight) {
                this.renderFlags &= ~_FLAG;
              } else {
                this.renderFlags |= _FLAG;
              }
              this.displayFrame = newFrame;
              this.dirty = true;
              this.updateTileTexture();
              return this;
            },
            setTilePosition: function (x, y) {
              if (x !== void 0) {
                this.tilePositionX = x;
              }
              if (y !== void 0) {
                this.tilePositionY = y;
              }
              return this;
            },
            setTileScale: function (x, y) {
              if (x === void 0) {
                x = this.tileScaleX;
              }
              if (y === void 0) {
                y = x;
              }
              this.tileScaleX = x;
              this.tileScaleY = y;
              return this;
            },
            updateTileTexture: function () {
              if (!this.dirty || !this.renderer) {
                return;
              }
              var frame = this.displayFrame;
              if (frame.source.isRenderTexture || frame.source.isGLTexture) {
                console.warn("TileSprites can only use Image or Canvas based textures");
                this.dirty = false;
                return;
              }
              var ctx = this.fillContext;
              var canvas = this.fillCanvas;
              var fw = this.potWidth;
              var fh = this.potHeight;
              if (!this.renderer || !this.renderer.gl) {
                fw = frame.cutWidth;
                fh = frame.cutHeight;
              }
              ctx.clearRect(0, 0, fw, fh);
              canvas.width = fw;
              canvas.height = fh;
              ctx.drawImage(frame.source.image, frame.cutX, frame.cutY, frame.cutWidth, frame.cutHeight, 0, 0, fw, fh);
              if (this.renderer && this.renderer.gl) {
                this.fillPattern = this.renderer.canvasToTexture(canvas, this.fillPattern);
              } else {
                this.fillPattern = ctx.createPattern(canvas, "repeat");
              }
              this.updateCanvas();
              this.dirty = false;
            },
            updateCanvas: function () {
              var canvas = this.canvas;
              if (canvas.width !== this.width || canvas.height !== this.height) {
                canvas.width = this.width;
                canvas.height = this.height;
                this.frame.setSize(this.width, this.height);
                this.updateDisplayOrigin();
                this.dirty = true;
              }
              if (!this.dirty || this.renderer && this.renderer.gl) {
                this.dirty = false;
                return;
              }
              var ctx = this.context;
              if (!this.scene.sys.game.config.antialias) {
                Smoothing.disable(ctx);
              }
              var scaleX = this._tileScale.x;
              var scaleY = this._tileScale.y;
              var positionX = this._tilePosition.x;
              var positionY = this._tilePosition.y;
              ctx.clearRect(0, 0, this.width, this.height);
              ctx.save();
              ctx.scale(scaleX, scaleY);
              ctx.translate(-positionX, -positionY);
              ctx.fillStyle = this.fillPattern;
              ctx.fillRect(positionX, positionY, this.width / scaleX, this.height / scaleY);
              ctx.restore();
              this.dirty = false;
            },
            preDestroy: function () {
              if (this.renderer && this.renderer.gl) {
                this.renderer.deleteTexture(this.fillPattern);
              }
              CanvasPool.remove(this.canvas);
              CanvasPool.remove(this.fillCanvas);
              this.fillPattern = null;
              this.fillContext = null;
              this.fillCanvas = null;
              this.displayTexture = null;
              this.displayFrame = null;
              this.texture.destroy();
              this.renderer = null;
            },
            tilePositionX: {
              get: function () {
                return this._tilePosition.x;
              },
              set: function (value) {
                this._tilePosition.x = value;
                this.dirty = true;
              }
            },
            tilePositionY: {
              get: function () {
                return this._tilePosition.y;
              },
              set: function (value) {
                this._tilePosition.y = value;
                this.dirty = true;
              }
            },
            tileScaleX: {
              get: function () {
                return this._tileScale.x;
              },
              set: function (value) {
                this._tileScale.x = value;
                this.dirty = true;
              }
            },
            tileScaleY: {
              get: function () {
                return this._tileScale.y;
              },
              set: function (value) {
                this._tileScale.y = value;
                this.dirty = true;
              }
            }
          });
          module2.exports = TileSprite;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Clamp = __webpack_require__(18);
          var Components = __webpack_require__(11);
          var Events = __webpack_require__(75);
          var GameEvents = __webpack_require__(22);
          var InputEvents = __webpack_require__(51);
          var GameObject = __webpack_require__(15);
          var SoundEvents = __webpack_require__(70);
          var UUID = __webpack_require__(222);
          var VideoRender = __webpack_require__(1094);
          var MATH_CONST = __webpack_require__(14);
          var Video = new Class({
            Extends: GameObject,
            Mixins: [Components.Alpha, Components.BlendMode, Components.Depth, Components.Flip, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Size, Components.TextureCrop, Components.Tint, Components.Transform, Components.Visible, VideoRender],
            initialize: function Video2(scene, x, y, key) {
              GameObject.call(this, scene, "Video");
              this.video = null;
              this.videoTexture = null;
              this.videoTextureSource = null;
              this.snapshotTexture = null;
              this.flipY = false;
              this._key = UUID();
              this.touchLocked = true;
              this.playWhenUnlocked = false;
              this.retryLimit = 20;
              this.retry = 0;
              this.retryInterval = 500;
              this._retryID = null;
              this._systemMuted = false;
              this._codeMuted = false;
              this._systemPaused = false;
              this._codePaused = false;
              this._callbacks = {
                play: this.playHandler.bind(this),
                error: this.loadErrorHandler.bind(this),
                end: this.completeHandler.bind(this),
                time: this.timeUpdateHandler.bind(this),
                seeking: this.seekingHandler.bind(this),
                seeked: this.seekedHandler.bind(this)
              };
              this._crop = this.resetCropObject();
              this.markers = {};
              this._markerIn = -1;
              this._markerOut = MATH_CONST.MAX_SAFE_INTEGER;
              this._lastUpdate = 0;
              this._cacheKey = "";
              this._isSeeking = false;
              this.removeVideoElementOnDestroy = false;
              this.setPosition(x, y);
              this.initPipeline();
              if (key) {
                this.changeSource(key, false);
              }
              var game = scene.sys.game.events;
              game.on(GameEvents.PAUSE, this.globalPause, this);
              game.on(GameEvents.RESUME, this.globalResume, this);
              var sound = scene.sys.sound;
              if (sound) {
                sound.on(SoundEvents.GLOBAL_MUTE, this.globalMute, this);
              }
            },
            addedToScene: function () {
              this.scene.sys.updateList.add(this);
            },
            removedFromScene: function () {
              this.scene.sys.updateList.remove(this);
            },
            play: function (loop, markerIn, markerOut) {
              if (this.touchLocked && this.playWhenUnlocked || this.isPlaying()) {
                return this;
              }
              var video = this.video;
              if (!video) {
                console.warn("Video not loaded");
                return this;
              }
              if (loop === void 0) {
                loop = video.loop;
              }
              var sound = this.scene.sys.sound;
              if (sound && sound.mute) {
                this.setMute(true);
              }
              if (!isNaN(markerIn)) {
                this._markerIn = markerIn;
              }
              if (!isNaN(markerOut) && markerOut > markerIn) {
                this._markerOut = markerOut;
              }
              video.loop = loop;
              var callbacks = this._callbacks;
              var playPromise = video.play();
              if (playPromise !== void 0) {
                playPromise.then(this.playPromiseSuccessHandler.bind(this)).catch(this.playPromiseErrorHandler.bind(this));
              } else {
                video.addEventListener("playing", callbacks.play, true);
                if (video.readyState < 2) {
                  this.retry = this.retryLimit;
                  this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);
                }
              }
              video.addEventListener("ended", callbacks.end, true);
              video.addEventListener("timeupdate", callbacks.time, true);
              video.addEventListener("seeking", callbacks.seeking, true);
              video.addEventListener("seeked", callbacks.seeked, true);
              return this;
            },
            changeSource: function (key, autoplay, loop, markerIn, markerOut) {
              if (autoplay === void 0) {
                autoplay = true;
              }
              var currentVideo = this.video;
              if (currentVideo) {
                this.stop();
              }
              var newVideo = this.scene.sys.cache.video.get(key);
              if (newVideo) {
                this.video = newVideo;
                this._cacheKey = key;
                this._codePaused = newVideo.paused;
                this._codeMuted = newVideo.muted;
                if (this.videoTexture) {
                  this.scene.sys.textures.remove(this._key);
                  this.videoTexture = this.scene.sys.textures.create(this._key, newVideo, newVideo.videoWidth, newVideo.videoHeight);
                  this.videoTextureSource = this.videoTexture.source[0];
                  this.videoTexture.add("__BASE", 0, 0, 0, newVideo.videoWidth, newVideo.videoHeight);
                  this.setTexture(this.videoTexture);
                  this.setSizeToFrame();
                  this.updateDisplayOrigin();
                  this.emit(Events.VIDEO_CREATED, this, newVideo.videoWidth, newVideo.videoHeight);
                } else {
                  this.updateTexture();
                }
                newVideo.currentTime = 0;
                this._lastUpdate = 0;
                if (autoplay) {
                  this.play(loop, markerIn, markerOut);
                }
              } else {
                this.video = null;
              }
              return this;
            },
            addMarker: function (key, markerIn, markerOut) {
              if (!isNaN(markerIn) && markerIn >= 0 && !isNaN(markerOut)) {
                this.markers[key] = [markerIn, markerOut];
              }
              return this;
            },
            playMarker: function (key, loop) {
              var marker = this.markers[key];
              if (marker) {
                this.play(loop, marker[0], marker[1]);
              }
              return this;
            },
            removeMarker: function (key) {
              delete this.markers[key];
              return this;
            },
            snapshot: function (width, height) {
              if (width === void 0) {
                width = this.width;
              }
              if (height === void 0) {
                height = this.height;
              }
              return this.snapshotArea(0, 0, this.width, this.height, width, height);
            },
            snapshotArea: function (x, y, srcWidth, srcHeight, destWidth, destHeight) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (srcWidth === void 0) {
                srcWidth = this.width;
              }
              if (srcHeight === void 0) {
                srcHeight = this.height;
              }
              if (destWidth === void 0) {
                destWidth = srcWidth;
              }
              if (destHeight === void 0) {
                destHeight = srcHeight;
              }
              var video = this.video;
              var snap = this.snapshotTexture;
              if (!snap) {
                snap = this.scene.sys.textures.createCanvas(UUID(), destWidth, destHeight);
                this.snapshotTexture = snap;
                if (video) {
                  snap.context.drawImage(video, x, y, srcWidth, srcHeight, 0, 0, destWidth, destHeight);
                }
              } else {
                snap.setSize(destWidth, destHeight);
                if (video) {
                  snap.context.drawImage(video, x, y, srcWidth, srcHeight, 0, 0, destWidth, destHeight);
                }
              }
              return snap.update();
            },
            saveSnapshotTexture: function (key) {
              if (this.snapshotTexture) {
                this.scene.sys.textures.renameTexture(this.snapshotTexture.key, key);
              } else {
                this.snapshotTexture = this.scene.sys.textures.createCanvas(key, this.width, this.height);
              }
              return this.snapshotTexture;
            },
            loadURL: function (url, loadEvent, noAudio) {
              if (loadEvent === void 0) {
                loadEvent = "loadeddata";
              }
              if (noAudio === void 0) {
                noAudio = false;
              }
              if (this.video) {
                this.stop();
              }
              if (this.videoTexture) {
                this.scene.sys.textures.remove(this._key);
              }
              var video = document.createElement("video");
              video.controls = false;
              if (noAudio) {
                video.muted = true;
                video.defaultMuted = true;
                video.setAttribute("autoplay", "autoplay");
              }
              video.setAttribute("playsinline", "playsinline");
              video.setAttribute("preload", "auto");
              video.addEventListener("error", this._callbacks.error, true);
              video.src = url;
              video.load();
              this.video = video;
              return this;
            },
            loadMediaStream: function (stream, loadEvent, noAudio) {
              if (loadEvent === void 0) {
                loadEvent = "loadeddata";
              }
              if (noAudio === void 0) {
                noAudio = false;
              }
              if (this.video) {
                this.stop();
              }
              if (this.videoTexture) {
                this.scene.sys.textures.remove(this._key);
              }
              var video = document.createElement("video");
              video.controls = false;
              if (noAudio) {
                video.muted = true;
                video.defaultMuted = true;
                video.setAttribute("autoplay", "autoplay");
              }
              video.setAttribute("playsinline", "playsinline");
              video.setAttribute("preload", "auto");
              video.addEventListener("error", this._callbacks.error, true);
              try {
                video.srcObject = stream;
              } catch (error) {
                video.src = window.URL.createObjectURL(stream);
              }
              video.load();
              this.video = video;
              return this;
            },
            playPromiseSuccessHandler: function () {
              this._codePaused = false;
              this.touchLocked = false;
              this.emit(Events.VIDEO_PLAY, this);
              if (this._markerIn > -1) {
                this.video.currentTime = this._markerIn;
              }
            },
            playPromiseErrorHandler: function (error) {
              this.scene.sys.input.once(InputEvents.POINTER_DOWN, this.unlockHandler, this);
              this.touchLocked = true;
              this.playWhenUnlocked = true;
              this.emit(Events.VIDEO_ERROR, this, error);
            },
            playHandler: function () {
              this._codePaused = false;
              this.touchLocked = false;
              this.emit(Events.VIDEO_PLAY, this);
              this.video.removeEventListener("playing", this._callbacks.play, true);
            },
            loadErrorHandler: function (event) {
              this.stop();
              this.emit(Events.VIDEO_ERROR, this, event);
            },
            unlockHandler: function () {
              this.touchLocked = false;
              this.playWhenUnlocked = false;
              this.emit(Events.VIDEO_UNLOCKED, this);
              if (this._markerIn > -1) {
                this.video.currentTime = this._markerIn;
              }
              this.video.play();
              this.emit(Events.VIDEO_PLAY, this);
            },
            completeHandler: function () {
              this.emit(Events.VIDEO_COMPLETE, this);
            },
            timeUpdateHandler: function () {
              if (this.video && this.video.currentTime < this._lastUpdate) {
                this.emit(Events.VIDEO_LOOP, this);
                this._lastUpdate = 0;
              }
            },
            preUpdate: function () {
              var video = this.video;
              if (video) {
                var currentTime = video.currentTime;
                if (currentTime !== this._lastUpdate) {
                  this._lastUpdate = currentTime;
                  this.updateTexture();
                  if (currentTime >= this._markerOut) {
                    if (video.loop) {
                      video.currentTime = this._markerIn;
                      this.updateTexture();
                      this._lastUpdate = currentTime;
                      this.emit(Events.VIDEO_LOOP, this);
                    } else {
                      this.emit(Events.VIDEO_COMPLETE, this);
                      this.stop();
                    }
                  }
                }
              }
            },
            checkVideoProgress: function () {
              if (this.video.readyState >= 2) {
                this.updateTexture();
              } else {
                this.retry--;
                if (this.retry > 0) {
                  this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);
                } else {
                  this.emit(Events.VIDEO_TIMEOUT, this);
                }
              }
            },
            updateTexture: function () {
              var video = this.video;
              var width = video.videoWidth;
              var height = video.videoHeight;
              if (!this.videoTexture) {
                this.videoTexture = this.scene.sys.textures.create(this._key, video, width, height);
                this.videoTextureSource = this.videoTexture.source[0];
                this.videoTexture.add("__BASE", 0, 0, 0, width, height);
                this.setTexture(this.videoTexture);
                this.setSizeToFrame();
                this.updateDisplayOrigin();
                this.emit(Events.VIDEO_CREATED, this, width, height);
              } else {
                var textureSource = this.videoTextureSource;
                if (textureSource.source !== video) {
                  textureSource.source = video;
                  textureSource.width = width;
                  textureSource.height = height;
                }
                textureSource.update();
              }
            },
            getVideoKey: function () {
              return this._cacheKey;
            },
            seekTo: function (value) {
              var video = this.video;
              if (video) {
                var duration = video.duration;
                if (duration !== Infinity && !isNaN(duration)) {
                  var seekTime = duration * value;
                  this.setCurrentTime(seekTime);
                }
              }
              return this;
            },
            getCurrentTime: function () {
              return this.video ? this.video.currentTime : 0;
            },
            setCurrentTime: function (value) {
              var video = this.video;
              if (video) {
                if (typeof value === "string") {
                  var op = value[0];
                  var num = parseFloat(value.substr(1));
                  if (op === "+") {
                    value = video.currentTime + num;
                  } else if (op === "-") {
                    value = video.currentTime - num;
                  }
                }
                video.currentTime = value;
                this._lastUpdate = value;
              }
              return this;
            },
            isSeeking: function () {
              return this._isSeeking;
            },
            seekingHandler: function () {
              this._isSeeking = true;
              this.emit(Events.VIDEO_SEEKING, this);
            },
            seekedHandler: function () {
              this._isSeeking = false;
              this.emit(Events.VIDEO_SEEKED, this);
              var video = this.video;
              if (video) {
                this.updateTexture();
              }
            },
            getProgress: function () {
              var video = this.video;
              if (video) {
                var now = video.currentTime;
                var duration = video.duration;
                if (duration !== Infinity && !isNaN(duration)) {
                  return now / duration;
                }
              }
              return 0;
            },
            getDuration: function () {
              return this.video ? this.video.duration : 0;
            },
            setMute: function (value) {
              if (value === void 0) {
                value = true;
              }
              this._codeMuted = value;
              var video = this.video;
              if (video) {
                video.muted = this._systemMuted ? true : value;
              }
              return this;
            },
            isMuted: function () {
              return this._codeMuted;
            },
            globalMute: function (soundManager, value) {
              this._systemMuted = value;
              var video = this.video;
              if (video) {
                video.muted = this._codeMuted ? true : value;
              }
            },
            globalPause: function () {
              this._systemPaused = true;
              if (this.video) {
                this.video.pause();
              }
            },
            globalResume: function () {
              this._systemPaused = false;
              if (this.video && !this._codePaused) {
                this.video.play();
              }
            },
            setPaused: function (value) {
              if (value === void 0) {
                value = true;
              }
              var video = this.video;
              this._codePaused = value;
              if (video) {
                if (value) {
                  if (!video.paused) {
                    video.pause();
                  }
                } else if (!value) {
                  if (video.paused && !this._systemPaused) {
                    video.play();
                  }
                }
              }
              return this;
            },
            getVolume: function () {
              return this.video ? this.video.volume : 1;
            },
            setVolume: function (value) {
              if (value === void 0) {
                value = 1;
              }
              if (this.video) {
                this.video.volume = Clamp(value, 0, 1);
              }
              return this;
            },
            getPlaybackRate: function () {
              return this.video ? this.video.playbackRate : 1;
            },
            setPlaybackRate: function (rate) {
              if (this.video) {
                this.video.playbackRate = rate;
              }
              return this;
            },
            getLoop: function () {
              return this.video ? this.video.loop : false;
            },
            setLoop: function (value) {
              if (value === void 0) {
                value = true;
              }
              if (this.video) {
                this.video.loop = value;
              }
              return this;
            },
            isPlaying: function () {
              return this.video ? !(this.video.paused || this.video.ended) : false;
            },
            isPaused: function () {
              return this.video && this.video.paused || this._codePaused || this._systemPaused;
            },
            saveTexture: function (key, flipY) {
              if (flipY === void 0) {
                flipY = false;
              }
              if (this.videoTexture) {
                this.scene.sys.textures.renameTexture(this._key, key);
              }
              this._key = key;
              this.flipY = flipY;
              if (this.videoTextureSource) {
                this.videoTextureSource.setFlipY(flipY);
              }
              return this.videoTexture;
            },
            stop: function () {
              var video = this.video;
              if (video) {
                var callbacks = this._callbacks;
                for (var callback in callbacks) {
                  video.removeEventListener(callback, callbacks[callback], true);
                }
                video.pause();
              }
              if (this._retryID) {
                window.clearTimeout(this._retryID);
              }
              this.emit(Events.VIDEO_STOP, this);
              return this;
            },
            removeVideoElement: function () {
              var video = this.video;
              if (!video) {
                return;
              }
              if (video.parentNode) {
                video.parentNode.removeChild(video);
              }
              while (video.hasChildNodes()) {
                video.removeChild(video.firstChild);
              }
              video.removeAttribute("autoplay");
              video.removeAttribute("src");
              this.video = null;
            },
            preDestroy: function () {
              this.stop();
              if (this.removeVideoElementOnDestroy) {
                this.removeVideoElement();
              }
              var game = this.scene.sys.game.events;
              game.off(GameEvents.PAUSE, this.globalPause, this);
              game.off(GameEvents.RESUME, this.globalResume, this);
              var sound = this.scene.sys.sound;
              if (sound) {
                sound.off(SoundEvents.GLOBAL_MUTE, this.globalMute, this);
              }
              if (this._retryID) {
                window.clearTimeout(this._retryID);
              }
            }
          });
          module2.exports = Video;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Contains = __webpack_require__(228);
          var GetPoints = __webpack_require__(470);
          var GEOM_CONST = __webpack_require__(56);
          var Polygon = new Class({
            initialize: function Polygon2(points) {
              this.type = GEOM_CONST.POLYGON;
              this.area = 0;
              this.points = [];
              if (points) {
                this.setTo(points);
              }
            },
            contains: function (x, y) {
              return Contains(this, x, y);
            },
            setTo: function (points) {
              this.area = 0;
              this.points = [];
              if (typeof points === "string") {
                points = points.split(" ");
              }
              if (!Array.isArray(points)) {
                return this;
              }
              var p3;
              var y0 = Number.MAX_VALUE;
              for (var i = 0; i < points.length; i++) {
                p3 = {
                  x: 0,
                  y: 0
                };
                if (typeof points[i] === "number" || typeof points[i] === "string") {
                  p3.x = parseFloat(points[i]);
                  p3.y = parseFloat(points[i + 1]);
                  i++;
                } else if (Array.isArray(points[i])) {
                  p3.x = points[i][0];
                  p3.y = points[i][1];
                } else {
                  p3.x = points[i].x;
                  p3.y = points[i].y;
                }
                this.points.push(p3);
                if (p3.y < y0) {
                  y0 = p3.y;
                }
              }
              this.calculateArea(y0);
              return this;
            },
            calculateArea: function () {
              if (this.points.length < 3) {
                this.area = 0;
                return this.area;
              }
              var sum = 0;
              var p1;
              var p22;
              for (var i = 0; i < this.points.length - 1; i++) {
                p1 = this.points[i];
                p22 = this.points[i + 1];
                sum += (p22.x - p1.x) * (p1.y + p22.y);
              }
              p1 = this.points[0];
              p22 = this.points[this.points.length - 1];
              sum += (p1.x - p22.x) * (p22.y + p1.y);
              this.area = -sum * 0.5;
              return this.area;
            },
            getPoints: function (quantity, step, output) {
              return GetPoints(this, quantity, step, output);
            }
          });
          module2.exports = Polygon;
        }, function (module2, exports2) {
          var Contains = function (polygon, x, y) {
            var inside = false;
            for (var i = -1, j = polygon.points.length - 1; ++i < polygon.points.length; j = i) {
              var ix = polygon.points[i].x;
              var iy = polygon.points[i].y;
              var jx = polygon.points[j].x;
              var jy = polygon.points[j].y;
              if ((iy <= y && y < jy || jy <= y && y < iy) && x < (jx - ix) * (y - iy) / (jy - iy) + ix) {
                inside = !inside;
              }
            }
            return inside;
          };
          module2.exports = Contains;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var GetFastValue = __webpack_require__(2);
          var Extend = __webpack_require__(17);
          var SetValue = __webpack_require__(478);
          var ShaderRender = __webpack_require__(1176);
          var TransformMatrix = __webpack_require__(25);
          var Shader = new Class({
            Extends: GameObject,
            Mixins: [Components.ComputedSize, Components.Depth, Components.GetBounds, Components.Mask, Components.Origin, Components.ScrollFactor, Components.Transform, Components.Visible, ShaderRender],
            initialize: function Shader2(scene, key, x, y, width, height, textures, textureData) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = 128;
              }
              if (height === void 0) {
                height = 128;
              }
              GameObject.call(this, scene, "Shader");
              this.blendMode = -1;
              this.shader;
              var renderer = scene.sys.renderer;
              this.renderer = renderer;
              this.gl = renderer.gl;
              this.vertexData = new ArrayBuffer(6 * (Float32Array.BYTES_PER_ELEMENT * 2));
              this.vertexBuffer = renderer.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW);
              this.program = null;
              this.bytes = new Uint8Array(this.vertexData);
              this.vertexViewF32 = new Float32Array(this.vertexData);
              this._tempMatrix1 = new TransformMatrix();
              this._tempMatrix2 = new TransformMatrix();
              this._tempMatrix3 = new TransformMatrix();
              this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
              this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
              this.uniforms = {};
              this.pointer = null;
              this._rendererWidth = renderer.width;
              this._rendererHeight = renderer.height;
              this._textureCount = 0;
              this.framebuffer = null;
              this.glTexture = null;
              this.renderToTexture = false;
              this.texture = null;
              this.setPosition(x, y);
              this.setSize(width, height);
              this.setOrigin(0.5, 0.5);
              this.setShader(key, textures, textureData);
            },
            willRender: function (camera) {
              if (this.renderToTexture) {
                return true;
              } else {
                return !(GameObject.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
              }
            },
            setRenderToTexture: function (key, flipY) {
              if (flipY === void 0) {
                flipY = false;
              }
              if (!this.renderToTexture) {
                var width = this.width;
                var height = this.height;
                var renderer = this.renderer;
                this.glTexture = renderer.createTextureFromSource(null, width, height, 0);
                this.glTexture.flipY = flipY;
                this.framebuffer = renderer.createFramebuffer(width, height, this.glTexture, false);
                this._rendererWidth = width;
                this._rendererHeight = height;
                this.renderToTexture = true;
                this.projOrtho(0, this.width, this.height, 0);
                if (key) {
                  this.texture = this.scene.sys.textures.addGLTexture(key, this.glTexture, width, height);
                }
              }
              if (this.shader) {
                renderer.pipelines.clear();
                this.load();
                this.flush();
                renderer.pipelines.rebind();
              }
              return this;
            },
            setShader: function (key, textures, textureData) {
              if (textures === void 0) {
                textures = [];
              }
              if (typeof key === "string") {
                var cache = this.scene.sys.cache.shader;
                if (!cache.has(key)) {
                  console.warn("Shader missing: " + key);
                  return this;
                }
                this.shader = cache.get(key);
              } else {
                this.shader = key;
              }
              var gl = this.gl;
              var renderer = this.renderer;
              if (this.program) {
                gl.deleteProgram(this.program);
              }
              var program = renderer.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc);
              gl.uniformMatrix4fv(gl.getUniformLocation(program, "uViewMatrix"), false, this.viewMatrix);
              gl.uniformMatrix4fv(gl.getUniformLocation(program, "uProjectionMatrix"), false, this.projectionMatrix);
              gl.uniform2f(gl.getUniformLocation(program, "uResolution"), this.width, this.height);
              this.program = program;
              var d = new Date();
              var defaultUniforms = {
                resolution: {
                  type: "2f",
                  value: {
                    x: this.width,
                    y: this.height
                  }
                },
                time: {
                  type: "1f",
                  value: 0
                },
                mouse: {
                  type: "2f",
                  value: {
                    x: this.width / 2,
                    y: this.height / 2
                  }
                },
                date: {
                  type: "4fv",
                  value: [d.getFullYear(), d.getMonth(), d.getDate(), d.getHours() * 60 * 60 + d.getMinutes() * 60 + d.getSeconds()]
                },
                sampleRate: {
                  type: "1f",
                  value: 44100
                },
                iChannel0: {
                  type: "sampler2D",
                  value: null,
                  textureData: {
                    repeat: true
                  }
                },
                iChannel1: {
                  type: "sampler2D",
                  value: null,
                  textureData: {
                    repeat: true
                  }
                },
                iChannel2: {
                  type: "sampler2D",
                  value: null,
                  textureData: {
                    repeat: true
                  }
                },
                iChannel3: {
                  type: "sampler2D",
                  value: null,
                  textureData: {
                    repeat: true
                  }
                }
              };
              if (this.shader.uniforms) {
                this.uniforms = Extend(true, {}, this.shader.uniforms, defaultUniforms);
              } else {
                this.uniforms = defaultUniforms;
              }
              for (var i = 0; i < 4; i++) {
                if (textures[i]) {
                  this.setSampler2D("iChannel" + i, textures[i], i, textureData);
                }
              }
              this.initUniforms();
              this.projOrtho(0, this._rendererWidth, this._rendererHeight, 0);
              return this;
            },
            setPointer: function (pointer) {
              this.pointer = pointer;
              return this;
            },
            projOrtho: function (left, right, bottom, top) {
              var near = -1e3;
              var far = 1e3;
              var leftRight = 1 / (left - right);
              var bottomTop = 1 / (bottom - top);
              var nearFar = 1 / (near - far);
              var pm = this.projectionMatrix;
              pm[0] = -2 * leftRight;
              pm[5] = -2 * bottomTop;
              pm[10] = 2 * nearFar;
              pm[12] = (left + right) * leftRight;
              pm[13] = (top + bottom) * bottomTop;
              pm[14] = (far + near) * nearFar;
              var program = this.program;
              var gl = this.gl;
              var renderer = this.renderer;
              renderer.setProgram(program);
              gl.uniformMatrix4fv(gl.getUniformLocation(program, "uProjectionMatrix"), false, this.projectionMatrix);
              this._rendererWidth = right;
              this._rendererHeight = bottom;
            },
            initUniforms: function () {
              var gl = this.gl;
              var map = this.renderer.glFuncMap;
              var program = this.program;
              this._textureCount = 0;
              for (var key in this.uniforms) {
                var uniform = this.uniforms[key];
                var type = uniform.type;
                var data = map[type];
                uniform.uniformLocation = gl.getUniformLocation(program, key);
                if (type !== "sampler2D") {
                  uniform.glMatrix = data.matrix;
                  uniform.glValueLength = data.length;
                  uniform.glFunc = data.func;
                }
              }
            },
            setSampler2DBuffer: function (uniformKey, texture, width, height, textureIndex, textureData) {
              if (textureIndex === void 0) {
                textureIndex = 0;
              }
              if (textureData === void 0) {
                textureData = {};
              }
              var uniform = this.uniforms[uniformKey];
              uniform.value = texture;
              textureData.width = width;
              textureData.height = height;
              uniform.textureData = textureData;
              this._textureCount = textureIndex;
              this.initSampler2D(uniform);
              return this;
            },
            setSampler2D: function (uniformKey, textureKey, textureIndex, textureData) {
              if (textureIndex === void 0) {
                textureIndex = 0;
              }
              var textureManager = this.scene.sys.textures;
              if (textureManager.exists(textureKey)) {
                var frame = textureManager.getFrame(textureKey);
                if (frame.glTexture && frame.glTexture.isRenderTexture) {
                  return this.setSampler2DBuffer(uniformKey, frame.glTexture, frame.width, frame.height, textureIndex, textureData);
                }
                var uniform = this.uniforms[uniformKey];
                var source = frame.source;
                uniform.textureKey = textureKey;
                uniform.source = source.image;
                uniform.value = frame.glTexture;
                if (source.isGLTexture) {
                  if (!textureData) {
                    textureData = {};
                  }
                  textureData.width = source.width;
                  textureData.height = source.height;
                }
                if (textureData) {
                  uniform.textureData = textureData;
                }
                this._textureCount = textureIndex;
                this.initSampler2D(uniform);
              }
              return this;
            },
            setUniform: function (key, value) {
              SetValue(this.uniforms, key, value);
              return this;
            },
            getUniform: function (key) {
              return GetFastValue(this.uniforms, key, null);
            },
            setChannel0: function (textureKey, textureData) {
              return this.setSampler2D("iChannel0", textureKey, 0, textureData);
            },
            setChannel1: function (textureKey, textureData) {
              return this.setSampler2D("iChannel1", textureKey, 1, textureData);
            },
            setChannel2: function (textureKey, textureData) {
              return this.setSampler2D("iChannel2", textureKey, 2, textureData);
            },
            setChannel3: function (textureKey, textureData) {
              return this.setSampler2D("iChannel3", textureKey, 3, textureData);
            },
            initSampler2D: function (uniform) {
              if (!uniform.value) {
                return;
              }
              var gl = this.gl;
              gl.activeTexture(gl.TEXTURE0 + this._textureCount);
              gl.bindTexture(gl.TEXTURE_2D, uniform.value);
              var data = uniform.textureData;
              if (data && !uniform.value.isRenderTexture) {
                var magFilter = gl[GetFastValue(data, "magFilter", "linear").toUpperCase()];
                var minFilter = gl[GetFastValue(data, "minFilter", "linear").toUpperCase()];
                var wrapS = gl[GetFastValue(data, "wrapS", "repeat").toUpperCase()];
                var wrapT = gl[GetFastValue(data, "wrapT", "repeat").toUpperCase()];
                var format = gl[GetFastValue(data, "format", "rgba").toUpperCase()];
                if (data.repeat) {
                  wrapS = gl.REPEAT;
                  wrapT = gl.REPEAT;
                }
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);
                if (data.width) {
                  var width = GetFastValue(data, "width", 512);
                  var height = GetFastValue(data, "height", 2);
                  var border = GetFastValue(data, "border", 0);
                  gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);
                } else {
                  gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.source);
                }
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
              }
              this.renderer.setProgram(this.program);
              gl.uniform1i(uniform.uniformLocation, this._textureCount);
              this._textureCount++;
            },
            syncUniforms: function () {
              var gl = this.gl;
              var uniforms = this.uniforms;
              var uniform;
              var length;
              var glFunc;
              var location;
              var value;
              var textureCount = 0;
              for (var key in uniforms) {
                uniform = uniforms[key];
                glFunc = uniform.glFunc;
                length = uniform.glValueLength;
                location = uniform.uniformLocation;
                value = uniform.value;
                if (value === null) {
                  continue;
                }
                if (length === 1) {
                  if (uniform.glMatrix) {
                    glFunc.call(gl, location, uniform.transpose, value);
                  } else {
                    glFunc.call(gl, location, value);
                  }
                } else if (length === 2) {
                  glFunc.call(gl, location, value.x, value.y);
                } else if (length === 3) {
                  glFunc.call(gl, location, value.x, value.y, value.z);
                } else if (length === 4) {
                  glFunc.call(gl, location, value.x, value.y, value.z, value.w);
                } else if (uniform.type === "sampler2D") {
                  gl.activeTexture(gl.TEXTURE0 + textureCount);
                  gl.bindTexture(gl.TEXTURE_2D, value);
                  gl.uniform1i(location, textureCount);
                  textureCount++;
                }
              }
            },
            load: function (matrix2D) {
              var gl = this.gl;
              var width = this.width;
              var height = this.height;
              var renderer = this.renderer;
              var program = this.program;
              var vm = this.viewMatrix;
              if (!this.renderToTexture) {
                var x = -this._displayOriginX;
                var y = -this._displayOriginY;
                vm[0] = matrix2D[0];
                vm[1] = matrix2D[1];
                vm[4] = matrix2D[2];
                vm[5] = matrix2D[3];
                vm[8] = matrix2D[4];
                vm[9] = matrix2D[5];
                vm[12] = vm[0] * x + vm[4] * y;
                vm[13] = vm[1] * x + vm[5] * y;
              }
              gl.useProgram(program);
              gl.uniformMatrix4fv(gl.getUniformLocation(program, "uViewMatrix"), false, vm);
              gl.uniform2f(gl.getUniformLocation(program, "uResolution"), this.width, this.height);
              var uniforms = this.uniforms;
              var res = uniforms.resolution;
              res.value.x = width;
              res.value.y = height;
              uniforms.time.value = renderer.game.loop.getDuration();
              var pointer = this.pointer;
              if (pointer) {
                var mouse = uniforms.mouse;
                var px = pointer.x / width;
                var py = 1 - pointer.y / height;
                mouse.value.x = px.toFixed(2);
                mouse.value.y = py.toFixed(2);
              }
              this.syncUniforms();
            },
            flush: function () {
              var width = this.width;
              var height = this.height;
              var program = this.program;
              var gl = this.gl;
              var vertexBuffer = this.vertexBuffer;
              var renderer = this.renderer;
              var vertexSize = Float32Array.BYTES_PER_ELEMENT * 2;
              if (this.renderToTexture) {
                renderer.setFramebuffer(this.framebuffer);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
              }
              gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
              var location = gl.getAttribLocation(program, "inPosition");
              if (location !== -1) {
                gl.enableVertexAttribArray(location);
                gl.vertexAttribPointer(location, 2, gl.FLOAT, false, vertexSize, 0);
              }
              var vf = this.vertexViewF32;
              vf[3] = height;
              vf[4] = width;
              vf[5] = height;
              vf[8] = width;
              vf[9] = height;
              vf[10] = width;
              var vertexCount = 6;
              gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));
              gl.drawArrays(gl.TRIANGLES, 0, vertexCount);
              if (this.renderToTexture) {
                renderer.setFramebuffer(null, false);
              }
            },
            setAlpha: function () {},
            setBlendMode: function () {},
            preDestroy: function () {
              var gl = this.gl;
              gl.deleteProgram(this.program);
              gl.deleteBuffer(this.vertexBuffer);
              if (this.renderToTexture) {
                this.renderer.deleteFramebuffer(this.framebuffer);
                this.texture.destroy();
                this.framebuffer = null;
                this.glTexture = null;
                this.texture = null;
              }
            }
          });
          module2.exports = Shader;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var DegToRad = __webpack_require__(36);
          var Face = __webpack_require__(116);
          var GameObject = __webpack_require__(15);
          var GenerateVerts = __webpack_require__(479);
          var GenerateObjVerts = __webpack_require__(480);
          var GetCalcMatrix = __webpack_require__(19);
          var Matrix4 = __webpack_require__(69);
          var MeshRender = __webpack_require__(1179);
          var StableSort = __webpack_require__(79);
          var Vector3 = __webpack_require__(39);
          var Vertex = __webpack_require__(117);
          var Mesh = new Class({
            Extends: GameObject,
            Mixins: [Components.AlphaSingle, Components.BlendMode, Components.Depth, Components.Mask, Components.Pipeline, Components.Size, Components.Texture, Components.Transform, Components.Visible, Components.ScrollFactor, MeshRender],
            initialize: function Mesh2(scene, x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (texture === void 0) {
                texture = "__WHITE";
              }
              GameObject.call(this, scene, "Mesh");
              this.faces = [];
              this.vertices = [];
              this.tintFill = false;
              this.debugCallback = null;
              this.debugGraphic = null;
              this.hideCCW = true;
              this.modelPosition = new Vector3();
              this.modelScale = new Vector3(1, 1, 1);
              this.modelRotation = new Vector3();
              this.dirtyCache = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              this.transformMatrix = new Matrix4();
              this.viewPosition = new Vector3();
              this.viewMatrix = new Matrix4();
              this.projectionMatrix = new Matrix4();
              this.totalRendered = 0;
              this.totalFrame = 0;
              this.ignoreDirtyCache = false;
              var renderer = scene.sys.renderer;
              this.setPosition(x, y);
              this.setTexture(texture, frame);
              this.setSize(renderer.width, renderer.height);
              this.initPipeline();
              this.setPerspective(renderer.width, renderer.height);
              if (vertices) {
                this.addVertices(vertices, uvs, indicies, containsZ, normals, colors, alphas);
              }
            },
            addedToScene: function () {
              this.scene.sys.updateList.add(this);
            },
            removedFromScene: function () {
              this.scene.sys.updateList.remove(this);
            },
            panX: function (v) {
              this.viewPosition.addScale(Vector3.LEFT, v);
              this.dirtyCache[10] = 1;
              return this;
            },
            panY: function (v) {
              this.viewPosition.y += Vector3.DOWN.y * v;
              this.dirtyCache[10] = 1;
              return this;
            },
            panZ: function (amount) {
              this.viewPosition.z += amount;
              this.dirtyCache[10] = 1;
              return this;
            },
            setPerspective: function (width, height, fov, near, far) {
              if (fov === void 0) {
                fov = 45;
              }
              if (near === void 0) {
                near = 0.01;
              }
              if (far === void 0) {
                far = 1e3;
              }
              this.projectionMatrix.perspective(DegToRad(fov), width / height, near, far);
              this.dirtyCache[10] = 1;
              this.dirtyCache[11] = 0;
              return this;
            },
            setOrtho: function (scaleX, scaleY, near, far) {
              if (scaleX === void 0) {
                scaleX = this.scene.sys.renderer.getAspectRatio();
              }
              if (scaleY === void 0) {
                scaleY = 1;
              }
              if (near === void 0) {
                near = -1e3;
              }
              if (far === void 0) {
                far = 1e3;
              }
              this.projectionMatrix.ortho(-scaleX, scaleX, -scaleY, scaleY, near, far);
              this.dirtyCache[10] = 1;
              this.dirtyCache[11] = 1;
              return this;
            },
            clear: function () {
              this.faces.forEach(function (face) {
                face.destroy();
              });
              this.faces = [];
              this.vertices = [];
              return this;
            },
            addVerticesFromObj: function (key, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp) {
              var data = this.scene.sys.cache.obj.get(key);
              if (data) {
                GenerateObjVerts(data, this, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp);
              }
              return this;
            },
            sortByDepth: function (faceA, faceB) {
              return faceA.depth - faceB.depth;
            },
            depthSort: function () {
              StableSort(this.faces, this.sortByDepth);
              return this;
            },
            addVertex: function (x, y, z, u, v, color, alpha) {
              var vert = new Vertex(x, y, z, u, v, color, alpha);
              this.vertices.push(vert);
              return vert;
            },
            addFace: function (vertex1, vertex2, vertex3) {
              var face = new Face(vertex1, vertex2, vertex3);
              this.faces.push(face);
              this.dirtyCache[9] = -1;
              return face;
            },
            addVertices: function (vertices, uvs, indicies, containsZ, normals, colors, alphas) {
              var result = GenerateVerts(vertices, uvs, indicies, containsZ, normals, colors, alphas);
              if (result) {
                this.faces = this.faces.concat(result.faces);
                this.vertices = this.vertices.concat(result.vertices);
              }
              this.dirtyCache[9] = -1;
              return this;
            },
            getFaceCount: function () {
              return this.faces.length;
            },
            getVertexCount: function () {
              return this.vertices.length;
            },
            getFace: function (index) {
              return this.faces[index];
            },
            getFaceAt: function (x, y, camera) {
              if (camera === void 0) {
                camera = this.scene.sys.cameras.main;
              }
              var calcMatrix = GetCalcMatrix(this, camera).calc;
              var faces = this.faces;
              var results = [];
              for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                if (face.contains(x, y, calcMatrix)) {
                  results.push(face);
                }
              }
              return StableSort(results, this.sortByDepth);
            },
            setDebug: function (graphic, callback) {
              this.debugGraphic = graphic;
              if (!graphic && !callback) {
                this.debugCallback = null;
              } else if (!callback) {
                this.debugCallback = this.renderDebug;
              } else {
                this.debugCallback = callback;
              }
              return this;
            },
            isDirty: function () {
              var position = this.modelPosition;
              var rotation = this.modelRotation;
              var scale = this.modelScale;
              var dirtyCache = this.dirtyCache;
              var px = position.x;
              var py = position.y;
              var pz = position.z;
              var rx = rotation.x;
              var ry = rotation.y;
              var rz = rotation.z;
              var sx = scale.x;
              var sy = scale.y;
              var sz = scale.z;
              var faces = this.getFaceCount();
              var pxCached = dirtyCache[0];
              var pyCached = dirtyCache[1];
              var pzCached = dirtyCache[2];
              var rxCached = dirtyCache[3];
              var ryCached = dirtyCache[4];
              var rzCached = dirtyCache[5];
              var sxCached = dirtyCache[6];
              var syCached = dirtyCache[7];
              var szCached = dirtyCache[8];
              var fCached = dirtyCache[9];
              dirtyCache[0] = px;
              dirtyCache[1] = py;
              dirtyCache[2] = pz;
              dirtyCache[3] = rx;
              dirtyCache[4] = ry;
              dirtyCache[5] = rz;
              dirtyCache[6] = sx;
              dirtyCache[7] = sy;
              dirtyCache[8] = sz;
              dirtyCache[9] = faces;
              return pxCached !== px || pyCached !== py || pzCached !== pz || rxCached !== rx || ryCached !== ry || rzCached !== rz || sxCached !== sx || syCached !== sy || szCached !== sz || fCached !== faces;
            },
            preUpdate: function () {
              this.totalRendered = this.totalFrame;
              this.totalFrame = 0;
              var dirty = this.dirtyCache;
              if (!this.ignoreDirtyCache && !dirty[10] && !this.isDirty()) {
                return;
              }
              var width = this.width;
              var height = this.height;
              var viewMatrix = this.viewMatrix;
              var viewPosition = this.viewPosition;
              if (dirty[10]) {
                viewMatrix.identity();
                viewMatrix.translate(viewPosition);
                viewMatrix.invert();
                dirty[10] = 0;
              }
              var transformMatrix = this.transformMatrix;
              transformMatrix.setWorldMatrix(this.modelRotation, this.modelPosition, this.modelScale, this.viewMatrix, this.projectionMatrix);
              var z = viewPosition.z;
              var faces = this.faces;
              for (var i = 0; i < faces.length; i++) {
                faces[i].transformCoordinatesLocal(transformMatrix, width, height, z);
              }
              this.depthSort();
            },
            renderDebug: function (src, faces) {
              var graphic = src.debugGraphic;
              for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                var x0 = face.vertex1.tx;
                var y0 = face.vertex1.ty;
                var x1 = face.vertex2.tx;
                var y1 = face.vertex2.ty;
                var x2 = face.vertex3.tx;
                var y2 = face.vertex3.ty;
                graphic.strokeTriangle(x0, y0, x1, y1, x2, y2);
              }
            },
            preDestroy: function () {
              this.clear();
              this.debugCallback = null;
              this.debugGraphic = null;
            }
          });
          module2.exports = Mesh;
        }, function (module2, exports2, __webpack_require__) {
          var DistanceBetween = __webpack_require__(50);
          var CircleToCircle = function (circleA, circleB) {
            return DistanceBetween(circleA.x, circleA.y, circleB.x, circleB.y) <= circleA.radius + circleB.radius;
          };
          module2.exports = CircleToCircle;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var LineToCircle = __webpack_require__(233);
          var GetLineToCircle = function (line, circle, out) {
            if (out === void 0) {
              out = [];
            }
            if (LineToCircle(line, circle)) {
              var lx1 = line.x1;
              var ly1 = line.y1;
              var lx2 = line.x2;
              var ly2 = line.y2;
              var cx = circle.x;
              var cy = circle.y;
              var cr = circle.radius;
              var lDirX = lx2 - lx1;
              var lDirY = ly2 - ly1;
              var oDirX = lx1 - cx;
              var oDirY = ly1 - cy;
              var coefficientA = lDirX * lDirX + lDirY * lDirY;
              var coefficientB = 2 * (lDirX * oDirX + lDirY * oDirY);
              var coefficientC = oDirX * oDirX + oDirY * oDirY - cr * cr;
              var lambda = coefficientB * coefficientB - 4 * coefficientA * coefficientC;
              var x, y;
              if (lambda === 0) {
                var root = -coefficientB / (2 * coefficientA);
                x = lx1 + root * lDirX;
                y = ly1 + root * lDirY;
                if (root >= 0 && root <= 1) {
                  out.push(new Point(x, y));
                }
              } else if (lambda > 0) {
                var root1 = (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA);
                x = lx1 + root1 * lDirX;
                y = ly1 + root1 * lDirY;
                if (root1 >= 0 && root1 <= 1) {
                  out.push(new Point(x, y));
                }
                var root2 = (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA);
                x = lx1 + root2 * lDirX;
                y = ly1 + root2 * lDirY;
                if (root2 >= 0 && root2 <= 1) {
                  out.push(new Point(x, y));
                }
              }
            }
            return out;
          };
          module2.exports = GetLineToCircle;
        }, function (module2, exports2, __webpack_require__) {
          var Contains = __webpack_require__(66);
          var Point = __webpack_require__(4);
          var tmp = new Point();
          var LineToCircle = function (line, circle, nearest) {
            if (nearest === void 0) {
              nearest = tmp;
            }
            if (Contains(circle, line.x1, line.y1)) {
              nearest.x = line.x1;
              nearest.y = line.y1;
              return true;
            }
            if (Contains(circle, line.x2, line.y2)) {
              nearest.x = line.x2;
              nearest.y = line.y2;
              return true;
            }
            var dx = line.x2 - line.x1;
            var dy = line.y2 - line.y1;
            var lcx = circle.x - line.x1;
            var lcy = circle.y - line.y1;
            var dLen2 = dx * dx + dy * dy;
            var px = dx;
            var py = dy;
            if (dLen2 > 0) {
              var dp = (lcx * dx + lcy * dy) / dLen2;
              px *= dp;
              py *= dp;
            }
            nearest.x = line.x1 + px;
            nearest.y = line.y1 + py;
            var pLen2 = px * px + py * py;
            return pLen2 <= dLen2 && px * dx + py * dy >= 0 && Contains(circle, nearest.x, nearest.y);
          };
          module2.exports = LineToCircle;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var LineToLine = __webpack_require__(96);
          var LineToRectangle = __webpack_require__(488);
          var GetLineToRectangle = function (line, rect, out) {
            if (out === void 0) {
              out = [];
            }
            if (LineToRectangle(line, rect)) {
              var lineA = rect.getLineA();
              var lineB = rect.getLineB();
              var lineC = rect.getLineC();
              var lineD = rect.getLineD();
              var output = [new Point(), new Point(), new Point(), new Point()];
              var result = [LineToLine(lineA, line, output[0]), LineToLine(lineB, line, output[1]), LineToLine(lineC, line, output[2]), LineToLine(lineD, line, output[3])];
              for (var i = 0; i < 4; i++) {
                if (result[i]) {
                  out.push(output[i]);
                }
              }
            }
            return out;
          };
          module2.exports = GetLineToRectangle;
        }, function (module2, exports2) {
          var ContainsArray = function (triangle, points, returnFirst, out) {
            if (returnFirst === void 0) {
              returnFirst = false;
            }
            if (out === void 0) {
              out = [];
            }
            var v0x = triangle.x3 - triangle.x1;
            var v0y = triangle.y3 - triangle.y1;
            var v1x = triangle.x2 - triangle.x1;
            var v1y = triangle.y2 - triangle.y1;
            var dot00 = v0x * v0x + v0y * v0y;
            var dot01 = v0x * v1x + v0y * v1y;
            var dot11 = v1x * v1x + v1y * v1y;
            var b = dot00 * dot11 - dot01 * dot01;
            var inv = b === 0 ? 0 : 1 / b;
            var u;
            var v;
            var v2x;
            var v2y;
            var dot02;
            var dot12;
            var x1 = triangle.x1;
            var y1 = triangle.y1;
            for (var i = 0; i < points.length; i++) {
              v2x = points[i].x - x1;
              v2y = points[i].y - y1;
              dot02 = v0x * v2x + v0y * v2y;
              dot12 = v1x * v2x + v1y * v2y;
              u = (dot11 * dot02 - dot01 * dot12) * inv;
              v = (dot00 * dot12 - dot01 * dot02) * inv;
              if (u >= 0 && v >= 0 && u + v < 1) {
                out.push({
                  x: points[i].x,
                  y: points[i].y
                });
                if (returnFirst) {
                  break;
                }
              }
            }
            return out;
          };
          module2.exports = ContainsArray;
        }, function (module2, exports2) {
          var RotateAroundXY = function (line, x, y, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var tx = line.x1 - x;
            var ty = line.y1 - y;
            line.x1 = tx * c - ty * s + x;
            line.y1 = tx * s + ty * c + y;
            tx = line.x2 - x;
            ty = line.y2 - y;
            line.x2 = tx * c - ty * s + x;
            line.y2 = tx * s + ty * c + y;
            return line;
          };
          module2.exports = RotateAroundXY;
        }, function (module2, exports2) {
          var GetAspectRatio = function (rect) {
            return rect.height === 0 ? NaN : rect.width / rect.height;
          };
          module2.exports = GetAspectRatio;
        }, function (module2, exports2) {
          var RotateAroundXY = function (triangle, x, y, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var tx = triangle.x1 - x;
            var ty = triangle.y1 - y;
            triangle.x1 = tx * c - ty * s + x;
            triangle.y1 = tx * s + ty * c + y;
            tx = triangle.x2 - x;
            ty = triangle.y2 - y;
            triangle.x2 = tx * c - ty * s + x;
            triangle.y2 = tx * s + ty * c + y;
            tx = triangle.x3 - x;
            ty = triangle.y3 - y;
            triangle.x3 = tx * c - ty * s + x;
            triangle.y3 = tx * s + ty * c + y;
            return triangle;
          };
          module2.exports = RotateAroundXY;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            BUTTON_DOWN: __webpack_require__(1310),
            BUTTON_UP: __webpack_require__(1311),
            CONNECTED: __webpack_require__(1312),
            DISCONNECTED: __webpack_require__(1313),
            GAMEPAD_BUTTON_DOWN: __webpack_require__(1314),
            GAMEPAD_BUTTON_UP: __webpack_require__(1315)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Extend = __webpack_require__(17);
          var XHRSettings = __webpack_require__(156);
          var MergeXHRSettings = function (global, local) {
            var output = global === void 0 ? XHRSettings() : Extend({}, global);
            if (local) {
              for (var setting in local) {
                if (local[setting] !== void 0) {
                  output[setting] = local[setting];
                }
              }
            }
            return output;
          };
          module2.exports = MergeXHRSettings;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var ParseXML = __webpack_require__(408);
          var XMLFile = new Class({
            Extends: File,
            initialize: function XMLFile2(loader, key, url, xhrSettings) {
              var extension = "xml";
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                url = GetFastValue(config, "url");
                xhrSettings = GetFastValue(config, "xhrSettings");
                extension = GetFastValue(config, "extension", extension);
              }
              var fileConfig = {
                type: "xml",
                cache: loader.cacheManager.xml,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function () {
              this.state = CONST.FILE_PROCESSING;
              this.data = ParseXML(this.xhrLoader.responseText);
              if (this.data) {
                this.onProcessComplete();
              } else {
                console.warn("Invalid XMLFile: " + this.key);
                this.onProcessError();
              }
            }
          });
          FileTypesManager.register("xml", function (key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new XMLFile(this, key[i]));
              }
            } else {
              this.addFile(new XMLFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = XMLFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var TextFile = new Class({
            Extends: File,
            initialize: function TextFile2(loader, key, url, xhrSettings) {
              var type = "text";
              var extension = "txt";
              var cache = loader.cacheManager.text;
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                url = GetFastValue(config, "url");
                xhrSettings = GetFastValue(config, "xhrSettings");
                extension = GetFastValue(config, "extension", extension);
                type = GetFastValue(config, "type", type);
                cache = GetFastValue(config, "cache", cache);
              }
              var fileConfig = {
                type,
                cache,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function () {
              this.state = CONST.FILE_PROCESSING;
              this.data = this.xhrLoader.responseText;
              this.onProcessComplete();
            }
          });
          FileTypesManager.register("text", function (key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new TextFile(this, key[i]));
              }
            } else {
              this.addFile(new TextFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = TextFile;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Acceleration: __webpack_require__(1368),
            Angular: __webpack_require__(1369),
            Bounce: __webpack_require__(1370),
            Debug: __webpack_require__(1371),
            Drag: __webpack_require__(1372),
            Enable: __webpack_require__(1373),
            Friction: __webpack_require__(1374),
            Gravity: __webpack_require__(1375),
            Immovable: __webpack_require__(1376),
            Mass: __webpack_require__(1377),
            OverlapCirc: __webpack_require__(523),
            OverlapRect: __webpack_require__(244),
            Pushable: __webpack_require__(1378),
            Size: __webpack_require__(1379),
            Velocity: __webpack_require__(1380)
          };
        }, function (module2, exports2) {
          var OverlapRect = function (world, x, y, width, height, includeDynamic, includeStatic) {
            if (includeDynamic === void 0) {
              includeDynamic = true;
            }
            if (includeStatic === void 0) {
              includeStatic = false;
            }
            var dynamicBodies = [];
            var staticBodies = [];
            var minMax = world.treeMinMax;
            minMax.minX = x;
            minMax.minY = y;
            minMax.maxX = x + width;
            minMax.maxY = y + height;
            if (includeStatic) {
              staticBodies = world.staticTree.search(minMax);
            }
            if (includeDynamic && world.useTree) {
              dynamicBodies = world.tree.search(minMax);
            } else if (includeDynamic) {
              var bodies = world.bodies;
              var fakeBody = {
                position: {
                  x,
                  y
                },
                left: x,
                top: y,
                right: x + width,
                bottom: y + height,
                isCircle: false
              };
              var intersects = world.intersects;
              bodies.iterate(function (target) {
                if (intersects(target, fakeBody)) {
                  dynamicBodies.push(target);
                }
              });
            }
            return staticBodies.concat(dynamicBodies);
          };
          module2.exports = OverlapRect;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            COLLIDE: __webpack_require__(1381),
            OVERLAP: __webpack_require__(1382),
            PAUSE: __webpack_require__(1383),
            RESUME: __webpack_require__(1384),
            TILE_COLLIDE: __webpack_require__(1385),
            TILE_OVERLAP: __webpack_require__(1386),
            WORLD_BOUNDS: __webpack_require__(1387),
            WORLD_STEP: __webpack_require__(1388)
          };
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(62);
          var GetOverlapX = function (body1, body2, overlapOnly, bias) {
            var overlap = 0;
            var maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + bias;
            if (body1._dx === 0 && body2._dx === 0) {
              body1.embedded = true;
              body2.embedded = true;
            } else if (body1._dx > body2._dx) {
              overlap = body1.right - body2.x;
              if (overlap > maxOverlap && !overlapOnly || body1.checkCollision.right === false || body2.checkCollision.left === false) {
                overlap = 0;
              } else {
                body1.touching.none = false;
                body1.touching.right = true;
                body2.touching.none = false;
                body2.touching.left = true;
                if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                  body1.blocked.none = false;
                  body1.blocked.right = true;
                }
                if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                  body2.blocked.none = false;
                  body2.blocked.left = true;
                }
              }
            } else if (body1._dx < body2._dx) {
              overlap = body1.x - body2.width - body2.x;
              if (-overlap > maxOverlap && !overlapOnly || body1.checkCollision.left === false || body2.checkCollision.right === false) {
                overlap = 0;
              } else {
                body1.touching.none = false;
                body1.touching.left = true;
                body2.touching.none = false;
                body2.touching.right = true;
                if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                  body1.blocked.none = false;
                  body1.blocked.left = true;
                }
                if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                  body2.blocked.none = false;
                  body2.blocked.right = true;
                }
              }
            }
            body1.overlapX = overlap;
            body2.overlapX = overlap;
            return overlap;
          };
          module2.exports = GetOverlapX;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(62);
          var GetOverlapY = function (body1, body2, overlapOnly, bias) {
            var overlap = 0;
            var maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + bias;
            if (body1._dy === 0 && body2._dy === 0) {
              body1.embedded = true;
              body2.embedded = true;
            } else if (body1._dy > body2._dy) {
              overlap = body1.bottom - body2.y;
              if (overlap > maxOverlap && !overlapOnly || body1.checkCollision.down === false || body2.checkCollision.up === false) {
                overlap = 0;
              } else {
                body1.touching.none = false;
                body1.touching.down = true;
                body2.touching.none = false;
                body2.touching.up = true;
                if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                  body1.blocked.none = false;
                  body1.blocked.down = true;
                }
                if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                  body2.blocked.none = false;
                  body2.blocked.up = true;
                }
              }
            } else if (body1._dy < body2._dy) {
              overlap = body1.y - body2.bottom;
              if (-overlap > maxOverlap && !overlapOnly || body1.checkCollision.up === false || body2.checkCollision.down === false) {
                overlap = 0;
              } else {
                body1.touching.none = false;
                body1.touching.up = true;
                body2.touching.none = false;
                body2.touching.down = true;
                if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                  body1.blocked.none = false;
                  body1.blocked.up = true;
                }
                if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
                  body2.blocked.none = false;
                  body2.blocked.down = true;
                }
              }
            }
            body1.overlapY = overlap;
            body2.overlapY = overlap;
            return overlap;
          };
          module2.exports = GetOverlapY;
        }, function (module2, exports2) {
          var TileIntersectsBody = function (tileWorldRect, body) {
            return !(body.right <= tileWorldRect.left || body.bottom <= tileWorldRect.top || body.position.x >= tileWorldRect.right || body.position.y >= tileWorldRect.bottom);
          };
          module2.exports = TileIntersectsBody;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Bounce: __webpack_require__(1495),
            Collision: __webpack_require__(1496),
            Force: __webpack_require__(1497),
            Friction: __webpack_require__(1498),
            Gravity: __webpack_require__(1499),
            Mass: __webpack_require__(1500),
            Sensor: __webpack_require__(1501),
            SetBody: __webpack_require__(1502),
            Sleep: __webpack_require__(1503),
            Static: __webpack_require__(1520),
            Transform: __webpack_require__(1521),
            Velocity: __webpack_require__(1522)
          };
        }, function (module2, exports2) {
          var Pair = {};
          module2.exports = Pair;
          (function () {
            Pair.create = function (collision, timestamp) {
              var bodyA = collision.bodyA, bodyB = collision.bodyB;
              var pair = {
                id: Pair.id(bodyA, bodyB),
                bodyA,
                bodyB,
                activeContacts: [],
                separation: 0,
                isActive: true,
                confirmedActive: true,
                isSensor: bodyA.isSensor || bodyB.isSensor,
                timeCreated: timestamp,
                timeUpdated: timestamp,
                collision: null,
                inverseMass: 0,
                friction: 0,
                frictionStatic: 0,
                restitution: 0,
                slop: 0
              };
              Pair.update(pair, collision, timestamp);
              return pair;
            };
            Pair.update = function (pair, collision, timestamp) {
              pair.collision = collision;
              if (collision.collided) {
                var supports = collision.supports, activeContacts = pair.activeContacts, parentA = collision.parentA, parentB = collision.parentB;
                pair.inverseMass = parentA.inverseMass + parentB.inverseMass;
                pair.friction = Math.min(parentA.friction, parentB.friction);
                pair.frictionStatic = Math.max(parentA.frictionStatic, parentB.frictionStatic);
                pair.restitution = Math.max(parentA.restitution, parentB.restitution);
                pair.slop = Math.max(parentA.slop, parentB.slop);
                for (var i = 0; i < supports.length; i++) {
                  activeContacts[i] = supports[i].contact;
                }
                var supportCount = supports.length;
                if (supportCount < activeContacts.length) {
                  activeContacts.length = supportCount;
                }
                pair.separation = collision.depth;
                Pair.setActive(pair, true, timestamp);
              } else {
                if (pair.isActive === true) Pair.setActive(pair, false, timestamp);
              }
            };
            Pair.setActive = function (pair, isActive, timestamp) {
              if (isActive) {
                pair.isActive = true;
                pair.timeUpdated = timestamp;
              } else {
                pair.isActive = false;
                pair.activeContacts.length = 0;
              }
            };
            Pair.id = function (bodyA, bodyB) {
              if (bodyA.id < bodyB.id) {
                return "A" + bodyA.id + "B" + bodyB.id;
              } else {
                return "A" + bodyB.id + "B" + bodyA.id;
              }
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            CalculateFacesAt: __webpack_require__(252),
            CalculateFacesWithin: __webpack_require__(63),
            CheckIsoBounds: __webpack_require__(541),
            Copy: __webpack_require__(1420),
            CreateFromTiles: __webpack_require__(1421),
            CullBounds: __webpack_require__(543),
            CullTiles: __webpack_require__(544),
            Fill: __webpack_require__(1422),
            FilterTiles: __webpack_require__(1423),
            FindByIndex: __webpack_require__(1424),
            FindTile: __webpack_require__(1425),
            ForEachTile: __webpack_require__(1426),
            GetCullTilesFunction: __webpack_require__(1427),
            GetTileAt: __webpack_require__(158),
            GetTileAtWorldXY: __webpack_require__(1428),
            GetTilesWithin: __webpack_require__(26),
            GetTilesWithinShape: __webpack_require__(1429),
            GetTilesWithinWorldXY: __webpack_require__(529),
            GetTileToWorldXFunction: __webpack_require__(1430),
            GetTileToWorldXYFunction: __webpack_require__(1431),
            GetTileToWorldYFunction: __webpack_require__(1432),
            GetWorldToTileXFunction: __webpack_require__(1433),
            GetWorldToTileXYFunction: __webpack_require__(1434),
            GetWorldToTileYFunction: __webpack_require__(1435),
            HasTileAt: __webpack_require__(562),
            HasTileAtWorldXY: __webpack_require__(1436),
            HexagonalCullBounds: __webpack_require__(546),
            HexagonalCullTiles: __webpack_require__(545),
            HexagonalTileToWorldXY: __webpack_require__(550),
            HexagonalTileToWorldY: __webpack_require__(554),
            HexagonalWorldToTileXY: __webpack_require__(556),
            HexagonalWorldToTileY: __webpack_require__(560),
            IsInLayerBounds: __webpack_require__(119),
            IsometricCullTiles: __webpack_require__(547),
            IsometricTileToWorldXY: __webpack_require__(551),
            IsometricWorldToTileXY: __webpack_require__(557),
            PutTileAt: __webpack_require__(257),
            PutTileAtWorldXY: __webpack_require__(1437),
            PutTilesAt: __webpack_require__(1438),
            Randomize: __webpack_require__(1439),
            RemoveTileAt: __webpack_require__(563),
            RemoveTileAtWorldXY: __webpack_require__(1440),
            RenderDebug: __webpack_require__(1441),
            ReplaceByIndex: __webpack_require__(542),
            RunCull: __webpack_require__(159),
            SetCollision: __webpack_require__(1442),
            SetCollisionBetween: __webpack_require__(1443),
            SetCollisionByExclusion: __webpack_require__(1444),
            SetCollisionByProperty: __webpack_require__(1445),
            SetCollisionFromCollisionGroup: __webpack_require__(1446),
            SetLayerCollisionIndex: __webpack_require__(160),
            SetTileCollision: __webpack_require__(72),
            SetTileIndexCallback: __webpack_require__(1447),
            SetTileLocationCallback: __webpack_require__(1448),
            Shuffle: __webpack_require__(1449),
            StaggeredCullBounds: __webpack_require__(549),
            StaggeredCullTiles: __webpack_require__(548),
            StaggeredTileToWorldXY: __webpack_require__(552),
            StaggeredTileToWorldY: __webpack_require__(555),
            StaggeredWorldToTileXY: __webpack_require__(558),
            StaggeredWorldToTileY: __webpack_require__(561),
            SwapByIndex: __webpack_require__(1450),
            TileToWorldX: __webpack_require__(253),
            TileToWorldXY: __webpack_require__(553),
            TileToWorldY: __webpack_require__(254),
            WeightedRandomize: __webpack_require__(1451),
            WorldToTileX: __webpack_require__(255),
            WorldToTileXY: __webpack_require__(559),
            WorldToTileY: __webpack_require__(256)
          };
        }, function (module2, exports2, __webpack_require__) {
          var GetTileAt = __webpack_require__(158);
          var CalculateFacesAt = function (tileX, tileY, layer) {
            var tile = GetTileAt(tileX, tileY, true, layer);
            var above = GetTileAt(tileX, tileY - 1, true, layer);
            var below = GetTileAt(tileX, tileY + 1, true, layer);
            var left = GetTileAt(tileX - 1, tileY, true, layer);
            var right = GetTileAt(tileX + 1, tileY, true, layer);
            var tileCollides = tile && tile.collides;
            if (tileCollides) {
              tile.faceTop = true;
              tile.faceBottom = true;
              tile.faceLeft = true;
              tile.faceRight = true;
            }
            if (above && above.collides) {
              if (tileCollides) {
                tile.faceTop = false;
              }
              above.faceBottom = !tileCollides;
            }
            if (below && below.collides) {
              if (tileCollides) {
                tile.faceBottom = false;
              }
              below.faceTop = !tileCollides;
            }
            if (left && left.collides) {
              if (tileCollides) {
                tile.faceLeft = false;
              }
              left.faceRight = !tileCollides;
            }
            if (right && right.collides) {
              if (tileCollides) {
                tile.faceRight = false;
              }
              right.faceLeft = !tileCollides;
            }
            if (tile && !tile.collides) {
              tile.resetFaces();
            }
            return tile;
          };
          module2.exports = CalculateFacesAt;
        }, function (module2, exports2) {
          var TileToWorldX = function (tileX, camera, layer) {
            var tileWidth = layer.baseTileWidth;
            var tilemapLayer = layer.tilemapLayer;
            var layerWorldX = 0;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
              tileWidth *= tilemapLayer.scaleX;
            }
            return layerWorldX + tileX * tileWidth;
          };
          module2.exports = TileToWorldX;
        }, function (module2, exports2) {
          var TileToWorldY = function (tileY, camera, layer) {
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            var layerWorldY = 0;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
              tileHeight *= tilemapLayer.scaleY;
            }
            return layerWorldY + tileY * tileHeight;
          };
          module2.exports = TileToWorldY;
        }, function (module2, exports2) {
          var WorldToTileX = function (worldX, snapToFloor, camera, layer) {
            if (snapToFloor === void 0) {
              snapToFloor = true;
            }
            var tileWidth = layer.baseTileWidth;
            var tilemapLayer = layer.tilemapLayer;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
              tileWidth *= tilemapLayer.scaleX;
            }
            return snapToFloor ? Math.floor(worldX / tileWidth) : worldX / tileWidth;
          };
          module2.exports = WorldToTileX;
        }, function (module2, exports2) {
          var WorldToTileY = function (worldY, snapToFloor, camera, layer) {
            if (snapToFloor === void 0) {
              snapToFloor = true;
            }
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
              tileHeight *= tilemapLayer.scaleY;
            }
            return snapToFloor ? Math.floor(worldY / tileHeight) : worldY / tileHeight;
          };
          module2.exports = WorldToTileY;
        }, function (module2, exports2, __webpack_require__) {
          var Tile = __webpack_require__(85);
          var IsInLayerBounds = __webpack_require__(119);
          var CalculateFacesAt = __webpack_require__(252);
          var SetTileCollision = __webpack_require__(72);
          var PutTileAt = function (tile, tileX, tileY, recalculateFaces, layer) {
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            if (!IsInLayerBounds(tileX, tileY, layer)) {
              return null;
            }
            var oldTile = layer.data[tileY][tileX];
            var oldTileCollides = oldTile && oldTile.collides;
            if (tile instanceof Tile) {
              if (layer.data[tileY][tileX] === null) {
                layer.data[tileY][tileX] = new Tile(layer, tile.index, tileX, tileY, layer.tileWidth, layer.tileHeight);
              }
              layer.data[tileY][tileX].copy(tile);
            } else {
              var index = tile;
              if (layer.data[tileY][tileX] === null) {
                layer.data[tileY][tileX] = new Tile(layer, index, tileX, tileY, layer.tileWidth, layer.tileHeight);
              } else {
                layer.data[tileY][tileX].index = index;
              }
            }
            var newTile = layer.data[tileY][tileX];
            var collides = layer.collideIndexes.indexOf(newTile.index) !== -1;
            SetTileCollision(newTile, collides);
            if (recalculateFaces && oldTileCollides !== newTile.collides) {
              CalculateFacesAt(tileX, tileY, layer);
            }
            return newTile;
          };
          module2.exports = PutTileAt;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(29);
          var FromOrientationString = function (orientation) {
            orientation = orientation.toLowerCase();
            if (orientation === "isometric") {
              return CONST.ISOMETRIC;
            } else if (orientation === "staggered") {
              return CONST.STAGGERED;
            } else if (orientation === "hexagonal") {
              return CONST.HEXAGONAL;
            } else {
              return CONST.ORTHOGONAL;
            }
          };
          module2.exports = FromOrientationString;
        }, function (module2, exports2, __webpack_require__) {
          var Formats = __webpack_require__(40);
          var LayerData = __webpack_require__(120);
          var MapData = __webpack_require__(121);
          var Tile = __webpack_require__(85);
          var Parse2DArray = function (name, data, tileWidth, tileHeight, insertNull) {
            var layerData = new LayerData({
              tileWidth,
              tileHeight
            });
            var mapData = new MapData({
              name,
              tileWidth,
              tileHeight,
              format: Formats.ARRAY_2D,
              layers: [layerData]
            });
            var tiles = [];
            var height = data.length;
            var width = 0;
            for (var y = 0; y < data.length; y++) {
              tiles[y] = [];
              var row = data[y];
              for (var x = 0; x < row.length; x++) {
                var tileIndex = parseInt(row[x], 10);
                if (isNaN(tileIndex) || tileIndex === -1) {
                  tiles[y][x] = insertNull ? null : new Tile(layerData, -1, x, y, tileWidth, tileHeight);
                } else {
                  tiles[y][x] = new Tile(layerData, tileIndex, x, y, tileWidth, tileHeight);
                }
              }
              if (width === 0) {
                width = row.length;
              }
            }
            mapData.width = layerData.width = width;
            mapData.height = layerData.height = height;
            mapData.widthInPixels = layerData.widthInPixels = width * tileWidth;
            mapData.heightInPixels = layerData.heightInPixels = height * tileHeight;
            layerData.data = tiles;
            return mapData;
          };
          module2.exports = Parse2DArray;
        }, function (module2, exports2, __webpack_require__) {
          var Pick = __webpack_require__(571);
          var ParseGID = __webpack_require__(261);
          var copyPoints = function (p3) {
            return {
              x: p3.x,
              y: p3.y
            };
          };
          var commonObjectProps = ["id", "name", "type", "rotation", "properties", "visible", "x", "y", "width", "height"];
          var ParseObject = function (tiledObject, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            var parsedObject = Pick(tiledObject, commonObjectProps);
            parsedObject.x += offsetX;
            parsedObject.y += offsetY;
            if (tiledObject.gid) {
              var gidInfo = ParseGID(tiledObject.gid);
              parsedObject.gid = gidInfo.gid;
              parsedObject.flippedHorizontal = gidInfo.flippedHorizontal;
              parsedObject.flippedVertical = gidInfo.flippedVertical;
              parsedObject.flippedAntiDiagonal = gidInfo.flippedAntiDiagonal;
            } else if (tiledObject.polyline) {
              parsedObject.polyline = tiledObject.polyline.map(copyPoints);
            } else if (tiledObject.polygon) {
              parsedObject.polygon = tiledObject.polygon.map(copyPoints);
            } else if (tiledObject.ellipse) {
              parsedObject.ellipse = tiledObject.ellipse;
            } else if (tiledObject.text) {
              parsedObject.text = tiledObject.text;
            } else if (tiledObject.point) {
              parsedObject.point = true;
            } else {
              parsedObject.rectangle = true;
            }
            return parsedObject;
          };
          module2.exports = ParseObject;
        }, function (module2, exports2) {
          var FLIPPED_HORIZONTAL = 2147483648;
          var FLIPPED_VERTICAL = 1073741824;
          var FLIPPED_ANTI_DIAGONAL = 536870912;
          var ParseGID = function (gid) {
            var flippedHorizontal = Boolean(gid & FLIPPED_HORIZONTAL);
            var flippedVertical = Boolean(gid & FLIPPED_VERTICAL);
            var flippedAntiDiagonal = Boolean(gid & FLIPPED_ANTI_DIAGONAL);
            gid = gid & ~(FLIPPED_HORIZONTAL | FLIPPED_VERTICAL | FLIPPED_ANTI_DIAGONAL);
            var rotation = 0;
            var flipped = false;
            if (flippedHorizontal && flippedVertical && flippedAntiDiagonal) {
              rotation = Math.PI / 2;
              flipped = true;
            } else if (flippedHorizontal && flippedVertical && !flippedAntiDiagonal) {
              rotation = Math.PI;
              flipped = false;
            } else if (flippedHorizontal && !flippedVertical && flippedAntiDiagonal) {
              rotation = Math.PI / 2;
              flipped = false;
            } else if (flippedHorizontal && !flippedVertical && !flippedAntiDiagonal) {
              rotation = 0;
              flipped = true;
            } else if (!flippedHorizontal && flippedVertical && flippedAntiDiagonal) {
              rotation = 3 * Math.PI / 2;
              flipped = false;
            } else if (!flippedHorizontal && flippedVertical && !flippedAntiDiagonal) {
              rotation = Math.PI;
              flipped = true;
            } else if (!flippedHorizontal && !flippedVertical && flippedAntiDiagonal) {
              rotation = 3 * Math.PI / 2;
              flipped = true;
            } else if (!flippedHorizontal && !flippedVertical && !flippedAntiDiagonal) {
              rotation = 0;
              flipped = false;
            }
            return {
              gid,
              flippedHorizontal,
              flippedVertical,
              flippedAntiDiagonal,
              rotation,
              flipped
            };
          };
          module2.exports = ParseGID;
        }, function (module2, exports2, __webpack_require__) {
          var Formats = __webpack_require__(40);
          var MapData = __webpack_require__(121);
          var Parse = __webpack_require__(564);
          var Tilemap = __webpack_require__(580);
          var ParseToTilemap = function (scene, key, tileWidth, tileHeight, width, height, data, insertNull) {
            if (tileWidth === void 0) {
              tileWidth = 32;
            }
            if (tileHeight === void 0) {
              tileHeight = 32;
            }
            if (width === void 0) {
              width = 10;
            }
            if (height === void 0) {
              height = 10;
            }
            if (insertNull === void 0) {
              insertNull = false;
            }
            var mapData = null;
            if (Array.isArray(data)) {
              var name = key !== void 0 ? key : "map";
              mapData = Parse(name, Formats.ARRAY_2D, data, tileWidth, tileHeight, insertNull);
            } else if (key !== void 0) {
              var tilemapData = scene.cache.tilemap.get(key);
              if (!tilemapData) {
                console.warn("No map data found for key " + key);
              } else {
                mapData = Parse(key, tilemapData.format, tilemapData.data, tileWidth, tileHeight, insertNull);
              }
            }
            if (mapData === null) {
              mapData = new MapData({
                tileWidth,
                tileHeight,
                width,
                height
              });
            }
            return new Tilemap(scene, mapData);
          };
          module2.exports = ParseToTilemap;
        }, function (module2, exports2, __webpack_require__) {
          var GetValue = __webpack_require__(6);
          var GetTargets = function (config) {
            var targets = GetValue(config, "targets", null);
            if (targets === null) {
              return targets;
            }
            if (typeof targets === "function") {
              targets = targets.call();
            }
            if (!Array.isArray(targets)) {
              targets = [targets];
            }
            return targets;
          };
          module2.exports = GetTargets;
        }, function (module2, exports2) {
          function hasGetActive(def) {
            return !!def.getActive && typeof def.getActive === "function";
          }
          function hasGetStart(def) {
            return !!def.getStart && typeof def.getStart === "function";
          }
          function hasGetEnd(def) {
            return !!def.getEnd && typeof def.getEnd === "function";
          }
          function hasGetters(def) {
            return hasGetStart(def) || hasGetEnd(def) || hasGetActive(def);
          }
          var GetValueOp = function (key, propertyValue) {
            var callbacks;
            var getEnd = function (target, key2, value) {
              return value;
            };
            var getStart = function (target, key2, value) {
              return value;
            };
            var getActive = null;
            var t = typeof propertyValue;
            if (t === "number") {
              getEnd = function () {
                return propertyValue;
              };
            } else if (t === "string") {
              var op = propertyValue[0];
              var num = parseFloat(propertyValue.substr(2));
              switch (op) {
                case "+":
                  getEnd = function (target, key2, value) {
                    return value + num;
                  };
                  break;
                case "-":
                  getEnd = function (target, key2, value) {
                    return value - num;
                  };
                  break;
                case "*":
                  getEnd = function (target, key2, value) {
                    return value * num;
                  };
                  break;
                case "/":
                  getEnd = function (target, key2, value) {
                    return value / num;
                  };
                  break;
                default:
                  getEnd = function () {
                    return parseFloat(propertyValue);
                  };
              }
            } else if (t === "function") {
              getEnd = propertyValue;
            } else if (t === "object") {
              if (hasGetters(propertyValue)) {
                if (hasGetActive(propertyValue)) {
                  getActive = propertyValue.getActive;
                }
                if (hasGetEnd(propertyValue)) {
                  getEnd = propertyValue.getEnd;
                }
                if (hasGetStart(propertyValue)) {
                  getStart = propertyValue.getStart;
                }
              } else if (propertyValue.hasOwnProperty("value")) {
                callbacks = GetValueOp(key, propertyValue.value);
              } else {
                var hasTo = propertyValue.hasOwnProperty("to");
                var hasFrom = propertyValue.hasOwnProperty("from");
                var hasStart = propertyValue.hasOwnProperty("start");
                if (hasTo && (hasFrom || hasStart)) {
                  callbacks = GetValueOp(key, propertyValue.to);
                  if (hasStart) {
                    var startCallbacks = GetValueOp(key, propertyValue.start);
                    callbacks.getActive = startCallbacks.getEnd;
                  }
                  if (hasFrom) {
                    var fromCallbacks = GetValueOp(key, propertyValue.from);
                    callbacks.getStart = fromCallbacks.getEnd;
                  }
                }
              }
            }
            if (!callbacks) {
              callbacks = {
                getActive,
                getEnd,
                getStart
              };
            }
            return callbacks;
          };
          module2.exports = GetValueOp;
        }, function (module2, exports2) {
          var TWEEN_DEFAULTS = {
            targets: null,
            delay: 0,
            duration: 1e3,
            ease: "Power0",
            easeParams: null,
            hold: 0,
            repeat: 0,
            repeatDelay: 0,
            yoyo: false,
            flipX: false,
            flipY: false
          };
          module2.exports = TWEEN_DEFAULTS;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(267);
          var GameObjectCreator = __webpack_require__(16);
          var GameObjectFactory = __webpack_require__(5);
          var TWEEN_CONST = __webpack_require__(100);
          var MATH_CONST = __webpack_require__(14);
          var Tween = new Class({
            Extends: EventEmitter,
            initialize: function Tween2(parent, data, targets) {
              EventEmitter.call(this);
              this.parent = parent;
              this.parentIsTimeline = parent.hasOwnProperty("isTimeline");
              this.data = data;
              this.totalData = data.length;
              this.targets = targets;
              this.totalTargets = targets.length;
              this.useFrames = false;
              this.timeScale = 1;
              this.loop = 0;
              this.loopDelay = 0;
              this.loopCounter = 0;
              this.startDelay = 0;
              this.hasStarted = false;
              this.isSeeking = false;
              this.completeDelay = 0;
              this.countdown = 0;
              this.offset = 0;
              this.calculatedOffset = 0;
              this.state = TWEEN_CONST.PENDING_ADD;
              this._pausedState = TWEEN_CONST.INIT;
              this.paused = false;
              this.elapsed = 0;
              this.totalElapsed = 0;
              this.duration = 0;
              this.progress = 0;
              this.totalDuration = 0;
              this.totalProgress = 0;
              this.callbacks = {
                onActive: null,
                onComplete: null,
                onLoop: null,
                onRepeat: null,
                onStart: null,
                onStop: null,
                onUpdate: null,
                onYoyo: null
              };
              this.callbackScope;
            },
            getValue: function (index) {
              if (index === void 0) {
                index = 0;
              }
              return this.data[index].current;
            },
            setTimeScale: function (value) {
              this.timeScale = value;
              return this;
            },
            getTimeScale: function () {
              return this.timeScale;
            },
            isPlaying: function () {
              return this.state === TWEEN_CONST.ACTIVE;
            },
            isPaused: function () {
              return this.state === TWEEN_CONST.PAUSED;
            },
            hasTarget: function (target) {
              return this.targets.indexOf(target) !== -1;
            },
            updateTo: function (key, value, startToCurrent) {
              if (startToCurrent === void 0) {
                startToCurrent = false;
              }
              for (var i = 0; i < this.totalData; i++) {
                var tweenData = this.data[i];
                if (tweenData.key === key) {
                  tweenData.end = value;
                  if (startToCurrent) {
                    tweenData.start = tweenData.current;
                  }
                }
              }
              return this;
            },
            restart: function () {
              this.elapsed = 0;
              this.progress = 0;
              this.totalElapsed = 0;
              this.totalProgress = 0;
              if (this.state === TWEEN_CONST.ACTIVE) {
                return this.seek(0);
              } else if (this.state === TWEEN_CONST.REMOVED) {
                this.seek(0);
                this.parent.makeActive(this);
                return this;
              } else if (this.state === TWEEN_CONST.PENDING_ADD) {
                return this;
              } else {
                return this.play();
              }
            },
            calcDuration: function () {
              var maxDuration = 0;
              var minDelay = MATH_CONST.MAX_SAFE_INTEGER;
              var data = this.data;
              for (var i = 0; i < this.totalData; i++) {
                var tweenData = data[i];
                tweenData.t1 = tweenData.duration + tweenData.hold;
                if (tweenData.yoyo) {
                  tweenData.t1 += tweenData.duration;
                }
                tweenData.t2 = tweenData.t1 + tweenData.repeatDelay;
                tweenData.totalDuration = tweenData.delay + tweenData.t1;
                if (tweenData.repeat === -1) {
                  tweenData.totalDuration += tweenData.t2 * 999999999999;
                } else if (tweenData.repeat > 0) {
                  tweenData.totalDuration += tweenData.t2 * tweenData.repeat;
                }
                if (tweenData.totalDuration > maxDuration) {
                  maxDuration = tweenData.totalDuration;
                }
                if (tweenData.delay < minDelay) {
                  minDelay = tweenData.delay;
                }
              }
              this.duration = Math.max(maxDuration, 1e-3);
              this.loopCounter = this.loop === -1 ? 999999999999 : this.loop;
              if (this.loopCounter > 0) {
                this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter;
              } else {
                this.totalDuration = this.duration + this.completeDelay;
              }
              this.startDelay = minDelay;
            },
            init: function () {
              if (this.paused && !this.parentIsTimeline) {
                this.state = TWEEN_CONST.PENDING_ADD;
                this._pausedState = TWEEN_CONST.INIT;
                return false;
              }
              var data = this.data;
              var totalTargets = this.totalTargets;
              for (var i = 0; i < this.totalData; i++) {
                var tweenData = data[i];
                var target = tweenData.target;
                var gen = tweenData.gen;
                var key = tweenData.key;
                var targetIndex = tweenData.index;
                tweenData.delay = gen.delay(target, key, 0, targetIndex, totalTargets, this);
                tweenData.duration = Math.max(gen.duration(target, key, 0, targetIndex, totalTargets, this), 1e-3);
                tweenData.hold = gen.hold(target, key, 0, targetIndex, totalTargets, this);
                tweenData.repeat = gen.repeat(target, key, 0, targetIndex, totalTargets, this);
                tweenData.repeatDelay = gen.repeatDelay(target, key, 0, targetIndex, totalTargets, this);
              }
              this.calcDuration();
              this.progress = 0;
              this.totalProgress = 0;
              this.elapsed = 0;
              this.totalElapsed = 0;
              this.state = TWEEN_CONST.INIT;
              return true;
            },
            makeActive: function () {
              this.parent.makeActive(this);
              this.dispatchTweenEvent(Events.TWEEN_ACTIVE, this.callbacks.onActive);
            },
            nextState: function () {
              if (this.loopCounter > 0) {
                this.elapsed = 0;
                this.progress = 0;
                this.loopCounter--;
                this.resetTweenData(true);
                if (this.loopDelay > 0) {
                  this.countdown = this.loopDelay;
                  this.state = TWEEN_CONST.LOOP_DELAY;
                } else {
                  this.state = TWEEN_CONST.ACTIVE;
                  this.dispatchTweenEvent(Events.TWEEN_LOOP, this.callbacks.onLoop);
                }
              } else if (this.completeDelay > 0) {
                this.state = TWEEN_CONST.COMPLETE_DELAY;
                this.countdown = this.completeDelay;
              } else {
                this.state = TWEEN_CONST.PENDING_REMOVE;
                this.dispatchTweenEvent(Events.TWEEN_COMPLETE, this.callbacks.onComplete);
              }
            },
            pause: function () {
              if (this.state === TWEEN_CONST.PAUSED) {
                return this;
              }
              this.paused = true;
              this._pausedState = this.state;
              this.state = TWEEN_CONST.PAUSED;
              return this;
            },
            play: function (resetFromTimeline) {
              if (resetFromTimeline === void 0) {
                resetFromTimeline = false;
              }
              var state = this.state;
              if (state === TWEEN_CONST.INIT && !this.parentIsTimeline) {
                this.resetTweenData(false);
                this.state = TWEEN_CONST.ACTIVE;
                return this;
              } else if (state === TWEEN_CONST.ACTIVE || state === TWEEN_CONST.PENDING_ADD && this._pausedState === TWEEN_CONST.PENDING_ADD) {
                return this;
              } else if (!this.parentIsTimeline && (state === TWEEN_CONST.PENDING_REMOVE || state === TWEEN_CONST.REMOVED)) {
                this.seek(0);
                this.parent.makeActive(this);
                return this;
              }
              if (this.parentIsTimeline) {
                this.resetTweenData(resetFromTimeline);
                if (this.calculatedOffset === 0) {
                  this.state = TWEEN_CONST.ACTIVE;
                } else {
                  this.countdown = this.calculatedOffset;
                  this.state = TWEEN_CONST.OFFSET_DELAY;
                }
              } else if (this.paused) {
                this.paused = false;
                this.makeActive();
              } else {
                this.resetTweenData(resetFromTimeline);
                this.state = TWEEN_CONST.ACTIVE;
                this.makeActive();
              }
              return this;
            },
            resetTweenData: function (resetFromLoop) {
              var data = this.data;
              var total = this.totalData;
              var totalTargets = this.totalTargets;
              for (var i = 0; i < total; i++) {
                var tweenData = data[i];
                var target = tweenData.target;
                var key = tweenData.key;
                var targetIndex = tweenData.index;
                tweenData.progress = 0;
                tweenData.elapsed = 0;
                tweenData.repeatCounter = tweenData.repeat === -1 ? 999999999999 : tweenData.repeat;
                if (resetFromLoop) {
                  tweenData.start = tweenData.getStartValue(target, key, tweenData.start, targetIndex, totalTargets, this);
                  tweenData.end = tweenData.getEndValue(target, key, tweenData.end, targetIndex, totalTargets, this);
                  tweenData.current = tweenData.start;
                  tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
                } else {
                  tweenData.state = TWEEN_CONST.PENDING_RENDER;
                }
                if (tweenData.delay > 0) {
                  tweenData.elapsed = tweenData.delay;
                  tweenData.state = TWEEN_CONST.DELAY;
                }
                if (tweenData.getActiveValue) {
                  target[key] = tweenData.getActiveValue(tweenData.target, tweenData.key, tweenData.start);
                }
              }
            },
            resume: function () {
              if (this.state === TWEEN_CONST.PAUSED) {
                this.paused = false;
                this.state = this._pausedState;
              } else {
                this.play();
              }
              return this;
            },
            seek: function (toPosition, delta) {
              if (delta === void 0) {
                delta = 16.6;
              }
              if (this.state === TWEEN_CONST.REMOVED) {
                this.makeActive();
              }
              this.elapsed = 0;
              this.progress = 0;
              this.totalElapsed = 0;
              this.totalProgress = 0;
              var data = this.data;
              var totalTargets = this.totalTargets;
              for (var i = 0; i < this.totalData; i++) {
                var tweenData = data[i];
                var target = tweenData.target;
                var gen = tweenData.gen;
                var key = tweenData.key;
                var targetIndex = tweenData.index;
                tweenData.progress = 0;
                tweenData.elapsed = 0;
                tweenData.repeatCounter = tweenData.repeat === -1 ? 999999999999 : tweenData.repeat;
                tweenData.delay = gen.delay(target, key, 0, targetIndex, totalTargets, this);
                tweenData.duration = Math.max(gen.duration(target, key, 0, targetIndex, totalTargets, this), 1e-3);
                tweenData.hold = gen.hold(target, key, 0, targetIndex, totalTargets, this);
                tweenData.repeat = gen.repeat(target, key, 0, targetIndex, totalTargets, this);
                tweenData.repeatDelay = gen.repeatDelay(target, key, 0, targetIndex, totalTargets, this);
                tweenData.current = tweenData.start;
                tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
                this.updateTweenData(this, tweenData, 0, targetIndex, totalTargets);
                if (tweenData.delay > 0) {
                  tweenData.elapsed = tweenData.delay;
                  tweenData.state = TWEEN_CONST.DELAY;
                }
              }
              this.calcDuration();
              var wasPaused = false;
              if (this.state === TWEEN_CONST.PAUSED) {
                wasPaused = true;
                this.state = TWEEN_CONST.ACTIVE;
              }
              this.isSeeking = true;
              do {
                this.update(0, delta);
              } while (this.totalProgress < toPosition);
              this.isSeeking = false;
              if (wasPaused) {
                this.state = TWEEN_CONST.PAUSED;
              }
              return this;
            },
            setCallback: function (type, callback, params, scope) {
              this.callbacks[type] = {
                func: callback,
                scope,
                params
              };
              return this;
            },
            complete: function (delay) {
              if (delay === void 0) {
                delay = 0;
              }
              if (delay) {
                this.state = TWEEN_CONST.COMPLETE_DELAY;
                this.countdown = delay;
              } else {
                this.state = TWEEN_CONST.PENDING_REMOVE;
                this.dispatchTweenEvent(Events.TWEEN_COMPLETE, this.callbacks.onComplete);
              }
              return this;
            },
            remove: function () {
              this.parent.remove(this);
              return this;
            },
            stop: function (resetTo) {
              if (this.state === TWEEN_CONST.ACTIVE) {
                if (resetTo !== void 0) {
                  this.seek(resetTo);
                }
              }
              if (this.state !== TWEEN_CONST.REMOVED) {
                if (this.state === TWEEN_CONST.PAUSED || this.state === TWEEN_CONST.PENDING_ADD) {
                  if (this.parentIsTimeline) {
                    this.parent.manager._destroy.push(this);
                    this.parent.manager._toProcess++;
                  } else {
                    this.parent._destroy.push(this);
                    this.parent._toProcess++;
                  }
                }
                this.dispatchTweenEvent(Events.TWEEN_STOP, this.callbacks.onStop);
                this.removeAllListeners();
                this.state = TWEEN_CONST.PENDING_REMOVE;
              }
              return this;
            },
            update: function (timestamp, delta) {
              if (this.state === TWEEN_CONST.PAUSED) {
                return false;
              }
              if (this.useFrames) {
                delta = 1 * this.parent.timeScale;
              }
              delta *= this.timeScale;
              this.elapsed += delta;
              this.progress = Math.min(this.elapsed / this.duration, 1);
              this.totalElapsed += delta;
              this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1);
              switch (this.state) {
                case TWEEN_CONST.ACTIVE:
                  if (!this.hasStarted && !this.isSeeking) {
                    this.startDelay -= delta;
                    if (this.startDelay <= 0) {
                      this.hasStarted = true;
                      this.dispatchTweenEvent(Events.TWEEN_START, this.callbacks.onStart);
                    }
                  }
                  var stillRunning = false;
                  for (var i = 0; i < this.totalData; i++) {
                    var tweenData = this.data[i];
                    if (this.updateTweenData(this, tweenData, delta)) {
                      stillRunning = true;
                    }
                  }
                  if (!stillRunning) {
                    this.nextState();
                  }
                  break;
                case TWEEN_CONST.LOOP_DELAY:
                  this.countdown -= delta;
                  if (this.countdown <= 0) {
                    this.state = TWEEN_CONST.ACTIVE;
                    this.dispatchTweenEvent(Events.TWEEN_LOOP, this.callbacks.onLoop);
                  }
                  break;
                case TWEEN_CONST.OFFSET_DELAY:
                  this.countdown -= delta;
                  if (this.countdown <= 0) {
                    this.state = TWEEN_CONST.ACTIVE;
                  }
                  break;
                case TWEEN_CONST.COMPLETE_DELAY:
                  this.countdown -= delta;
                  if (this.countdown <= 0) {
                    this.state = TWEEN_CONST.PENDING_REMOVE;
                    this.dispatchTweenEvent(Events.TWEEN_COMPLETE, this.callbacks.onComplete);
                  }
                  break;
              }
              return this.state === TWEEN_CONST.PENDING_REMOVE;
            },
            dispatchTweenDataEvent: function (event, callback, tweenData) {
              if (!this.isSeeking) {
                this.emit(event, this, tweenData.key, tweenData.target, tweenData.current, tweenData.previous);
                if (callback) {
                  callback.params[1] = tweenData.target;
                  callback.func.apply(callback.scope, callback.params);
                }
              }
            },
            dispatchTweenEvent: function (event, callback) {
              if (!this.isSeeking) {
                this.emit(event, this, this.targets);
                if (callback) {
                  callback.params[1] = this.targets;
                  callback.func.apply(callback.scope, callback.params);
                }
              }
            },
            setStateFromEnd: function (tween, tweenData, diff) {
              if (tweenData.yoyo) {
                tweenData.elapsed = diff;
                tweenData.progress = diff / tweenData.duration;
                if (tweenData.flipX) {
                  tweenData.target.toggleFlipX();
                }
                if (tweenData.flipY) {
                  tweenData.target.toggleFlipY();
                }
                this.dispatchTweenDataEvent(Events.TWEEN_YOYO, tween.callbacks.onYoyo, tweenData);
                tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
                return TWEEN_CONST.PLAYING_BACKWARD;
              } else if (tweenData.repeatCounter > 0) {
                tweenData.repeatCounter--;
                tweenData.elapsed = diff;
                tweenData.progress = diff / tweenData.duration;
                if (tweenData.flipX) {
                  tweenData.target.toggleFlipX();
                }
                if (tweenData.flipY) {
                  tweenData.target.toggleFlipY();
                }
                tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
                tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
                if (tweenData.repeatDelay > 0) {
                  tweenData.elapsed = tweenData.repeatDelay - diff;
                  tweenData.current = tweenData.start;
                  tweenData.target[tweenData.key] = tweenData.current;
                  return TWEEN_CONST.REPEAT_DELAY;
                } else {
                  this.dispatchTweenDataEvent(Events.TWEEN_REPEAT, tween.callbacks.onRepeat, tweenData);
                  return TWEEN_CONST.PLAYING_FORWARD;
                }
              }
              return TWEEN_CONST.COMPLETE;
            },
            setStateFromStart: function (tween, tweenData, diff) {
              if (tweenData.repeatCounter > 0) {
                tweenData.repeatCounter--;
                tweenData.elapsed = diff;
                tweenData.progress = diff / tweenData.duration;
                if (tweenData.flipX) {
                  tweenData.target.toggleFlipX();
                }
                if (tweenData.flipY) {
                  tweenData.target.toggleFlipY();
                }
                tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
                if (tweenData.repeatDelay > 0) {
                  tweenData.elapsed = tweenData.repeatDelay - diff;
                  tweenData.current = tweenData.start;
                  tweenData.target[tweenData.key] = tweenData.current;
                  return TWEEN_CONST.REPEAT_DELAY;
                } else {
                  this.dispatchTweenDataEvent(Events.TWEEN_REPEAT, tween.callbacks.onRepeat, tweenData);
                  return TWEEN_CONST.PLAYING_FORWARD;
                }
              }
              return TWEEN_CONST.COMPLETE;
            },
            updateTweenData: function (tween, tweenData, delta) {
              var target = tweenData.target;
              switch (tweenData.state) {
                case TWEEN_CONST.PLAYING_FORWARD:
                case TWEEN_CONST.PLAYING_BACKWARD:
                  if (!target) {
                    tweenData.state = TWEEN_CONST.COMPLETE;
                    break;
                  }
                  var elapsed = tweenData.elapsed;
                  var duration = tweenData.duration;
                  var diff = 0;
                  elapsed += delta;
                  if (elapsed > duration) {
                    diff = elapsed - duration;
                    elapsed = duration;
                  }
                  var forward = tweenData.state === TWEEN_CONST.PLAYING_FORWARD;
                  var progress = elapsed / duration;
                  tweenData.elapsed = elapsed;
                  tweenData.progress = progress;
                  tweenData.previous = tweenData.current;
                  if (progress === 1) {
                    if (forward) {
                      tweenData.current = tweenData.end;
                      target[tweenData.key] = tweenData.end;
                      if (tweenData.hold > 0) {
                        tweenData.elapsed = tweenData.hold - diff;
                        tweenData.state = TWEEN_CONST.HOLD_DELAY;
                      } else {
                        tweenData.state = this.setStateFromEnd(tween, tweenData, diff);
                      }
                    } else {
                      tweenData.current = tweenData.start;
                      target[tweenData.key] = tweenData.start;
                      tweenData.state = this.setStateFromStart(tween, tweenData, diff);
                    }
                  } else {
                    var v = forward ? tweenData.ease(progress) : tweenData.ease(1 - progress);
                    tweenData.current = tweenData.start + (tweenData.end - tweenData.start) * v;
                    target[tweenData.key] = tweenData.current;
                  }
                  this.dispatchTweenDataEvent(Events.TWEEN_UPDATE, tween.callbacks.onUpdate, tweenData);
                  break;
                case TWEEN_CONST.DELAY:
                  tweenData.elapsed -= delta;
                  if (tweenData.elapsed <= 0) {
                    tweenData.elapsed = Math.abs(tweenData.elapsed);
                    tweenData.state = TWEEN_CONST.PENDING_RENDER;
                  }
                  break;
                case TWEEN_CONST.REPEAT_DELAY:
                  tweenData.elapsed -= delta;
                  if (tweenData.elapsed <= 0) {
                    tweenData.elapsed = Math.abs(tweenData.elapsed);
                    tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
                    this.dispatchTweenDataEvent(Events.TWEEN_REPEAT, tween.callbacks.onRepeat, tweenData);
                  }
                  break;
                case TWEEN_CONST.HOLD_DELAY:
                  tweenData.elapsed -= delta;
                  if (tweenData.elapsed <= 0) {
                    tweenData.state = this.setStateFromEnd(tween, tweenData, Math.abs(tweenData.elapsed));
                  }
                  break;
                case TWEEN_CONST.PENDING_RENDER:
                  if (target) {
                    tweenData.start = tweenData.getStartValue(target, tweenData.key, target[tweenData.key], tweenData.index, tween.totalTargets, tween);
                    tweenData.end = tweenData.getEndValue(target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
                    tweenData.current = tweenData.start;
                    target[tweenData.key] = tweenData.start;
                    tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
                  } else {
                    tweenData.state = TWEEN_CONST.COMPLETE;
                  }
                  break;
              }
              return tweenData.state !== TWEEN_CONST.COMPLETE;
            }
          });
          Tween.TYPES = ["onActive", "onComplete", "onLoop", "onRepeat", "onStart", "onStop", "onUpdate", "onYoyo"];
          GameObjectFactory.register("tween", function (config) {
            return this.scene.sys.tweens.add(config);
          });
          GameObjectCreator.register("tween", function (config) {
            return this.scene.sys.tweens.create(config);
          });
          module2.exports = Tween;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            TIMELINE_COMPLETE: __webpack_require__(1466),
            TIMELINE_LOOP: __webpack_require__(1467),
            TIMELINE_PAUSE: __webpack_require__(1468),
            TIMELINE_RESUME: __webpack_require__(1469),
            TIMELINE_START: __webpack_require__(1470),
            TIMELINE_UPDATE: __webpack_require__(1471),
            TWEEN_ACTIVE: __webpack_require__(1472),
            TWEEN_COMPLETE: __webpack_require__(1473),
            TWEEN_LOOP: __webpack_require__(1474),
            TWEEN_REPEAT: __webpack_require__(1475),
            TWEEN_START: __webpack_require__(1476),
            TWEEN_STOP: __webpack_require__(1477),
            TWEEN_UPDATE: __webpack_require__(1478),
            TWEEN_YOYO: __webpack_require__(1479)
          };
        }, function (module2, exports2) {
          var TweenData = function (target, index, key, getEnd, getStart, getActive, ease, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY) {
            return {
              target,
              index,
              key,
              getActiveValue: getActive,
              getEndValue: getEnd,
              getStartValue: getStart,
              ease,
              duration: 0,
              totalDuration: 0,
              delay: 0,
              yoyo,
              hold: 0,
              repeat: 0,
              repeatDelay: 0,
              flipX,
              flipY,
              progress: 0,
              elapsed: 0,
              repeatCounter: 0,
              start: 0,
              previous: 0,
              current: 0,
              end: 0,
              t1: 0,
              t2: 0,
              gen: {
                delay,
                duration,
                hold,
                repeat,
                repeatDelay
              },
              state: 0
            };
          };
          module2.exports = TweenData;
        }, function (module2, exports2, __webpack_require__) {
          var MathWrap = __webpack_require__(68);
          var Wrap = function (angle) {
            return MathWrap(angle, -Math.PI, Math.PI);
          };
          module2.exports = Wrap;
        }, function (module2, exports2, __webpack_require__) {
          var Wrap = __webpack_require__(68);
          var WrapDegrees = function (angle) {
            return Wrap(angle, -180, 180);
          };
          module2.exports = WrapDegrees;
        }, function (module2, exports2, __webpack_require__) {
          var Axes = {};
          module2.exports = Axes;
          var Vector = __webpack_require__(83);
          var Common = __webpack_require__(32);
          (function () {
            Axes.fromVertices = function (vertices) {
              var axes = {};
              for (var i = 0; i < vertices.length; i++) {
                var j = (i + 1) % vertices.length, normal = Vector.normalise({
                  x: vertices[j].y - vertices[i].y,
                  y: vertices[i].x - vertices[j].x
                }), gradient = normal.y === 0 ? Infinity : normal.x / normal.y;
                gradient = gradient.toFixed(3).toString();
                axes[gradient] = normal;
              }
              return Common.values(axes);
            };
            Axes.rotate = function (axes, angle) {
              if (angle === 0) return;
              var cos = Math.cos(angle), sin = Math.sin(angle);
              for (var i = 0; i < axes.length; i++) {
                var axis = axes[i], xx;
                xx = axis.x * cos - axis.y * sin;
                axis.y = axis.x * sin + axis.y * cos;
                axis.x = xx;
              }
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            AFTER_ADD: __webpack_require__(1504),
            AFTER_REMOVE: __webpack_require__(1505),
            AFTER_UPDATE: __webpack_require__(1506),
            BEFORE_ADD: __webpack_require__(1507),
            BEFORE_REMOVE: __webpack_require__(1508),
            BEFORE_UPDATE: __webpack_require__(1509),
            COLLISION_ACTIVE: __webpack_require__(1510),
            COLLISION_END: __webpack_require__(1511),
            COLLISION_START: __webpack_require__(1512),
            DRAG_END: __webpack_require__(1513),
            DRAG: __webpack_require__(1514),
            DRAG_START: __webpack_require__(1515),
            PAUSE: __webpack_require__(1516),
            RESUME: __webpack_require__(1517),
            SLEEP_END: __webpack_require__(1518),
            SLEEP_START: __webpack_require__(1519)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Detector = {};
          module2.exports = Detector;
          var SAT = __webpack_require__(274);
          var Pair = __webpack_require__(250);
          var Bounds = __webpack_require__(84);
          (function () {
            Detector.collisions = function (broadphasePairs, engine) {
              var collisions = [], pairsTable = engine.pairs.table;
              var metrics = engine.metrics;
              for (var i = 0; i < broadphasePairs.length; i++) {
                var bodyA = broadphasePairs[i][0], bodyB = broadphasePairs[i][1];
                if ((bodyA.isStatic || bodyA.isSleeping) && (bodyB.isStatic || bodyB.isSleeping)) continue;
                if (!Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter)) continue;
                metrics.midphaseTests += 1;
                if (Bounds.overlaps(bodyA.bounds, bodyB.bounds)) {
                  for (var j = bodyA.parts.length > 1 ? 1 : 0; j < bodyA.parts.length; j++) {
                    var partA = bodyA.parts[j];
                    for (var k = bodyB.parts.length > 1 ? 1 : 0; k < bodyB.parts.length; k++) {
                      var partB = bodyB.parts[k];
                      if (partA === bodyA && partB === bodyB || Bounds.overlaps(partA.bounds, partB.bounds)) {
                        var pairId = Pair.id(partA, partB), pair = pairsTable[pairId], previousCollision;
                        if (pair && pair.isActive) {
                          previousCollision = pair.collision;
                        } else {
                          previousCollision = null;
                        }
                        var collision = SAT.collides(partA, partB, previousCollision);
                        metrics.narrowphaseTests += 1;
                        if (collision.reused) metrics.narrowReuseCount += 1;
                        if (collision.collided) {
                          collisions.push(collision);
                          metrics.narrowDetections += 1;
                        }
                      }
                    }
                  }
                }
              }
              return collisions;
            };
            Detector.canCollide = function (filterA, filterB) {
              if (filterA.group === filterB.group && filterA.group !== 0) return filterA.group > 0;
              return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          var SAT = {};
          module2.exports = SAT;
          var Vertices = __webpack_require__(64);
          var Vector = __webpack_require__(83);
          (function () {
            SAT.collides = function (bodyA, bodyB, previousCollision) {
              var overlapAB, overlapBA, minOverlap, collision, canReusePrevCol = false;
              if (previousCollision) {
                var parentA = bodyA.parent, parentB = bodyB.parent, motion = parentA.speed * parentA.speed + parentA.angularSpeed * parentA.angularSpeed + parentB.speed * parentB.speed + parentB.angularSpeed * parentB.angularSpeed;
                canReusePrevCol = previousCollision && previousCollision.collided && motion < 0.2;
                collision = previousCollision;
              } else {
                collision = {
                  collided: false,
                  bodyA,
                  bodyB
                };
              }
              if (previousCollision && canReusePrevCol) {
                var axisBodyA = collision.axisBody, axisBodyB = axisBodyA === bodyA ? bodyB : bodyA, axes = [axisBodyA.axes[previousCollision.axisNumber]];
                minOverlap = SAT._overlapAxes(axisBodyA.vertices, axisBodyB.vertices, axes);
                collision.reused = true;
                if (minOverlap.overlap <= 0) {
                  collision.collided = false;
                  return collision;
                }
              } else {
                overlapAB = SAT._overlapAxes(bodyA.vertices, bodyB.vertices, bodyA.axes);
                if (overlapAB.overlap <= 0) {
                  collision.collided = false;
                  return collision;
                }
                overlapBA = SAT._overlapAxes(bodyB.vertices, bodyA.vertices, bodyB.axes);
                if (overlapBA.overlap <= 0) {
                  collision.collided = false;
                  return collision;
                }
                if (overlapAB.overlap < overlapBA.overlap) {
                  minOverlap = overlapAB;
                  collision.axisBody = bodyA;
                } else {
                  minOverlap = overlapBA;
                  collision.axisBody = bodyB;
                }
                collision.axisNumber = minOverlap.axisNumber;
              }
              collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;
              collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;
              collision.collided = true;
              collision.depth = minOverlap.overlap;
              collision.parentA = collision.bodyA.parent;
              collision.parentB = collision.bodyB.parent;
              bodyA = collision.bodyA;
              bodyB = collision.bodyB;
              if (Vector.dot(minOverlap.axis, Vector.sub(bodyB.position, bodyA.position)) < 0) {
                collision.normal = {
                  x: minOverlap.axis.x,
                  y: minOverlap.axis.y
                };
              } else {
                collision.normal = {
                  x: -minOverlap.axis.x,
                  y: -minOverlap.axis.y
                };
              }
              collision.tangent = Vector.perp(collision.normal);
              collision.penetration = collision.penetration || ({});
              collision.penetration.x = collision.normal.x * collision.depth;
              collision.penetration.y = collision.normal.y * collision.depth;
              var verticesB = SAT._findSupports(bodyA, bodyB, collision.normal), supports = [];
              if (Vertices.contains(bodyA.vertices, verticesB[0])) supports.push(verticesB[0]);
              if (Vertices.contains(bodyA.vertices, verticesB[1])) supports.push(verticesB[1]);
              if (supports.length < 2) {
                var verticesA = SAT._findSupports(bodyB, bodyA, Vector.neg(collision.normal));
                if (Vertices.contains(bodyB.vertices, verticesA[0])) supports.push(verticesA[0]);
                if (supports.length < 2 && Vertices.contains(bodyB.vertices, verticesA[1])) supports.push(verticesA[1]);
              }
              if (supports.length < 1) supports = [verticesB[0]];
              collision.supports = supports;
              return collision;
            };
            SAT._overlapAxes = function (verticesA, verticesB, axes) {
              var projectionA = Vector._temp[0], projectionB = Vector._temp[1], result = {
                overlap: Number.MAX_VALUE
              }, overlap, axis;
              for (var i = 0; i < axes.length; i++) {
                axis = axes[i];
                SAT._projectToAxis(projectionA, verticesA, axis);
                SAT._projectToAxis(projectionB, verticesB, axis);
                overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);
                if (overlap <= 0) {
                  result.overlap = overlap;
                  return result;
                }
                if (overlap < result.overlap) {
                  result.overlap = overlap;
                  result.axis = axis;
                  result.axisNumber = i;
                }
              }
              return result;
            };
            SAT._projectToAxis = function (projection, vertices, axis) {
              var min = Vector.dot(vertices[0], axis), max = min;
              for (var i = 1; i < vertices.length; i += 1) {
                var dot = Vector.dot(vertices[i], axis);
                if (dot > max) {
                  max = dot;
                } else if (dot < min) {
                  min = dot;
                }
              }
              projection.min = min;
              projection.max = max;
            };
            SAT._findSupports = function (bodyA, bodyB, normal) {
              var nearestDistance = Number.MAX_VALUE, vertexToBody = Vector._temp[0], vertices = bodyB.vertices, bodyAPosition = bodyA.position, distance, vertex, vertexA, vertexB;
              for (var i = 0; i < vertices.length; i++) {
                vertex = vertices[i];
                vertexToBody.x = vertex.x - bodyAPosition.x;
                vertexToBody.y = vertex.y - bodyAPosition.y;
                distance = -Vector.dot(normal, vertexToBody);
                if (distance < nearestDistance) {
                  nearestDistance = distance;
                  vertexA = vertex;
                }
              }
              var prevIndex = vertexA.index - 1 >= 0 ? vertexA.index - 1 : vertices.length - 1;
              vertex = vertices[prevIndex];
              vertexToBody.x = vertex.x - bodyAPosition.x;
              vertexToBody.y = vertex.y - bodyAPosition.y;
              nearestDistance = -Vector.dot(normal, vertexToBody);
              vertexB = vertex;
              var nextIndex = (vertexA.index + 1) % vertices.length;
              vertex = vertices[nextIndex];
              vertexToBody.x = vertex.x - bodyAPosition.x;
              vertexToBody.y = vertex.y - bodyAPosition.y;
              distance = -Vector.dot(normal, vertexToBody);
              if (distance < nearestDistance) {
                vertexB = vertex;
              }
              return [vertexA, vertexB];
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            AlignTo: __webpack_require__(601),
            Angle: __webpack_require__(602),
            Call: __webpack_require__(603),
            GetFirst: __webpack_require__(604),
            GetLast: __webpack_require__(605),
            GridAlign: __webpack_require__(606),
            IncAlpha: __webpack_require__(678),
            IncX: __webpack_require__(679),
            IncXY: __webpack_require__(680),
            IncY: __webpack_require__(681),
            PlaceOnCircle: __webpack_require__(682),
            PlaceOnEllipse: __webpack_require__(683),
            PlaceOnLine: __webpack_require__(684),
            PlaceOnRectangle: __webpack_require__(685),
            PlaceOnTriangle: __webpack_require__(686),
            PlayAnimation: __webpack_require__(687),
            PropertyValueInc: __webpack_require__(46),
            PropertyValueSet: __webpack_require__(27),
            RandomCircle: __webpack_require__(688),
            RandomEllipse: __webpack_require__(689),
            RandomLine: __webpack_require__(690),
            RandomRectangle: __webpack_require__(691),
            RandomTriangle: __webpack_require__(692),
            Rotate: __webpack_require__(693),
            RotateAround: __webpack_require__(694),
            RotateAroundDistance: __webpack_require__(695),
            ScaleX: __webpack_require__(696),
            ScaleXY: __webpack_require__(697),
            ScaleY: __webpack_require__(698),
            SetAlpha: __webpack_require__(699),
            SetBlendMode: __webpack_require__(700),
            SetDepth: __webpack_require__(701),
            SetHitArea: __webpack_require__(702),
            SetOrigin: __webpack_require__(703),
            SetRotation: __webpack_require__(704),
            SetScale: __webpack_require__(705),
            SetScaleX: __webpack_require__(706),
            SetScaleY: __webpack_require__(707),
            SetScrollFactor: __webpack_require__(708),
            SetScrollFactorX: __webpack_require__(709),
            SetScrollFactorY: __webpack_require__(710),
            SetTint: __webpack_require__(711),
            SetVisible: __webpack_require__(712),
            SetX: __webpack_require__(713),
            SetXY: __webpack_require__(714),
            SetY: __webpack_require__(715),
            ShiftPosition: __webpack_require__(716),
            Shuffle: __webpack_require__(717),
            SmootherStep: __webpack_require__(718),
            SmoothStep: __webpack_require__(719),
            Spread: __webpack_require__(720),
            ToggleVisible: __webpack_require__(721),
            WrapInRectangle: __webpack_require__(722)
          };
        }, function (module2, exports2, __webpack_require__) {
          var ALIGN_CONST = __webpack_require__(123);
          var AlignToMap = [];
          AlignToMap[ALIGN_CONST.BOTTOM_CENTER] = __webpack_require__(277);
          AlignToMap[ALIGN_CONST.BOTTOM_LEFT] = __webpack_require__(278);
          AlignToMap[ALIGN_CONST.BOTTOM_RIGHT] = __webpack_require__(279);
          AlignToMap[ALIGN_CONST.LEFT_BOTTOM] = __webpack_require__(280);
          AlignToMap[ALIGN_CONST.LEFT_CENTER] = __webpack_require__(281);
          AlignToMap[ALIGN_CONST.LEFT_TOP] = __webpack_require__(282);
          AlignToMap[ALIGN_CONST.RIGHT_BOTTOM] = __webpack_require__(283);
          AlignToMap[ALIGN_CONST.RIGHT_CENTER] = __webpack_require__(284);
          AlignToMap[ALIGN_CONST.RIGHT_TOP] = __webpack_require__(285);
          AlignToMap[ALIGN_CONST.TOP_CENTER] = __webpack_require__(286);
          AlignToMap[ALIGN_CONST.TOP_LEFT] = __webpack_require__(287);
          AlignToMap[ALIGN_CONST.TOP_RIGHT] = __webpack_require__(288);
          var QuickSet = function (child, alignTo, position, offsetX, offsetY) {
            return AlignToMap[position](child, alignTo, offsetX, offsetY);
          };
          module2.exports = QuickSet;
        }, function (module2, exports2, __webpack_require__) {
          var GetBottom = __webpack_require__(42);
          var GetCenterX = __webpack_require__(87);
          var SetCenterX = __webpack_require__(88);
          var SetTop = __webpack_require__(52);
          var BottomCenter = function (gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetCenterX(gameObject, GetCenterX(alignTo) + offsetX);
            SetTop(gameObject, GetBottom(alignTo) + offsetY);
            return gameObject;
          };
          module2.exports = BottomCenter;
        }, function (module2, exports2, __webpack_require__) {
          var GetBottom = __webpack_require__(42);
          var GetLeft = __webpack_require__(43);
          var SetLeft = __webpack_require__(53);
          var SetTop = __webpack_require__(52);
          var BottomLeft = function (gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetLeft(gameObject, GetLeft(alignTo) - offsetX);
            SetTop(gameObject, GetBottom(alignTo) + offsetY);
            return gameObject;
          };
          module2.exports = BottomLeft;
        }, function (module2, exports2, __webpack_require__) {
          var GetBottom = __webpack_require__(42);
          var GetRight = __webpack_require__(44);
          var SetRight = __webpack_require__(54);
          var SetTop = __webpack_require__(52);
          var BottomRight = function (gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetRight(gameObject, GetRight(alignTo) + offsetX);
            SetTop(gameObject, GetBottom(alignTo) + offsetY);
            return gameObject;
          };
          module2.exports = BottomRight;
        }, function (module2, exports2, __webpack_require__) {
          var GetBottom = __webpack_require__(42);
          var GetLeft = __webpack_require__(43);
          var SetBottom = __webpack_require__(55);
          var SetRight = __webpack_require__(54);
          var LeftBottom = function (gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetRight(gameObject, GetLeft(alignTo) - offsetX);
            SetBottom(gameObject, GetBottom(alignTo) + offsetY);
            return gameObject;
          };
          module2.exports = LeftBottom;
        }, function (module2, exports2, __webpack_require__) {
          var GetCenterY = __webpack_require__(89);
          var GetLeft = __webpack_require__(43);
          var SetCenterY = __webpack_require__(90);
          var SetRight = __webpack_require__(54);
          var LeftCenter = function (gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetRight(gameObject, GetLeft(alignTo) - offsetX);
            SetCenterY(gameObject, GetCenterY(alignTo) + offsetY);
            return gameObject;
          };
          module2.exports = LeftCenter;
        }, function (module2, exports2, __webpack_require__) {
          var GetLeft = __webpack_require__(43);
          var GetTop = __webpack_require__(45);
          var SetRight = __webpack_require__(54);
          var SetTop = __webpack_require__(52);
          var LeftTop = function (gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetRight(gameObject, GetLeft(alignTo) - offsetX);
            SetTop(gameObject, GetTop(alignTo) - offsetY);
            return gameObject;
          };
          module2.exports = LeftTop;
        }, function (module2, exports2, __webpack_require__) {
          var GetBottom = __webpack_require__(42);
          var GetRight = __webpack_require__(44);
          var SetBottom = __webpack_require__(55);
          var SetLeft = __webpack_require__(53);
          var RightBottom = function (gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetLeft(gameObject, GetRight(alignTo) + offsetX);
            SetBottom(gameObject, GetBottom(alignTo) + offsetY);
            return gameObject;
          };
          module2.exports = RightBottom;
        }, function (module2, exports2, __webpack_require__) {
          var GetCenterY = __webpack_require__(89);
          var GetRight = __webpack_require__(44);
          var SetCenterY = __webpack_require__(90);
          var SetLeft = __webpack_require__(53);
          var RightCenter = function (gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetLeft(gameObject, GetRight(alignTo) + offsetX);
            SetCenterY(gameObject, GetCenterY(alignTo) + offsetY);
            return gameObject;
          };
          module2.exports = RightCenter;
        }, function (module2, exports2, __webpack_require__) {
          var GetRight = __webpack_require__(44);
          var GetTop = __webpack_require__(45);
          var SetLeft = __webpack_require__(53);
          var SetTop = __webpack_require__(52);
          var RightTop = function (gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetLeft(gameObject, GetRight(alignTo) + offsetX);
            SetTop(gameObject, GetTop(alignTo) - offsetY);
            return gameObject;
          };
          module2.exports = RightTop;
        }, function (module2, exports2, __webpack_require__) {
          var GetCenterX = __webpack_require__(87);
          var GetTop = __webpack_require__(45);
          var SetBottom = __webpack_require__(55);
          var SetCenterX = __webpack_require__(88);
          var TopCenter = function (gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetCenterX(gameObject, GetCenterX(alignTo) + offsetX);
            SetBottom(gameObject, GetTop(alignTo) - offsetY);
            return gameObject;
          };
          module2.exports = TopCenter;
        }, function (module2, exports2, __webpack_require__) {
          var GetLeft = __webpack_require__(43);
          var GetTop = __webpack_require__(45);
          var SetBottom = __webpack_require__(55);
          var SetLeft = __webpack_require__(53);
          var TopLeft = function (gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetLeft(gameObject, GetLeft(alignTo) - offsetX);
            SetBottom(gameObject, GetTop(alignTo) - offsetY);
            return gameObject;
          };
          module2.exports = TopLeft;
        }, function (module2, exports2, __webpack_require__) {
          var GetRight = __webpack_require__(44);
          var GetTop = __webpack_require__(45);
          var SetBottom = __webpack_require__(55);
          var SetRight = __webpack_require__(54);
          var TopRight = function (gameObject, alignTo, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetRight(gameObject, GetRight(alignTo) + offsetX);
            SetBottom(gameObject, GetTop(alignTo) - offsetY);
            return gameObject;
          };
          module2.exports = TopRight;
        }, function (module2, exports2, __webpack_require__) {
          var ALIGN_CONST = __webpack_require__(123);
          var AlignInMap = [];
          AlignInMap[ALIGN_CONST.BOTTOM_CENTER] = __webpack_require__(290);
          AlignInMap[ALIGN_CONST.BOTTOM_LEFT] = __webpack_require__(291);
          AlignInMap[ALIGN_CONST.BOTTOM_RIGHT] = __webpack_require__(292);
          AlignInMap[ALIGN_CONST.CENTER] = __webpack_require__(293);
          AlignInMap[ALIGN_CONST.LEFT_CENTER] = __webpack_require__(295);
          AlignInMap[ALIGN_CONST.RIGHT_CENTER] = __webpack_require__(296);
          AlignInMap[ALIGN_CONST.TOP_CENTER] = __webpack_require__(297);
          AlignInMap[ALIGN_CONST.TOP_LEFT] = __webpack_require__(298);
          AlignInMap[ALIGN_CONST.TOP_RIGHT] = __webpack_require__(299);
          AlignInMap[ALIGN_CONST.LEFT_BOTTOM] = AlignInMap[ALIGN_CONST.BOTTOM_LEFT];
          AlignInMap[ALIGN_CONST.LEFT_TOP] = AlignInMap[ALIGN_CONST.TOP_LEFT];
          AlignInMap[ALIGN_CONST.RIGHT_BOTTOM] = AlignInMap[ALIGN_CONST.BOTTOM_RIGHT];
          AlignInMap[ALIGN_CONST.RIGHT_TOP] = AlignInMap[ALIGN_CONST.TOP_RIGHT];
          var QuickSet = function (child, alignIn, position, offsetX, offsetY) {
            return AlignInMap[position](child, alignIn, offsetX, offsetY);
          };
          module2.exports = QuickSet;
        }, function (module2, exports2, __webpack_require__) {
          var GetBottom = __webpack_require__(42);
          var GetCenterX = __webpack_require__(87);
          var SetBottom = __webpack_require__(55);
          var SetCenterX = __webpack_require__(88);
          var BottomCenter = function (gameObject, alignIn, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
            SetBottom(gameObject, GetBottom(alignIn) + offsetY);
            return gameObject;
          };
          module2.exports = BottomCenter;
        }, function (module2, exports2, __webpack_require__) {
          var GetBottom = __webpack_require__(42);
          var GetLeft = __webpack_require__(43);
          var SetBottom = __webpack_require__(55);
          var SetLeft = __webpack_require__(53);
          var BottomLeft = function (gameObject, alignIn, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetLeft(gameObject, GetLeft(alignIn) - offsetX);
            SetBottom(gameObject, GetBottom(alignIn) + offsetY);
            return gameObject;
          };
          module2.exports = BottomLeft;
        }, function (module2, exports2, __webpack_require__) {
          var GetBottom = __webpack_require__(42);
          var GetRight = __webpack_require__(44);
          var SetBottom = __webpack_require__(55);
          var SetRight = __webpack_require__(54);
          var BottomRight = function (gameObject, alignIn, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetRight(gameObject, GetRight(alignIn) + offsetX);
            SetBottom(gameObject, GetBottom(alignIn) + offsetY);
            return gameObject;
          };
          module2.exports = BottomRight;
        }, function (module2, exports2, __webpack_require__) {
          var CenterOn = __webpack_require__(294);
          var GetCenterX = __webpack_require__(87);
          var GetCenterY = __webpack_require__(89);
          var Center = function (gameObject, alignIn, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            CenterOn(gameObject, GetCenterX(alignIn) + offsetX, GetCenterY(alignIn) + offsetY);
            return gameObject;
          };
          module2.exports = Center;
        }, function (module2, exports2, __webpack_require__) {
          var SetCenterX = __webpack_require__(88);
          var SetCenterY = __webpack_require__(90);
          var CenterOn = function (gameObject, x, y) {
            SetCenterX(gameObject, x);
            return SetCenterY(gameObject, y);
          };
          module2.exports = CenterOn;
        }, function (module2, exports2, __webpack_require__) {
          var GetCenterY = __webpack_require__(89);
          var GetLeft = __webpack_require__(43);
          var SetCenterY = __webpack_require__(90);
          var SetLeft = __webpack_require__(53);
          var LeftCenter = function (gameObject, alignIn, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetLeft(gameObject, GetLeft(alignIn) - offsetX);
            SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);
            return gameObject;
          };
          module2.exports = LeftCenter;
        }, function (module2, exports2, __webpack_require__) {
          var GetCenterY = __webpack_require__(89);
          var GetRight = __webpack_require__(44);
          var SetCenterY = __webpack_require__(90);
          var SetRight = __webpack_require__(54);
          var RightCenter = function (gameObject, alignIn, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetRight(gameObject, GetRight(alignIn) + offsetX);
            SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);
            return gameObject;
          };
          module2.exports = RightCenter;
        }, function (module2, exports2, __webpack_require__) {
          var GetCenterX = __webpack_require__(87);
          var GetTop = __webpack_require__(45);
          var SetCenterX = __webpack_require__(88);
          var SetTop = __webpack_require__(52);
          var TopCenter = function (gameObject, alignIn, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
            SetTop(gameObject, GetTop(alignIn) - offsetY);
            return gameObject;
          };
          module2.exports = TopCenter;
        }, function (module2, exports2, __webpack_require__) {
          var GetLeft = __webpack_require__(43);
          var GetTop = __webpack_require__(45);
          var SetLeft = __webpack_require__(53);
          var SetTop = __webpack_require__(52);
          var TopLeft = function (gameObject, alignIn, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetLeft(gameObject, GetLeft(alignIn) - offsetX);
            SetTop(gameObject, GetTop(alignIn) - offsetY);
            return gameObject;
          };
          module2.exports = TopLeft;
        }, function (module2, exports2, __webpack_require__) {
          var GetRight = __webpack_require__(44);
          var GetTop = __webpack_require__(45);
          var SetRight = __webpack_require__(54);
          var SetTop = __webpack_require__(52);
          var TopRight = function (gameObject, alignIn, offsetX, offsetY) {
            if (offsetX === void 0) {
              offsetX = 0;
            }
            if (offsetY === void 0) {
              offsetY = 0;
            }
            SetRight(gameObject, GetRight(alignIn) + offsetX);
            SetTop(gameObject, GetTop(alignIn) - offsetY);
            return gameObject;
          };
          module2.exports = TopRight;
        }, function (module2, exports2, __webpack_require__) {
          var CircumferencePoint = __webpack_require__(169);
          var FromPercent = __webpack_require__(98);
          var MATH_CONST = __webpack_require__(14);
          var Point = __webpack_require__(4);
          var GetPoint = function (circle, position, out) {
            if (out === void 0) {
              out = new Point();
            }
            var angle = FromPercent(position, 0, MATH_CONST.PI2);
            return CircumferencePoint(circle, angle, out);
          };
          module2.exports = GetPoint;
        }, function (module2, exports2, __webpack_require__) {
          var Circumference = __webpack_require__(302);
          var CircumferencePoint = __webpack_require__(169);
          var FromPercent = __webpack_require__(98);
          var MATH_CONST = __webpack_require__(14);
          var GetPoints = function (circle, quantity, stepRate, out) {
            if (out === void 0) {
              out = [];
            }
            if (!quantity && stepRate > 0) {
              quantity = Circumference(circle) / stepRate;
            }
            for (var i = 0; i < quantity; i++) {
              var angle = FromPercent(i / quantity, 0, MATH_CONST.PI2);
              out.push(CircumferencePoint(circle, angle));
            }
            return out;
          };
          module2.exports = GetPoints;
        }, function (module2, exports2) {
          var Circumference = function (circle) {
            return 2 * (Math.PI * circle.radius);
          };
          module2.exports = Circumference;
        }, function (module2, exports2, __webpack_require__) {
          var Clamp = __webpack_require__(18);
          var _FLAG = 2;
          var AlphaSingle = {
            _alpha: 1,
            clearAlpha: function () {
              return this.setAlpha(1);
            },
            setAlpha: function (value) {
              if (value === void 0) {
                value = 1;
              }
              this.alpha = value;
              return this;
            },
            alpha: {
              get: function () {
                return this._alpha;
              },
              set: function (value) {
                var v = Clamp(value, 0, 1);
                this._alpha = v;
                if (v === 0) {
                  this.renderFlags &= ~_FLAG;
                } else {
                  this.renderFlags |= _FLAG;
                }
              }
            }
          };
          module2.exports = AlphaSingle;
        }, function (module2, exports2, __webpack_require__) {
          var BlendModes = __webpack_require__(35);
          var BlendMode = {
            _blendMode: BlendModes.NORMAL,
            blendMode: {
              get: function () {
                return this._blendMode;
              },
              set: function (value) {
                if (typeof value === "string") {
                  value = BlendModes[value];
                }
                value |= 0;
                if (value >= -1) {
                  this._blendMode = value;
                }
              }
            },
            setBlendMode: function (value) {
              this.blendMode = value;
              return this;
            }
          };
          module2.exports = BlendMode;
        }, function (module2, exports2) {
          var Depth = {
            _depth: 0,
            depth: {
              get: function () {
                return this._depth;
              },
              set: function (value) {
                if (this.displayList) {
                  this.displayList.queueDepthSort();
                }
                this._depth = value;
              }
            },
            setDepth: function (value) {
              if (value === void 0) {
                value = 0;
              }
              this.depth = value;
              return this;
            }
          };
          module2.exports = Depth;
        }, function (module2, exports2, __webpack_require__) {
          var GetPoint = __webpack_require__(171);
          var Perimeter = __webpack_require__(130);
          var GetPoints = function (rectangle, quantity, stepRate, out) {
            if (out === void 0) {
              out = [];
            }
            if (!quantity && stepRate > 0) {
              quantity = Perimeter(rectangle) / stepRate;
            }
            for (var i = 0; i < quantity; i++) {
              var position = i / quantity;
              out.push(GetPoint(rectangle, position));
            }
            return out;
          };
          module2.exports = GetPoints;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var GetPoint = function (line, position, out) {
            if (out === void 0) {
              out = new Point();
            }
            out.x = line.x1 + (line.x2 - line.x1) * position;
            out.y = line.y1 + (line.y2 - line.y1) * position;
            return out;
          };
          module2.exports = GetPoint;
        }, function (module2, exports2) {
          var RotateAround = function (point, x, y, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var tx = point.x - x;
            var ty = point.y - y;
            point.x = tx * c - ty * s + x;
            point.y = tx * s + ty * c + y;
            return point;
          };
          module2.exports = RotateAround;
        }, function (module2, exports2, __webpack_require__) {
          var BitmapMask = __webpack_require__(310);
          var GeometryMask = __webpack_require__(311);
          var Mask = {
            mask: null,
            setMask: function (mask) {
              this.mask = mask;
              return this;
            },
            clearMask: function (destroyMask) {
              if (destroyMask === void 0) {
                destroyMask = false;
              }
              if (destroyMask && this.mask) {
                this.mask.destroy();
              }
              this.mask = null;
              return this;
            },
            createBitmapMask: function (renderable) {
              if (renderable === void 0 && (this.texture || this.shader)) {
                renderable = this;
              }
              return new BitmapMask(this.scene, renderable);
            },
            createGeometryMask: function (graphics) {
              if (graphics === void 0 && this.type === "Graphics") {
                graphics = this;
              }
              return new GeometryMask(this.scene, graphics);
            }
          };
          module2.exports = Mask;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GameEvents = __webpack_require__(22);
          var RenderEvents = __webpack_require__(91);
          var BitmapMask = new Class({
            initialize: function BitmapMask2(scene, renderable) {
              var renderer = scene.sys.renderer;
              this.renderer = renderer;
              this.bitmapMask = renderable;
              this.maskTexture = null;
              this.mainTexture = null;
              this.dirty = true;
              this.mainFramebuffer = null;
              this.maskFramebuffer = null;
              this.invertAlpha = false;
              this.isStencil = false;
              this.createMask();
              scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, this.createMask, this);
              if (renderer) {
                renderer.on(RenderEvents.RESIZE, this.createMask, this);
              }
            },
            createMask: function () {
              var renderer = this.renderer;
              if (!renderer || !renderer.gl) {
                return;
              }
              if (this.mainTexture) {
                this.clearMask();
              }
              var width = renderer.width;
              var height = renderer.height;
              var pot = (width & width - 1) === 0 && (height & height - 1) === 0;
              var gl = renderer.gl;
              var wrap = pot ? gl.REPEAT : gl.CLAMP_TO_EDGE;
              var filter = gl.LINEAR;
              this.mainTexture = renderer.createTexture2D(0, filter, filter, wrap, wrap, gl.RGBA, null, width, height);
              this.maskTexture = renderer.createTexture2D(0, filter, filter, wrap, wrap, gl.RGBA, null, width, height);
              this.mainFramebuffer = renderer.createFramebuffer(width, height, this.mainTexture, true);
              this.maskFramebuffer = renderer.createFramebuffer(width, height, this.maskTexture, true);
            },
            clearMask: function () {
              var renderer = this.renderer;
              if (!renderer || !renderer.gl || !this.mainTexture) {
                return;
              }
              renderer.deleteTexture(this.mainTexture);
              renderer.deleteTexture(this.maskTexture);
              renderer.deleteFramebuffer(this.mainFramebuffer);
              renderer.deleteFramebuffer(this.maskFramebuffer);
              this.mainTexture = null;
              this.maskTexture = null;
              this.mainFramebuffer = null;
              this.maskFramebuffer = null;
            },
            setBitmap: function (renderable) {
              this.bitmapMask = renderable;
            },
            preRenderWebGL: function (renderer, maskedObject, camera) {
              renderer.pipelines.BITMAPMASK_PIPELINE.beginMask(this, maskedObject, camera);
            },
            postRenderWebGL: function (renderer, camera) {
              renderer.pipelines.BITMAPMASK_PIPELINE.endMask(this, camera);
            },
            preRenderCanvas: function () {},
            postRenderCanvas: function () {},
            destroy: function () {
              this.clearMask();
              if (this.renderer) {
                this.renderer.off(RenderEvents.RESIZE, this.createMask, this);
              }
              this.bitmapMask = null;
              this.prevFramebuffer = null;
              this.renderer = null;
            }
          });
          module2.exports = BitmapMask;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GeometryMask = new Class({
            initialize: function GeometryMask2(scene, graphicsGeometry) {
              this.geometryMask = graphicsGeometry;
              this.invertAlpha = false;
              this.isStencil = true;
              this.level = 0;
            },
            setShape: function (graphicsGeometry) {
              this.geometryMask = graphicsGeometry;
              return this;
            },
            setInvertAlpha: function (value) {
              if (value === void 0) {
                value = true;
              }
              this.invertAlpha = value;
              return this;
            },
            preRenderWebGL: function (renderer, child, camera) {
              var gl = renderer.gl;
              renderer.flush();
              if (renderer.maskStack.length === 0) {
                gl.enable(gl.STENCIL_TEST);
                gl.clear(gl.STENCIL_BUFFER_BIT);
                renderer.maskCount = 0;
              }
              if (renderer.currentCameraMask.mask !== this) {
                renderer.currentMask.mask = this;
              }
              renderer.maskStack.push({
                mask: this,
                camera
              });
              this.applyStencil(renderer, camera, true);
              renderer.maskCount++;
            },
            applyStencil: function (renderer, camera, inc) {
              var gl = renderer.gl;
              var geometryMask = this.geometryMask;
              var level = renderer.maskCount;
              gl.colorMask(false, false, false, false);
              if (inc) {
                gl.stencilFunc(gl.EQUAL, level, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
              } else {
                gl.stencilFunc(gl.EQUAL, level + 1, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
              }
              geometryMask.renderWebGL(renderer, geometryMask, camera);
              renderer.flush();
              gl.colorMask(true, true, true, true);
              gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
              if (inc) {
                if (this.invertAlpha) {
                  gl.stencilFunc(gl.NOTEQUAL, level + 1, 255);
                } else {
                  gl.stencilFunc(gl.EQUAL, level + 1, 255);
                }
              } else if (this.invertAlpha) {
                gl.stencilFunc(gl.NOTEQUAL, level, 255);
              } else {
                gl.stencilFunc(gl.EQUAL, level, 255);
              }
            },
            postRenderWebGL: function (renderer) {
              var gl = renderer.gl;
              renderer.maskStack.pop();
              renderer.maskCount--;
              renderer.flush();
              var current = renderer.currentMask;
              if (renderer.maskStack.length === 0) {
                current.mask = null;
                gl.disable(gl.STENCIL_TEST);
              } else {
                var prev = renderer.maskStack[renderer.maskStack.length - 1];
                prev.mask.applyStencil(renderer, prev.camera, false);
                if (renderer.currentCameraMask.mask !== prev.mask) {
                  current.mask = prev.mask;
                  current.camera = prev.camera;
                } else {
                  current.mask = null;
                }
              }
            },
            preRenderCanvas: function (renderer, mask, camera) {
              var geometryMask = this.geometryMask;
              renderer.currentContext.save();
              geometryMask.renderCanvas(renderer, geometryMask, camera, null, null, true);
              renderer.currentContext.clip();
            },
            postRenderCanvas: function (renderer) {
              renderer.currentContext.restore();
            },
            destroy: function () {
              this.geometryMask = null;
            }
          });
          module2.exports = GeometryMask;
        }, function (module2, exports2) {
          var ScrollFactor = {
            scrollFactorX: 1,
            scrollFactorY: 1,
            setScrollFactor: function (x, y) {
              if (y === void 0) {
                y = x;
              }
              this.scrollFactorX = x;
              this.scrollFactorY = y;
              return this;
            }
          };
          module2.exports = ScrollFactor;
        }, function (module2, exports2, __webpack_require__) {
          var MATH_CONST = __webpack_require__(14);
          var TransformMatrix = __webpack_require__(25);
          var TransformXY = __webpack_require__(177);
          var WrapAngle = __webpack_require__(269);
          var WrapAngleDegrees = __webpack_require__(270);
          var Vector2 = __webpack_require__(3);
          var _FLAG = 4;
          var Transform = {
            _scaleX: 1,
            _scaleY: 1,
            _rotation: 0,
            x: 0,
            y: 0,
            z: 0,
            w: 0,
            scale: {
              get: function () {
                return (this._scaleX + this._scaleY) / 2;
              },
              set: function (value) {
                this._scaleX = value;
                this._scaleY = value;
                if (value === 0) {
                  this.renderFlags &= ~_FLAG;
                } else {
                  this.renderFlags |= _FLAG;
                }
              }
            },
            scaleX: {
              get: function () {
                return this._scaleX;
              },
              set: function (value) {
                this._scaleX = value;
                if (value === 0) {
                  this.renderFlags &= ~_FLAG;
                } else {
                  this.renderFlags |= _FLAG;
                }
              }
            },
            scaleY: {
              get: function () {
                return this._scaleY;
              },
              set: function (value) {
                this._scaleY = value;
                if (value === 0) {
                  this.renderFlags &= ~_FLAG;
                } else {
                  this.renderFlags |= _FLAG;
                }
              }
            },
            angle: {
              get: function () {
                return WrapAngleDegrees(this._rotation * MATH_CONST.RAD_TO_DEG);
              },
              set: function (value) {
                this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;
              }
            },
            rotation: {
              get: function () {
                return this._rotation;
              },
              set: function (value) {
                this._rotation = WrapAngle(value);
              }
            },
            setPosition: function (x, y, z, w) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = x;
              }
              if (z === void 0) {
                z = 0;
              }
              if (w === void 0) {
                w = 0;
              }
              this.x = x;
              this.y = y;
              this.z = z;
              this.w = w;
              return this;
            },
            copyPosition: function (source) {
              if (source.x !== void 0) {
                this.x = source.x;
              }
              if (source.y !== void 0) {
                this.y = source.y;
              }
              if (source.z !== void 0) {
                this.z = source.z;
              }
              if (source.w !== void 0) {
                this.w = source.w;
              }
              return this;
            },
            setRandomPosition: function (x, y, width, height) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = this.scene.sys.scale.width;
              }
              if (height === void 0) {
                height = this.scene.sys.scale.height;
              }
              this.x = x + Math.random() * width;
              this.y = y + Math.random() * height;
              return this;
            },
            setRotation: function (radians) {
              if (radians === void 0) {
                radians = 0;
              }
              this.rotation = radians;
              return this;
            },
            setAngle: function (degrees) {
              if (degrees === void 0) {
                degrees = 0;
              }
              this.angle = degrees;
              return this;
            },
            setScale: function (x, y) {
              if (x === void 0) {
                x = 1;
              }
              if (y === void 0) {
                y = x;
              }
              this.scaleX = x;
              this.scaleY = y;
              return this;
            },
            setX: function (value) {
              if (value === void 0) {
                value = 0;
              }
              this.x = value;
              return this;
            },
            setY: function (value) {
              if (value === void 0) {
                value = 0;
              }
              this.y = value;
              return this;
            },
            setZ: function (value) {
              if (value === void 0) {
                value = 0;
              }
              this.z = value;
              return this;
            },
            setW: function (value) {
              if (value === void 0) {
                value = 0;
              }
              this.w = value;
              return this;
            },
            getLocalTransformMatrix: function (tempMatrix) {
              if (tempMatrix === void 0) {
                tempMatrix = new TransformMatrix();
              }
              return tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);
            },
            getWorldTransformMatrix: function (tempMatrix, parentMatrix) {
              if (tempMatrix === void 0) {
                tempMatrix = new TransformMatrix();
              }
              if (parentMatrix === void 0) {
                parentMatrix = new TransformMatrix();
              }
              var parent = this.parentContainer;
              if (!parent) {
                return this.getLocalTransformMatrix(tempMatrix);
              }
              tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);
              while (parent) {
                parentMatrix.applyITRS(parent.x, parent.y, parent._rotation, parent._scaleX, parent._scaleY);
                parentMatrix.multiply(tempMatrix, tempMatrix);
                parent = parent.parentContainer;
              }
              return tempMatrix;
            },
            getLocalPoint: function (x, y, point, camera) {
              if (!point) {
                point = new Vector2();
              }
              if (!camera) {
                camera = this.scene.sys.cameras.main;
              }
              var csx = camera.scrollX;
              var csy = camera.scrollY;
              var px = x + csx * this.scrollFactorX - csx;
              var py = y + csy * this.scrollFactorY - csy;
              if (this.parentContainer) {
                this.getWorldTransformMatrix().applyInverse(px, py, point);
              } else {
                TransformXY(px, py, this.x, this.y, this.rotation, this.scaleX, this.scaleY, point);
              }
              if (this._originComponent) {
                point.x += this._displayOriginX;
                point.y += this._displayOriginY;
              }
              return point;
            },
            getParentRotation: function () {
              var rotation = 0;
              var parent = this.parentContainer;
              while (parent) {
                rotation += parent.rotation;
                parent = parent.parentContainer;
              }
              return rotation;
            }
          };
          module2.exports = Transform;
        }, function (module2, exports2) {
          var _FLAG = 1;
          var Visible = {
            _visible: true,
            visible: {
              get: function () {
                return this._visible;
              },
              set: function (value) {
                if (value) {
                  this._visible = true;
                  this.renderFlags |= _FLAG;
                } else {
                  this._visible = false;
                  this.renderFlags &= ~_FLAG;
                }
              }
            },
            setVisible: function (value) {
              this.visible = value;
              return this;
            }
          };
          module2.exports = Visible;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            CHANGE_DATA: __webpack_require__(638),
            CHANGE_DATA_KEY: __webpack_require__(639),
            DESTROY: __webpack_require__(640),
            REMOVE_DATA: __webpack_require__(641),
            SET_DATA: __webpack_require__(642)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Perimeter = __webpack_require__(130);
          var Point = __webpack_require__(4);
          var MarchingAnts = function (rect, step, quantity, out) {
            if (out === void 0) {
              out = [];
            }
            if (!step && !quantity) {
              return out;
            }
            if (!step) {
              step = Perimeter(rect) / quantity;
            } else {
              quantity = Math.round(Perimeter(rect) / step);
            }
            var x = rect.x;
            var y = rect.y;
            var face = 0;
            for (var i = 0; i < quantity; i++) {
              out.push(new Point(x, y));
              switch (face) {
                case 0:
                  x += step;
                  if (x >= rect.right) {
                    face = 1;
                    y += x - rect.right;
                    x = rect.right;
                  }
                  break;
                case 1:
                  y += step;
                  if (y >= rect.bottom) {
                    face = 2;
                    x -= y - rect.bottom;
                    y = rect.bottom;
                  }
                  break;
                case 2:
                  x -= step;
                  if (x <= rect.left) {
                    face = 3;
                    y -= rect.left - x;
                    x = rect.left;
                  }
                  break;
                case 3:
                  y -= step;
                  if (y <= rect.top) {
                    face = 0;
                    y = rect.top;
                  }
                  break;
              }
            }
            return out;
          };
          module2.exports = MarchingAnts;
        }, function (module2, exports2) {
          var BresenhamPoints = function (line, stepRate, results) {
            if (stepRate === void 0) {
              stepRate = 1;
            }
            if (results === void 0) {
              results = [];
            }
            var x1 = Math.round(line.x1);
            var y1 = Math.round(line.y1);
            var x2 = Math.round(line.x2);
            var y2 = Math.round(line.y2);
            var dx = Math.abs(x2 - x1);
            var dy = Math.abs(y2 - y1);
            var sx = x1 < x2 ? 1 : -1;
            var sy = y1 < y2 ? 1 : -1;
            var err = dx - dy;
            results.push({
              x: x1,
              y: y1
            });
            var i = 1;
            while (!(x1 === x2 && y1 === y2)) {
              var e2 = err << 1;
              if (e2 > -dy) {
                err -= dy;
                x1 += sx;
              }
              if (e2 < dx) {
                err += dx;
                y1 += sy;
              }
              if (i % stepRate === 0) {
                results.push({
                  x: x1,
                  y: y1
                });
              }
              i++;
            }
            return results;
          };
          module2.exports = BresenhamPoints;
        }, function (module2, exports2) {
          var FindClosestInSorted = function (value, array, key) {
            if (!array.length) {
              return NaN;
            } else if (array.length === 1) {
              return array[0];
            }
            var i = 1;
            var low;
            var high;
            if (key) {
              if (value < array[0][key]) {
                return array[0];
              }
              while (array[i][key] < value) {
                i++;
              }
            } else {
              while (array[i] < value) {
                i++;
              }
            }
            if (i > array.length) {
              i = array.length;
            }
            if (key) {
              low = array[i - 1][key];
              high = array[i][key];
              return high - value <= value - low ? array[i] : array[i - 1];
            } else {
              low = array[i - 1];
              high = array[i];
              return high - value <= value - low ? high : low;
            }
          };
          module2.exports = FindClosestInSorted;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var AnimationFrame = new Class({
            initialize: function AnimationFrame2(textureKey, textureFrame, index, frame, isKeyFrame) {
              if (isKeyFrame === void 0) {
                isKeyFrame = false;
              }
              this.textureKey = textureKey;
              this.textureFrame = textureFrame;
              this.index = index;
              this.frame = frame;
              this.isFirst = false;
              this.isLast = false;
              this.prevFrame = null;
              this.nextFrame = null;
              this.duration = 0;
              this.progress = 0;
              this.isKeyFrame = isKeyFrame;
            },
            toJSON: function () {
              return {
                key: this.textureKey,
                frame: this.textureFrame,
                duration: this.duration,
                keyframe: this.isKeyFrame
              };
            },
            destroy: function () {
              this.frame = void 0;
            }
          });
          module2.exports = AnimationFrame;
        }, function (module2, exports2) {
          var SortByDigits = function (array) {
            var re = /\D/g;
            array.sort(function (a, b) {
              return parseInt(a.replace(re, ""), 10) - parseInt(b.replace(re, ""), 10);
            });
            return array;
          };
          module2.exports = SortByDigits;
        }, function (module2, exports2, __webpack_require__) {
          var Animation = __webpack_require__(185);
          var Class = __webpack_require__(0);
          var CustomMap = __webpack_require__(102);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(132);
          var GameEvents = __webpack_require__(22);
          var GetFastValue = __webpack_require__(2);
          var GetValue = __webpack_require__(6);
          var Pad = __webpack_require__(186);
          var NumberArray = __webpack_require__(322);
          var AnimationManager = new Class({
            Extends: EventEmitter,
            initialize: function AnimationManager2(game) {
              EventEmitter.call(this);
              this.game = game;
              this.textureManager = null;
              this.globalTimeScale = 1;
              this.anims = new CustomMap();
              this.mixes = new CustomMap();
              this.paused = false;
              this.name = "AnimationManager";
              game.events.once(GameEvents.BOOT, this.boot, this);
            },
            boot: function () {
              this.textureManager = this.game.textures;
              this.game.events.once(GameEvents.DESTROY, this.destroy, this);
            },
            addMix: function (animA, animB, delay) {
              var anims = this.anims;
              var mixes = this.mixes;
              var keyA = typeof animA === "string" ? animA : animA.key;
              var keyB = typeof animB === "string" ? animB : animB.key;
              if (anims.has(keyA) && anims.has(keyB)) {
                var mixObj = mixes.get(keyA);
                if (!mixObj) {
                  mixObj = {};
                }
                mixObj[keyB] = delay;
                mixes.set(keyA, mixObj);
              }
              return this;
            },
            removeMix: function (animA, animB) {
              var mixes = this.mixes;
              var keyA = typeof animA === "string" ? animA : animA.key;
              var mixObj = mixes.get(keyA);
              if (mixObj) {
                if (animB) {
                  var keyB = typeof animB === "string" ? animB : animB.key;
                  if (mixObj.hasOwnProperty(keyB)) {
                    delete mixObj[keyB];
                  }
                } else if (!animB) {
                  mixes.delete(keyA);
                }
              }
              return this;
            },
            getMix: function (animA, animB) {
              var mixes = this.mixes;
              var keyA = typeof animA === "string" ? animA : animA.key;
              var keyB = typeof animB === "string" ? animB : animB.key;
              var mixObj = mixes.get(keyA);
              if (mixObj && mixObj.hasOwnProperty(keyB)) {
                return mixObj[keyB];
              } else {
                return 0;
              }
            },
            add: function (key, animation) {
              if (this.anims.has(key)) {
                console.warn("Animation key exists: " + key);
                return this;
              }
              animation.key = key;
              this.anims.set(key, animation);
              this.emit(Events.ADD_ANIMATION, key, animation);
              return this;
            },
            exists: function (key) {
              return this.anims.has(key);
            },
            createFromAseprite: function (key, tags) {
              var output = [];
              var data = this.game.cache.json.get(key);
              if (!data) {
                return output;
              }
              var _this = this;
              var meta = GetValue(data, "meta", null);
              var frames = GetValue(data, "frames", null);
              if (meta && frames) {
                var frameTags = GetValue(meta, "frameTags", []);
                frameTags.forEach(function (tag) {
                  var animFrames = [];
                  var name = GetFastValue(tag, "name", null);
                  var from = GetFastValue(tag, "from", 0);
                  var to = GetFastValue(tag, "to", 0);
                  var direction = GetFastValue(tag, "direction", "forward");
                  if (!name) {
                    return;
                  }
                  if (!tags || tags && tags.indexOf(name) > -1) {
                    var tempFrames = [];
                    var minDuration = Number.MAX_SAFE_INTEGER;
                    for (var i = from; i <= to; i++) {
                      var frameKey = i.toString();
                      var frame = frames[frameKey];
                      if (frame) {
                        var frameDuration = GetFastValue(frame, "duration", Number.MAX_SAFE_INTEGER);
                        if (frameDuration < minDuration) {
                          minDuration = frameDuration;
                        }
                        tempFrames.push({
                          frame: frameKey,
                          duration: frameDuration
                        });
                      }
                    }
                    tempFrames.forEach(function (entry) {
                      animFrames.push({
                        key,
                        frame: entry.frame,
                        duration: minDuration - entry.duration
                      });
                    });
                    var totalDuration = minDuration * animFrames.length;
                    if (direction === "reverse") {
                      animFrames = animFrames.reverse();
                    }
                    var createConfig = {
                      key: name,
                      frames: animFrames,
                      duration: totalDuration,
                      yoyo: direction === "pingpong"
                    };
                    var result = _this.create(createConfig);
                    if (result) {
                      output.push(result);
                    }
                  }
                });
              }
              return output;
            },
            create: function (config) {
              var key = config.key;
              var anim = false;
              if (key) {
                anim = this.get(key);
                if (!anim) {
                  anim = new Animation(this, key, config);
                  this.anims.set(key, anim);
                  this.emit(Events.ADD_ANIMATION, key, anim);
                }
              }
              return anim;
            },
            fromJSON: function (data, clearCurrentAnimations) {
              if (clearCurrentAnimations === void 0) {
                clearCurrentAnimations = false;
              }
              if (clearCurrentAnimations) {
                this.anims.clear();
              }
              if (typeof data === "string") {
                data = JSON.parse(data);
              }
              var output = [];
              if (data.hasOwnProperty("anims") && Array.isArray(data.anims)) {
                for (var i = 0; i < data.anims.length; i++) {
                  output.push(this.create(data.anims[i]));
                }
                if (data.hasOwnProperty("globalTimeScale")) {
                  this.globalTimeScale = data.globalTimeScale;
                }
              } else if (data.hasOwnProperty("key") && data.type === "frame") {
                output.push(this.create(data));
              }
              return output;
            },
            generateFrameNames: function (key, config) {
              var prefix = GetValue(config, "prefix", "");
              var start = GetValue(config, "start", 0);
              var end = GetValue(config, "end", 0);
              var suffix = GetValue(config, "suffix", "");
              var zeroPad = GetValue(config, "zeroPad", 0);
              var out = GetValue(config, "outputArray", []);
              var frames = GetValue(config, "frames", false);
              var texture = this.textureManager.get(key);
              if (!texture) {
                return out;
              }
              var i;
              if (!config) {
                frames = texture.getFrameNames();
                for (i = 0; i < frames.length; i++) {
                  out.push({
                    key,
                    frame: frames[i]
                  });
                }
              } else {
                if (!frames) {
                  frames = NumberArray(start, end);
                }
                for (i = 0; i < frames.length; i++) {
                  var frame = prefix + Pad(frames[i], zeroPad, "0", 1) + suffix;
                  if (texture.has(frame)) {
                    out.push({
                      key,
                      frame
                    });
                  } else {
                    console.warn("generateFrameNames: Frame missing: " + frame + " from texture: " + key);
                  }
                }
              }
              return out;
            },
            generateFrameNumbers: function (key, config) {
              var start = GetValue(config, "start", 0);
              var end = GetValue(config, "end", -1);
              var first = GetValue(config, "first", false);
              var out = GetValue(config, "outputArray", []);
              var frames = GetValue(config, "frames", false);
              var texture = this.textureManager.get(key);
              if (!texture) {
                return out;
              }
              if (first && texture.has(first)) {
                out.push({
                  key,
                  frame: first
                });
              }
              if (!frames) {
                if (end === -1) {
                  end = texture.frameTotal - 2;
                }
                frames = NumberArray(start, end);
              }
              for (var i = 0; i < frames.length; i++) {
                if (texture.has(frames[i])) {
                  out.push({
                    key,
                    frame: frames[i]
                  });
                } else {
                  console.warn("generateFrameNumbers: Frame " + i + " missing from texture: " + key);
                }
              }
              return out;
            },
            get: function (key) {
              return this.anims.get(key);
            },
            pauseAll: function () {
              if (!this.paused) {
                this.paused = true;
                this.emit(Events.PAUSE_ALL);
              }
              return this;
            },
            play: function (key, children) {
              if (!Array.isArray(children)) {
                children = [children];
              }
              for (var i = 0; i < children.length; i++) {
                children[i].anims.play(key);
              }
              return this;
            },
            staggerPlay: function (key, children, stagger, staggerFirst) {
              if (stagger === void 0) {
                stagger = 0;
              }
              if (staggerFirst === void 0) {
                staggerFirst = true;
              }
              if (!Array.isArray(children)) {
                children = [children];
              }
              var len = children.length;
              if (!staggerFirst) {
                len--;
              }
              for (var i = 0; i < children.length; i++) {
                var time = stagger < 0 ? Math.abs(stagger) * (len - i) : stagger * i;
                children[i].anims.playAfterDelay(key, time);
              }
              return this;
            },
            remove: function (key) {
              var anim = this.get(key);
              if (anim) {
                this.emit(Events.REMOVE_ANIMATION, key, anim);
                this.anims.delete(key);
                this.removeMix(key);
              }
              return anim;
            },
            resumeAll: function () {
              if (this.paused) {
                this.paused = false;
                this.emit(Events.RESUME_ALL);
              }
              return this;
            },
            toJSON: function (key) {
              var output = {
                anims: [],
                globalTimeScale: this.globalTimeScale
              };
              if (key !== void 0 && key !== "") {
                output.anims.push(this.anims.get(key).toJSON());
              } else {
                this.anims.each(function (animationKey, animation) {
                  output.anims.push(animation.toJSON());
                });
              }
              return output;
            },
            destroy: function () {
              this.anims.clear();
              this.mixes.clear();
              this.textureManager = null;
              this.game = null;
            }
          });
          module2.exports = AnimationManager;
        }, function (module2, exports2) {
          var NumberArray = function (start, end, prefix, suffix) {
            var result = [];
            var i;
            var asString = false;
            if (prefix || suffix) {
              asString = true;
              if (!prefix) {
                prefix = "";
              }
              if (!suffix) {
                suffix = "";
              }
            }
            if (end < start) {
              for (i = start; i >= end; i--) {
                if (asString) {
                  result.push(prefix + i.toString() + suffix);
                } else {
                  result.push(i);
                }
              }
            } else {
              for (i = start; i <= end; i++) {
                if (asString) {
                  result.push(prefix + i.toString() + suffix);
                } else {
                  result.push(i);
                }
              }
            }
            return result;
          };
          module2.exports = NumberArray;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CustomMap = __webpack_require__(102);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(324);
          var BaseCache = new Class({
            initialize: function BaseCache2() {
              this.entries = new CustomMap();
              this.events = new EventEmitter();
            },
            add: function (key, data) {
              this.entries.set(key, data);
              this.events.emit(Events.ADD, this, key, data);
              return this;
            },
            has: function (key) {
              return this.entries.has(key);
            },
            exists: function (key) {
              return this.entries.has(key);
            },
            get: function (key) {
              return this.entries.get(key);
            },
            remove: function (key) {
              var entry = this.get(key);
              if (entry) {
                this.entries.delete(key);
                this.events.emit(Events.REMOVE, this, key, entry.data);
              }
              return this;
            },
            getKeys: function () {
              return this.entries.keys();
            },
            destroy: function () {
              this.entries.clear();
              this.events.removeAllListeners();
              this.entries = null;
              this.events = null;
            }
          });
          module2.exports = BaseCache;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            ADD: __webpack_require__(736),
            REMOVE: __webpack_require__(737)
          };
        }, function (module2, exports2, __webpack_require__) {
          var BaseCache = __webpack_require__(323);
          var Class = __webpack_require__(0);
          var GameEvents = __webpack_require__(22);
          var CacheManager = new Class({
            initialize: function CacheManager2(game) {
              this.game = game;
              this.binary = new BaseCache();
              this.bitmapFont = new BaseCache();
              this.json = new BaseCache();
              this.physics = new BaseCache();
              this.shader = new BaseCache();
              this.audio = new BaseCache();
              this.video = new BaseCache();
              this.text = new BaseCache();
              this.html = new BaseCache();
              this.obj = new BaseCache();
              this.tilemap = new BaseCache();
              this.xml = new BaseCache();
              this.custom = {};
              this.game.events.once(GameEvents.DESTROY, this.destroy, this);
            },
            addCustom: function (key) {
              if (!this.custom.hasOwnProperty(key)) {
                this.custom[key] = new BaseCache();
              }
              return this.custom[key];
            },
            destroy: function () {
              var keys = ["binary", "bitmapFont", "json", "physics", "shader", "audio", "video", "text", "html", "obj", "tilemap", "xml"];
              for (var i = 0; i < keys.length; i++) {
                this[keys[i]].destroy();
                this[keys[i]] = null;
              }
              for (var key in this.custom) {
                this.custom[key].destroy();
              }
              this.custom = null;
              this.game = null;
            }
          });
          module2.exports = CacheManager;
        }, function (module2, exports2, __webpack_require__) {
          var BaseCamera = __webpack_require__(133);
          var CenterOn = __webpack_require__(190);
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var Effects = __webpack_require__(333);
          var Events = __webpack_require__(37);
          var Linear = __webpack_require__(135);
          var Rectangle = __webpack_require__(10);
          var Vector2 = __webpack_require__(3);
          var Camera = new Class({
            Extends: BaseCamera,
            Mixins: [Components.Flip, Components.Tint, Components.Pipeline],
            initialize: function Camera2(x, y, width, height) {
              BaseCamera.call(this, x, y, width, height);
              this.postPipelines = [];
              this.pipelineData = {};
              this.inputEnabled = true;
              this.fadeEffect = new Effects.Fade(this);
              this.flashEffect = new Effects.Flash(this);
              this.shakeEffect = new Effects.Shake(this);
              this.panEffect = new Effects.Pan(this);
              this.rotateToEffect = new Effects.RotateTo(this);
              this.zoomEffect = new Effects.Zoom(this);
              this.lerp = new Vector2(1, 1);
              this.followOffset = new Vector2();
              this.deadzone = null;
              this._follow = null;
            },
            setDeadzone: function (width, height) {
              if (width === void 0) {
                this.deadzone = null;
              } else {
                if (this.deadzone) {
                  this.deadzone.width = width;
                  this.deadzone.height = height;
                } else {
                  this.deadzone = new Rectangle(0, 0, width, height);
                }
                if (this._follow) {
                  var originX = this.width / 2;
                  var originY = this.height / 2;
                  var fx = this._follow.x - this.followOffset.x;
                  var fy = this._follow.y - this.followOffset.y;
                  this.midPoint.set(fx, fy);
                  this.scrollX = fx - originX;
                  this.scrollY = fy - originY;
                }
                CenterOn(this.deadzone, this.midPoint.x, this.midPoint.y);
              }
              return this;
            },
            fadeIn: function (duration, red, green, blue, callback, context) {
              return this.fadeEffect.start(false, duration, red, green, blue, true, callback, context);
            },
            fadeOut: function (duration, red, green, blue, callback, context) {
              return this.fadeEffect.start(true, duration, red, green, blue, true, callback, context);
            },
            fadeFrom: function (duration, red, green, blue, force, callback, context) {
              return this.fadeEffect.start(false, duration, red, green, blue, force, callback, context);
            },
            fade: function (duration, red, green, blue, force, callback, context) {
              return this.fadeEffect.start(true, duration, red, green, blue, force, callback, context);
            },
            flash: function (duration, red, green, blue, force, callback, context) {
              return this.flashEffect.start(duration, red, green, blue, force, callback, context);
            },
            shake: function (duration, intensity, force, callback, context) {
              return this.shakeEffect.start(duration, intensity, force, callback, context);
            },
            pan: function (x, y, duration, ease, force, callback, context) {
              return this.panEffect.start(x, y, duration, ease, force, callback, context);
            },
            rotateTo: function (radians, shortestPath, duration, ease, force, callback, context) {
              return this.rotateToEffect.start(radians, shortestPath, duration, ease, force, callback, context);
            },
            zoomTo: function (zoom, duration, ease, force, callback, context) {
              return this.zoomEffect.start(zoom, duration, ease, force, callback, context);
            },
            preRender: function () {
              this.renderList.length = 0;
              var width = this.width;
              var height = this.height;
              var halfWidth = width * 0.5;
              var halfHeight = height * 0.5;
              var zoom = this.zoom;
              var matrix = this.matrix;
              var originX = width * this.originX;
              var originY = height * this.originY;
              var follow = this._follow;
              var deadzone = this.deadzone;
              var sx = this.scrollX;
              var sy = this.scrollY;
              if (deadzone) {
                CenterOn(deadzone, this.midPoint.x, this.midPoint.y);
              }
              var emitFollowEvent = false;
              if (follow && !this.panEffect.isRunning) {
                var fx = follow.x - this.followOffset.x;
                var fy = follow.y - this.followOffset.y;
                if (deadzone) {
                  if (fx < deadzone.x) {
                    sx = Linear(sx, sx - (deadzone.x - fx), this.lerp.x);
                  } else if (fx > deadzone.right) {
                    sx = Linear(sx, sx + (fx - deadzone.right), this.lerp.x);
                  }
                  if (fy < deadzone.y) {
                    sy = Linear(sy, sy - (deadzone.y - fy), this.lerp.y);
                  } else if (fy > deadzone.bottom) {
                    sy = Linear(sy, sy + (fy - deadzone.bottom), this.lerp.y);
                  }
                } else {
                  sx = Linear(sx, fx - originX, this.lerp.x);
                  sy = Linear(sy, fy - originY, this.lerp.y);
                }
                emitFollowEvent = true;
              }
              if (this.useBounds) {
                sx = this.clampX(sx);
                sy = this.clampY(sy);
              }
              if (this.roundPixels) {
                originX = Math.round(originX);
                originY = Math.round(originY);
                sx = Math.round(sx);
                sy = Math.round(sy);
              }
              this.scrollX = sx;
              this.scrollY = sy;
              var midX = sx + halfWidth;
              var midY = sy + halfHeight;
              this.midPoint.set(midX, midY);
              var displayWidth = width / zoom;
              var displayHeight = height / zoom;
              var vwx = midX - displayWidth / 2;
              var vwy = midY - displayHeight / 2;
              if (this.roundPixels) {
                vwx = Math.round(vwx);
                vwy = Math.round(vwy);
              }
              this.worldView.setTo(vwx, vwy, displayWidth, displayHeight);
              matrix.applyITRS(this.x + originX, this.y + originY, this.rotation, zoom, zoom);
              matrix.translate(-originX, -originY);
              this.shakeEffect.preRender();
              if (emitFollowEvent) {
                this.emit(Events.FOLLOW_UPDATE, this, follow);
              }
            },
            setLerp: function (x, y) {
              if (x === void 0) {
                x = 1;
              }
              if (y === void 0) {
                y = x;
              }
              this.lerp.set(x, y);
              return this;
            },
            setFollowOffset: function (x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              this.followOffset.set(x, y);
              return this;
            },
            startFollow: function (target, roundPixels, lerpX, lerpY, offsetX, offsetY) {
              if (roundPixels === void 0) {
                roundPixels = false;
              }
              if (lerpX === void 0) {
                lerpX = 1;
              }
              if (lerpY === void 0) {
                lerpY = lerpX;
              }
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = offsetX;
              }
              this._follow = target;
              this.roundPixels = roundPixels;
              lerpX = Clamp(lerpX, 0, 1);
              lerpY = Clamp(lerpY, 0, 1);
              this.lerp.set(lerpX, lerpY);
              this.followOffset.set(offsetX, offsetY);
              var originX = this.width / 2;
              var originY = this.height / 2;
              var fx = target.x - offsetX;
              var fy = target.y - offsetY;
              this.midPoint.set(fx, fy);
              this.scrollX = fx - originX;
              this.scrollY = fy - originY;
              if (this.useBounds) {
                this.scrollX = this.clampX(this.scrollX);
                this.scrollY = this.clampY(this.scrollY);
              }
              return this;
            },
            stopFollow: function () {
              this._follow = null;
              return this;
            },
            resetFX: function () {
              this.rotateToEffect.reset();
              this.panEffect.reset();
              this.shakeEffect.reset();
              this.flashEffect.reset();
              this.fadeEffect.reset();
              return this;
            },
            update: function (time, delta) {
              if (this.visible) {
                this.rotateToEffect.update(time, delta);
                this.panEffect.update(time, delta);
                this.zoomEffect.update(time, delta);
                this.shakeEffect.update(time, delta);
                this.flashEffect.update(time, delta);
                this.fadeEffect.update(time, delta);
              }
            },
            destroy: function () {
              this.resetFX();
              BaseCamera.prototype.destroy.call(this);
              this._follow = null;
              this.deadzone = null;
            }
          });
          module2.exports = Camera;
        }, function (module2, exports2, __webpack_require__) {
          var Color = __webpack_require__(38);
          var HexStringToColor = function (hex) {
            var color = new Color();
            hex = hex.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function (m, r2, g2, b2) {
              return r2 + r2 + g2 + g2 + b2 + b2;
            });
            var result = (/^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i).exec(hex);
            if (result) {
              var r = parseInt(result[1], 16);
              var g = parseInt(result[2], 16);
              var b = parseInt(result[3], 16);
              color.setTo(r, g, b);
            }
            return color;
          };
          module2.exports = HexStringToColor;
        }, function (module2, exports2) {
          var GetColor32 = function (red, green, blue, alpha) {
            return alpha << 24 | red << 16 | green << 8 | blue;
          };
          module2.exports = GetColor32;
        }, function (module2, exports2) {
          var RGBToHSV = function (r, g, b, out) {
            if (out === void 0) {
              out = {
                h: 0,
                s: 0,
                v: 0
              };
            }
            r /= 255;
            g /= 255;
            b /= 255;
            var min = Math.min(r, g, b);
            var max = Math.max(r, g, b);
            var d = max - min;
            var h = 0;
            var s = max === 0 ? 0 : d / max;
            var v = max;
            if (max !== min) {
              if (max === r) {
                h = (g - b) / d + (g < b ? 6 : 0);
              } else if (max === g) {
                h = (b - r) / d + 2;
              } else if (max === b) {
                h = (r - g) / d + 4;
              }
              h /= 6;
            }
            if (out.hasOwnProperty("_h")) {
              out._h = h;
              out._s = s;
              out._v = v;
            } else {
              out.h = h;
              out.s = s;
              out.v = v;
            }
            return out;
          };
          module2.exports = RGBToHSV;
        }, function (module2, exports2) {
          var IntegerToRGB = function (color) {
            if (color > 16777215) {
              return {
                a: color >>> 24,
                r: color >> 16 & 255,
                g: color >> 8 & 255,
                b: color & 255
              };
            } else {
              return {
                a: 255,
                r: color >> 16 & 255,
                g: color >> 8 & 255,
                b: color & 255
              };
            }
          };
          module2.exports = IntegerToRGB;
        }, function (module2, exports2, __webpack_require__) {
          var Color = __webpack_require__(38);
          var ObjectToColor = function (input) {
            return new Color(input.r, input.g, input.b, input.a);
          };
          module2.exports = ObjectToColor;
        }, function (module2, exports2, __webpack_require__) {
          var Color = __webpack_require__(38);
          var RGBStringToColor = function (rgb) {
            var color = new Color();
            var result = (/^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/).exec(rgb.toLowerCase());
            if (result) {
              var r = parseInt(result[1], 10);
              var g = parseInt(result[2], 10);
              var b = parseInt(result[3], 10);
              var a = result[4] !== void 0 ? parseFloat(result[4]) : 1;
              color.setTo(r, g, b, a * 255);
            }
            return color;
          };
          module2.exports = RGBStringToColor;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Fade: __webpack_require__(761),
            Flash: __webpack_require__(762),
            Pan: __webpack_require__(763),
            Shake: __webpack_require__(796),
            RotateTo: __webpack_require__(797),
            Zoom: __webpack_require__(798)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            In: __webpack_require__(764),
            Out: __webpack_require__(765),
            InOut: __webpack_require__(766)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            In: __webpack_require__(767),
            Out: __webpack_require__(768),
            InOut: __webpack_require__(769)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            In: __webpack_require__(770),
            Out: __webpack_require__(771),
            InOut: __webpack_require__(772)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            In: __webpack_require__(773),
            Out: __webpack_require__(774),
            InOut: __webpack_require__(775)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            In: __webpack_require__(776),
            Out: __webpack_require__(777),
            InOut: __webpack_require__(778)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            In: __webpack_require__(779),
            Out: __webpack_require__(780),
            InOut: __webpack_require__(781)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = __webpack_require__(782);
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            In: __webpack_require__(783),
            Out: __webpack_require__(784),
            InOut: __webpack_require__(785)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            In: __webpack_require__(786),
            Out: __webpack_require__(787),
            InOut: __webpack_require__(788)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            In: __webpack_require__(789),
            Out: __webpack_require__(790),
            InOut: __webpack_require__(791)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            In: __webpack_require__(792),
            Out: __webpack_require__(793),
            InOut: __webpack_require__(794)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = __webpack_require__(795);
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(33);
          var Device = __webpack_require__(347);
          var GetFastValue = __webpack_require__(2);
          var GetValue = __webpack_require__(6);
          var IsPlainObject = __webpack_require__(7);
          var PhaserMath = __webpack_require__(193);
          var NOOP = __webpack_require__(1);
          var DefaultPlugins = __webpack_require__(197);
          var ValueToColor = __webpack_require__(187);
          var Config = new Class({
            initialize: function Config2(config) {
              if (config === void 0) {
                config = {};
              }
              var defaultBannerColor = ["#ff0000", "#ffff00", "#00ff00", "#00ffff", "#000000"];
              var defaultBannerTextColor = "#ffffff";
              this.width = GetValue(config, "width", 1024);
              this.height = GetValue(config, "height", 768);
              this.zoom = GetValue(config, "zoom", 1);
              this.parent = GetValue(config, "parent", void 0);
              this.scaleMode = GetValue(config, "scaleMode", 0);
              this.expandParent = GetValue(config, "expandParent", true);
              this.autoRound = GetValue(config, "autoRound", false);
              this.autoCenter = GetValue(config, "autoCenter", 0);
              this.resizeInterval = GetValue(config, "resizeInterval", 500);
              this.fullscreenTarget = GetValue(config, "fullscreenTarget", null);
              this.minWidth = GetValue(config, "minWidth", 0);
              this.maxWidth = GetValue(config, "maxWidth", 0);
              this.minHeight = GetValue(config, "minHeight", 0);
              this.maxHeight = GetValue(config, "maxHeight", 0);
              var scaleConfig = GetValue(config, "scale", null);
              if (scaleConfig) {
                this.width = GetValue(scaleConfig, "width", this.width);
                this.height = GetValue(scaleConfig, "height", this.height);
                this.zoom = GetValue(scaleConfig, "zoom", this.zoom);
                this.parent = GetValue(scaleConfig, "parent", this.parent);
                this.scaleMode = GetValue(scaleConfig, "mode", this.scaleMode);
                this.expandParent = GetValue(scaleConfig, "expandParent", this.expandParent);
                this.autoRound = GetValue(scaleConfig, "autoRound", this.autoRound);
                this.autoCenter = GetValue(scaleConfig, "autoCenter", this.autoCenter);
                this.resizeInterval = GetValue(scaleConfig, "resizeInterval", this.resizeInterval);
                this.fullscreenTarget = GetValue(scaleConfig, "fullscreenTarget", this.fullscreenTarget);
                this.minWidth = GetValue(scaleConfig, "min.width", this.minWidth);
                this.maxWidth = GetValue(scaleConfig, "max.width", this.maxWidth);
                this.minHeight = GetValue(scaleConfig, "min.height", this.minHeight);
                this.maxHeight = GetValue(scaleConfig, "max.height", this.maxHeight);
              }
              this.renderType = GetValue(config, "type", CONST.AUTO);
              this.canvas = GetValue(config, "canvas", null);
              this.context = GetValue(config, "context", null);
              this.canvasStyle = GetValue(config, "canvasStyle", null);
              this.customEnvironment = GetValue(config, "customEnvironment", false);
              this.sceneConfig = GetValue(config, "scene", null);
              this.seed = GetValue(config, "seed", [(Date.now() * Math.random()).toString()]);
              PhaserMath.RND = new PhaserMath.RandomDataGenerator(this.seed);
              this.gameTitle = GetValue(config, "title", "");
              this.gameURL = GetValue(config, "url", "https://phaser.io");
              this.gameVersion = GetValue(config, "version", "");
              this.autoFocus = GetValue(config, "autoFocus", true);
              this.domCreateContainer = GetValue(config, "dom.createContainer", false);
              this.domBehindCanvas = GetValue(config, "dom.behindCanvas", false);
              this.domPointerEvents = GetValue(config, "dom.pointerEvents", "none");
              this.inputKeyboard = GetValue(config, "input.keyboard", true);
              this.inputKeyboardEventTarget = GetValue(config, "input.keyboard.target", window);
              this.inputKeyboardCapture = GetValue(config, "input.keyboard.capture", []);
              this.inputMouse = GetValue(config, "input.mouse", true);
              this.inputMouseEventTarget = GetValue(config, "input.mouse.target", null);
              this.inputMousePreventDefaultDown = GetValue(config, "input.mouse.preventDefaultDown", true);
              this.inputMousePreventDefaultUp = GetValue(config, "input.mouse.preventDefaultUp", true);
              this.inputMousePreventDefaultMove = GetValue(config, "input.mouse.preventDefaultMove", true);
              this.inputMousePreventDefaultWheel = GetValue(config, "input.mouse.preventDefaultWheel", true);
              this.inputTouch = GetValue(config, "input.touch", Device.input.touch);
              this.inputTouchEventTarget = GetValue(config, "input.touch.target", null);
              this.inputTouchCapture = GetValue(config, "input.touch.capture", true);
              this.inputActivePointers = GetValue(config, "input.activePointers", 1);
              this.inputSmoothFactor = GetValue(config, "input.smoothFactor", 0);
              this.inputWindowEvents = GetValue(config, "input.windowEvents", true);
              this.inputGamepad = GetValue(config, "input.gamepad", false);
              this.inputGamepadEventTarget = GetValue(config, "input.gamepad.target", window);
              this.disableContextMenu = GetValue(config, "disableContextMenu", false);
              this.audio = GetValue(config, "audio", {});
              this.hideBanner = GetValue(config, "banner", null) === false;
              this.hidePhaser = GetValue(config, "banner.hidePhaser", false);
              this.bannerTextColor = GetValue(config, "banner.text", defaultBannerTextColor);
              this.bannerBackgroundColor = GetValue(config, "banner.background", defaultBannerColor);
              if (this.gameTitle === "" && this.hidePhaser) {
                this.hideBanner = true;
              }
              this.fps = GetValue(config, "fps", null);
              var renderConfig = GetValue(config, "render", config);
              this.pipeline = GetValue(renderConfig, "pipeline", null);
              this.antialias = GetValue(renderConfig, "antialias", true);
              this.antialiasGL = GetValue(renderConfig, "antialiasGL", true);
              this.mipmapFilter = GetValue(renderConfig, "mipmapFilter", "LINEAR");
              this.desynchronized = GetValue(renderConfig, "desynchronized", false);
              this.roundPixels = GetValue(renderConfig, "roundPixels", false);
              this.pixelArt = GetValue(renderConfig, "pixelArt", this.zoom !== 1);
              if (this.pixelArt) {
                this.antialias = false;
                this.antialiasGL = false;
                this.roundPixels = true;
              }
              this.transparent = GetValue(renderConfig, "transparent", false);
              this.clearBeforeRender = GetValue(renderConfig, "clearBeforeRender", true);
              this.preserveDrawingBuffer = GetValue(renderConfig, "preserveDrawingBuffer", false);
              this.premultipliedAlpha = GetValue(renderConfig, "premultipliedAlpha", true);
              this.failIfMajorPerformanceCaveat = GetValue(renderConfig, "failIfMajorPerformanceCaveat", false);
              this.powerPreference = GetValue(renderConfig, "powerPreference", "default");
              this.batchSize = GetValue(renderConfig, "batchSize", 4096);
              this.maxTextures = GetValue(renderConfig, "maxTextures", -1);
              this.maxLights = GetValue(renderConfig, "maxLights", 10);
              var bgc = GetValue(config, "backgroundColor", 0);
              this.backgroundColor = ValueToColor(bgc);
              if (this.transparent) {
                this.backgroundColor = ValueToColor(0);
                this.backgroundColor.alpha = 0;
              }
              this.preBoot = GetValue(config, "callbacks.preBoot", NOOP);
              this.postBoot = GetValue(config, "callbacks.postBoot", NOOP);
              this.physics = GetValue(config, "physics", {});
              this.defaultPhysicsSystem = GetValue(this.physics, "default", false);
              this.loaderBaseURL = GetValue(config, "loader.baseURL", "");
              this.loaderPath = GetValue(config, "loader.path", "");
              var defaultParallel = Device.os.android ? 6 : 32;
              this.loaderMaxParallelDownloads = GetValue(config, "loader.maxParallelDownloads", defaultParallel);
              this.loaderCrossOrigin = GetValue(config, "loader.crossOrigin", void 0);
              this.loaderResponseType = GetValue(config, "loader.responseType", "");
              this.loaderAsync = GetValue(config, "loader.async", true);
              this.loaderUser = GetValue(config, "loader.user", "");
              this.loaderPassword = GetValue(config, "loader.password", "");
              this.loaderTimeout = GetValue(config, "loader.timeout", 0);
              this.loaderWithCredentials = GetValue(config, "loader.withCredentials", false);
              this.installGlobalPlugins = [];
              this.installScenePlugins = [];
              var plugins = GetValue(config, "plugins", null);
              var defaultPlugins = DefaultPlugins.DefaultScene;
              if (plugins) {
                if (Array.isArray(plugins)) {
                  this.defaultPlugins = plugins;
                } else if (IsPlainObject(plugins)) {
                  this.installGlobalPlugins = GetFastValue(plugins, "global", []);
                  this.installScenePlugins = GetFastValue(plugins, "scene", []);
                  if (Array.isArray(plugins.default)) {
                    defaultPlugins = plugins.default;
                  } else if (Array.isArray(plugins.defaultMerge)) {
                    defaultPlugins = defaultPlugins.concat(plugins.defaultMerge);
                  }
                }
              }
              this.defaultPlugins = defaultPlugins;
              var pngPrefix = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg";
              this.defaultImage = GetValue(config, "images.default", pngPrefix + "AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==");
              this.missingImage = GetValue(config, "images.missing", pngPrefix + "CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==");
              this.whiteImage = GetValue(config, "images.white", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABdJREFUeNpi/P//PwMMMDEgAdwcgAADAJZuAwXJYZOzAAAAAElFTkSuQmCC");
              if (window) {
                if (window.FORCE_WEBGL) {
                  this.renderType = CONST.WEBGL;
                } else if (window.FORCE_CANVAS) {
                  this.renderType = CONST.CANVAS;
                }
              }
            }
          });
          module2.exports = Config;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            os: __webpack_require__(105),
            browser: __webpack_require__(136),
            features: __webpack_require__(191),
            input: __webpack_require__(808),
            audio: __webpack_require__(809),
            video: __webpack_require__(810),
            fullscreen: __webpack_require__(811),
            canvasFeatures: __webpack_require__(348)
          };
        }, function (module2, exports2, __webpack_require__) {
          var CanvasPool = __webpack_require__(31);
          var CanvasFeatures = {
            supportInverseAlpha: false,
            supportNewBlendModes: false
          };
          function checkBlendMode() {
            var pngHead = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/";
            var pngEnd = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==";
            var magenta = new Image();
            magenta.onload = function () {
              var yellow = new Image();
              yellow.onload = function () {
                var canvas = CanvasPool.create(yellow, 6, 1);
                var context = canvas.getContext("2d");
                context.globalCompositeOperation = "multiply";
                context.drawImage(magenta, 0, 0);
                context.drawImage(yellow, 2, 0);
                if (!context.getImageData(2, 0, 1, 1)) {
                  return false;
                }
                var data = context.getImageData(2, 0, 1, 1).data;
                CanvasPool.remove(yellow);
                CanvasFeatures.supportNewBlendModes = data[0] === 255 && data[1] === 0 && data[2] === 0;
              };
              yellow.src = pngHead + "/wCKxvRF" + pngEnd;
            };
            magenta.src = pngHead + "AP804Oa6" + pngEnd;
            return false;
          }
          function checkInverseAlpha() {
            var canvas = CanvasPool.create(this, 2, 1);
            var context = canvas.getContext("2d");
            context.fillStyle = "rgba(10, 20, 30, 0.5)";
            context.fillRect(0, 0, 1, 1);
            var s1 = context.getImageData(0, 0, 1, 1);
            if (s1 === null) {
              return false;
            }
            context.putImageData(s1, 1, 0);
            var s2 = context.getImageData(1, 0, 1, 1);
            return s2.data[0] === s1.data[0] && s2.data[1] === s1.data[1] && s2.data[2] === s1.data[2] && s2.data[3] === s1.data[3];
          }
          function init() {
            if (typeof importScripts !== "function" && document !== void 0) {
              CanvasFeatures.supportNewBlendModes = checkBlendMode();
              CanvasFeatures.supportInverseAlpha = checkInverseAlpha();
            }
            return CanvasFeatures;
          }
          module2.exports = init();
        }, function (module2, exports2) {
          var Between = function (x1, y1, x2, y2) {
            return Math.atan2(y2 - y1, x2 - x1);
          };
          module2.exports = Between;
        }, function (module2, exports2) {
          var BetweenPoints = function (point1, point2) {
            return Math.atan2(point2.y - point1.y, point2.x - point1.x);
          };
          module2.exports = BetweenPoints;
        }, function (module2, exports2) {
          var Normalize = function (angle) {
            angle = angle % (2 * Math.PI);
            if (angle >= 0) {
              return angle;
            } else {
              return angle + 2 * Math.PI;
            }
          };
          module2.exports = Normalize;
        }, function (module2, exports2) {
          var DistanceBetweenPoints = function (a, b) {
            var dx = a.x - b.x;
            var dy = a.y - b.y;
            return Math.sqrt(dx * dx + dy * dy);
          };
          module2.exports = DistanceBetweenPoints;
        }, function (module2, exports2) {
          var DistanceSquared = function (x1, y1, x2, y2) {
            var dx = x1 - x2;
            var dy = y1 - y2;
            return dx * dx + dy * dy;
          };
          module2.exports = DistanceSquared;
        }, function (module2, exports2) {
          var GreaterThan = function (a, b, epsilon) {
            if (epsilon === void 0) {
              epsilon = 1e-4;
            }
            return a > b - epsilon;
          };
          module2.exports = GreaterThan;
        }, function (module2, exports2) {
          var LessThan = function (a, b, epsilon) {
            if (epsilon === void 0) {
              epsilon = 1e-4;
            }
            return a < b + epsilon;
          };
          module2.exports = LessThan;
        }, function (module2, exports2, __webpack_require__) {
          var Factorial = __webpack_require__(357);
          var Bernstein = function (n, i) {
            return Factorial(n) / Factorial(i) / Factorial(n - i);
          };
          module2.exports = Bernstein;
        }, function (module2, exports2) {
          var Factorial = function (value) {
            if (value === 0) {
              return 1;
            }
            var res = value;
            while (--value) {
              res *= value;
            }
            return res;
          };
          module2.exports = Factorial;
        }, function (module2, exports2) {
          function P0(t, p3) {
            var k = 1 - t;
            return k * k * k * p3;
          }
          function P1(t, p3) {
            var k = 1 - t;
            return 3 * k * k * t * p3;
          }
          function P2(t, p3) {
            return 3 * (1 - t) * t * t * p3;
          }
          function P3(t, p3) {
            return t * t * t * p3;
          }
          var CubicBezierInterpolation = function (t, p0, p1, p22, p3) {
            return P0(t, p0) + P1(t, p1) + P2(t, p22) + P3(t, p3);
          };
          module2.exports = CubicBezierInterpolation;
        }, function (module2, exports2) {
          function P0(t, p3) {
            var k = 1 - t;
            return k * k * p3;
          }
          function P1(t, p3) {
            return 2 * (1 - t) * t * p3;
          }
          function P2(t, p3) {
            return t * t * p3;
          }
          var QuadraticBezierInterpolation = function (t, p0, p1, p22) {
            return P0(t, p0) + P1(t, p1) + P2(t, p22);
          };
          module2.exports = QuadraticBezierInterpolation;
        }, function (module2, exports2, __webpack_require__) {
          var SmoothStep = __webpack_require__(184);
          var SmoothStepInterpolation = function (t, min, max) {
            return min + (max - min) * SmoothStep(t, 0, 1);
          };
          module2.exports = SmoothStepInterpolation;
        }, function (module2, exports2) {
          var GetPowerOfTwo = function (value) {
            var index = Math.log(value) / 0.6931471805599453;
            return 1 << Math.ceil(index);
          };
          module2.exports = GetPowerOfTwo;
        }, function (module2, exports2) {
          var Rotate = function (point, angle) {
            var x = point.x;
            var y = point.y;
            point.x = x * Math.cos(angle) - y * Math.sin(angle);
            point.y = x * Math.sin(angle) + y * Math.cos(angle);
            return point;
          };
          module2.exports = Rotate;
        }, function (module2, exports2) {
          var RoundAwayFromZero = function (value) {
            return value > 0 ? Math.ceil(value) : Math.floor(value);
          };
          module2.exports = RoundAwayFromZero;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Matrix3 = new Class({
            initialize: function Matrix32(m) {
              this.val = new Float32Array(9);
              if (m) {
                this.copy(m);
              } else {
                this.identity();
              }
            },
            clone: function () {
              return new Matrix3(this);
            },
            set: function (src) {
              return this.copy(src);
            },
            copy: function (src) {
              var out = this.val;
              var a = src.val;
              out[0] = a[0];
              out[1] = a[1];
              out[2] = a[2];
              out[3] = a[3];
              out[4] = a[4];
              out[5] = a[5];
              out[6] = a[6];
              out[7] = a[7];
              out[8] = a[8];
              return this;
            },
            fromMat4: function (m) {
              var a = m.val;
              var out = this.val;
              out[0] = a[0];
              out[1] = a[1];
              out[2] = a[2];
              out[3] = a[4];
              out[4] = a[5];
              out[5] = a[6];
              out[6] = a[8];
              out[7] = a[9];
              out[8] = a[10];
              return this;
            },
            fromArray: function (a) {
              var out = this.val;
              out[0] = a[0];
              out[1] = a[1];
              out[2] = a[2];
              out[3] = a[3];
              out[4] = a[4];
              out[5] = a[5];
              out[6] = a[6];
              out[7] = a[7];
              out[8] = a[8];
              return this;
            },
            identity: function () {
              var out = this.val;
              out[0] = 1;
              out[1] = 0;
              out[2] = 0;
              out[3] = 0;
              out[4] = 1;
              out[5] = 0;
              out[6] = 0;
              out[7] = 0;
              out[8] = 1;
              return this;
            },
            transpose: function () {
              var a = this.val;
              var a01 = a[1];
              var a02 = a[2];
              var a12 = a[5];
              a[1] = a[3];
              a[2] = a[6];
              a[3] = a01;
              a[5] = a[7];
              a[6] = a02;
              a[7] = a12;
              return this;
            },
            invert: function () {
              var a = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a10 = a[3];
              var a11 = a[4];
              var a12 = a[5];
              var a20 = a[6];
              var a21 = a[7];
              var a22 = a[8];
              var b01 = a22 * a11 - a12 * a21;
              var b11 = -a22 * a10 + a12 * a20;
              var b21 = a21 * a10 - a11 * a20;
              var det = a00 * b01 + a01 * b11 + a02 * b21;
              if (!det) {
                return null;
              }
              det = 1 / det;
              a[0] = b01 * det;
              a[1] = (-a22 * a01 + a02 * a21) * det;
              a[2] = (a12 * a01 - a02 * a11) * det;
              a[3] = b11 * det;
              a[4] = (a22 * a00 - a02 * a20) * det;
              a[5] = (-a12 * a00 + a02 * a10) * det;
              a[6] = b21 * det;
              a[7] = (-a21 * a00 + a01 * a20) * det;
              a[8] = (a11 * a00 - a01 * a10) * det;
              return this;
            },
            adjoint: function () {
              var a = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a10 = a[3];
              var a11 = a[4];
              var a12 = a[5];
              var a20 = a[6];
              var a21 = a[7];
              var a22 = a[8];
              a[0] = a11 * a22 - a12 * a21;
              a[1] = a02 * a21 - a01 * a22;
              a[2] = a01 * a12 - a02 * a11;
              a[3] = a12 * a20 - a10 * a22;
              a[4] = a00 * a22 - a02 * a20;
              a[5] = a02 * a10 - a00 * a12;
              a[6] = a10 * a21 - a11 * a20;
              a[7] = a01 * a20 - a00 * a21;
              a[8] = a00 * a11 - a01 * a10;
              return this;
            },
            determinant: function () {
              var a = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a10 = a[3];
              var a11 = a[4];
              var a12 = a[5];
              var a20 = a[6];
              var a21 = a[7];
              var a22 = a[8];
              return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
            },
            multiply: function (src) {
              var a = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a10 = a[3];
              var a11 = a[4];
              var a12 = a[5];
              var a20 = a[6];
              var a21 = a[7];
              var a22 = a[8];
              var b = src.val;
              var b00 = b[0];
              var b01 = b[1];
              var b02 = b[2];
              var b10 = b[3];
              var b11 = b[4];
              var b12 = b[5];
              var b20 = b[6];
              var b21 = b[7];
              var b22 = b[8];
              a[0] = b00 * a00 + b01 * a10 + b02 * a20;
              a[1] = b00 * a01 + b01 * a11 + b02 * a21;
              a[2] = b00 * a02 + b01 * a12 + b02 * a22;
              a[3] = b10 * a00 + b11 * a10 + b12 * a20;
              a[4] = b10 * a01 + b11 * a11 + b12 * a21;
              a[5] = b10 * a02 + b11 * a12 + b12 * a22;
              a[6] = b20 * a00 + b21 * a10 + b22 * a20;
              a[7] = b20 * a01 + b21 * a11 + b22 * a21;
              a[8] = b20 * a02 + b21 * a12 + b22 * a22;
              return this;
            },
            translate: function (v) {
              var a = this.val;
              var x = v.x;
              var y = v.y;
              a[6] = x * a[0] + y * a[3] + a[6];
              a[7] = x * a[1] + y * a[4] + a[7];
              a[8] = x * a[2] + y * a[5] + a[8];
              return this;
            },
            rotate: function (rad) {
              var a = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a10 = a[3];
              var a11 = a[4];
              var a12 = a[5];
              var s = Math.sin(rad);
              var c = Math.cos(rad);
              a[0] = c * a00 + s * a10;
              a[1] = c * a01 + s * a11;
              a[2] = c * a02 + s * a12;
              a[3] = c * a10 - s * a00;
              a[4] = c * a11 - s * a01;
              a[5] = c * a12 - s * a02;
              return this;
            },
            scale: function (v) {
              var a = this.val;
              var x = v.x;
              var y = v.y;
              a[0] = x * a[0];
              a[1] = x * a[1];
              a[2] = x * a[2];
              a[3] = y * a[3];
              a[4] = y * a[4];
              a[5] = y * a[5];
              return this;
            },
            fromQuat: function (q) {
              var x = q.x;
              var y = q.y;
              var z = q.z;
              var w = q.w;
              var x2 = x + x;
              var y2 = y + y;
              var z2 = z + z;
              var xx = x * x2;
              var xy = x * y2;
              var xz = x * z2;
              var yy = y * y2;
              var yz = y * z2;
              var zz = z * z2;
              var wx = w * x2;
              var wy = w * y2;
              var wz = w * z2;
              var out = this.val;
              out[0] = 1 - (yy + zz);
              out[3] = xy + wz;
              out[6] = xz - wy;
              out[1] = xy - wz;
              out[4] = 1 - (xx + zz);
              out[7] = yz + wx;
              out[2] = xz + wy;
              out[5] = yz - wx;
              out[8] = 1 - (xx + yy);
              return this;
            },
            normalFromMat4: function (m) {
              var a = m.val;
              var out = this.val;
              var a00 = a[0];
              var a01 = a[1];
              var a02 = a[2];
              var a03 = a[3];
              var a10 = a[4];
              var a11 = a[5];
              var a12 = a[6];
              var a13 = a[7];
              var a20 = a[8];
              var a21 = a[9];
              var a22 = a[10];
              var a23 = a[11];
              var a30 = a[12];
              var a31 = a[13];
              var a32 = a[14];
              var a33 = a[15];
              var b00 = a00 * a11 - a01 * a10;
              var b01 = a00 * a12 - a02 * a10;
              var b02 = a00 * a13 - a03 * a10;
              var b03 = a01 * a12 - a02 * a11;
              var b04 = a01 * a13 - a03 * a11;
              var b05 = a02 * a13 - a03 * a12;
              var b06 = a20 * a31 - a21 * a30;
              var b07 = a20 * a32 - a22 * a30;
              var b08 = a20 * a33 - a23 * a30;
              var b09 = a21 * a32 - a22 * a31;
              var b10 = a21 * a33 - a23 * a31;
              var b11 = a22 * a33 - a23 * a32;
              var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
              if (!det) {
                return null;
              }
              det = 1 / det;
              out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
              out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
              out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
              out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
              out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
              out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
              out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
              out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
              out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
              return this;
            }
          });
          module2.exports = Matrix3;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Matrix3 = __webpack_require__(364);
          var NOOP = __webpack_require__(1);
          var Vector3 = __webpack_require__(39);
          var EPSILON = 1e-6;
          var siNext = new Int8Array([1, 2, 0]);
          var tmp = new Float32Array([0, 0, 0]);
          var xUnitVec3 = new Vector3(1, 0, 0);
          var yUnitVec3 = new Vector3(0, 1, 0);
          var tmpvec = new Vector3();
          var tmpMat3 = new Matrix3();
          var Quaternion = new Class({
            initialize: function Quaternion2(x, y, z, w) {
              this.onChangeCallback = NOOP;
              this.set(x, y, z, w);
            },
            x: {
              get: function () {
                return this._x;
              },
              set: function (value) {
                this._x = value;
                this.onChangeCallback(this);
              }
            },
            y: {
              get: function () {
                return this._y;
              },
              set: function (value) {
                this._y = value;
                this.onChangeCallback(this);
              }
            },
            z: {
              get: function () {
                return this._z;
              },
              set: function (value) {
                this._z = value;
                this.onChangeCallback(this);
              }
            },
            w: {
              get: function () {
                return this._w;
              },
              set: function (value) {
                this._w = value;
                this.onChangeCallback(this);
              }
            },
            copy: function (src) {
              return this.set(src);
            },
            set: function (x, y, z, w, update) {
              if (update === void 0) {
                update = true;
              }
              if (typeof x === "object") {
                this._x = x.x || 0;
                this._y = x.y || 0;
                this._z = x.z || 0;
                this._w = x.w || 0;
              } else {
                this._x = x || 0;
                this._y = y || 0;
                this._z = z || 0;
                this._w = w || 0;
              }
              if (update) {
                this.onChangeCallback(this);
              }
              return this;
            },
            add: function (v) {
              this._x += v.x;
              this._y += v.y;
              this._z += v.z;
              this._w += v.w;
              this.onChangeCallback(this);
              return this;
            },
            subtract: function (v) {
              this._x -= v.x;
              this._y -= v.y;
              this._z -= v.z;
              this._w -= v.w;
              this.onChangeCallback(this);
              return this;
            },
            scale: function (scale) {
              this._x *= scale;
              this._y *= scale;
              this._z *= scale;
              this._w *= scale;
              this.onChangeCallback(this);
              return this;
            },
            length: function () {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var w = this.w;
              return Math.sqrt(x * x + y * y + z * z + w * w);
            },
            lengthSq: function () {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var w = this.w;
              return x * x + y * y + z * z + w * w;
            },
            normalize: function () {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var w = this.w;
              var len = x * x + y * y + z * z + w * w;
              if (len > 0) {
                len = 1 / Math.sqrt(len);
                this._x = x * len;
                this._y = y * len;
                this._z = z * len;
                this._w = w * len;
              }
              this.onChangeCallback(this);
              return this;
            },
            dot: function (v) {
              return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
            },
            lerp: function (v, t) {
              if (t === void 0) {
                t = 0;
              }
              var ax = this.x;
              var ay = this.y;
              var az = this.z;
              var aw = this.w;
              return this.set(ax + t * (v.x - ax), ay + t * (v.y - ay), az + t * (v.z - az), aw + t * (v.w - aw));
            },
            rotationTo: function (a, b) {
              var dot = a.x * b.x + a.y * b.y + a.z * b.z;
              if (dot < -0.999999) {
                if (tmpvec.copy(xUnitVec3).cross(a).length() < EPSILON) {
                  tmpvec.copy(yUnitVec3).cross(a);
                }
                tmpvec.normalize();
                return this.setAxisAngle(tmpvec, Math.PI);
              } else if (dot > 0.999999) {
                return this.set(0, 0, 0, 1);
              } else {
                tmpvec.copy(a).cross(b);
                this._x = tmpvec.x;
                this._y = tmpvec.y;
                this._z = tmpvec.z;
                this._w = 1 + dot;
                return this.normalize();
              }
            },
            setAxes: function (view, right, up) {
              var m = tmpMat3.val;
              m[0] = right.x;
              m[3] = right.y;
              m[6] = right.z;
              m[1] = up.x;
              m[4] = up.y;
              m[7] = up.z;
              m[2] = -view.x;
              m[5] = -view.y;
              m[8] = -view.z;
              return this.fromMat3(tmpMat3).normalize();
            },
            identity: function () {
              return this.set(0, 0, 0, 1);
            },
            setAxisAngle: function (axis, rad) {
              rad = rad * 0.5;
              var s = Math.sin(rad);
              return this.set(s * axis.x, s * axis.y, s * axis.z, Math.cos(rad));
            },
            multiply: function (b) {
              var ax = this.x;
              var ay = this.y;
              var az = this.z;
              var aw = this.w;
              var bx = b.x;
              var by = b.y;
              var bz = b.z;
              var bw = b.w;
              return this.set(ax * bw + aw * bx + ay * bz - az * by, ay * bw + aw * by + az * bx - ax * bz, az * bw + aw * bz + ax * by - ay * bx, aw * bw - ax * bx - ay * by - az * bz);
            },
            slerp: function (b, t) {
              var ax = this.x;
              var ay = this.y;
              var az = this.z;
              var aw = this.w;
              var bx = b.x;
              var by = b.y;
              var bz = b.z;
              var bw = b.w;
              var cosom = ax * bx + ay * by + az * bz + aw * bw;
              if (cosom < 0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
              }
              var scale0 = 1 - t;
              var scale1 = t;
              if (1 - cosom > EPSILON) {
                var omega = Math.acos(cosom);
                var sinom = Math.sin(omega);
                scale0 = Math.sin((1 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
              }
              return this.set(scale0 * ax + scale1 * bx, scale0 * ay + scale1 * by, scale0 * az + scale1 * bz, scale0 * aw + scale1 * bw);
            },
            invert: function () {
              var a0 = this.x;
              var a1 = this.y;
              var a2 = this.z;
              var a3 = this.w;
              var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
              var invDot = dot ? 1 / dot : 0;
              return this.set(-a0 * invDot, -a1 * invDot, -a2 * invDot, a3 * invDot);
            },
            conjugate: function () {
              this._x = -this.x;
              this._y = -this.y;
              this._z = -this.z;
              this.onChangeCallback(this);
              return this;
            },
            rotateX: function (rad) {
              rad *= 0.5;
              var ax = this.x;
              var ay = this.y;
              var az = this.z;
              var aw = this.w;
              var bx = Math.sin(rad);
              var bw = Math.cos(rad);
              return this.set(ax * bw + aw * bx, ay * bw + az * bx, az * bw - ay * bx, aw * bw - ax * bx);
            },
            rotateY: function (rad) {
              rad *= 0.5;
              var ax = this.x;
              var ay = this.y;
              var az = this.z;
              var aw = this.w;
              var by = Math.sin(rad);
              var bw = Math.cos(rad);
              return this.set(ax * bw - az * by, ay * bw + aw * by, az * bw + ax * by, aw * bw - ay * by);
            },
            rotateZ: function (rad) {
              rad *= 0.5;
              var ax = this.x;
              var ay = this.y;
              var az = this.z;
              var aw = this.w;
              var bz = Math.sin(rad);
              var bw = Math.cos(rad);
              return this.set(ax * bw + ay * bz, ay * bw - ax * bz, az * bw + aw * bz, aw * bw - az * bz);
            },
            calculateW: function () {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              this.w = -Math.sqrt(1 - x * x - y * y - z * z);
              return this;
            },
            setFromEuler: function (euler, update) {
              var x = euler.x / 2;
              var y = euler.y / 2;
              var z = euler.z / 2;
              var c1 = Math.cos(x);
              var c2 = Math.cos(y);
              var c3 = Math.cos(z);
              var s1 = Math.sin(x);
              var s2 = Math.sin(y);
              var s3 = Math.sin(z);
              switch (euler.order) {
                case "XYZ":
                  {
                    this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
                    break;
                  }
                case "YXZ":
                  {
                    this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
                    break;
                  }
                case "ZXY":
                  {
                    this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
                    break;
                  }
                case "ZYX":
                  {
                    this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
                    break;
                  }
                case "YZX":
                  {
                    this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
                    break;
                  }
                case "XZY":
                  {
                    this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
                    break;
                  }
              }
              return this;
            },
            setFromRotationMatrix: function (mat4) {
              var m = mat4.val;
              var m11 = m[0];
              var m12 = m[4];
              var m13 = m[8];
              var m21 = m[1];
              var m22 = m[5];
              var m23 = m[9];
              var m31 = m[2];
              var m32 = m[6];
              var m33 = m[10];
              var trace = m11 + m22 + m33;
              var s;
              if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1);
                this.set((m32 - m23) * s, (m13 - m31) * s, (m21 - m12) * s, 0.25 / s);
              } else if (m11 > m22 && m11 > m33) {
                s = 2 * Math.sqrt(1 + m11 - m22 - m33);
                this.set(0.25 * s, (m12 + m21) / s, (m13 + m31) / s, (m32 - m23) / s);
              } else if (m22 > m33) {
                s = 2 * Math.sqrt(1 + m22 - m11 - m33);
                this.set((m12 + m21) / s, 0.25 * s, (m23 + m32) / s, (m13 - m31) / s);
              } else {
                s = 2 * Math.sqrt(1 + m33 - m11 - m22);
                this.set((m13 + m31) / s, (m23 + m32) / s, 0.25 * s, (m21 - m12) / s);
              }
              return this;
            },
            fromMat3: function (mat) {
              var m = mat.val;
              var fTrace = m[0] + m[4] + m[8];
              var fRoot;
              if (fTrace > 0) {
                fRoot = Math.sqrt(fTrace + 1);
                this.w = 0.5 * fRoot;
                fRoot = 0.5 / fRoot;
                this._x = (m[7] - m[5]) * fRoot;
                this._y = (m[2] - m[6]) * fRoot;
                this._z = (m[3] - m[1]) * fRoot;
              } else {
                var i = 0;
                if (m[4] > m[0]) {
                  i = 1;
                }
                if (m[8] > m[i * 3 + i]) {
                  i = 2;
                }
                var j = siNext[i];
                var k = siNext[j];
                fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
                tmp[i] = 0.5 * fRoot;
                fRoot = 0.5 / fRoot;
                tmp[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
                tmp[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
                this._x = tmp[0];
                this._y = tmp[1];
                this._z = tmp[2];
                this._w = (m[k * 3 + j] - m[j * 3 + k]) * fRoot;
              }
              this.onChangeCallback(this);
              return this;
            }
          });
          module2.exports = Quaternion;
        }, function (module2, exports2, __webpack_require__) {
          var CanvasInterpolation = __webpack_require__(367);
          var CanvasPool = __webpack_require__(31);
          var CONST = __webpack_require__(33);
          var Features = __webpack_require__(191);
          var CreateRenderer = function (game) {
            var config = game.config;
            if ((config.customEnvironment || config.canvas) && config.renderType === CONST.AUTO) {
              throw new Error("Must set explicit renderType in custom environment");
            }
            if (!config.customEnvironment && !config.canvas && config.renderType !== CONST.HEADLESS) {
              if (config.renderType === CONST.CANVAS || config.renderType !== CONST.CANVAS && !Features.webGL) {
                if (Features.canvas) {
                  config.renderType = CONST.CANVAS;
                } else {
                  throw new Error("Cannot create Canvas or WebGL context, aborting.");
                }
              } else {
                config.renderType = CONST.WEBGL;
              }
            }
            if (!config.antialias) {
              CanvasPool.disableSmoothing();
            }
            var baseSize = game.scale.baseSize;
            var width = baseSize.width;
            var height = baseSize.height;
            if (config.canvas) {
              game.canvas = config.canvas;
              game.canvas.width = width;
              game.canvas.height = height;
            } else {
              game.canvas = CanvasPool.create(game, width, height, config.renderType);
            }
            if (config.canvasStyle) {
              game.canvas.style = config.canvasStyle;
            }
            if (!config.antialias) {
              CanvasInterpolation.setCrisp(game.canvas);
            }
            if (config.renderType === CONST.HEADLESS) {
              return;
            }
            var CanvasRenderer;
            var WebGLRenderer;
            if (true) {
              CanvasRenderer = __webpack_require__(368);
              WebGLRenderer = __webpack_require__(371);
              if (config.renderType === CONST.WEBGL) {
                game.renderer = new WebGLRenderer(game);
              } else {
                game.renderer = new CanvasRenderer(game);
                game.context = game.renderer.gameContext;
              }
            }
            if (false) {}
            if (false) {}
          };
          module2.exports = CreateRenderer;
        }, function (module2, exports2) {
          var CanvasInterpolation = {
            setCrisp: function (canvas) {
              var types = ["optimizeSpeed", "-moz-crisp-edges", "-o-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "crisp-edges", "pixelated"];
              types.forEach(function (type) {
                canvas.style["image-rendering"] = type;
              });
              canvas.style.msInterpolationMode = "nearest-neighbor";
              return canvas;
            },
            setBicubic: function (canvas) {
              canvas.style["image-rendering"] = "auto";
              canvas.style.msInterpolationMode = "bicubic";
              return canvas;
            }
          };
          module2.exports = CanvasInterpolation;
        }, function (module2, exports2, __webpack_require__) {
          var CameraEvents = __webpack_require__(37);
          var CanvasSnapshot = __webpack_require__(369);
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(33);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(91);
          var GetBlendModes = __webpack_require__(370);
          var ScaleEvents = __webpack_require__(104);
          var TextureEvents = __webpack_require__(106);
          var TransformMatrix = __webpack_require__(25);
          var CanvasRenderer = new Class({
            Extends: EventEmitter,
            initialize: function CanvasRenderer2(game) {
              EventEmitter.call(this);
              var gameConfig = game.config;
              this.config = {
                clearBeforeRender: gameConfig.clearBeforeRender,
                backgroundColor: gameConfig.backgroundColor,
                antialias: gameConfig.antialias,
                roundPixels: gameConfig.roundPixels
              };
              this.game = game;
              this.type = CONST.CANVAS;
              this.drawCount = 0;
              this.width = 0;
              this.height = 0;
              this.gameCanvas = game.canvas;
              var contextOptions = {
                alpha: game.config.transparent,
                desynchronized: game.config.desynchronized
              };
              this.gameContext = gameConfig.context ? gameConfig.context : this.gameCanvas.getContext("2d", contextOptions);
              this.currentContext = this.gameContext;
              this.antialias = game.config.antialias;
              this.blendModes = GetBlendModes();
              this.snapshotState = {
                x: 0,
                y: 0,
                width: 1,
                height: 1,
                getPixel: false,
                callback: null,
                type: "image/png",
                encoder: 0.92
              };
              this._tempMatrix1 = new TransformMatrix();
              this._tempMatrix2 = new TransformMatrix();
              this._tempMatrix3 = new TransformMatrix();
              this.isBooted = false;
              this.init();
            },
            init: function () {
              this.game.textures.once(TextureEvents.READY, this.boot, this);
            },
            boot: function () {
              var game = this.game;
              var baseSize = game.scale.baseSize;
              this.width = baseSize.width;
              this.height = baseSize.height;
              this.isBooted = true;
              game.scale.on(ScaleEvents.RESIZE, this.onResize, this);
              this.resize(baseSize.width, baseSize.height);
            },
            onResize: function (gameSize, baseSize) {
              if (baseSize.width !== this.width || baseSize.height !== this.height) {
                this.resize(baseSize.width, baseSize.height);
              }
            },
            resize: function (width, height) {
              this.width = width;
              this.height = height;
              this.emit(Events.RESIZE, width, height);
            },
            resetTransform: function () {
              this.currentContext.setTransform(1, 0, 0, 1, 0, 0);
            },
            setBlendMode: function (blendMode) {
              this.currentContext.globalCompositeOperation = blendMode;
              return this;
            },
            setContext: function (ctx) {
              this.currentContext = ctx ? ctx : this.gameContext;
              return this;
            },
            setAlpha: function (alpha) {
              this.currentContext.globalAlpha = alpha;
              return this;
            },
            preRender: function () {
              var ctx = this.gameContext;
              var config = this.config;
              var width = this.width;
              var height = this.height;
              ctx.globalAlpha = 1;
              ctx.globalCompositeOperation = "source-over";
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              if (config.clearBeforeRender) {
                ctx.clearRect(0, 0, width, height);
                if (!config.transparent) {
                  ctx.fillStyle = config.backgroundColor.rgba;
                  ctx.fillRect(0, 0, width, height);
                }
              }
              ctx.save();
              this.drawCount = 0;
              this.emit(Events.PRE_RENDER);
            },
            render: function (scene, children, camera) {
              var childCount = children.length;
              this.emit(Events.RENDER, scene, camera);
              var cx = camera.x;
              var cy = camera.y;
              var cw = camera.width;
              var ch = camera.height;
              var ctx = camera.renderToTexture ? camera.context : scene.sys.context;
              ctx.save();
              if (this.game.scene.customViewports) {
                ctx.beginPath();
                ctx.rect(cx, cy, cw, ch);
                ctx.clip();
              }
              this.currentContext = ctx;
              var mask = camera.mask;
              if (mask) {
                mask.preRenderCanvas(this, null, camera._maskCamera);
              }
              if (!camera.transparent) {
                ctx.fillStyle = camera.backgroundColor.rgba;
                ctx.fillRect(cx, cy, cw, ch);
              }
              ctx.globalAlpha = camera.alpha;
              ctx.globalCompositeOperation = "source-over";
              this.drawCount += childCount;
              if (camera.renderToTexture) {
                camera.emit(CameraEvents.PRE_RENDER, camera);
              }
              camera.matrix.copyToContext(ctx);
              for (var i = 0; i < childCount; i++) {
                var child = children[i];
                if (child.mask) {
                  child.mask.preRenderCanvas(this, child, camera);
                }
                child.renderCanvas(this, child, camera);
                if (child.mask) {
                  child.mask.postRenderCanvas(this, child, camera);
                }
              }
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              ctx.globalCompositeOperation = "source-over";
              ctx.globalAlpha = 1;
              camera.flashEffect.postRenderCanvas(ctx);
              camera.fadeEffect.postRenderCanvas(ctx);
              camera.dirty = false;
              if (mask) {
                mask.postRenderCanvas(this);
              }
              ctx.restore();
              if (camera.renderToTexture) {
                camera.emit(CameraEvents.POST_RENDER, camera);
                if (camera.renderToGame) {
                  scene.sys.context.drawImage(camera.canvas, cx, cy);
                }
              }
            },
            postRender: function () {
              var ctx = this.gameContext;
              ctx.restore();
              this.emit(Events.POST_RENDER);
              var state = this.snapshotState;
              if (state.callback) {
                CanvasSnapshot(this.gameCanvas, state);
                state.callback = null;
              }
            },
            snapshotCanvas: function (canvas, callback, getPixel, x, y, width, height, type, encoderOptions) {
              if (getPixel === void 0) {
                getPixel = false;
              }
              this.snapshotArea(x, y, width, height, callback, type, encoderOptions);
              var state = this.snapshotState;
              state.getPixel = getPixel;
              CanvasSnapshot(this.canvas, state);
              state.callback = null;
              return this;
            },
            snapshot: function (callback, type, encoderOptions) {
              return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, callback, type, encoderOptions);
            },
            snapshotArea: function (x, y, width, height, callback, type, encoderOptions) {
              var state = this.snapshotState;
              state.callback = callback;
              state.type = type;
              state.encoder = encoderOptions;
              state.getPixel = false;
              state.x = x;
              state.y = y;
              state.width = Math.min(width, this.gameCanvas.width);
              state.height = Math.min(height, this.gameCanvas.height);
              return this;
            },
            snapshotPixel: function (x, y, callback) {
              this.snapshotArea(x, y, 1, 1, callback);
              this.snapshotState.getPixel = true;
              return this;
            },
            batchSprite: function (sprite, frame, camera, parentTransformMatrix) {
              var alpha = camera.alpha * sprite.alpha;
              if (alpha === 0) {
                return;
              }
              var ctx = this.currentContext;
              var camMatrix = this._tempMatrix1;
              var spriteMatrix = this._tempMatrix2;
              var cd = frame.canvasData;
              var frameX = cd.x;
              var frameY = cd.y;
              var frameWidth = frame.cutWidth;
              var frameHeight = frame.cutHeight;
              var customPivot = frame.customPivot;
              var res = frame.source.resolution;
              var displayOriginX = sprite.displayOriginX;
              var displayOriginY = sprite.displayOriginY;
              var x = -displayOriginX + frame.x;
              var y = -displayOriginY + frame.y;
              if (sprite.isCropped) {
                var crop = sprite._crop;
                if (crop.flipX !== sprite.flipX || crop.flipY !== sprite.flipY) {
                  frame.updateCropUVs(crop, sprite.flipX, sprite.flipY);
                }
                frameWidth = crop.cw;
                frameHeight = crop.ch;
                frameX = crop.cx;
                frameY = crop.cy;
                x = -displayOriginX + crop.x;
                y = -displayOriginY + crop.y;
                if (sprite.flipX) {
                  if (x >= 0) {
                    x = -(x + frameWidth);
                  } else if (x < 0) {
                    x = Math.abs(x) - frameWidth;
                  }
                }
                if (sprite.flipY) {
                  if (y >= 0) {
                    y = -(y + frameHeight);
                  } else if (y < 0) {
                    y = Math.abs(y) - frameHeight;
                  }
                }
              }
              var flipX = 1;
              var flipY = 1;
              if (sprite.flipX) {
                if (!customPivot) {
                  x += -frame.realWidth + displayOriginX * 2;
                }
                flipX = -1;
              }
              if (sprite.flipY) {
                if (!customPivot) {
                  y += -frame.realHeight + displayOriginY * 2;
                }
                flipY = -1;
              }
              spriteMatrix.applyITRS(sprite.x, sprite.y, sprite.rotation, sprite.scaleX * flipX, sprite.scaleY * flipY);
              camMatrix.copyFrom(camera.matrix);
              if (parentTransformMatrix) {
                camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * sprite.scrollFactorX, -camera.scrollY * sprite.scrollFactorY);
                spriteMatrix.e = sprite.x;
                spriteMatrix.f = sprite.y;
              } else {
                spriteMatrix.e -= camera.scrollX * sprite.scrollFactorX;
                spriteMatrix.f -= camera.scrollY * sprite.scrollFactorY;
              }
              camMatrix.multiply(spriteMatrix);
              ctx.save();
              camMatrix.setToContext(ctx);
              ctx.globalCompositeOperation = this.blendModes[sprite.blendMode];
              ctx.globalAlpha = alpha;
              ctx.imageSmoothingEnabled = !(!this.antialias || frame.source.scaleMode);
              if (sprite.mask) {
                sprite.mask.preRenderCanvas(this, sprite, camera);
              }
              ctx.drawImage(frame.source.image, frameX, frameY, frameWidth, frameHeight, x, y, frameWidth / res, frameHeight / res);
              if (sprite.mask) {
                sprite.mask.postRenderCanvas(this, sprite, camera);
              }
              ctx.restore();
            },
            destroy: function () {
              this.removeAllListeners();
              this.game = null;
              this.gameCanvas = null;
              this.gameContext = null;
            }
          });
          module2.exports = CanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var CanvasPool = __webpack_require__(31);
          var Color = __webpack_require__(38);
          var GetFastValue = __webpack_require__(2);
          var CanvasSnapshot = function (canvas, config) {
            var callback = GetFastValue(config, "callback");
            var type = GetFastValue(config, "type", "image/png");
            var encoderOptions = GetFastValue(config, "encoder", 0.92);
            var x = Math.abs(Math.round(GetFastValue(config, "x", 0)));
            var y = Math.abs(Math.round(GetFastValue(config, "y", 0)));
            var width = GetFastValue(config, "width", canvas.width);
            var height = GetFastValue(config, "height", canvas.height);
            var getPixel = GetFastValue(config, "getPixel", false);
            if (getPixel) {
              var context = canvas.getContext("2d");
              var imageData = context.getImageData(x, y, 1, 1);
              var data = imageData.data;
              callback.call(null, new Color(data[0], data[1], data[2], data[3] / 255));
            } else if (x !== 0 || y !== 0 || width !== canvas.width || height !== canvas.height) {
              var copyCanvas = CanvasPool.createWebGL(this, width, height);
              var ctx = copyCanvas.getContext("2d");
              ctx.drawImage(canvas, x, y, width, height, 0, 0, width, height);
              var image1 = new Image();
              image1.onerror = function () {
                callback.call(null);
                CanvasPool.remove(copyCanvas);
              };
              image1.onload = function () {
                callback.call(null, image1);
                CanvasPool.remove(copyCanvas);
              };
              image1.src = copyCanvas.toDataURL(type, encoderOptions);
            } else {
              var image2 = new Image();
              image2.onerror = function () {
                callback.call(null);
              };
              image2.onload = function () {
                callback.call(null, image2);
              };
              image2.src = canvas.toDataURL(type, encoderOptions);
            }
          };
          module2.exports = CanvasSnapshot;
        }, function (module2, exports2, __webpack_require__) {
          var modes = __webpack_require__(35);
          var CanvasFeatures = __webpack_require__(348);
          var GetBlendModes = function () {
            var output = [];
            var useNew = CanvasFeatures.supportNewBlendModes;
            var so = "source-over";
            output[modes.NORMAL] = so;
            output[modes.ADD] = "lighter";
            output[modes.MULTIPLY] = useNew ? "multiply" : so;
            output[modes.SCREEN] = useNew ? "screen" : so;
            output[modes.OVERLAY] = useNew ? "overlay" : so;
            output[modes.DARKEN] = useNew ? "darken" : so;
            output[modes.LIGHTEN] = useNew ? "lighten" : so;
            output[modes.COLOR_DODGE] = useNew ? "color-dodge" : so;
            output[modes.COLOR_BURN] = useNew ? "color-burn" : so;
            output[modes.HARD_LIGHT] = useNew ? "hard-light" : so;
            output[modes.SOFT_LIGHT] = useNew ? "soft-light" : so;
            output[modes.DIFFERENCE] = useNew ? "difference" : so;
            output[modes.EXCLUSION] = useNew ? "exclusion" : so;
            output[modes.HUE] = useNew ? "hue" : so;
            output[modes.SATURATION] = useNew ? "saturation" : so;
            output[modes.COLOR] = useNew ? "color" : so;
            output[modes.LUMINOSITY] = useNew ? "luminosity" : so;
            output[modes.ERASE] = "destination-out";
            output[modes.SOURCE_IN] = "source-in";
            output[modes.SOURCE_OUT] = "source-out";
            output[modes.SOURCE_ATOP] = "source-atop";
            output[modes.DESTINATION_OVER] = "destination-over";
            output[modes.DESTINATION_IN] = "destination-in";
            output[modes.DESTINATION_OUT] = "destination-out";
            output[modes.DESTINATION_ATOP] = "destination-atop";
            output[modes.LIGHTER] = "lighter";
            output[modes.COPY] = "copy";
            output[modes.XOR] = "xor";
            return output;
          };
          module2.exports = GetBlendModes;
        }, function (module2, exports2, __webpack_require__) {
          var ArrayRemove = __webpack_require__(93);
          var CameraEvents = __webpack_require__(37);
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(33);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(91);
          var GameEvents = __webpack_require__(22);
          var IsSizePowerOfTwo = __webpack_require__(138);
          var Matrix4 = __webpack_require__(69);
          var NOOP = __webpack_require__(1);
          var PipelineManager = __webpack_require__(372);
          var RenderTarget = __webpack_require__(141);
          var ScaleEvents = __webpack_require__(104);
          var TextureEvents = __webpack_require__(106);
          var Utils = __webpack_require__(12);
          var WebGLSnapshot = __webpack_require__(383);
          var WebGLRenderer = new Class({
            Extends: EventEmitter,
            initialize: function WebGLRenderer2(game) {
              EventEmitter.call(this);
              var gameConfig = game.config;
              var contextCreationConfig = {
                alpha: gameConfig.transparent,
                desynchronized: gameConfig.desynchronized,
                depth: false,
                antialias: gameConfig.antialiasGL,
                premultipliedAlpha: gameConfig.premultipliedAlpha,
                stencil: true,
                failIfMajorPerformanceCaveat: gameConfig.failIfMajorPerformanceCaveat,
                powerPreference: gameConfig.powerPreference,
                preserveDrawingBuffer: gameConfig.preserveDrawingBuffer
              };
              this.config = {
                clearBeforeRender: gameConfig.clearBeforeRender,
                antialias: gameConfig.antialias,
                backgroundColor: gameConfig.backgroundColor,
                contextCreation: contextCreationConfig,
                roundPixels: gameConfig.roundPixels,
                maxTextures: gameConfig.maxTextures,
                maxTextureSize: gameConfig.maxTextureSize,
                batchSize: gameConfig.batchSize,
                maxLights: gameConfig.maxLights,
                mipmapFilter: gameConfig.mipmapFilter
              };
              this.game = game;
              this.type = CONST.WEBGL;
              this.pipelines = null;
              this.width = 0;
              this.height = 0;
              this.canvas = game.canvas;
              this.blendModes = [];
              this.contextLost = false;
              this.snapshotState = {
                x: 0,
                y: 0,
                width: 1,
                height: 1,
                getPixel: false,
                callback: null,
                type: "image/png",
                encoder: 0.92,
                isFramebuffer: false,
                bufferWidth: 0,
                bufferHeight: 0
              };
              this.currentActiveTexture = 0;
              this.startActiveTexture = 0;
              this.maxTextures = 0;
              this.textureIndexes;
              this.tempTextures;
              this.textureZero;
              this.normalTexture;
              this.currentFramebuffer = null;
              this.fboStack = [];
              this.currentProgram = null;
              this.currentBlendMode = Infinity;
              this.currentScissorEnabled = false;
              this.currentScissor = null;
              this.scissorStack = [];
              this.contextLostHandler = NOOP;
              this.contextRestoredHandler = NOOP;
              this.gl = null;
              this.supportedExtensions = null;
              this.instancedArraysExtension = null;
              this.vaoExtension = null;
              this.extensions = {};
              this.glFormats = [];
              this.compression = {
                ETC1: false,
                PVRTC: false,
                S3TC: false
              };
              this.drawingBufferHeight = 0;
              this.blankTexture = null;
              this.whiteTexture = null;
              this.maskCount = 0;
              this.maskStack = [];
              this.currentMask = {
                mask: null,
                camera: null
              };
              this.currentCameraMask = {
                mask: null,
                camera: null
              };
              this.glFuncMap = null;
              this.currentType = "";
              this.newType = false;
              this.nextTypeMatch = false;
              this.finalType = false;
              this.mipmapFilter = null;
              this.textureFlush = 0;
              this.isTextureClean = false;
              this.defaultScissor = [0, 0, 0, 0];
              this.isBooted = false;
              this.renderTarget = null;
              this.projectionMatrix;
              this.projectionWidth = 0;
              this.projectionHeight = 0;
              this.init(this.config);
            },
            init: function (config) {
              var gl;
              var game = this.game;
              var canvas = this.canvas;
              var clearColor = config.backgroundColor;
              if (game.config.context) {
                gl = game.config.context;
              } else {
                gl = canvas.getContext("webgl", config.contextCreation) || canvas.getContext("experimental-webgl", config.contextCreation);
              }
              if (!gl || gl.isContextLost()) {
                this.contextLost = true;
                throw new Error("WebGL unsupported");
              }
              this.gl = gl;
              var _this = this;
              this.contextLostHandler = function (event) {
                _this.contextLost = true;
                _this.game.events.emit(GameEvents.CONTEXT_LOST, _this);
                event.preventDefault();
              };
              this.contextRestoredHandler = function () {
                _this.contextLost = false;
                _this.init(_this.config);
                _this.game.events.emit(GameEvents.CONTEXT_RESTORED, _this);
              };
              canvas.addEventListener("webglcontextlost", this.contextLostHandler, false);
              canvas.addEventListener("webglcontextrestored", this.contextRestoredHandler, false);
              game.context = gl;
              for (var i = 0; i <= 27; i++) {
                this.blendModes.push({
                  func: [gl.ONE, gl.ONE_MINUS_SRC_ALPHA],
                  equation: gl.FUNC_ADD
                });
              }
              this.blendModes[1].func = [gl.ONE, gl.DST_ALPHA];
              this.blendModes[2].func = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
              this.blendModes[3].func = [gl.ONE, gl.ONE_MINUS_SRC_COLOR];
              this.blendModes[17] = {
                func: [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA],
                equation: gl.FUNC_REVERSE_SUBTRACT
              };
              this.glFormats[0] = gl.BYTE;
              this.glFormats[1] = gl.SHORT;
              this.glFormats[2] = gl.UNSIGNED_BYTE;
              this.glFormats[3] = gl.UNSIGNED_SHORT;
              this.glFormats[4] = gl.FLOAT;
              this.glFuncMap = {
                mat2: {
                  func: gl.uniformMatrix2fv,
                  length: 1,
                  matrix: true
                },
                mat3: {
                  func: gl.uniformMatrix3fv,
                  length: 1,
                  matrix: true
                },
                mat4: {
                  func: gl.uniformMatrix4fv,
                  length: 1,
                  matrix: true
                },
                "1f": {
                  func: gl.uniform1f,
                  length: 1
                },
                "1fv": {
                  func: gl.uniform1fv,
                  length: 1
                },
                "1i": {
                  func: gl.uniform1i,
                  length: 1
                },
                "1iv": {
                  func: gl.uniform1iv,
                  length: 1
                },
                "2f": {
                  func: gl.uniform2f,
                  length: 2
                },
                "2fv": {
                  func: gl.uniform2fv,
                  length: 1
                },
                "2i": {
                  func: gl.uniform2i,
                  length: 2
                },
                "2iv": {
                  func: gl.uniform2iv,
                  length: 1
                },
                "3f": {
                  func: gl.uniform3f,
                  length: 3
                },
                "3fv": {
                  func: gl.uniform3fv,
                  length: 1
                },
                "3i": {
                  func: gl.uniform3i,
                  length: 3
                },
                "3iv": {
                  func: gl.uniform3iv,
                  length: 1
                },
                "4f": {
                  func: gl.uniform4f,
                  length: 4
                },
                "4fv": {
                  func: gl.uniform4fv,
                  length: 1
                },
                "4i": {
                  func: gl.uniform4i,
                  length: 4
                },
                "4iv": {
                  func: gl.uniform4iv,
                  length: 1
                }
              };
              var exts = gl.getSupportedExtensions();
              if (!config.maxTextures || config.maxTextures === -1) {
                config.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
              }
              if (!config.maxTextureSize) {
                config.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
              }
              var extString = "WEBGL_compressed_texture_";
              var wkExtString = "WEBKIT_" + extString;
              this.compression.ETC1 = gl.getExtension(extString + "etc1") || gl.getExtension(wkExtString + "etc1");
              this.compression.PVRTC = gl.getExtension(extString + "pvrtc") || gl.getExtension(wkExtString + "pvrtc");
              this.compression.S3TC = gl.getExtension(extString + "s3tc") || gl.getExtension(wkExtString + "s3tc");
              this.supportedExtensions = exts;
              var angleString = "ANGLE_instanced_arrays";
              this.instancedArraysExtension = exts.indexOf(angleString) > -1 ? gl.getExtension(angleString) : null;
              var vaoString = "OES_vertex_array_object";
              this.vaoExtension = exts.indexOf(vaoString) > -1 ? gl.getExtension(vaoString) : null;
              gl.disable(gl.DEPTH_TEST);
              gl.disable(gl.CULL_FACE);
              gl.enable(gl.BLEND);
              gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);
              this.mipmapFilter = gl[config.mipmapFilter];
              this.maxTextures = Utils.checkShaderMax(gl, config.maxTextures);
              this.textureIndexes = [];
              var tempTextures = this.tempTextures;
              if (Array.isArray(tempTextures)) {
                for (var t = 0; i < this.maxTextures; t++) {
                  gl.deleteTexture(tempTextures[t]);
                }
              } else {
                tempTextures = new Array(this.maxTextures);
              }
              for (var index = 0; index < this.maxTextures; index++) {
                var tempTexture = gl.createTexture();
                gl.activeTexture(gl.TEXTURE0 + index);
                gl.bindTexture(gl.TEXTURE_2D, tempTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));
                tempTextures[index] = tempTexture;
                this.textureIndexes.push(index);
              }
              this.tempTextures = tempTextures;
              this.currentActiveTexture = 1;
              this.startActiveTexture++;
              gl.activeTexture(gl.TEXTURE1);
              this.pipelines = new PipelineManager(this);
              this.setBlendMode(CONST.BlendModes.NORMAL);
              this.projectionMatrix = new Matrix4().identity();
              game.textures.once(TextureEvents.READY, this.boot, this);
              return this;
            },
            boot: function () {
              var game = this.game;
              var pipelineManager = this.pipelines;
              var baseSize = game.scale.baseSize;
              this.width = baseSize.width;
              this.height = baseSize.height;
              this.isBooted = true;
              this.renderTarget = new RenderTarget(this, this.width, this.height, 1, 0, true, true);
              pipelineManager.boot(game.config.pipeline);
              this.blankTexture = game.textures.getFrame("__DEFAULT");
              this.whiteTexture = game.textures.getFrame("__WHITE");
              var gl = this.gl;
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.enable(gl.SCISSOR_TEST);
              game.scale.on(ScaleEvents.RESIZE, this.onResize, this);
              this.resize(baseSize.width, baseSize.height);
            },
            onResize: function (gameSize, baseSize) {
              if (baseSize.width !== this.width || baseSize.height !== this.height) {
                this.resize(baseSize.width, baseSize.height);
              }
            },
            beginCapture: function (width, height) {
              if (width === void 0) {
                width = this.width;
              }
              if (height === void 0) {
                height = this.height;
              }
              this.renderTarget.bind(true, width, height);
              this.setProjectionMatrix(width, height);
              this.resetTextures();
            },
            endCapture: function () {
              this.renderTarget.unbind(true);
              this.resetProjectionMatrix();
              return this.renderTarget;
            },
            resize: function (width, height) {
              var gl = this.gl;
              this.width = width;
              this.height = height;
              this.setProjectionMatrix(width, height);
              gl.viewport(0, 0, width, height);
              this.drawingBufferHeight = gl.drawingBufferHeight;
              gl.scissor(0, gl.drawingBufferHeight - height, width, height);
              this.defaultScissor[2] = width;
              this.defaultScissor[3] = height;
              this.emit(Events.RESIZE, width, height);
              return this;
            },
            getAspectRatio: function () {
              return this.width / this.height;
            },
            setProjectionMatrix: function (width, height) {
              if (width !== this.projectionWidth || height !== this.projectionHeight) {
                this.projectionWidth = width;
                this.projectionHeight = height;
                this.projectionMatrix.ortho(0, width, height, 0, -1e3, 1e3);
              }
              return this;
            },
            resetProjectionMatrix: function () {
              this.projectionWidth = this.width;
              this.projectionHeight = this.height;
              this.projectionMatrix.ortho(0, this.width, this.height, 0, -1e3, 1e3);
            },
            hasExtension: function (extensionName) {
              return this.supportedExtensions ? this.supportedExtensions.indexOf(extensionName) : false;
            },
            getExtension: function (extensionName) {
              if (!this.hasExtension(extensionName)) {
                return null;
              }
              if (!((extensionName in this.extensions))) {
                this.extensions[extensionName] = this.gl.getExtension(extensionName);
              }
              return this.extensions[extensionName];
            },
            flush: function () {
              this.pipelines.flush();
            },
            pushScissor: function (x, y, width, height, drawingBufferHeight) {
              if (drawingBufferHeight === void 0) {
                drawingBufferHeight = this.drawingBufferHeight;
              }
              var scissorStack = this.scissorStack;
              var scissor = [x, y, width, height];
              scissorStack.push(scissor);
              this.setScissor(x, y, width, height, drawingBufferHeight);
              this.currentScissor = scissor;
              return scissor;
            },
            setScissor: function (x, y, width, height, drawingBufferHeight) {
              if (drawingBufferHeight === void 0) {
                drawingBufferHeight = this.drawingBufferHeight;
              }
              var gl = this.gl;
              var current = this.currentScissor;
              var setScissor = width > 0 && height > 0;
              if (current && setScissor) {
                var cx = current[0];
                var cy = current[1];
                var cw = current[2];
                var ch = current[3];
                setScissor = cx !== x || cy !== y || cw !== width || ch !== height;
              }
              if (setScissor) {
                this.flush();
                gl.scissor(x, drawingBufferHeight - y - height, width, height);
              }
            },
            resetScissor: function () {
              var gl = this.gl;
              gl.enable(gl.SCISSOR_TEST);
              var current = this.currentScissor;
              if (current) {
                var x = current[0];
                var y = current[1];
                var width = current[2];
                var height = current[3];
                if (width > 0 && height > 0) {
                  gl.scissor(x, this.drawingBufferHeight - y - height, width, height);
                }
              }
            },
            popScissor: function () {
              var scissorStack = this.scissorStack;
              scissorStack.pop();
              var scissor = scissorStack[scissorStack.length - 1];
              if (scissor) {
                this.setScissor(scissor[0], scissor[1], scissor[2], scissor[3]);
              }
              this.currentScissor = scissor;
            },
            hasActiveStencilMask: function () {
              var mask = this.currentMask.mask;
              var camMask = this.currentCameraMask.mask;
              return mask && mask.isStencil || camMask && camMask.isStencil;
            },
            resetViewport: function () {
              var gl = this.gl;
              gl.viewport(0, 0, this.width, this.height);
              this.drawingBufferHeight = gl.drawingBufferHeight;
            },
            setBlendMode: function (blendModeId, force) {
              if (force === void 0) {
                force = false;
              }
              var gl = this.gl;
              var blendMode = this.blendModes[blendModeId];
              if (force || blendModeId !== CONST.BlendModes.SKIP_CHECK && this.currentBlendMode !== blendModeId) {
                this.flush();
                gl.enable(gl.BLEND);
                gl.blendEquation(blendMode.equation);
                if (blendMode.func.length > 2) {
                  gl.blendFuncSeparate(blendMode.func[0], blendMode.func[1], blendMode.func[2], blendMode.func[3]);
                } else {
                  gl.blendFunc(blendMode.func[0], blendMode.func[1]);
                }
                this.currentBlendMode = blendModeId;
                return true;
              }
              return false;
            },
            addBlendMode: function (func, equation) {
              var index = this.blendModes.push({
                func,
                equation
              });
              return index - 1;
            },
            updateBlendMode: function (index, func, equation) {
              if (this.blendModes[index]) {
                this.blendModes[index].func = func;
                if (equation) {
                  this.blendModes[index].equation = equation;
                }
              }
              return this;
            },
            removeBlendMode: function (index) {
              if (index > 17 && this.blendModes[index]) {
                this.blendModes.splice(index, 1);
              }
              return this;
            },
            setBlankTexture: function () {
              this.setTexture2D(this.blankTexture.glTexture);
            },
            setTextureSource: function (textureSource) {
              if (this.pipelines.forceZero()) {
                this.setTextureZero(textureSource.glTexture, true);
                return 0;
              }
              var gl = this.gl;
              var currentActiveTexture = this.currentActiveTexture;
              if (textureSource.glIndexCounter < this.startActiveTexture) {
                textureSource.glIndexCounter = this.startActiveTexture;
                if (currentActiveTexture < this.maxTextures) {
                  textureSource.glIndex = currentActiveTexture;
                  gl.activeTexture(gl.TEXTURE0 + currentActiveTexture);
                  gl.bindTexture(gl.TEXTURE_2D, textureSource.glTexture);
                  this.currentActiveTexture++;
                } else {
                  this.flush();
                  this.startActiveTexture++;
                  this.textureFlush++;
                  textureSource.glIndexCounter = this.startActiveTexture;
                  textureSource.glIndex = 1;
                  gl.activeTexture(gl.TEXTURE1);
                  gl.bindTexture(gl.TEXTURE_2D, textureSource.glTexture);
                  this.currentActiveTexture = 2;
                }
              }
              this.isTextureClean = false;
              return textureSource.glIndex;
            },
            isNewNormalMap: function (texture, normalMap) {
              return this.textureZero !== texture || this.normalTexture !== normalMap;
            },
            setTextureZero: function (texture, flush) {
              if (this.textureZero !== texture) {
                if (flush) {
                  this.flush();
                }
                var gl = this.gl;
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                this.textureZero = texture;
              }
            },
            clearTextureZero: function () {
              this.textureZero = null;
            },
            setNormalMap: function (texture) {
              if (this.normalTexture !== texture) {
                var gl = this.gl;
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                this.normalTexture = texture;
                if (this.currentActiveTexture === 1) {
                  this.currentActiveTexture = 2;
                }
              }
            },
            clearNormalMap: function () {
              this.normalTexture = null;
              this.startActiveTexture++;
              this.currentActiveTexture = 1;
              this.textureFlush++;
            },
            unbindTextures: function () {
              var gl = this.gl;
              var temp = this.tempTextures;
              for (var i = 0; i < temp.length; i++) {
                gl.activeTexture(gl.TEXTURE0 + i);
                gl.bindTexture(gl.TEXTURE_2D, null);
              }
              this.normalTexture = null;
              this.textureZero = null;
              this.currentActiveTexture = 1;
              this.startActiveTexture++;
              this.textureFlush++;
            },
            resetTextures: function (all) {
              if (all === void 0) {
                all = false;
              }
              if (this.isTextureClean) {
                return;
              }
              this.flush();
              var gl = this.gl;
              var temp = this.tempTextures;
              if (all) {
                for (var i = 0; i < temp.length; i++) {
                  gl.activeTexture(gl.TEXTURE0 + i);
                  gl.bindTexture(gl.TEXTURE_2D, temp[i]);
                }
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, temp[1]);
                this.isTextureClean = true;
              } else {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, temp[0]);
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, temp[1]);
              }
              this.normalTexture = null;
              this.textureZero = null;
              this.currentActiveTexture = 1;
              this.startActiveTexture++;
              this.textureFlush++;
            },
            setTexture2D: function (texture) {
              if (this.pipelines.forceZero()) {
                this.setTextureZero(texture, true);
                return 0;
              }
              var gl = this.gl;
              var currentActiveTexture = this.currentActiveTexture;
              if (texture.glIndexCounter < this.startActiveTexture) {
                texture.glIndexCounter = this.startActiveTexture;
                if (currentActiveTexture < this.maxTextures) {
                  texture.glIndex = currentActiveTexture;
                  gl.activeTexture(gl.TEXTURE0 + currentActiveTexture);
                  gl.bindTexture(gl.TEXTURE_2D, texture);
                  this.currentActiveTexture++;
                } else {
                  this.flush();
                  this.startActiveTexture++;
                  this.textureFlush++;
                  texture.glIndexCounter = this.startActiveTexture;
                  texture.glIndex = 1;
                  gl.activeTexture(gl.TEXTURE1);
                  gl.bindTexture(gl.TEXTURE_2D, texture);
                  this.currentActiveTexture = 2;
                }
              }
              this.isTextureClean = false;
              return texture.glIndex;
            },
            pushFramebuffer: function (framebuffer, updateScissor, resetTextures, setViewport) {
              if (framebuffer === this.currentFramebuffer) {
                return this;
              }
              this.fboStack.push(framebuffer);
              return this.setFramebuffer(framebuffer, updateScissor, resetTextures, setViewport);
            },
            setFramebuffer: function (framebuffer, updateScissor, resetTextures, setViewport) {
              if (updateScissor === void 0) {
                updateScissor = false;
              }
              if (resetTextures === void 0) {
                resetTextures = false;
              }
              if (setViewport === void 0) {
                setViewport = true;
              }
              if (framebuffer === this.currentFramebuffer) {
                return this;
              }
              var gl = this.gl;
              var width = this.width;
              var height = this.height;
              if (framebuffer && framebuffer.renderTexture && setViewport) {
                width = framebuffer.renderTexture.width;
                height = framebuffer.renderTexture.height;
              } else {
                this.flush();
              }
              gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
              if (setViewport) {
                gl.viewport(0, 0, width, height);
              }
              if (updateScissor) {
                if (framebuffer) {
                  this.drawingBufferHeight = height;
                  this.pushScissor(0, 0, width, height);
                } else {
                  this.drawingBufferHeight = this.height;
                  this.popScissor();
                }
              }
              this.currentFramebuffer = framebuffer;
              if (resetTextures) {
                this.resetTextures();
              }
              return this;
            },
            popFramebuffer: function (updateScissor, resetTextures, setViewport) {
              if (updateScissor === void 0) {
                updateScissor = false;
              }
              if (resetTextures === void 0) {
                resetTextures = false;
              }
              if (setViewport === void 0) {
                setViewport = true;
              }
              var fboStack = this.fboStack;
              fboStack.pop();
              var framebuffer = fboStack[fboStack.length - 1];
              if (!framebuffer) {
                framebuffer = null;
              }
              this.setFramebuffer(framebuffer, updateScissor, resetTextures, setViewport);
              return framebuffer;
            },
            setProgram: function (program) {
              if (program !== this.currentProgram) {
                this.flush();
                this.gl.useProgram(program);
                this.currentProgram = program;
                return true;
              }
              return false;
            },
            resetProgram: function () {
              this.gl.useProgram(this.currentProgram);
              return this;
            },
            createTextureFromSource: function (source, width, height, scaleMode) {
              var gl = this.gl;
              var minFilter = gl.NEAREST;
              var magFilter = gl.NEAREST;
              var wrap = gl.CLAMP_TO_EDGE;
              var texture = null;
              width = source ? source.width : width;
              height = source ? source.height : height;
              var pow = IsSizePowerOfTwo(width, height);
              if (pow) {
                wrap = gl.REPEAT;
              }
              if (scaleMode === CONST.ScaleModes.LINEAR && this.config.antialias) {
                minFilter = pow ? this.mipmapFilter : gl.LINEAR;
                magFilter = gl.LINEAR;
              }
              if (!source && typeof width === "number" && typeof height === "number") {
                texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, null, width, height);
              } else {
                texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, source);
              }
              return texture;
            },
            createTexture2D: function (mipLevel, minFilter, magFilter, wrapT, wrapS, format, pixels, width, height, pma, forceSize, flipY) {
              pma = pma === void 0 || pma === null ? true : pma;
              if (forceSize === void 0) {
                forceSize = false;
              }
              if (flipY === void 0) {
                flipY = false;
              }
              var gl = this.gl;
              var texture = gl.createTexture();
              gl.activeTexture(gl.TEXTURE0);
              var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
              gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, pma);
              gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
              if (pixels === null || pixels === void 0) {
                gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, width, height, 0, format, gl.UNSIGNED_BYTE, null);
              } else {
                if (!forceSize) {
                  width = pixels.width;
                  height = pixels.height;
                }
                gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, format, gl.UNSIGNED_BYTE, pixels);
              }
              if (IsSizePowerOfTwo(width, height)) {
                gl.generateMipmap(gl.TEXTURE_2D);
              }
              if (currentTexture) {
                gl.bindTexture(gl.TEXTURE_2D, currentTexture);
              }
              texture.isAlphaPremultiplied = pma;
              texture.isRenderTexture = false;
              texture.width = width;
              texture.height = height;
              texture.glIndex = 0;
              texture.glIndexCounter = -1;
              return texture;
            },
            createFramebuffer: function (width, height, renderTexture, addDepthStencilBuffer) {
              var gl = this.gl;
              var framebuffer = gl.createFramebuffer();
              var complete = 0;
              this.setFramebuffer(framebuffer);
              if (addDepthStencilBuffer) {
                var depthStencilBuffer = gl.createRenderbuffer();
                gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilBuffer);
                gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilBuffer);
              }
              renderTexture.isRenderTexture = true;
              renderTexture.isAlphaPremultiplied = false;
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture, 0);
              complete = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
              if (complete !== gl.FRAMEBUFFER_COMPLETE) {
                var errors = {
                  36054: "Incomplete Attachment",
                  36055: "Missing Attachment",
                  36057: "Incomplete Dimensions",
                  36061: "Framebuffer Unsupported"
                };
                throw new Error("Framebuffer status: " + errors[complete]);
              }
              framebuffer.renderTexture = renderTexture;
              this.setFramebuffer(null);
              this.resetTextures();
              return framebuffer;
            },
            createProgram: function (vertexShader, fragmentShader) {
              var gl = this.gl;
              var program = gl.createProgram();
              var vs = gl.createShader(gl.VERTEX_SHADER);
              var fs = gl.createShader(gl.FRAGMENT_SHADER);
              gl.shaderSource(vs, vertexShader);
              gl.shaderSource(fs, fragmentShader);
              gl.compileShader(vs);
              gl.compileShader(fs);
              if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
                throw new Error("Vertex Shader failed:\n" + gl.getShaderInfoLog(vs));
              }
              if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
                throw new Error("Fragment Shader failed:\n" + gl.getShaderInfoLog(fs));
              }
              gl.attachShader(program, vs);
              gl.attachShader(program, fs);
              gl.linkProgram(program);
              if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                throw new Error("Link Program failed:\n" + gl.getProgramInfoLog(program));
              }
              gl.useProgram(program);
              return program;
            },
            createVertexBuffer: function (initialDataOrSize, bufferUsage) {
              var gl = this.gl;
              var vertexBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
              gl.bufferData(gl.ARRAY_BUFFER, initialDataOrSize, bufferUsage);
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              return vertexBuffer;
            },
            createIndexBuffer: function (initialDataOrSize, bufferUsage) {
              var gl = this.gl;
              var indexBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, initialDataOrSize, bufferUsage);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              return indexBuffer;
            },
            deleteTexture: function (texture, reset) {
              if (reset) {
                this.resetTextures(true);
              }
              if (texture) {
                this.gl.deleteTexture(texture);
              }
              return this;
            },
            deleteFramebuffer: function (framebuffer) {
              if (framebuffer) {
                this.gl.deleteFramebuffer(framebuffer);
                ArrayRemove(this.fboStack, framebuffer);
                if (this.currentFramebuffer === framebuffer) {
                  this.currentFramebuffer = null;
                }
              }
              return this;
            },
            deleteProgram: function (program) {
              if (program) {
                this.gl.deleteProgram(program);
              }
              return this;
            },
            deleteBuffer: function (buffer) {
              this.gl.deleteBuffer(buffer);
              return this;
            },
            preRenderCamera: function (camera) {
              var cx = camera.x;
              var cy = camera.y;
              var cw = camera.width;
              var ch = camera.height;
              var color = camera.backgroundColor;
              camera.emit(CameraEvents.PRE_RENDER, camera);
              this.pipelines.preBatchCamera(camera);
              this.pushScissor(cx, cy, cw, ch);
              if (camera.mask) {
                this.currentCameraMask.mask = camera.mask;
                this.currentCameraMask.camera = camera._maskCamera;
                camera.mask.preRenderWebGL(this, camera, camera._maskCamera);
              }
              if (color.alphaGL > 0) {
                var pipeline = this.pipelines.setMulti();
                pipeline.drawFillRect(cx, cy, cw, ch, Utils.getTintFromFloats(color.blueGL, color.greenGL, color.redGL, 1), color.alphaGL);
              }
            },
            getCurrentStencilMask: function () {
              var prev = null;
              var stack = this.maskStack;
              var cameraMask = this.currentCameraMask;
              if (stack.length > 0) {
                prev = stack[stack.length - 1];
              } else if (cameraMask.mask && cameraMask.mask.isStencil) {
                prev = cameraMask;
              }
              return prev;
            },
            postRenderCamera: function (camera) {
              var flashEffect = camera.flashEffect;
              var fadeEffect = camera.fadeEffect;
              if (flashEffect.isRunning || (fadeEffect.isRunning || fadeEffect.isComplete)) {
                var pipeline = this.pipelines.setMulti();
                flashEffect.postRenderWebGL(pipeline, Utils.getTintFromFloats);
                fadeEffect.postRenderWebGL(pipeline, Utils.getTintFromFloats);
              }
              camera.dirty = false;
              this.popScissor();
              if (camera.mask) {
                this.currentCameraMask.mask = null;
                camera.mask.postRenderWebGL(this, camera._maskCamera);
              }
              this.pipelines.postBatchCamera(camera);
              camera.emit(CameraEvents.POST_RENDER, camera);
            },
            preRender: function () {
              if (this.contextLost) {
                return;
              }
              var gl = this.gl;
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              if (this.config.clearBeforeRender) {
                var clearColor = this.config.backgroundColor;
                gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
              }
              gl.enable(gl.SCISSOR_TEST);
              this.currentScissor = this.defaultScissor;
              this.scissorStack.length = 0;
              this.scissorStack.push(this.currentScissor);
              if (this.game.scene.customViewports) {
                gl.scissor(0, this.drawingBufferHeight - this.height, this.width, this.height);
              }
              this.currentMask.mask = null;
              this.currentCameraMask.mask = null;
              this.maskStack.length = 0;
              this.textureFlush = 0;
              this.emit(Events.PRE_RENDER);
            },
            render: function (scene, children, camera) {
              if (this.contextLost) {
                return;
              }
              var childCount = children.length;
              this.emit(Events.RENDER, scene, camera);
              this.preRenderCamera(camera);
              if (childCount === 0) {
                this.setBlendMode(CONST.BlendModes.NORMAL);
                this.postRenderCamera(camera);
                return;
              }
              this.currentType = "";
              var current = this.currentMask;
              for (var i = 0; i < childCount; i++) {
                this.finalType = i === childCount - 1;
                var child = children[i];
                var mask = child.mask;
                current = this.currentMask;
                if (current.mask && current.mask !== mask) {
                  current.mask.postRenderWebGL(this, current.camera);
                }
                if (mask && current.mask !== mask) {
                  mask.preRenderWebGL(this, child, camera);
                }
                if (child.blendMode !== this.currentBlendMode) {
                  this.setBlendMode(child.blendMode);
                }
                var type = child.type;
                if (type !== this.currentType) {
                  this.newType = true;
                  this.currentType = type;
                }
                if (!this.finalType) {
                  this.nextTypeMatch = children[i + 1].type === this.currentType;
                } else {
                  this.nextTypeMatch = false;
                }
                child.renderWebGL(this, child, camera);
                this.newType = false;
              }
              current = this.currentMask;
              if (current.mask) {
                current.mask.postRenderWebGL(this, current.camera);
              }
              this.setBlendMode(CONST.BlendModes.NORMAL);
              this.postRenderCamera(camera);
            },
            postRender: function () {
              if (this.contextLost) {
                return;
              }
              this.flush();
              this.emit(Events.POST_RENDER);
              var state = this.snapshotState;
              if (state.callback) {
                WebGLSnapshot(this.canvas, state);
                state.callback = null;
              }
              if (this.textureFlush > 0) {
                this.startActiveTexture++;
                this.currentActiveTexture = 1;
              }
            },
            snapshot: function (callback, type, encoderOptions) {
              return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, callback, type, encoderOptions);
            },
            snapshotArea: function (x, y, width, height, callback, type, encoderOptions) {
              var state = this.snapshotState;
              state.callback = callback;
              state.type = type;
              state.encoder = encoderOptions;
              state.getPixel = false;
              state.x = x;
              state.y = y;
              state.width = Math.min(width, this.gl.drawingBufferWidth);
              state.height = Math.min(height, this.gl.drawingBufferHeight);
              return this;
            },
            snapshotPixel: function (x, y, callback) {
              this.snapshotArea(x, y, 1, 1, callback);
              this.snapshotState.getPixel = true;
              return this;
            },
            snapshotFramebuffer: function (framebuffer, bufferWidth, bufferHeight, callback, getPixel, x, y, width, height, type, encoderOptions) {
              if (getPixel === void 0) {
                getPixel = false;
              }
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = bufferWidth;
              }
              if (height === void 0) {
                height = bufferHeight;
              }
              var currentFramebuffer = this.currentFramebuffer;
              this.snapshotArea(x, y, width, height, callback, type, encoderOptions);
              var state = this.snapshotState;
              state.getPixel = getPixel;
              state.isFramebuffer = true;
              state.bufferWidth = bufferWidth;
              state.bufferHeight = bufferHeight;
              this.setFramebuffer(framebuffer);
              WebGLSnapshot(this.canvas, state);
              this.setFramebuffer(currentFramebuffer);
              state.callback = null;
              state.isFramebuffer = false;
              return this;
            },
            canvasToTexture: function (srcCanvas, dstTexture, noRepeat, flipY) {
              if (noRepeat === void 0) {
                noRepeat = false;
              }
              if (flipY === void 0) {
                flipY = false;
              }
              if (!dstTexture) {
                return this.createCanvasTexture(srcCanvas, noRepeat, flipY);
              } else {
                return this.updateCanvasTexture(srcCanvas, dstTexture, flipY);
              }
            },
            createCanvasTexture: function (srcCanvas, noRepeat, flipY) {
              if (noRepeat === void 0) {
                noRepeat = false;
              }
              if (flipY === void 0) {
                flipY = false;
              }
              var gl = this.gl;
              var minFilter = gl.NEAREST;
              var magFilter = gl.NEAREST;
              var width = srcCanvas.width;
              var height = srcCanvas.height;
              var wrapping = gl.CLAMP_TO_EDGE;
              var pow = IsSizePowerOfTwo(width, height);
              if (!noRepeat && pow) {
                wrapping = gl.REPEAT;
              }
              if (this.config.antialias) {
                minFilter = pow ? this.mipmapFilter : gl.LINEAR;
                magFilter = gl.LINEAR;
              }
              return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcCanvas, width, height, true, false, flipY);
            },
            updateCanvasTexture: function (srcCanvas, dstTexture, flipY) {
              if (flipY === void 0) {
                flipY = false;
              }
              var gl = this.gl;
              var width = srcCanvas.width;
              var height = srcCanvas.height;
              if (width > 0 && height > 0) {
                gl.activeTexture(gl.TEXTURE0);
                var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
                gl.bindTexture(gl.TEXTURE_2D, dstTexture);
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas);
                dstTexture.width = width;
                dstTexture.height = height;
                if (currentTexture) {
                  gl.bindTexture(gl.TEXTURE_2D, currentTexture);
                }
              }
              return dstTexture;
            },
            createVideoTexture: function (srcVideo, noRepeat, flipY) {
              if (noRepeat === void 0) {
                noRepeat = false;
              }
              if (flipY === void 0) {
                flipY = false;
              }
              var gl = this.gl;
              var minFilter = gl.NEAREST;
              var magFilter = gl.NEAREST;
              var width = srcVideo.videoWidth;
              var height = srcVideo.videoHeight;
              var wrapping = gl.CLAMP_TO_EDGE;
              var pow = IsSizePowerOfTwo(width, height);
              if (!noRepeat && pow) {
                wrapping = gl.REPEAT;
              }
              if (this.config.antialias) {
                minFilter = pow ? this.mipmapFilter : gl.LINEAR;
                magFilter = gl.LINEAR;
              }
              return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcVideo, width, height, true, true, flipY);
            },
            updateVideoTexture: function (srcVideo, dstTexture, flipY) {
              if (flipY === void 0) {
                flipY = false;
              }
              var gl = this.gl;
              var width = srcVideo.videoWidth;
              var height = srcVideo.videoHeight;
              if (width > 0 && height > 0) {
                gl.activeTexture(gl.TEXTURE0);
                var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
                gl.bindTexture(gl.TEXTURE_2D, dstTexture);
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcVideo);
                dstTexture.width = width;
                dstTexture.height = height;
                if (currentTexture) {
                  gl.bindTexture(gl.TEXTURE_2D, currentTexture);
                }
              }
              return dstTexture;
            },
            setTextureFilter: function (texture, filter) {
              var gl = this.gl;
              var glFilter = [gl.LINEAR, gl.NEAREST][filter];
              gl.activeTexture(gl.TEXTURE0);
              var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glFilter);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glFilter);
              if (currentTexture) {
                gl.bindTexture(gl.TEXTURE_2D, currentTexture);
              }
              return this;
            },
            getMaxTextureSize: function () {
              return this.config.maxTextureSize;
            },
            destroy: function () {
              this.canvas.removeEventListener("webglcontextlost", this.contextLostHandler, false);
              this.canvas.removeEventListener("webglcontextrestored", this.contextRestoredHandler, false);
              var gl = this.gl;
              var temp = this.tempTextures;
              for (var i = 0; i < temp.length; i++) {
                gl.deleteTexture(temp[i]);
              }
              this.pipelines.destroy();
              this.removeAllListeners();
              this.fboStack = [];
              this.maskStack = [];
              this.extensions = {};
              this.textureIndexes = [];
              this.gl = null;
              this.game = null;
              this.canvas = null;
              this.contextLost = true;
              this.currentMask = null;
              this.currentCameraMask = null;
            }
          });
          module2.exports = WebGLRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(92);
          var CustomMap = __webpack_require__(102);
          var BitmapMaskPipeline = __webpack_require__(373);
          var GraphicsPipeline = __webpack_require__(376);
          var LightPipeline = __webpack_require__(377);
          var MultiPipeline = __webpack_require__(108);
          var PointLightPipeline = __webpack_require__(378);
          var RopePipeline = __webpack_require__(379);
          var SinglePipeline = __webpack_require__(380);
          var UtilityPipeline = __webpack_require__(381);
          var PipelineManager = new Class({
            initialize: function PipelineManager2(renderer) {
              this.game = renderer.game;
              this.renderer = renderer;
              this.classes = new CustomMap([[CONST.UTILITY_PIPELINE, UtilityPipeline], [CONST.MULTI_PIPELINE, MultiPipeline], [CONST.BITMAPMASK_PIPELINE, BitmapMaskPipeline], [CONST.SINGLE_PIPELINE, SinglePipeline], [CONST.ROPE_PIPELINE, RopePipeline], [CONST.LIGHT_PIPELINE, LightPipeline], [CONST.POINTLIGHT_PIPELINE, PointLightPipeline], [CONST.GRAPHICS_PIPELINE, GraphicsPipeline]]);
              this.postPipelineClasses = new CustomMap();
              this.pipelines = new CustomMap();
              this.current = null;
              this.previous = null;
              this.MULTI_PIPELINE = null;
              this.BITMAPMASK_PIPELINE = null;
              this.UTILITY_PIPELINE = null;
              this.fullFrame1;
              this.fullFrame2;
              this.halfFrame1;
              this.halfFrame2;
            },
            boot: function (pipelineConfig) {
              var instance;
              var pipelineName;
              var _this = this;
              var game = this.game;
              this.classes.each(function (pipelineName2, pipeline) {
                instance = _this.add(pipelineName2, new pipeline({
                  game
                }));
                if (pipelineName2 === CONST.UTILITY_PIPELINE) {
                  _this.UTILITY_PIPELINE = instance;
                  _this.fullFrame1 = instance.fullFrame1;
                  _this.fullFrame2 = instance.fullFrame2;
                  _this.halfFrame1 = instance.halfFrame1;
                  _this.halfFrame2 = instance.halfFrame2;
                }
              });
              this.MULTI_PIPELINE = this.get(CONST.MULTI_PIPELINE);
              this.BITMAPMASK_PIPELINE = this.get(CONST.BITMAPMASK_PIPELINE);
              if (pipelineConfig) {
                for (pipelineName in pipelineConfig) {
                  var pipelineClass = pipelineConfig[pipelineName];
                  instance = new pipelineClass(game);
                  if (instance.isPostFX) {
                    this.postPipelineClasses.set(pipelineName, pipelineClass);
                  } else if (!this.has(pipelineName)) {
                    this.classes.set(pipelineName, pipelineClass);
                    this.add(pipelineName, instance);
                  }
                }
              }
            },
            add: function (name, pipeline) {
              if (pipeline.isPostFX) {
                console.warn(name + " is a Post Pipeline. Use `addPostPipeline` instead");
                return;
              }
              var pipelines = this.pipelines;
              var renderer = this.renderer;
              if (!pipelines.has(name)) {
                pipeline.name = name;
                pipeline.manager = this;
                pipelines.set(name, pipeline);
              } else {
                console.warn("Pipeline exists: " + name);
              }
              if (!pipeline.hasBooted) {
                pipeline.boot();
              }
              if (renderer.width !== 0 && renderer.height !== 0) {
                pipeline.resize(renderer.width, renderer.height);
              }
              return pipeline;
            },
            addPostPipeline: function (name, pipeline) {
              if (!this.postPipelineClasses.has(name)) {
                this.postPipelineClasses.set(name, pipeline);
              }
            },
            flush: function () {
              if (this.current) {
                this.current.flush();
              }
            },
            has: function (pipeline) {
              var pipelines = this.pipelines;
              if (typeof pipeline === "string") {
                return pipelines.has(pipeline);
              } else if (pipelines.contains(pipeline)) {
                return true;
              }
              return false;
            },
            get: function (pipeline) {
              var pipelines = this.pipelines;
              if (typeof pipeline === "string") {
                return pipelines.get(pipeline);
              } else if (pipelines.contains(pipeline)) {
                return pipeline;
              }
            },
            getPostPipeline: function (pipeline, gameObject) {
              var pipelineClasses = this.postPipelineClasses;
              var instance;
              if (typeof pipeline === "string") {
                instance = pipelineClasses.get(pipeline);
              } else if (typeof pipeline === "function") {
                if (pipelineClasses.contains(pipeline)) {
                  instance = pipeline;
                }
              } else if (typeof pipeline === "object") {
                instance = pipelineClasses.get(pipeline.name);
              }
              if (instance) {
                var newPipeline = new instance(this.game);
                if (gameObject) {
                  newPipeline.gameObject = gameObject;
                }
                return newPipeline;
              }
            },
            remove: function (name, removeClass, removePostPipelineClass) {
              if (removeClass === void 0) {
                removeClass = true;
              }
              if (removePostPipelineClass === void 0) {
                removePostPipelineClass = true;
              }
              this.pipelines.delete(name);
              if (removeClass) {
                this.classes.delete(name);
              }
              if (removePostPipelineClass) {
                this.postPipelineClasses.delete(name);
              }
            },
            set: function (pipeline, gameObject, currentShader) {
              if (pipeline.isPostFX) {
                return;
              }
              if (!this.isCurrent(pipeline, currentShader)) {
                this.flush();
                if (this.current) {
                  this.current.unbind();
                }
                this.current = pipeline;
                pipeline.bind(currentShader);
              }
              pipeline.updateProjectionMatrix();
              pipeline.onBind(gameObject);
              return pipeline;
            },
            preBatch: function (gameObject) {
              if (gameObject.hasPostPipeline) {
                this.flush();
                var pipelines = gameObject.postPipelines;
                for (var i = pipelines.length - 1; i >= 0; i--) {
                  var pipeline = pipelines[i];
                  if (pipeline.active) {
                    pipeline.preBatch(gameObject);
                  }
                }
              }
            },
            postBatch: function (gameObject) {
              if (gameObject.hasPostPipeline) {
                this.flush();
                var pipelines = gameObject.postPipelines;
                for (var i = 0; i < pipelines.length; i++) {
                  var pipeline = pipelines[i];
                  if (pipeline.active) {
                    pipeline.postBatch(gameObject);
                  }
                }
              }
            },
            preBatchCamera: function (camera) {
              if (camera.hasPostPipeline) {
                this.flush();
                var pipelines = camera.postPipelines;
                for (var i = pipelines.length - 1; i >= 0; i--) {
                  var pipeline = pipelines[i];
                  if (pipeline.active) {
                    pipeline.preBatch(camera);
                  }
                }
              }
            },
            postBatchCamera: function (camera) {
              if (camera.hasPostPipeline) {
                this.flush();
                var pipelines = camera.postPipelines;
                for (var i = 0; i < pipelines.length; i++) {
                  var pipeline = pipelines[i];
                  if (pipeline.active) {
                    pipeline.postBatch(camera);
                  }
                }
              }
            },
            isCurrent: function (pipeline, currentShader) {
              var renderer = this.renderer;
              var current = this.current;
              if (current && !currentShader) {
                currentShader = current.currentShader;
              }
              return !(current !== pipeline || currentShader.program !== renderer.currentProgram);
            },
            copyFrame: function (source, target, brightness, clear, clearAlpha) {
              this.setUtility(this.UTILITY_PIPELINE.copyShader).copyFrame(source, target, brightness, clear, clearAlpha);
              return this;
            },
            copyToGame: function (source) {
              this.setUtility(this.UTILITY_PIPELINE.copyShader).copyToGame(source);
              return this;
            },
            drawFrame: function (source, target, clearAlpha, colorMatrix) {
              this.setUtility(this.UTILITY_PIPELINE.colorMatrixShader).drawFrame(source, target, clearAlpha, colorMatrix);
              return this;
            },
            blendFrames: function (source1, source2, target, strength, clearAlpha) {
              this.setUtility(this.UTILITY_PIPELINE.linearShader).blendFrames(source1, source2, target, strength, clearAlpha);
              return this;
            },
            blendFramesAdditive: function (source1, source2, target, strength, clearAlpha) {
              this.setUtility(this.UTILITY_PIPELINE.addShader).blendFramesAdditive(source1, source2, target, strength, clearAlpha);
              return this;
            },
            clearFrame: function (target, clearAlpha) {
              this.UTILITY_PIPELINE.clearFrame(target, clearAlpha);
              return this;
            },
            blitFrame: function (source, target, brightness, clear, clearAlpha, eraseMode) {
              this.setUtility(this.UTILITY_PIPELINE.copyShader).blitFrame(source, target, brightness, clear, clearAlpha, eraseMode);
              return this;
            },
            copyFrameRect: function (source, target, x, y, width, height, clear, clearAlpha) {
              this.UTILITY_PIPELINE.copyFrameRect(source, target, x, y, width, height, clear, clearAlpha);
              return this;
            },
            forceZero: function () {
              return this.current && this.current.forceZero;
            },
            setMulti: function () {
              return this.set(this.MULTI_PIPELINE);
            },
            setUtility: function (currentShader) {
              return this.UTILITY_PIPELINE.bind(currentShader);
            },
            rebind: function (pipeline) {
              if (pipeline === void 0 && this.previous) {
                pipeline = this.previous;
              }
              var renderer = this.renderer;
              var gl = renderer.gl;
              gl.disable(gl.DEPTH_TEST);
              gl.disable(gl.CULL_FACE);
              if (renderer.hasActiveStencilMask()) {
                gl.clear(gl.DEPTH_BUFFER_BIT);
              } else {
                gl.disable(gl.STENCIL_TEST);
                gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
              }
              gl.viewport(0, 0, renderer.width, renderer.height);
              renderer.currentProgram = null;
              renderer.setBlendMode(0, true);
              var entries = this.pipelines.entries;
              for (var key in entries) {
                entries[key].glReset = true;
              }
              if (pipeline) {
                this.current = pipeline;
                pipeline.rebind();
              }
              renderer.resetTextures();
            },
            clear: function () {
              var renderer = this.renderer;
              this.flush();
              if (this.current) {
                this.current.unbind();
                this.previous = this.current;
                this.current = null;
              } else {
                this.previous = null;
              }
              renderer.currentProgram = null;
              renderer.setBlendMode(0, true);
            },
            destroy: function () {
              this.flush();
              this.classes.clear();
              this.postPipelineClasses.clear();
              this.pipelines.clear();
              this.renderer = null;
              this.game = null;
              this.classes = null;
              this.postPipelineClasses = null;
              this.pipelines = null;
              this.current = null;
              this.previous = null;
            }
          });
          module2.exports = PipelineManager;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var ShaderSourceFS = __webpack_require__(866);
          var ShaderSourceVS = __webpack_require__(867);
          var WEBGL_CONST = __webpack_require__(107);
          var WebGLPipeline = __webpack_require__(58);
          var BitmapMaskPipeline = new Class({
            Extends: WebGLPipeline,
            initialize: function BitmapMaskPipeline2(config) {
              (config.fragShader = GetFastValue(config, "fragShader", ShaderSourceFS), config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS), config.batchSize = GetFastValue(config, "batchSize", 1), config.vertices = GetFastValue(config, "vertices", [-1, 1, -1, -7, 7, 1]), config.attributes = GetFastValue(config, "attributes", [{
                name: "inPosition",
                size: 2,
                type: WEBGL_CONST.FLOAT
              }]));
              WebGLPipeline.call(this, config);
            },
            boot: function () {
              WebGLPipeline.prototype.boot.call(this);
              this.set1i("uMainSampler", 0);
              this.set1i("uMaskSampler", 1);
            },
            resize: function (width, height) {
              WebGLPipeline.prototype.resize.call(this, width, height);
              this.set2f("uResolution", width, height);
            },
            beginMask: function (mask, maskedObject, camera) {
              var gl = this.gl;
              if (mask.bitmapMask && gl) {
                var renderer = this.renderer;
                renderer.flush();
                renderer.pushFramebuffer(mask.mainFramebuffer);
                gl.disable(gl.STENCIL_TEST);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                if (renderer.currentCameraMask.mask !== mask) {
                  renderer.currentMask.mask = mask;
                  renderer.currentMask.camera = camera;
                }
              }
            },
            endMask: function (mask, camera) {
              var gl = this.gl;
              var renderer = this.renderer;
              var bitmapMask = mask.bitmapMask;
              if (bitmapMask && gl) {
                renderer.flush();
                renderer.pushFramebuffer(mask.maskFramebuffer);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                renderer.setBlendMode(0, true);
                bitmapMask.renderWebGL(renderer, bitmapMask, camera);
                renderer.flush();
                renderer.popFramebuffer();
                renderer.popFramebuffer();
                var prev = renderer.getCurrentStencilMask();
                if (prev) {
                  gl.enable(gl.STENCIL_TEST);
                  prev.mask.applyStencil(renderer, prev.camera, true);
                } else {
                  renderer.currentMask.mask = null;
                }
                renderer.pipelines.set(this);
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, mask.maskTexture);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, mask.mainTexture);
                this.set1i("uInvertMaskAlpha", mask.invertAlpha);
                gl.drawArrays(this.topology, 0, 3);
                renderer.resetTextures();
              }
            }
          });
          module2.exports = BitmapMaskPipeline;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            AFTER_FLUSH: __webpack_require__(868),
            BEFORE_FLUSH: __webpack_require__(869),
            BIND: __webpack_require__(870),
            BOOT: __webpack_require__(871),
            DESTROY: __webpack_require__(872),
            REBIND: __webpack_require__(873),
            RESIZE: __webpack_require__(874)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var WEBGL_CONST = __webpack_require__(107);
          var WebGLShader = new Class({
            initialize: function WebGLShader2(pipeline, name, vertexShader, fragmentShader, attributes) {
              this.pipeline = pipeline;
              this.name = name;
              this.renderer = pipeline.renderer;
              this.gl = this.renderer.gl;
              this.program = this.renderer.createProgram(vertexShader, fragmentShader);
              this.attributes;
              this.vertexComponentCount = 0;
              this.vertexSize = 0;
              this.uniforms = {};
              this.createAttributes(attributes);
              this.createUniforms();
            },
            createAttributes: function (attributes) {
              var count = 0;
              var offset = 0;
              var result = [];
              this.vertexComponentCount = 0;
              for (var i = 0; i < attributes.length; i++) {
                var element = attributes[i];
                var name = element.name;
                var size = GetFastValue(element, "size", 1);
                var glType = GetFastValue(element, "type", WEBGL_CONST.FLOAT);
                var type = glType.enum;
                var typeSize = glType.size;
                var normalized = element.normalized ? true : false;
                result.push({
                  name,
                  size,
                  type,
                  normalized,
                  offset,
                  enabled: false,
                  location: -1
                });
                if (typeSize === 4) {
                  count += size;
                } else {
                  count++;
                }
                offset += size * typeSize;
              }
              this.vertexSize = offset;
              this.vertexComponentCount = count;
              this.attributes = result;
            },
            bind: function (setAttributes, flush) {
              if (setAttributes === void 0) {
                setAttributes = false;
              }
              if (flush === void 0) {
                flush = false;
              }
              if (flush) {
                this.pipeline.flush();
              }
              this.renderer.setProgram(this.program);
              if (setAttributes) {
                this.setAttribPointers();
              }
              return this;
            },
            rebind: function () {
              this.renderer.setProgram(this.program);
              this.setAttribPointers(true);
              return this;
            },
            setAttribPointers: function (reset) {
              if (reset === void 0) {
                reset = false;
              }
              var gl = this.gl;
              var vertexSize = this.vertexSize;
              var attributes = this.attributes;
              var program = this.program;
              for (var i = 0; i < attributes.length; i++) {
                var element = attributes[i];
                var size = element.size;
                var type = element.type;
                var offset = element.offset;
                var enabled = element.enabled;
                var location = element.location;
                var normalized = element.normalized ? true : false;
                if (reset) {
                  var attribLocation = gl.getAttribLocation(program, element.name);
                  if (attribLocation >= 0) {
                    gl.enableVertexAttribArray(attribLocation);
                    gl.vertexAttribPointer(attribLocation, size, type, normalized, vertexSize, offset);
                    element.enabled = true;
                    element.location = attribLocation;
                  } else if (attribLocation !== -1) {
                    gl.disableVertexAttribArray(attribLocation);
                  }
                } else if (enabled) {
                  gl.vertexAttribPointer(location, size, type, normalized, vertexSize, offset);
                } else if (!enabled && location > -1) {
                  gl.disableVertexAttribArray(location);
                  element.location = -1;
                }
              }
              return this;
            },
            createUniforms: function () {
              var gl = this.gl;
              var program = this.program;
              var uniforms = this.uniforms;
              var i;
              var name;
              var location;
              var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
              for (i = 0; i < totalUniforms; i++) {
                var info = gl.getActiveUniform(program, i);
                if (info) {
                  name = info.name;
                  location = gl.getUniformLocation(program, name);
                  if (location !== null) {
                    uniforms[name] = {
                      name,
                      location,
                      value1: null,
                      value2: null,
                      value3: null,
                      value4: null
                    };
                  }
                  var struct = name.indexOf("[");
                  if (struct > 0) {
                    name = name.substr(0, struct);
                    if (!uniforms.hasOwnProperty(name)) {
                      location = gl.getUniformLocation(program, name);
                      if (location !== null) {
                        uniforms[name] = {
                          name,
                          location,
                          value1: null,
                          value2: null,
                          value3: null,
                          value4: null
                        };
                      }
                    }
                  }
                }
              }
              return this;
            },
            hasUniform: function (name) {
              return this.uniforms.hasOwnProperty(name);
            },
            resetUniform: function (name) {
              var uniform = this.uniforms[name];
              if (uniform) {
                uniform.value1 = null;
                uniform.value2 = null;
                uniform.value3 = null;
                uniform.value4 = null;
              }
              return this;
            },
            setUniform1: function (setter, name, value1, skipCheck) {
              var uniform = this.uniforms[name];
              if (!uniform) {
                return this;
              }
              if (skipCheck || uniform.value1 !== value1) {
                uniform.value1 = value1;
                this.renderer.setProgram(this.program);
                setter.call(this.gl, uniform.location, value1);
                this.pipeline.currentShader = this;
              }
              return this;
            },
            setUniform2: function (setter, name, value1, value2, skipCheck) {
              var uniform = this.uniforms[name];
              if (!uniform) {
                return this;
              }
              if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2) {
                uniform.value1 = value1;
                uniform.value2 = value2;
                this.renderer.setProgram(this.program);
                setter.call(this.gl, uniform.location, value1, value2);
                this.pipeline.currentShader = this;
              }
              return this;
            },
            setUniform3: function (setter, name, value1, value2, value3, skipCheck) {
              var uniform = this.uniforms[name];
              if (!uniform) {
                return this;
              }
              if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2 || uniform.value3 !== value3) {
                uniform.value1 = value1;
                uniform.value2 = value2;
                uniform.value3 = value3;
                this.renderer.setProgram(this.program);
                setter.call(this.gl, uniform.location, value1, value2, value3);
                this.pipeline.currentShader = this;
              }
              return this;
            },
            setUniform4: function (setter, name, value1, value2, value3, value4, skipCheck) {
              var uniform = this.uniforms[name];
              if (!uniform) {
                return this;
              }
              if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2 || uniform.value3 !== value3 || uniform.value4 !== value4) {
                uniform.value1 = value1;
                uniform.value2 = value2;
                uniform.value3 = value3;
                uniform.value4 = value4;
                this.renderer.setProgram(this.program);
                setter.call(this.gl, uniform.location, value1, value2, value3, value4);
                this.pipeline.currentShader = this;
              }
              return this;
            },
            set1f: function (name, x) {
              return this.setUniform1(this.gl.uniform1f, name, x);
            },
            set2f: function (name, x, y) {
              return this.setUniform2(this.gl.uniform2f, name, x, y);
            },
            set3f: function (name, x, y, z) {
              return this.setUniform3(this.gl.uniform3f, name, x, y, z);
            },
            set4f: function (name, x, y, z, w) {
              return this.setUniform4(this.gl.uniform4f, name, x, y, z, w);
            },
            set1fv: function (name, arr) {
              return this.setUniform1(this.gl.uniform1fv, name, arr, true);
            },
            set2fv: function (name, arr) {
              return this.setUniform1(this.gl.uniform2fv, name, arr, true);
            },
            set3fv: function (name, arr) {
              return this.setUniform1(this.gl.uniform3fv, name, arr, true);
            },
            set4fv: function (name, arr) {
              return this.setUniform1(this.gl.uniform4fv, name, arr, true);
            },
            set1iv: function (name, arr) {
              return this.setUniform1(this.gl.uniform1iv, name, arr, true);
            },
            set2iv: function (name, arr) {
              return this.setUniform1(this.gl.uniform2iv, name, arr, true);
            },
            set3iv: function (name, arr) {
              return this.setUniform1(this.gl.uniform3iv, name, arr, true);
            },
            set4iv: function (name, arr) {
              return this.setUniform1(this.gl.uniform4iv, name, arr, true);
            },
            set1i: function (name, x) {
              return this.setUniform1(this.gl.uniform1i, name, x);
            },
            set2i: function (name, x, y) {
              return this.setUniform2(this.gl.uniform2i, name, x, y);
            },
            set3i: function (name, x, y, z) {
              return this.setUniform3(this.gl.uniform3i, name, x, y, z);
            },
            set4i: function (name, x, y, z, w) {
              return this.setUniform4(this.gl.uniform4i, name, x, y, z, w);
            },
            setMatrix2fv: function (name, transpose, matrix) {
              return this.setUniform2(this.gl.uniformMatrix2fv, name, transpose, matrix, true);
            },
            setMatrix3fv: function (name, transpose, matrix) {
              return this.setUniform2(this.gl.uniformMatrix3fv, name, transpose, matrix, true);
            },
            setMatrix4fv: function (name, transpose, matrix) {
              return this.setUniform2(this.gl.uniformMatrix4fv, name, transpose, matrix, true);
            },
            destroy: function () {
              this.gl.deleteProgram(this.program);
              this.pipeline = null;
              this.renderer = null;
              this.gl = null;
              this.program = null;
              this.attributes = null;
              this.uniforms = null;
            }
          });
          module2.exports = WebGLShader;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Earcut = __webpack_require__(59);
          var GetFastValue = __webpack_require__(2);
          var ShaderSourceFS = __webpack_require__(875);
          var ShaderSourceVS = __webpack_require__(876);
          var TransformMatrix = __webpack_require__(25);
          var WEBGL_CONST = __webpack_require__(107);
          var WebGLPipeline = __webpack_require__(58);
          var GraphicsPipeline = new Class({
            Extends: WebGLPipeline,
            initialize: function GraphicsPipeline2(config) {
              config.fragShader = GetFastValue(config, "fragShader", ShaderSourceFS);
              config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS);
              config.attributes = GetFastValue(config, "attributes", [{
                name: "inPosition",
                size: 2
              }, {
                name: "inColor",
                size: 4,
                type: WEBGL_CONST.UNSIGNED_BYTE,
                normalized: true
              }]);
              WebGLPipeline.call(this, config);
              this.calcMatrix = new TransformMatrix();
              this.tempTriangle = [{
                x: 0,
                y: 0,
                width: 0
              }, {
                x: 0,
                y: 0,
                width: 0
              }, {
                x: 0,
                y: 0,
                width: 0
              }, {
                x: 0,
                y: 0,
                width: 0
              }];
              this.strokeTint = {
                TL: 0,
                TR: 0,
                BL: 0,
                BR: 0
              };
              this.fillTint = {
                TL: 0,
                TR: 0,
                BL: 0,
                BR: 0
              };
              this.currentFrame = {
                u0: 0,
                v0: 0,
                u1: 1,
                v1: 1
              };
              this.firstQuad = [0, 0, 0, 0, 0];
              this.prevQuad = [0, 0, 0, 0, 0];
              this.polygonCache = [];
            },
            batchFillRect: function (x, y, width, height, currentMatrix, parentMatrix) {
              this.renderer.pipelines.set(this);
              var calcMatrix = this.calcMatrix;
              if (parentMatrix) {
                parentMatrix.multiply(currentMatrix, calcMatrix);
              }
              var xw = x + width;
              var yh = y + height;
              var x0 = calcMatrix.getX(x, y);
              var y0 = calcMatrix.getY(x, y);
              var x1 = calcMatrix.getX(x, yh);
              var y1 = calcMatrix.getY(x, yh);
              var x2 = calcMatrix.getX(xw, yh);
              var y2 = calcMatrix.getY(xw, yh);
              var x3 = calcMatrix.getX(xw, y);
              var y3 = calcMatrix.getY(xw, y);
              var tint = this.fillTint;
              this.batchQuad(x0, y0, x1, y1, x2, y2, x3, y3, tint.TL, tint.TR, tint.BL, tint.BR);
            },
            batchFillTriangle: function (x0, y0, x1, y1, x2, y2, currentMatrix, parentMatrix) {
              this.renderer.pipelines.set(this);
              var calcMatrix = this.calcMatrix;
              if (parentMatrix) {
                parentMatrix.multiply(currentMatrix, calcMatrix);
              }
              var tx0 = calcMatrix.getX(x0, y0);
              var ty0 = calcMatrix.getY(x0, y0);
              var tx1 = calcMatrix.getX(x1, y1);
              var ty1 = calcMatrix.getY(x1, y1);
              var tx2 = calcMatrix.getX(x2, y2);
              var ty2 = calcMatrix.getY(x2, y2);
              var tint = this.fillTint;
              this.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, tint.TL, tint.TR, tint.BL);
            },
            batchStrokeTriangle: function (x0, y0, x1, y1, x2, y2, lineWidth, currentMatrix, parentMatrix) {
              var tempTriangle = this.tempTriangle;
              tempTriangle[0].x = x0;
              tempTriangle[0].y = y0;
              tempTriangle[0].width = lineWidth;
              tempTriangle[1].x = x1;
              tempTriangle[1].y = y1;
              tempTriangle[1].width = lineWidth;
              tempTriangle[2].x = x2;
              tempTriangle[2].y = y2;
              tempTriangle[2].width = lineWidth;
              tempTriangle[3].x = x0;
              tempTriangle[3].y = y0;
              tempTriangle[3].width = lineWidth;
              this.batchStrokePath(tempTriangle, lineWidth, false, currentMatrix, parentMatrix);
            },
            batchFillPath: function (path, currentMatrix, parentMatrix) {
              this.renderer.pipelines.set(this);
              var calcMatrix = this.calcMatrix;
              if (parentMatrix) {
                parentMatrix.multiply(currentMatrix, calcMatrix);
              }
              var length = path.length;
              var polygonCache = this.polygonCache;
              var polygonIndexArray;
              var point;
              var tintTL = this.fillTint.TL;
              var tintTR = this.fillTint.TR;
              var tintBL = this.fillTint.BL;
              for (var pathIndex = 0; pathIndex < length; ++pathIndex) {
                point = path[pathIndex];
                polygonCache.push(point.x, point.y);
              }
              polygonIndexArray = Earcut(polygonCache);
              length = polygonIndexArray.length;
              for (var index = 0; index < length; index += 3) {
                var p0 = polygonIndexArray[index + 0] * 2;
                var p1 = polygonIndexArray[index + 1] * 2;
                var p22 = polygonIndexArray[index + 2] * 2;
                var x0 = polygonCache[p0 + 0];
                var y0 = polygonCache[p0 + 1];
                var x1 = polygonCache[p1 + 0];
                var y1 = polygonCache[p1 + 1];
                var x2 = polygonCache[p22 + 0];
                var y2 = polygonCache[p22 + 1];
                var tx0 = calcMatrix.getX(x0, y0);
                var ty0 = calcMatrix.getY(x0, y0);
                var tx1 = calcMatrix.getX(x1, y1);
                var ty1 = calcMatrix.getY(x1, y1);
                var tx2 = calcMatrix.getX(x2, y2);
                var ty2 = calcMatrix.getY(x2, y2);
                this.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, tintTL, tintTR, tintBL);
              }
              polygonCache.length = 0;
            },
            batchStrokePath: function (path, lineWidth, pathOpen, currentMatrix, parentMatrix) {
              this.renderer.pipelines.set(this);
              this.prevQuad[4] = 0;
              this.firstQuad[4] = 0;
              var pathLength = path.length - 1;
              for (var pathIndex = 0; pathIndex < pathLength; pathIndex++) {
                var point0 = path[pathIndex];
                var point1 = path[pathIndex + 1];
                this.batchLine(point0.x, point0.y, point1.x, point1.y, point0.width / 2, point1.width / 2, lineWidth, pathIndex, !pathOpen && pathIndex === pathLength - 1, currentMatrix, parentMatrix);
              }
            },
            batchLine: function (ax, ay, bx, by, aLineWidth, bLineWidth, lineWidth, index, closePath, currentMatrix, parentMatrix) {
              this.renderer.pipelines.set(this);
              var calcMatrix = this.calcMatrix;
              if (parentMatrix) {
                parentMatrix.multiply(currentMatrix, calcMatrix);
              }
              var dx = bx - ax;
              var dy = by - ay;
              var len = Math.sqrt(dx * dx + dy * dy);
              var al0 = aLineWidth * (by - ay) / len;
              var al1 = aLineWidth * (ax - bx) / len;
              var bl0 = bLineWidth * (by - ay) / len;
              var bl1 = bLineWidth * (ax - bx) / len;
              var lx0 = bx - bl0;
              var ly0 = by - bl1;
              var lx1 = ax - al0;
              var ly1 = ay - al1;
              var lx2 = bx + bl0;
              var ly2 = by + bl1;
              var lx3 = ax + al0;
              var ly3 = ay + al1;
              var brX = calcMatrix.getX(lx0, ly0);
              var brY = calcMatrix.getY(lx0, ly0);
              var blX = calcMatrix.getX(lx1, ly1);
              var blY = calcMatrix.getY(lx1, ly1);
              var trX = calcMatrix.getX(lx2, ly2);
              var trY = calcMatrix.getY(lx2, ly2);
              var tlX = calcMatrix.getX(lx3, ly3);
              var tlY = calcMatrix.getY(lx3, ly3);
              var tint = this.strokeTint;
              var tintTL = tint.TL;
              var tintTR = tint.TR;
              var tintBL = tint.BL;
              var tintBR = tint.BR;
              this.batchQuad(tlX, tlY, blX, blY, brX, brY, trX, trY, tintTL, tintTR, tintBL, tintBR);
              if (lineWidth <= 2) {
                return;
              }
              var prev = this.prevQuad;
              var first = this.firstQuad;
              if (index > 0 && prev[4]) {
                this.batchQuad(tlX, tlY, blX, blY, prev[0], prev[1], prev[2], prev[3], tintTL, tintTR, tintBL, tintBR);
              } else {
                first[0] = tlX;
                first[1] = tlY;
                first[2] = blX;
                first[3] = blY;
                first[4] = 1;
              }
              if (closePath && first[4]) {
                this.batchQuad(brX, brY, trX, trY, first[0], first[1], first[2], first[3], tintTL, tintTR, tintBL, tintBR);
              } else {
                prev[0] = brX;
                prev[1] = brY;
                prev[2] = trX;
                prev[3] = trY;
                prev[4] = 1;
              }
            },
            batchVert: function (x, y, tint) {
              var vertexViewF32 = this.vertexViewF32;
              var vertexViewU32 = this.vertexViewU32;
              var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
              vertexViewF32[++vertexOffset] = x;
              vertexViewF32[++vertexOffset] = y;
              vertexViewU32[++vertexOffset] = tint;
              this.vertexCount++;
            },
            batchQuad: function (x0, y0, x1, y1, x2, y2, x3, y3, tintTL, tintTR, tintBL, tintBR) {
              var hasFlushed = false;
              if (this.shouldFlush(6)) {
                this.flush();
                hasFlushed = true;
              }
              this.batchVert(x0, y0, tintTL);
              this.batchVert(x1, y1, tintBL);
              this.batchVert(x2, y2, tintBR);
              this.batchVert(x0, y0, tintTL);
              this.batchVert(x2, y2, tintBR);
              this.batchVert(x3, y3, tintTR);
              return hasFlushed;
            },
            batchTri: function (x0, y0, x1, y1, x2, y2, tintTL, tintTR, tintBL) {
              var hasFlushed = false;
              if (this.shouldFlush(3)) {
                this.flush();
                hasFlushed = true;
              }
              this.batchVert(x0, y0, tintTL);
              this.batchVert(x1, y1, tintTR);
              this.batchVert(x2, y2, tintBL);
              return hasFlushed;
            },
            destroy: function () {
              WebGLPipeline.prototype.destroy.call(this);
              this.polygonCache = null;
              return this;
            }
          });
          module2.exports = GraphicsPipeline;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var LightShaderSourceFS = __webpack_require__(877);
          var MultiPipeline = __webpack_require__(108);
          var Vec2 = __webpack_require__(3);
          var WebGLPipeline = __webpack_require__(58);
          var LIGHT_COUNT = 10;
          var tempVec2 = new Vec2();
          var LightPipeline = new Class({
            Extends: MultiPipeline,
            initialize: function LightPipeline2(config) {
              LIGHT_COUNT = config.game.renderer.config.maxLights;
              var fragShader = GetFastValue(config, "fragShader", LightShaderSourceFS);
              var shaders = [];
              for (var i = 1; i <= LIGHT_COUNT; i++) {
                shaders.push({
                  name: "lights" + i,
                  fragShader: fragShader.replace("%LIGHT_COUNT%", i.toString())
                });
              }
              config.shaders = shaders;
              MultiPipeline.call(this, config);
              this.inverseRotationMatrix = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
              this.defaultNormalMap;
              this.lightsActive = true;
            },
            boot: function () {
              WebGLPipeline.prototype.boot.call(this);
              var gl = this.gl;
              var tempTexture = gl.createTexture();
              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, tempTexture);
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([127, 127, 255, 255]));
              this.defaultNormalMap = {
                glTexture: tempTexture
              };
              for (var i = 0; i < this.shaders.length; i++) {
                this["lightShader" + (i + 1)] = this.shaders[i];
              }
            },
            onRender: function (scene, camera) {
              var lightManager = scene.sys.lights;
              this.lightsActive = false;
              if (!lightManager || !lightManager.active) {
                return;
              }
              var lights = lightManager.getLights(camera);
              var lightsCount = lights.length;
              if (lightsCount === 0) {
                return;
              }
              this.lightsActive = true;
              this.setShader(this["lightShader" + lightsCount], true);
              var i;
              var renderer = this.renderer;
              var height = renderer.height;
              var cameraMatrix = camera.matrix;
              this.set1i("uMainSampler", 0);
              this.set1i("uNormSampler", 1);
              this.set2f("uResolution", this.width / 2, this.height / 2);
              this.set4f("uCamera", camera.x, camera.y, camera.rotation, camera.zoom);
              this.set3f("uAmbientLightColor", lightManager.ambientColor.r, lightManager.ambientColor.g, lightManager.ambientColor.b);
              for (i = 0; i < lightsCount; i++) {
                var light = lights[i].light;
                var color = light.color;
                var lightName = "uLights[" + i + "].";
                cameraMatrix.transformPoint(light.x, light.y, tempVec2);
                this.set2f(lightName + "position", tempVec2.x - camera.scrollX * light.scrollFactorX * camera.zoom, height - (tempVec2.y - camera.scrollY * light.scrollFactorY * camera.zoom));
                this.set3f(lightName + "color", color.r, color.g, color.b);
                this.set1f(lightName + "intensity", light.intensity);
                this.set1f(lightName + "radius", light.radius);
              }
              this.currentNormalMapRotation = null;
            },
            setNormalMapRotation: function (rotation) {
              if (rotation !== this.currentNormalMapRotation || this.vertexCount === 0) {
                if (this.vertexCount > 0) {
                  this.flush();
                }
                var inverseRotationMatrix = this.inverseRotationMatrix;
                if (rotation) {
                  var rot = -rotation;
                  var c = Math.cos(rot);
                  var s = Math.sin(rot);
                  inverseRotationMatrix[1] = s;
                  inverseRotationMatrix[3] = -s;
                  inverseRotationMatrix[0] = inverseRotationMatrix[4] = c;
                } else {
                  inverseRotationMatrix[0] = inverseRotationMatrix[4] = 1;
                  inverseRotationMatrix[1] = inverseRotationMatrix[3] = 0;
                }
                this.setMatrix3fv("uInverseRotationMatrix", false, inverseRotationMatrix);
                this.currentNormalMapRotation = rotation;
              }
            },
            setTexture2D: function (texture, gameObject) {
              var renderer = this.renderer;
              if (texture === void 0) {
                texture = renderer.tempTextures[0];
              }
              var normalTexture = this.getNormalMap(gameObject);
              if (renderer.isNewNormalMap(texture, normalTexture)) {
                this.flush();
                renderer.setTextureZero(texture);
                renderer.setNormalMap(normalTexture);
              }
              var rotation = gameObject ? gameObject.rotation : 0;
              this.setNormalMapRotation(rotation);
              this.currentUnit = 0;
              return 0;
            },
            setGameObject: function (gameObject, frame) {
              if (frame === void 0) {
                frame = gameObject.frame;
              }
              var renderer = this.renderer;
              var texture = frame.glTexture;
              var normalTexture = this.getNormalMap(gameObject);
              if (renderer.isNewNormalMap()) {
                this.flush();
                renderer.setTextureZero(texture);
                renderer.setNormalMap(normalTexture);
              }
              this.setNormalMapRotation(gameObject.rotation);
              this.currentUnit = 0;
              return 0;
            },
            getNormalMap: function (gameObject) {
              var normalTexture;
              if (!gameObject) {
                normalTexture = this.defaultNormalMap;
              } else if (gameObject.displayTexture) {
                normalTexture = gameObject.displayTexture.dataSource[gameObject.displayFrame.sourceIndex];
              } else if (gameObject.texture) {
                normalTexture = gameObject.texture.dataSource[gameObject.frame.sourceIndex];
              } else if (gameObject.tileset) {
                if (Array.isArray(gameObject.tileset)) {
                  normalTexture = gameObject.tileset[0].image.dataSource[0];
                } else {
                  normalTexture = gameObject.tileset.image.dataSource[0];
                }
              }
              if (!normalTexture) {
                normalTexture = this.defaultNormalMap;
              }
              return normalTexture.glTexture;
            },
            batchSprite: function (gameObject, camera, parentTransformMatrix) {
              if (this.lightsActive) {
                MultiPipeline.prototype.batchSprite.call(this, gameObject, camera, parentTransformMatrix);
              }
            },
            batchTexture: function (gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix, skipFlip, textureUnit) {
              if (this.lightsActive) {
                MultiPipeline.prototype.batchTexture.call(this, gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix, skipFlip, textureUnit);
              }
            },
            batchTextureFrame: function (frame, x, y, tint, alpha, transformMatrix, parentTransformMatrix) {
              if (this.lightsActive) {
                MultiPipeline.prototype.batchTextureFrame.call(this, frame, x, y, tint, alpha, transformMatrix, parentTransformMatrix);
              }
            }
          });
          LightPipeline.LIGHT_COUNT = LIGHT_COUNT;
          module2.exports = LightPipeline;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var PointLightShaderSourceFS = __webpack_require__(880);
          var PointLightShaderSourceVS = __webpack_require__(881);
          var WebGLPipeline = __webpack_require__(58);
          var PointLightPipeline = new Class({
            Extends: WebGLPipeline,
            initialize: function PointLightPipeline2(config) {
              config.vertShader = GetFastValue(config, "vertShader", PointLightShaderSourceVS);
              config.fragShader = GetFastValue(config, "fragShader", PointLightShaderSourceFS);
              config.attributes = GetFastValue(config, "attributes", [{
                name: "inPosition",
                size: 2
              }, {
                name: "inLightPosition",
                size: 2
              }, {
                name: "inLightRadius"
              }, {
                name: "inLightAttenuation"
              }, {
                name: "inLightColor",
                size: 4
              }]);
              WebGLPipeline.call(this, config);
            },
            onRender: function (scene, camera) {
              this.set2f("uResolution", this.width, this.height);
              this.set1f("uCameraZoom", camera.zoom);
            },
            batchPointLight: function (light, camera, x0, y0, x1, y1, x2, y2, x3, y3, lightX, lightY) {
              var color = light.color;
              var intensity = light.intensity;
              var radius = light.radius;
              var attenuation = light.attenuation;
              var r = color.r * intensity;
              var g = color.g * intensity;
              var b = color.b * intensity;
              var a = camera.alpha * light.alpha;
              if (this.shouldFlush(6)) {
                this.flush();
              }
              this.batchLightVert(x0, y0, lightX, lightY, radius, attenuation, r, g, b, a);
              this.batchLightVert(x1, y1, lightX, lightY, radius, attenuation, r, g, b, a);
              this.batchLightVert(x2, y2, lightX, lightY, radius, attenuation, r, g, b, a);
              this.batchLightVert(x0, y0, lightX, lightY, radius, attenuation, r, g, b, a);
              this.batchLightVert(x2, y2, lightX, lightY, radius, attenuation, r, g, b, a);
              this.batchLightVert(x3, y3, lightX, lightY, radius, attenuation, r, g, b, a);
            },
            batchLightVert: function (x, y, lightX, lightY, radius, attenuation, r, g, b, a) {
              var vertexViewF32 = this.vertexViewF32;
              var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
              vertexViewF32[++vertexOffset] = x;
              vertexViewF32[++vertexOffset] = y;
              vertexViewF32[++vertexOffset] = lightX;
              vertexViewF32[++vertexOffset] = lightY;
              vertexViewF32[++vertexOffset] = radius;
              vertexViewF32[++vertexOffset] = attenuation;
              vertexViewF32[++vertexOffset] = r;
              vertexViewF32[++vertexOffset] = g;
              vertexViewF32[++vertexOffset] = b;
              vertexViewF32[++vertexOffset] = a;
              this.vertexCount++;
            }
          });
          module2.exports = PointLightPipeline;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var MultiPipeline = __webpack_require__(108);
          var RopePipeline = new Class({
            Extends: MultiPipeline,
            initialize: function RopePipeline2(config) {
              config.topology = 5;
              config.batchSize = GetFastValue(config, "batchSize", 256);
              MultiPipeline.call(this, config);
            }
          });
          module2.exports = RopePipeline;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var MultiPipeline = __webpack_require__(108);
          var ShaderSourceFS = __webpack_require__(882);
          var ShaderSourceVS = __webpack_require__(883);
          var WebGLPipeline = __webpack_require__(58);
          var SinglePipeline = new Class({
            Extends: MultiPipeline,
            initialize: function SinglePipeline2(config) {
              (config.fragShader = GetFastValue(config, "fragShader", ShaderSourceFS), config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS), config.forceZero = true);
              MultiPipeline.call(this, config);
            },
            boot: function () {
              WebGLPipeline.prototype.boot.call(this);
              this.set1i("uMainSampler", 0);
            }
          });
          module2.exports = SinglePipeline;
        }, function (module2, exports2, __webpack_require__) {
          var AddBlendFS = __webpack_require__(884);
          var BlendModes = __webpack_require__(35);
          var Class = __webpack_require__(0);
          var ColorMatrix = __webpack_require__(198);
          var ColorMatrixFS = __webpack_require__(885);
          var CopyFS = __webpack_require__(886);
          var GetFastValue = __webpack_require__(2);
          var LinearBlendFS = __webpack_require__(887);
          var QuadVS = __webpack_require__(382);
          var WebGLPipeline = __webpack_require__(58);
          var UtilityPipeline = new Class({
            Extends: WebGLPipeline,
            initialize: function UtilityPipeline2(config) {
              config.renderTarget = GetFastValue(config, "renderTarget", [{
                scale: 1
              }, {
                scale: 1
              }, {
                scale: 0.5
              }, {
                scale: 0.5
              }]);
              config.vertShader = GetFastValue(config, "vertShader", QuadVS);
              config.shaders = GetFastValue(config, "shaders", [{
                name: "Copy",
                fragShader: CopyFS
              }, {
                name: "AddBlend",
                fragShader: AddBlendFS
              }, {
                name: "LinearBlend",
                fragShader: LinearBlendFS
              }, {
                name: "ColorMatrix",
                fragShader: ColorMatrixFS
              }]);
              config.attributes = GetFastValue(config, "attributes", [{
                name: "inPosition",
                size: 2
              }, {
                name: "inTexCoord",
                size: 2
              }]);
              config.vertices = [-1, -1, 0, 0, -1, 1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, 1, 1, 1, 1, 1, -1, 1, 0];
              config.batchSize = 1;
              WebGLPipeline.call(this, config);
              this.colorMatrix = new ColorMatrix();
              this.copyShader;
              this.addShader;
              this.linearShader;
              this.colorMatrixShader;
              this.fullFrame1;
              this.fullFrame2;
              this.halfFrame1;
              this.halfFrame2;
            },
            boot: function () {
              WebGLPipeline.prototype.boot.call(this);
              var shaders = this.shaders;
              var targets = this.renderTargets;
              this.copyShader = shaders[0];
              this.addShader = shaders[1];
              this.linearShader = shaders[2];
              this.colorMatrixShader = shaders[3];
              this.fullFrame1 = targets[0];
              this.fullFrame2 = targets[1];
              this.halfFrame1 = targets[2];
              this.halfFrame2 = targets[3];
            },
            copyFrame: function (source, target, brightness, clear, clearAlpha) {
              if (brightness === void 0) {
                brightness = 1;
              }
              if (clear === void 0) {
                clear = true;
              }
              if (clearAlpha === void 0) {
                clearAlpha = true;
              }
              var gl = this.gl;
              this.setShader(this.copyShader);
              this.set1i("uMainSampler", 0);
              this.set1f("uBrightness", brightness);
              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, source.texture);
              if (target) {
                gl.viewport(0, 0, target.width, target.height);
                gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
              } else {
                gl.viewport(0, 0, source.width, source.height);
              }
              if (clear) {
                if (clearAlpha) {
                  gl.clearColor(0, 0, 0, 0);
                } else {
                  gl.clearColor(0, 0, 0, 1);
                }
                gl.clear(gl.COLOR_BUFFER_BIT);
              }
              gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
              gl.drawArrays(gl.TRIANGLES, 0, 6);
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.bindTexture(gl.TEXTURE_2D, null);
            },
            blitFrame: function (source, target, brightness, clear, clearAlpha, eraseMode) {
              if (brightness === void 0) {
                brightness = 1;
              }
              if (clear === void 0) {
                clear = true;
              }
              if (clearAlpha === void 0) {
                clearAlpha = true;
              }
              if (eraseMode === void 0) {
                eraseMode = false;
              }
              var gl = this.gl;
              this.setShader(this.copyShader);
              this.set1i("uMainSampler", 0);
              this.set1f("uBrightness", brightness);
              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, source.texture);
              if (source.height > target.height) {
                gl.viewport(0, 0, source.width, source.height);
                this.setTargetUVs(source, target);
              } else {
                var diff = target.height - source.height;
                gl.viewport(0, diff, source.width, source.height);
              }
              gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
              if (clear) {
                if (clearAlpha) {
                  gl.clearColor(0, 0, 0, 0);
                } else {
                  gl.clearColor(0, 0, 0, 1);
                }
                gl.clear(gl.COLOR_BUFFER_BIT);
              }
              if (eraseMode) {
                var blendMode = this.renderer.currentBlendMode;
                this.renderer.setBlendMode(BlendModes.ERASE);
              }
              gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
              gl.drawArrays(gl.TRIANGLES, 0, 6);
              if (eraseMode) {
                this.renderer.setBlendMode(blendMode);
              }
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.bindTexture(gl.TEXTURE_2D, null);
              this.resetUVs();
            },
            copyFrameRect: function (source, target, x, y, width, height, clear, clearAlpha) {
              if (clear === void 0) {
                clear = true;
              }
              if (clearAlpha === void 0) {
                clearAlpha = true;
              }
              var gl = this.gl;
              gl.bindFramebuffer(gl.FRAMEBUFFER, source.framebuffer);
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, source.texture, 0);
              if (clear) {
                if (clearAlpha) {
                  gl.clearColor(0, 0, 0, 0);
                } else {
                  gl.clearColor(0, 0, 0, 1);
                }
                gl.clear(gl.COLOR_BUFFER_BIT);
              }
              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, target.texture);
              gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, y, width, height);
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.bindTexture(gl.TEXTURE_2D, null);
            },
            copyToGame: function (source) {
              var gl = this.gl;
              this.setShader(this.copyShader);
              this.set1i("uMainSampler", 0);
              this.set1f("uBrightness", 1);
              this.renderer.popFramebuffer();
              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, source.texture);
              gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
              gl.drawArrays(gl.TRIANGLES, 0, 6);
              this.renderer.resetTextures();
            },
            drawFrame: function (source, target, clearAlpha, colorMatrix) {
              if (clearAlpha === void 0) {
                clearAlpha = true;
              }
              if (colorMatrix === void 0) {
                colorMatrix = this.colorMatrix;
              }
              var gl = this.gl;
              this.setShader(this.colorMatrixShader);
              this.set1i("uMainSampler", 0);
              this.set1fv("uColorMatrix", colorMatrix.getData());
              this.set1f("uAlpha", colorMatrix.alpha);
              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, source.texture);
              if (target) {
                gl.viewport(0, 0, target.width, target.height);
                gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
              } else {
                gl.viewport(0, 0, source.width, source.height);
              }
              if (clearAlpha) {
                gl.clearColor(0, 0, 0, 0);
              } else {
                gl.clearColor(0, 0, 0, 1);
              }
              gl.clear(gl.COLOR_BUFFER_BIT);
              gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
              gl.drawArrays(gl.TRIANGLES, 0, 6);
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.bindTexture(gl.TEXTURE_2D, null);
            },
            blendFrames: function (source1, source2, target, strength, clearAlpha, blendShader) {
              if (strength === void 0) {
                strength = 1;
              }
              if (clearAlpha === void 0) {
                clearAlpha = true;
              }
              if (blendShader === void 0) {
                blendShader = this.linearShader;
              }
              var gl = this.gl;
              this.setShader(blendShader);
              this.set1i("uMainSampler1", 0);
              this.set1i("uMainSampler2", 1);
              this.set1f("uStrength", strength);
              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, source1.texture);
              gl.activeTexture(gl.TEXTURE1);
              gl.bindTexture(gl.TEXTURE_2D, source2.texture);
              if (target) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
                gl.viewport(0, 0, target.width, target.height);
              } else {
                gl.viewport(0, 0, source1.width, source1.height);
              }
              if (clearAlpha) {
                gl.clearColor(0, 0, 0, 0);
              } else {
                gl.clearColor(0, 0, 0, 1);
              }
              gl.clear(gl.COLOR_BUFFER_BIT);
              gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
              gl.drawArrays(gl.TRIANGLES, 0, 6);
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.bindTexture(gl.TEXTURE_2D, null);
            },
            blendFramesAdditive: function (source1, source2, target, strength, clearAlpha) {
              this.blendFrames(source1, source2, target, strength, clearAlpha, this.addShader);
            },
            clearFrame: function (target, clearAlpha) {
              if (clearAlpha === void 0) {
                clearAlpha = true;
              }
              var gl = this.gl;
              gl.viewport(0, 0, target.width, target.height);
              gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
              if (clearAlpha) {
                gl.clearColor(0, 0, 0, 0);
              } else {
                gl.clearColor(0, 0, 0, 1);
              }
              gl.clear(gl.COLOR_BUFFER_BIT);
              var fbo = this.renderer.currentFramebuffer;
              gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            },
            setUVs: function (uA, vA, uB, vB, uC, vC, uD, vD) {
              var vertexViewF32 = this.vertexViewF32;
              vertexViewF32[2] = uA;
              vertexViewF32[3] = vA;
              vertexViewF32[6] = uB;
              vertexViewF32[7] = vB;
              vertexViewF32[10] = uC;
              vertexViewF32[11] = vC;
              vertexViewF32[14] = uA;
              vertexViewF32[15] = vA;
              vertexViewF32[18] = uC;
              vertexViewF32[19] = vC;
              vertexViewF32[22] = uD;
              vertexViewF32[23] = vD;
            },
            setTargetUVs: function (source, target) {
              var diff = target.height / source.height;
              if (diff > 0.5) {
                diff = 0.5 - (diff - 0.5);
              } else {
                diff = 0.5 + (0.5 - diff);
              }
              this.setUVs(0, diff, 0, 1 + diff, 1, 1 + diff, 1, diff);
            },
            flipX: function () {
              this.setUVs(1, 0, 1, 1, 0, 1, 0, 0);
            },
            flipY: function () {
              this.setUVs(0, 1, 0, 0, 1, 0, 1, 1);
            },
            resetUVs: function () {
              this.setUVs(0, 0, 0, 1, 1, 1, 1, 0);
            }
          });
          module2.exports = UtilityPipeline;
        }, function (module2, exports2) {
          module2.exports = ["#define SHADER_NAME PHASER_QUAD_VS", "", "precision mediump float;", "", "attribute vec2 inPosition;", "attribute vec2 inTexCoord;", "", "varying vec2 outFragCoord;", "varying vec2 outTexCoord;", "", "void main ()", "{", "    outFragCoord = inPosition.xy * 0.5 + 0.5;", "    outTexCoord = inTexCoord;", "", "    gl_Position = vec4(inPosition, 0, 1);", "}", ""].join("\n");
        }, function (module2, exports2, __webpack_require__) {
          var CanvasPool = __webpack_require__(31);
          var Color = __webpack_require__(38);
          var GetFastValue = __webpack_require__(2);
          var WebGLSnapshot = function (sourceCanvas, config) {
            var gl = sourceCanvas.getContext("experimental-webgl");
            var callback = GetFastValue(config, "callback");
            var type = GetFastValue(config, "type", "image/png");
            var encoderOptions = GetFastValue(config, "encoder", 0.92);
            var x = GetFastValue(config, "x", 0);
            var y = GetFastValue(config, "y", 0);
            var getPixel = GetFastValue(config, "getPixel", false);
            var isFramebuffer = GetFastValue(config, "isFramebuffer", false);
            var bufferWidth = isFramebuffer ? GetFastValue(config, "bufferWidth", 1) : gl.drawingBufferWidth;
            var bufferHeight = isFramebuffer ? GetFastValue(config, "bufferHeight", 1) : gl.drawingBufferHeight;
            if (getPixel) {
              var pixel = new Uint8Array(4);
              var destY = isFramebuffer ? y : bufferHeight - y;
              gl.readPixels(x, destY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
              callback.call(null, new Color(pixel[0], pixel[1], pixel[2], pixel[3] / 255));
            } else {
              var width = GetFastValue(config, "width", bufferWidth);
              var height = GetFastValue(config, "height", bufferHeight);
              var total = width * height * 4;
              var pixels = new Uint8Array(total);
              gl.readPixels(x, bufferHeight - y - height, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
              var canvas = CanvasPool.createWebGL(this, width, height);
              var ctx = canvas.getContext("2d");
              var imageData = ctx.getImageData(0, 0, width, height);
              var data = imageData.data;
              for (var py = 0; py < height; py++) {
                for (var px = 0; px < width; px++) {
                  var sourceIndex = ((height - py - 1) * width + px) * 4;
                  var destIndex = (py * width + px) * 4;
                  data[destIndex + 0] = pixels[sourceIndex + 0];
                  data[destIndex + 1] = pixels[sourceIndex + 1];
                  data[destIndex + 2] = pixels[sourceIndex + 2];
                  data[destIndex + 3] = pixels[sourceIndex + 3];
                }
              }
              ctx.putImageData(imageData, 0, 0);
              var image = new Image();
              image.onerror = function () {
                callback.call(null);
                CanvasPool.remove(canvas);
              };
              image.onload = function () {
                callback.call(null, image);
                CanvasPool.remove(canvas);
              };
              image.src = canvas.toDataURL(type, encoderOptions);
            }
          };
          module2.exports = WebGLSnapshot;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(33);
          var DebugHeader = function (game) {
            var config = game.config;
            if (config.hideBanner) {
              return;
            }
            var renderType = "WebGL";
            if (config.renderType === CONST.CANVAS) {
              renderType = "Canvas";
            } else if (config.renderType === CONST.HEADLESS) {
              renderType = "Headless";
            }
            var audioConfig = config.audio;
            var deviceAudio = game.device.audio;
            var audioType;
            if (deviceAudio.webAudio && !audioConfig.disableWebAudio) {
              audioType = "Web Audio";
            } else if (audioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
              audioType = "No Audio";
            } else {
              audioType = "HTML5 Audio";
            }
            if (!game.device.browser.ie) {
              var c = "";
              var args = [c];
              if (Array.isArray(config.bannerBackgroundColor)) {
                var lastColor;
                config.bannerBackgroundColor.forEach(function (color) {
                  c = c.concat("%c ");
                  args.push("background: " + color);
                  lastColor = color;
                });
                args[args.length - 1] = "color: " + config.bannerTextColor + "; background: " + lastColor;
              } else {
                c = c.concat("%c ");
                args.push("color: " + config.bannerTextColor + "; background: " + config.bannerBackgroundColor);
              }
              args.push("background: transparent");
              if (config.gameTitle) {
                c = c.concat(config.gameTitle);
                if (config.gameVersion) {
                  c = c.concat(" v" + config.gameVersion);
                }
                if (!config.hidePhaser) {
                  c = c.concat(" / ");
                }
              }
              var fb = false ? void 0 : "";
              if (!config.hidePhaser) {
                c = c.concat("Phaser v" + CONST.VERSION + fb + " (" + renderType + " | " + audioType + ")");
              }
              c = c.concat(" %c " + config.gameURL);
              args[0] = c;
              console.log.apply(console, args);
            } else if (window["console"]) {
              console.log("Phaser v" + CONST.VERSION + " / https://phaser.io");
            }
          };
          module2.exports = DebugHeader;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GetValue = __webpack_require__(6);
          var NOOP = __webpack_require__(1);
          var RequestAnimationFrame = __webpack_require__(386);
          var TimeStep = new Class({
            initialize: function TimeStep2(game, config) {
              this.game = game;
              this.raf = new RequestAnimationFrame();
              this.started = false;
              this.running = false;
              this.minFps = GetValue(config, "min", 5);
              this.targetFps = GetValue(config, "target", 60);
              this._min = 1e3 / this.minFps;
              this._target = 1e3 / this.targetFps;
              this.actualFps = this.targetFps;
              this.nextFpsUpdate = 0;
              this.framesThisSecond = 0;
              this.callback = NOOP;
              this.forceSetTimeOut = GetValue(config, "forceSetTimeOut", false);
              this.time = 0;
              this.startTime = 0;
              this.lastTime = 0;
              this.frame = 0;
              this.inFocus = true;
              this._pauseTime = 0;
              this._coolDown = 0;
              this.delta = 0;
              this.deltaIndex = 0;
              this.deltaHistory = [];
              this.deltaSmoothingMax = GetValue(config, "deltaHistory", 10);
              this.panicMax = GetValue(config, "panicMax", 120);
              this.rawDelta = 0;
              this.now = 0;
              this.smoothStep = GetValue(config, "smoothStep", true);
            },
            blur: function () {
              this.inFocus = false;
            },
            focus: function () {
              this.inFocus = true;
              this.resetDelta();
            },
            pause: function () {
              this._pauseTime = window.performance.now();
            },
            resume: function () {
              this.resetDelta();
              this.startTime += this.time - this._pauseTime;
            },
            resetDelta: function () {
              var now = window.performance.now();
              this.time = now;
              this.lastTime = now;
              this.nextFpsUpdate = now + 1e3;
              this.framesThisSecond = 0;
              for (var i = 0; i < this.deltaSmoothingMax; i++) {
                this.deltaHistory[i] = Math.min(this._target, this.deltaHistory[i]);
              }
              this.delta = 0;
              this.deltaIndex = 0;
              this._coolDown = this.panicMax;
            },
            start: function (callback) {
              if (this.started) {
                return this;
              }
              this.started = true;
              this.running = true;
              for (var i = 0; i < this.deltaSmoothingMax; i++) {
                this.deltaHistory[i] = this._target;
              }
              this.resetDelta();
              this.startTime = window.performance.now();
              this.callback = callback;
              this.raf.start(this.step.bind(this), this.forceSetTimeOut, this._target);
            },
            step: function () {
              var time = window.performance.now();
              this.now = time;
              var before = time - this.lastTime;
              if (before < 0) {
                before = 0;
              }
              this.rawDelta = before;
              var idx = this.deltaIndex;
              var history = this.deltaHistory;
              var max = this.deltaSmoothingMax;
              var dt = before;
              var avg = before;
              if (this.smoothStep) {
                if (this._coolDown > 0 || !this.inFocus) {
                  this._coolDown--;
                  dt = Math.min(dt, this._target);
                }
                if (dt > this._min) {
                  dt = history[idx];
                  dt = Math.min(dt, this._min);
                }
                history[idx] = dt;
                this.deltaIndex++;
                if (this.deltaIndex > max) {
                  this.deltaIndex = 0;
                }
                avg = 0;
                for (var i = 0; i < max; i++) {
                  avg += history[i];
                }
                avg /= max;
              }
              this.delta = avg;
              this.time += this.rawDelta;
              if (time > this.nextFpsUpdate) {
                this.actualFps = 0.25 * this.framesThisSecond + 0.75 * this.actualFps;
                this.nextFpsUpdate = time + 1e3;
                this.framesThisSecond = 0;
              }
              this.framesThisSecond++;
              var interpolation = avg / this._target;
              this.callback(time, avg, interpolation);
              this.lastTime = time;
              this.frame++;
            },
            tick: function () {
              this.step();
            },
            sleep: function () {
              if (this.running) {
                this.raf.stop();
                this.running = false;
              }
            },
            wake: function (seamless) {
              if (this.running) {
                return;
              } else if (seamless) {
                this.startTime += -this.lastTime + (this.lastTime + window.performance.now());
              }
              this.raf.start(this.step.bind(this), this.useRAF);
              this.running = true;
              this.step();
            },
            getDuration: function () {
              return Math.round(this.lastTime - this.startTime) / 1e3;
            },
            getDurationMS: function () {
              return Math.round(this.lastTime - this.startTime);
            },
            stop: function () {
              this.running = false;
              this.started = false;
              this.raf.stop();
              return this;
            },
            destroy: function () {
              this.stop();
              this.callback = NOOP;
              this.raf = null;
              this.game = null;
            }
          });
          module2.exports = TimeStep;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var NOOP = __webpack_require__(1);
          var RequestAnimationFrame = new Class({
            initialize: function RequestAnimationFrame2() {
              this.isRunning = false;
              this.callback = NOOP;
              this.tick = 0;
              this.isSetTimeOut = false;
              this.timeOutID = null;
              this.lastTime = 0;
              this.target = 0;
              var _this = this;
              this.step = function step() {
                var timestamp = window.performance.now();
                _this.lastTime = _this.tick;
                _this.tick = timestamp;
                _this.callback(timestamp);
                _this.timeOutID = window.requestAnimationFrame(step);
              };
              this.stepTimeout = function stepTimeout() {
                var d = Date.now();
                var delay = Math.min(Math.max(_this.target * 2 + _this.tick - d, 0), _this.target);
                _this.lastTime = _this.tick;
                _this.tick = d;
                _this.callback(d);
                _this.timeOutID = window.setTimeout(stepTimeout, delay);
              };
            },
            start: function (callback, forceSetTimeOut, targetFPS) {
              if (this.isRunning) {
                return;
              }
              this.callback = callback;
              this.isSetTimeOut = forceSetTimeOut;
              this.target = targetFPS;
              this.isRunning = true;
              this.timeOutID = forceSetTimeOut ? window.setTimeout(this.stepTimeout, 0) : window.requestAnimationFrame(this.step);
            },
            stop: function () {
              this.isRunning = false;
              if (this.isSetTimeOut) {
                clearTimeout(this.timeOutID);
              } else {
                window.cancelAnimationFrame(this.timeOutID);
              }
            },
            destroy: function () {
              this.stop();
              this.callback = NOOP;
            }
          });
          module2.exports = RequestAnimationFrame;
        }, function (module2, exports2, __webpack_require__) {
          var Events = __webpack_require__(22);
          var VisibilityHandler = function (game) {
            var hiddenVar;
            var eventEmitter = game.events;
            if (document.hidden !== void 0) {
              hiddenVar = "visibilitychange";
            } else {
              var vendors = ["webkit", "moz", "ms"];
              vendors.forEach(function (prefix) {
                if (document[prefix + "Hidden"] !== void 0) {
                  document.hidden = function () {
                    return document[prefix + "Hidden"];
                  };
                  hiddenVar = prefix + "visibilitychange";
                }
              });
            }
            var onChange = function (event) {
              if (document.hidden || event.type === "pause") {
                eventEmitter.emit(Events.HIDDEN);
              } else {
                eventEmitter.emit(Events.VISIBLE);
              }
            };
            if (hiddenVar) {
              document.addEventListener(hiddenVar, onChange, false);
            }
            window.onblur = function () {
              eventEmitter.emit(Events.BLUR);
            };
            window.onfocus = function () {
              eventEmitter.emit(Events.FOCUS);
            };
            if (window.focus && game.config.autoFocus) {
              window.focus();
            }
          };
          module2.exports = VisibilityHandler;
        }, function (module2, exports2, __webpack_require__) {
          var Arne16 = __webpack_require__(389);
          var CanvasPool = __webpack_require__(31);
          var GetValue = __webpack_require__(6);
          var GenerateTexture = function (config) {
            var data = GetValue(config, "data", []);
            var canvas = GetValue(config, "canvas", null);
            var palette = GetValue(config, "palette", Arne16);
            var pixelWidth = GetValue(config, "pixelWidth", 1);
            var pixelHeight = GetValue(config, "pixelHeight", pixelWidth);
            var resizeCanvas = GetValue(config, "resizeCanvas", true);
            var clearCanvas = GetValue(config, "clearCanvas", true);
            var preRender = GetValue(config, "preRender", null);
            var postRender = GetValue(config, "postRender", null);
            var width = Math.floor(Math.abs(data[0].length * pixelWidth));
            var height = Math.floor(Math.abs(data.length * pixelHeight));
            if (!canvas) {
              canvas = CanvasPool.create2D(this, width, height);
              resizeCanvas = false;
              clearCanvas = false;
            }
            if (resizeCanvas) {
              canvas.width = width;
              canvas.height = height;
            }
            var ctx = canvas.getContext("2d");
            if (clearCanvas) {
              ctx.clearRect(0, 0, width, height);
            }
            if (preRender) {
              preRender(canvas, ctx);
            }
            for (var y = 0; y < data.length; y++) {
              var row = data[y];
              for (var x = 0; x < row.length; x++) {
                var d = row[x];
                if (d !== "." && d !== " ") {
                  ctx.fillStyle = palette[d];
                  ctx.fillRect(x * pixelWidth, y * pixelHeight, pixelWidth, pixelHeight);
                }
              }
            }
            if (postRender) {
              postRender(canvas, ctx);
            }
            return canvas;
          };
          module2.exports = GenerateTexture;
        }, function (module2, exports2) {
          module2.exports = {
            0: "#000",
            1: "#9D9D9D",
            2: "#FFF",
            3: "#BE2633",
            4: "#E06F8B",
            5: "#493C2B",
            6: "#A46422",
            7: "#EB8931",
            8: "#F7E26B",
            9: "#2F484E",
            A: "#44891A",
            B: "#A3CE27",
            C: "#1B2632",
            D: "#005784",
            E: "#31A2F2",
            F: "#B2DCEF"
          };
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CubicBezier = __webpack_require__(358);
          var Curve = __webpack_require__(94);
          var Vector2 = __webpack_require__(3);
          var CubicBezierCurve = new Class({
            Extends: Curve,
            initialize: function CubicBezierCurve2(p0, p1, p22, p3) {
              Curve.call(this, "CubicBezierCurve");
              if (Array.isArray(p0)) {
                p3 = new Vector2(p0[6], p0[7]);
                p22 = new Vector2(p0[4], p0[5]);
                p1 = new Vector2(p0[2], p0[3]);
                p0 = new Vector2(p0[0], p0[1]);
              }
              this.p0 = p0;
              this.p1 = p1;
              this.p2 = p22;
              this.p3 = p3;
            },
            getStartPoint: function (out) {
              if (out === void 0) {
                out = new Vector2();
              }
              return out.copy(this.p0);
            },
            getResolution: function (divisions) {
              return divisions;
            },
            getPoint: function (t, out) {
              if (out === void 0) {
                out = new Vector2();
              }
              var p0 = this.p0;
              var p1 = this.p1;
              var p22 = this.p2;
              var p3 = this.p3;
              return out.set(CubicBezier(t, p0.x, p1.x, p22.x, p3.x), CubicBezier(t, p0.y, p1.y, p22.y, p3.y));
            },
            draw: function (graphics, pointsTotal) {
              if (pointsTotal === void 0) {
                pointsTotal = 32;
              }
              var points = this.getPoints(pointsTotal);
              graphics.beginPath();
              graphics.moveTo(this.p0.x, this.p0.y);
              for (var i = 1; i < points.length; i++) {
                graphics.lineTo(points[i].x, points[i].y);
              }
              graphics.strokePath();
              return graphics;
            },
            toJSON: function () {
              return {
                type: this.type,
                points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y, this.p3.x, this.p3.y]
              };
            }
          });
          CubicBezierCurve.fromJSON = function (data) {
            var points = data.points;
            var p0 = new Vector2(points[0], points[1]);
            var p1 = new Vector2(points[2], points[3]);
            var p22 = new Vector2(points[4], points[5]);
            var p3 = new Vector2(points[6], points[7]);
            return new CubicBezierCurve(p0, p1, p22, p3);
          };
          module2.exports = CubicBezierCurve;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Curve = __webpack_require__(94);
          var DegToRad = __webpack_require__(36);
          var GetValue = __webpack_require__(6);
          var RadToDeg = __webpack_require__(196);
          var Vector2 = __webpack_require__(3);
          var EllipseCurve = new Class({
            Extends: Curve,
            initialize: function EllipseCurve2(x, y, xRadius, yRadius, startAngle, endAngle, clockwise, rotation) {
              if (typeof x === "object") {
                var config = x;
                x = GetValue(config, "x", 0);
                y = GetValue(config, "y", 0);
                xRadius = GetValue(config, "xRadius", 0);
                yRadius = GetValue(config, "yRadius", xRadius);
                startAngle = GetValue(config, "startAngle", 0);
                endAngle = GetValue(config, "endAngle", 360);
                clockwise = GetValue(config, "clockwise", false);
                rotation = GetValue(config, "rotation", 0);
              } else {
                if (yRadius === void 0) {
                  yRadius = xRadius;
                }
                if (startAngle === void 0) {
                  startAngle = 0;
                }
                if (endAngle === void 0) {
                  endAngle = 360;
                }
                if (clockwise === void 0) {
                  clockwise = false;
                }
                if (rotation === void 0) {
                  rotation = 0;
                }
              }
              Curve.call(this, "EllipseCurve");
              this.p0 = new Vector2(x, y);
              this._xRadius = xRadius;
              this._yRadius = yRadius;
              this._startAngle = DegToRad(startAngle);
              this._endAngle = DegToRad(endAngle);
              this._clockwise = clockwise;
              this._rotation = DegToRad(rotation);
            },
            getStartPoint: function (out) {
              if (out === void 0) {
                out = new Vector2();
              }
              return this.getPoint(0, out);
            },
            getResolution: function (divisions) {
              return divisions * 2;
            },
            getPoint: function (t, out) {
              if (out === void 0) {
                out = new Vector2();
              }
              var twoPi = Math.PI * 2;
              var deltaAngle = this._endAngle - this._startAngle;
              var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
              while (deltaAngle < 0) {
                deltaAngle += twoPi;
              }
              while (deltaAngle > twoPi) {
                deltaAngle -= twoPi;
              }
              if (deltaAngle < Number.EPSILON) {
                if (samePoints) {
                  deltaAngle = 0;
                } else {
                  deltaAngle = twoPi;
                }
              }
              if (this._clockwise && !samePoints) {
                if (deltaAngle === twoPi) {
                  deltaAngle = -twoPi;
                } else {
                  deltaAngle = deltaAngle - twoPi;
                }
              }
              var angle = this._startAngle + t * deltaAngle;
              var x = this.p0.x + this._xRadius * Math.cos(angle);
              var y = this.p0.y + this._yRadius * Math.sin(angle);
              if (this._rotation !== 0) {
                var cos = Math.cos(this._rotation);
                var sin = Math.sin(this._rotation);
                var tx = x - this.p0.x;
                var ty = y - this.p0.y;
                x = tx * cos - ty * sin + this.p0.x;
                y = tx * sin + ty * cos + this.p0.y;
              }
              return out.set(x, y);
            },
            setXRadius: function (value) {
              this.xRadius = value;
              return this;
            },
            setYRadius: function (value) {
              this.yRadius = value;
              return this;
            },
            setWidth: function (value) {
              this.xRadius = value / 2;
              return this;
            },
            setHeight: function (value) {
              this.yRadius = value / 2;
              return this;
            },
            setStartAngle: function (value) {
              this.startAngle = value;
              return this;
            },
            setEndAngle: function (value) {
              this.endAngle = value;
              return this;
            },
            setClockwise: function (value) {
              this.clockwise = value;
              return this;
            },
            setRotation: function (value) {
              this.rotation = value;
              return this;
            },
            x: {
              get: function () {
                return this.p0.x;
              },
              set: function (value) {
                this.p0.x = value;
              }
            },
            y: {
              get: function () {
                return this.p0.y;
              },
              set: function (value) {
                this.p0.y = value;
              }
            },
            xRadius: {
              get: function () {
                return this._xRadius;
              },
              set: function (value) {
                this._xRadius = value;
              }
            },
            yRadius: {
              get: function () {
                return this._yRadius;
              },
              set: function (value) {
                this._yRadius = value;
              }
            },
            startAngle: {
              get: function () {
                return RadToDeg(this._startAngle);
              },
              set: function (value) {
                this._startAngle = DegToRad(value);
              }
            },
            endAngle: {
              get: function () {
                return RadToDeg(this._endAngle);
              },
              set: function (value) {
                this._endAngle = DegToRad(value);
              }
            },
            clockwise: {
              get: function () {
                return this._clockwise;
              },
              set: function (value) {
                this._clockwise = value;
              }
            },
            angle: {
              get: function () {
                return RadToDeg(this._rotation);
              },
              set: function (value) {
                this._rotation = DegToRad(value);
              }
            },
            rotation: {
              get: function () {
                return this._rotation;
              },
              set: function (value) {
                this._rotation = value;
              }
            },
            toJSON: function () {
              return {
                type: this.type,
                x: this.p0.x,
                y: this.p0.y,
                xRadius: this._xRadius,
                yRadius: this._yRadius,
                startAngle: RadToDeg(this._startAngle),
                endAngle: RadToDeg(this._endAngle),
                clockwise: this._clockwise,
                rotation: RadToDeg(this._rotation)
              };
            }
          });
          EllipseCurve.fromJSON = function (data) {
            return new EllipseCurve(data);
          };
          module2.exports = EllipseCurve;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Curve = __webpack_require__(94);
          var FromPoints = __webpack_require__(199);
          var Rectangle = __webpack_require__(10);
          var Vector2 = __webpack_require__(3);
          var LineCurve = new Class({
            Extends: Curve,
            initialize: function LineCurve2(p0, p1) {
              Curve.call(this, "LineCurve");
              if (Array.isArray(p0)) {
                p1 = new Vector2(p0[2], p0[3]);
                p0 = new Vector2(p0[0], p0[1]);
              }
              this.p0 = p0;
              this.p1 = p1;
              this.arcLengthDivisions = 1;
            },
            getBounds: function (out) {
              if (out === void 0) {
                out = new Rectangle();
              }
              return FromPoints([this.p0, this.p1], out);
            },
            getStartPoint: function (out) {
              if (out === void 0) {
                out = new Vector2();
              }
              return out.copy(this.p0);
            },
            getResolution: function (divisions) {
              if (divisions === void 0) {
                divisions = 1;
              }
              return divisions;
            },
            getPoint: function (t, out) {
              if (out === void 0) {
                out = new Vector2();
              }
              if (t === 1) {
                return out.copy(this.p1);
              }
              out.copy(this.p1).subtract(this.p0).scale(t).add(this.p0);
              return out;
            },
            getPointAt: function (u, out) {
              return this.getPoint(u, out);
            },
            getTangent: function (t, out) {
              if (out === void 0) {
                out = new Vector2();
              }
              out.copy(this.p1).subtract(this.p0).normalize();
              return out;
            },
            getUtoTmapping: function (u, distance, divisions) {
              var t;
              if (distance) {
                var arcLengths = this.getLengths(divisions);
                var lineLength = arcLengths[arcLengths.length - 1];
                var targetLineLength = Math.min(distance, lineLength);
                t = targetLineLength / lineLength;
              } else {
                t = u;
              }
              return t;
            },
            draw: function (graphics) {
              graphics.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y);
              return graphics;
            },
            toJSON: function () {
              return {
                type: this.type,
                points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y]
              };
            }
          });
          LineCurve.fromJSON = function (data) {
            var points = data.points;
            var p0 = new Vector2(points[0], points[1]);
            var p1 = new Vector2(points[2], points[3]);
            return new LineCurve(p0, p1);
          };
          module2.exports = LineCurve;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Vector2 = __webpack_require__(3);
          var MoveTo = new Class({
            initialize: function MoveTo2(x, y) {
              this.active = false;
              this.p0 = new Vector2(x, y);
            },
            getPoint: function (t, out) {
              if (out === void 0) {
                out = new Vector2();
              }
              return out.copy(this.p0);
            },
            getPointAt: function (u, out) {
              return this.getPoint(u, out);
            },
            getResolution: function () {
              return 1;
            },
            getLength: function () {
              return 0;
            },
            toJSON: function () {
              return {
                type: "MoveTo",
                points: [this.p0.x, this.p0.y]
              };
            }
          });
          module2.exports = MoveTo;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Curve = __webpack_require__(94);
          var QuadraticBezierInterpolation = __webpack_require__(359);
          var Vector2 = __webpack_require__(3);
          var QuadraticBezier = new Class({
            Extends: Curve,
            initialize: function QuadraticBezier2(p0, p1, p22) {
              Curve.call(this, "QuadraticBezier");
              if (Array.isArray(p0)) {
                p22 = new Vector2(p0[4], p0[5]);
                p1 = new Vector2(p0[2], p0[3]);
                p0 = new Vector2(p0[0], p0[1]);
              }
              this.p0 = p0;
              this.p1 = p1;
              this.p2 = p22;
            },
            getStartPoint: function (out) {
              if (out === void 0) {
                out = new Vector2();
              }
              return out.copy(this.p0);
            },
            getResolution: function (divisions) {
              return divisions;
            },
            getPoint: function (t, out) {
              if (out === void 0) {
                out = new Vector2();
              }
              var p0 = this.p0;
              var p1 = this.p1;
              var p22 = this.p2;
              return out.set(QuadraticBezierInterpolation(t, p0.x, p1.x, p22.x), QuadraticBezierInterpolation(t, p0.y, p1.y, p22.y));
            },
            draw: function (graphics, pointsTotal) {
              if (pointsTotal === void 0) {
                pointsTotal = 32;
              }
              var points = this.getPoints(pointsTotal);
              graphics.beginPath();
              graphics.moveTo(this.p0.x, this.p0.y);
              for (var i = 1; i < points.length; i++) {
                graphics.lineTo(points[i].x, points[i].y);
              }
              graphics.strokePath();
              return graphics;
            },
            toJSON: function () {
              return {
                type: this.type,
                points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y]
              };
            }
          });
          QuadraticBezier.fromJSON = function (data) {
            var points = data.points;
            var p0 = new Vector2(points[0], points[1]);
            var p1 = new Vector2(points[2], points[3]);
            var p22 = new Vector2(points[4], points[5]);
            return new QuadraticBezier(p0, p1, p22);
          };
          module2.exports = QuadraticBezier;
        }, function (module2, exports2, __webpack_require__) {
          var CatmullRom = __webpack_require__(194);
          var Class = __webpack_require__(0);
          var Curve = __webpack_require__(94);
          var Vector2 = __webpack_require__(3);
          var SplineCurve = new Class({
            Extends: Curve,
            initialize: function SplineCurve2(points) {
              if (points === void 0) {
                points = [];
              }
              Curve.call(this, "SplineCurve");
              this.points = [];
              this.addPoints(points);
            },
            addPoints: function (points) {
              for (var i = 0; i < points.length; i++) {
                var p3 = new Vector2();
                if (typeof points[i] === "number") {
                  p3.x = points[i];
                  p3.y = points[i + 1];
                  i++;
                } else if (Array.isArray(points[i])) {
                  p3.x = points[i][0];
                  p3.y = points[i][1];
                } else {
                  p3.x = points[i].x;
                  p3.y = points[i].y;
                }
                this.points.push(p3);
              }
              return this;
            },
            addPoint: function (x, y) {
              var vec = new Vector2(x, y);
              this.points.push(vec);
              return vec;
            },
            getStartPoint: function (out) {
              if (out === void 0) {
                out = new Vector2();
              }
              return out.copy(this.points[0]);
            },
            getResolution: function (divisions) {
              return divisions * this.points.length;
            },
            getPoint: function (t, out) {
              if (out === void 0) {
                out = new Vector2();
              }
              var points = this.points;
              var point = (points.length - 1) * t;
              var intPoint = Math.floor(point);
              var weight = point - intPoint;
              var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
              var p1 = points[intPoint];
              var p22 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
              var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
              return out.set(CatmullRom(weight, p0.x, p1.x, p22.x, p3.x), CatmullRom(weight, p0.y, p1.y, p22.y, p3.y));
            },
            toJSON: function () {
              var points = [];
              for (var i = 0; i < this.points.length; i++) {
                points.push(this.points[i].x);
                points.push(this.points[i].y);
              }
              return {
                type: this.type,
                points
              };
            }
          });
          SplineCurve.fromJSON = function (data) {
            return new SplineCurve(data.points);
          };
          module2.exports = SplineCurve;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var BaseShader = new Class({
            initialize: function BaseShader2(key, fragmentSrc, vertexSrc, uniforms) {
              if (!fragmentSrc || fragmentSrc === "") {
                fragmentSrc = ["precision mediump float;", "uniform vec2 resolution;", "varying vec2 fragCoord;", "void main () {", "    vec2 uv = fragCoord / resolution.xy;", "    gl_FragColor = vec4(uv.xyx, 1.0);", "}"].join("\n");
              }
              if (!vertexSrc || vertexSrc === "") {
                vertexSrc = ["precision mediump float;", "uniform mat4 uProjectionMatrix;", "uniform mat4 uViewMatrix;", "uniform vec2 uResolution;", "attribute vec2 inPosition;", "varying vec2 fragCoord;", "varying vec2 outTexCoord;", "void main () {", "   gl_Position = uProjectionMatrix * uViewMatrix * vec4(inPosition, 1.0, 1.0);", "   fragCoord = vec2(inPosition.x, uResolution.y - inPosition.y);", "   outTexCoord = vec2(inPosition.x / uResolution.x, fragCoord.y / uResolution.y);", "}"].join("\n");
              }
              if (uniforms === void 0) {
                uniforms = null;
              }
              this.key = key;
              this.fragmentSrc = fragmentSrc;
              this.vertexSrc = vertexSrc;
              this.uniforms = uniforms;
            }
          });
          module2.exports = BaseShader;
        }, function (module2, exports2, __webpack_require__) {
          var Color = __webpack_require__(38);
          Color.ColorSpectrum = __webpack_require__(909);
          Color.ColorToRGBA = __webpack_require__(910);
          Color.ComponentToHex = __webpack_require__(398);
          Color.GetColor = __webpack_require__(103);
          Color.GetColor32 = __webpack_require__(328);
          Color.HexStringToColor = __webpack_require__(327);
          Color.HSLToColor = __webpack_require__(911);
          Color.HSVColorWheel = __webpack_require__(912);
          Color.HSVToRGB = __webpack_require__(188);
          Color.HueToComponent = __webpack_require__(399);
          Color.IntegerToColor = __webpack_require__(189);
          Color.IntegerToRGB = __webpack_require__(330);
          Color.Interpolate = __webpack_require__(913);
          Color.ObjectToColor = __webpack_require__(331);
          Color.RandomRGB = __webpack_require__(914);
          Color.RGBStringToColor = __webpack_require__(332);
          Color.RGBToHSV = __webpack_require__(329);
          Color.RGBToString = __webpack_require__(915);
          Color.ValueToColor = __webpack_require__(187);
          module2.exports = Color;
        }, function (module2, exports2) {
          var ComponentToHex = function (color) {
            var hex = color.toString(16);
            return hex.length === 1 ? "0" + hex : hex;
          };
          module2.exports = ComponentToHex;
        }, function (module2, exports2) {
          var HueToComponent = function (p3, q, t) {
            if (t < 0) {
              t += 1;
            }
            if (t > 1) {
              t -= 1;
            }
            if (t < 1 / 6) {
              return p3 + (q - p3) * 6 * t;
            }
            if (t < 1 / 2) {
              return q;
            }
            if (t < 2 / 3) {
              return p3 + (q - p3) * (2 / 3 - t) * 6;
            }
            return p3;
          };
          module2.exports = HueToComponent;
        }, function (module2, exports2, __webpack_require__) {
          var OS = __webpack_require__(105);
          var DOMContentLoaded = function (callback) {
            if (document.readyState === "complete" || document.readyState === "interactive") {
              callback();
              return;
            }
            var check = function () {
              document.removeEventListener("deviceready", check, true);
              document.removeEventListener("DOMContentLoaded", check, true);
              window.removeEventListener("load", check, true);
              callback();
            };
            if (!document.body) {
              window.setTimeout(check, 20);
            } else if (OS.cordova) {
              document.addEventListener("deviceready", check, false);
            } else {
              document.addEventListener("DOMContentLoaded", check, true);
              window.addEventListener("load", check, true);
            }
          };
          module2.exports = DOMContentLoaded;
        }, function (module2, exports2) {
          var GetInnerHeight = function (iOS) {
            if (!iOS) {
              return window.innerHeight;
            }
            var axis = Math.abs(window.orientation);
            var size = {
              w: 0,
              h: 0
            };
            var ruler = document.createElement("div");
            ruler.setAttribute("style", "position: fixed; height: 100vh; width: 0; top: 0");
            document.documentElement.appendChild(ruler);
            size.w = axis === 90 ? ruler.offsetHeight : window.innerWidth;
            size.h = axis === 90 ? window.innerWidth : ruler.offsetHeight;
            document.documentElement.removeChild(ruler);
            ruler = null;
            if (Math.abs(window.orientation) !== 90) {
              return size.h;
            } else {
              return size.w;
            }
          };
          module2.exports = GetInnerHeight;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(201);
          var GetScreenOrientation = function (width, height) {
            var screen2 = window.screen;
            var orientation = screen2 ? screen2.orientation || screen2.mozOrientation || screen2.msOrientation : false;
            if (orientation && typeof orientation.type === "string") {
              return orientation.type;
            } else if (typeof orientation === "string") {
              return orientation;
            }
            if (typeof window.orientation === "number") {
              return window.orientation === 0 || window.orientation === 180 ? CONST.ORIENTATION.PORTRAIT : CONST.ORIENTATION.LANDSCAPE;
            } else if (window.matchMedia) {
              if (window.matchMedia("(orientation: portrait)").matches) {
                return CONST.ORIENTATION.PORTRAIT;
              } else if (window.matchMedia("(orientation: landscape)").matches) {
                return CONST.ORIENTATION.LANDSCAPE;
              }
            } else {
              return height > width ? CONST.ORIENTATION.PORTRAIT : CONST.ORIENTATION.LANDSCAPE;
            }
          };
          module2.exports = GetScreenOrientation;
        }, function (module2, exports2) {
          module2.exports = {
            NO_CENTER: 0,
            CENTER_BOTH: 1,
            CENTER_HORIZONTALLY: 2,
            CENTER_VERTICALLY: 3
          };
        }, function (module2, exports2) {
          module2.exports = {
            LANDSCAPE: "landscape-primary",
            PORTRAIT: "portrait-primary"
          };
        }, function (module2, exports2) {
          module2.exports = {
            NONE: 0,
            WIDTH_CONTROLS_HEIGHT: 1,
            HEIGHT_CONTROLS_WIDTH: 2,
            FIT: 3,
            ENVELOP: 4,
            RESIZE: 5
          };
        }, function (module2, exports2) {
          module2.exports = {
            NO_ZOOM: 1,
            ZOOM_2X: 2,
            ZOOM_4X: 4,
            MAX_ZOOM: -1
          };
        }, function (module2, exports2) {
          var GetTarget = function (element) {
            var target;
            if (element !== "") {
              if (typeof element === "string") {
                target = document.getElementById(element);
              } else if (element && element.nodeType === 1) {
                target = element;
              }
            }
            if (!target) {
              target = document.body;
            }
            return target;
          };
          module2.exports = GetTarget;
        }, function (module2, exports2) {
          var ParseXML = function (data) {
            var xml = "";
            try {
              if (window["DOMParser"]) {
                var domparser = new DOMParser();
                xml = domparser.parseFromString(data, "text/xml");
              } else {
                xml = new ActiveXObject("Microsoft.XMLDOM");
                xml.loadXML(data);
              }
            } catch (e) {
              xml = null;
            }
            if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
              return null;
            } else {
              return xml;
            }
          };
          module2.exports = ParseXML;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(203);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(51);
          var GameEvents = __webpack_require__(22);
          var Keyboard = __webpack_require__(410);
          var Mouse = __webpack_require__(411);
          var Pointer = __webpack_require__(412);
          var Touch = __webpack_require__(413);
          var TransformMatrix = __webpack_require__(25);
          var TransformXY = __webpack_require__(177);
          var InputManager = new Class({
            initialize: function InputManager2(game, config) {
              this.game = game;
              this.scaleManager;
              this.canvas;
              this.config = config;
              this.enabled = true;
              this.events = new EventEmitter();
              this.isOver = true;
              this.defaultCursor = "";
              this.keyboard = config.inputKeyboard ? new Keyboard(this) : null;
              this.mouse = config.inputMouse ? new Mouse(this) : null;
              this.touch = config.inputTouch ? new Touch(this) : null;
              this.pointers = [];
              this.pointersTotal = config.inputActivePointers;
              if (config.inputTouch && this.pointersTotal === 1) {
                this.pointersTotal = 2;
              }
              for (var i = 0; i <= this.pointersTotal; i++) {
                var pointer = new Pointer(this, i);
                pointer.smoothFactor = config.inputSmoothFactor;
                this.pointers.push(pointer);
              }
              this.mousePointer = config.inputMouse ? this.pointers[0] : null;
              this.activePointer = this.pointers[0];
              this.globalTopOnly = true;
              this.time = 0;
              this._tempPoint = {
                x: 0,
                y: 0
              };
              this._tempHitTest = [];
              this._tempMatrix = new TransformMatrix();
              this._tempMatrix2 = new TransformMatrix();
              this._tempSkip = false;
              this.mousePointerContainer = [this.mousePointer];
              game.events.once(GameEvents.BOOT, this.boot, this);
            },
            boot: function () {
              this.canvas = this.game.canvas;
              this.scaleManager = this.game.scale;
              this.events.emit(Events.MANAGER_BOOT);
              this.game.events.on(GameEvents.PRE_RENDER, this.preRender, this);
              this.game.events.once(GameEvents.DESTROY, this.destroy, this);
            },
            setCanvasOver: function (event) {
              this.isOver = true;
              this.events.emit(Events.GAME_OVER, event);
            },
            setCanvasOut: function (event) {
              this.isOver = false;
              this.events.emit(Events.GAME_OUT, event);
            },
            preRender: function () {
              var time = this.game.loop.now;
              var delta = this.game.loop.delta;
              var scenes = this.game.scene.getScenes(true, true);
              this.time = time;
              this.events.emit(Events.MANAGER_UPDATE);
              for (var i = 0; i < scenes.length; i++) {
                var scene = scenes[i];
                if (scene.sys.input && scene.sys.input.updatePoll(time, delta) && this.globalTopOnly) {
                  return;
                }
              }
            },
            setDefaultCursor: function (cursor) {
              this.defaultCursor = cursor;
              if (this.canvas.style.cursor !== cursor) {
                this.canvas.style.cursor = cursor;
              }
            },
            setCursor: function (interactiveObject) {
              if (interactiveObject.cursor) {
                this.canvas.style.cursor = interactiveObject.cursor;
              }
            },
            resetCursor: function (interactiveObject) {
              if (interactiveObject.cursor && this.canvas) {
                this.canvas.style.cursor = this.defaultCursor;
              }
            },
            addPointer: function (quantity) {
              if (quantity === void 0) {
                quantity = 1;
              }
              var output = [];
              if (this.pointersTotal + quantity > 10) {
                quantity = 10 - this.pointersTotal;
              }
              for (var i = 0; i < quantity; i++) {
                var id = this.pointers.length;
                var pointer = new Pointer(this, id);
                pointer.smoothFactor = this.config.inputSmoothFactor;
                this.pointers.push(pointer);
                this.pointersTotal++;
                output.push(pointer);
              }
              return output;
            },
            updateInputPlugins: function (type, pointers) {
              var scenes = this.game.scene.getScenes(true, true);
              this._tempSkip = false;
              for (var i = 0; i < scenes.length; i++) {
                var scene = scenes[i];
                if (scene.sys.input) {
                  var capture = scene.sys.input.update(type, pointers);
                  if (capture && this.globalTopOnly || this._tempSkip) {
                    return;
                  }
                }
              }
            },
            onTouchStart: function (event) {
              var pointers = this.pointers;
              var changed = [];
              for (var c = 0; c < event.changedTouches.length; c++) {
                var changedTouch = event.changedTouches[c];
                for (var i = 1; i < this.pointersTotal; i++) {
                  var pointer = pointers[i];
                  if (!pointer.active) {
                    pointer.touchstart(changedTouch, event);
                    this.activePointer = pointer;
                    changed.push(pointer);
                    break;
                  }
                }
              }
              this.updateInputPlugins(CONST.TOUCH_START, changed);
            },
            onTouchMove: function (event) {
              var pointers = this.pointers;
              var changed = [];
              for (var c = 0; c < event.changedTouches.length; c++) {
                var changedTouch = event.changedTouches[c];
                for (var i = 1; i < this.pointersTotal; i++) {
                  var pointer = pointers[i];
                  if (pointer.active && pointer.identifier === changedTouch.identifier) {
                    pointer.touchmove(changedTouch, event);
                    this.activePointer = pointer;
                    changed.push(pointer);
                    break;
                  }
                }
              }
              this.updateInputPlugins(CONST.TOUCH_MOVE, changed);
            },
            onTouchEnd: function (event) {
              var pointers = this.pointers;
              var changed = [];
              for (var c = 0; c < event.changedTouches.length; c++) {
                var changedTouch = event.changedTouches[c];
                for (var i = 1; i < this.pointersTotal; i++) {
                  var pointer = pointers[i];
                  if (pointer.active && pointer.identifier === changedTouch.identifier) {
                    pointer.touchend(changedTouch, event);
                    changed.push(pointer);
                    break;
                  }
                }
              }
              this.updateInputPlugins(CONST.TOUCH_END, changed);
            },
            onTouchCancel: function (event) {
              var pointers = this.pointers;
              var changed = [];
              for (var c = 0; c < event.changedTouches.length; c++) {
                var changedTouch = event.changedTouches[c];
                for (var i = 1; i < this.pointersTotal; i++) {
                  var pointer = pointers[i];
                  if (pointer.active && pointer.identifier === changedTouch.identifier) {
                    pointer.touchcancel(changedTouch, event);
                    changed.push(pointer);
                    break;
                  }
                }
              }
              this.updateInputPlugins(CONST.TOUCH_CANCEL, changed);
            },
            onMouseDown: function (event) {
              var mousePointer = this.mousePointer;
              mousePointer.down(event);
              mousePointer.updateMotion();
              this.activePointer = mousePointer;
              this.updateInputPlugins(CONST.MOUSE_DOWN, this.mousePointerContainer);
            },
            onMouseMove: function (event) {
              var mousePointer = this.mousePointer;
              mousePointer.move(event);
              mousePointer.updateMotion();
              this.activePointer = mousePointer;
              this.updateInputPlugins(CONST.MOUSE_MOVE, this.mousePointerContainer);
            },
            onMouseUp: function (event) {
              var mousePointer = this.mousePointer;
              mousePointer.up(event);
              mousePointer.updateMotion();
              this.activePointer = mousePointer;
              this.updateInputPlugins(CONST.MOUSE_UP, this.mousePointerContainer);
            },
            onMouseWheel: function (event) {
              var mousePointer = this.mousePointer;
              mousePointer.wheel(event);
              this.activePointer = mousePointer;
              this.updateInputPlugins(CONST.MOUSE_WHEEL, this.mousePointerContainer);
            },
            onPointerLockChange: function (event) {
              var isLocked = this.mouse.locked;
              this.mousePointer.locked = isLocked;
              this.events.emit(Events.POINTERLOCK_CHANGE, event, isLocked);
            },
            inputCandidate: function (gameObject, camera) {
              var input = gameObject.input;
              if (!input || !input.enabled || !input.alwaysEnabled && !gameObject.willRender(camera)) {
                return false;
              }
              var visible = true;
              var parent = gameObject.parentContainer;
              if (parent) {
                do {
                  if (!parent.willRender(camera)) {
                    visible = false;
                    break;
                  }
                  parent = parent.parentContainer;
                } while (parent);
              }
              return visible;
            },
            hitTest: function (pointer, gameObjects, camera, output) {
              if (output === void 0) {
                output = this._tempHitTest;
              }
              var tempPoint = this._tempPoint;
              var csx = camera.scrollX;
              var csy = camera.scrollY;
              output.length = 0;
              var x = pointer.x;
              var y = pointer.y;
              camera.getWorldPoint(x, y, tempPoint);
              pointer.worldX = tempPoint.x;
              pointer.worldY = tempPoint.y;
              var point = {
                x: 0,
                y: 0
              };
              var matrix = this._tempMatrix;
              var parentMatrix = this._tempMatrix2;
              for (var i = 0; i < gameObjects.length; i++) {
                var gameObject = gameObjects[i];
                if (!this.inputCandidate(gameObject, camera)) {
                  continue;
                }
                var px = tempPoint.x + csx * gameObject.scrollFactorX - csx;
                var py = tempPoint.y + csy * gameObject.scrollFactorY - csy;
                if (gameObject.parentContainer) {
                  gameObject.getWorldTransformMatrix(matrix, parentMatrix);
                  matrix.applyInverse(px, py, point);
                } else {
                  TransformXY(px, py, gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY, point);
                }
                if (this.pointWithinHitArea(gameObject, point.x, point.y)) {
                  output.push(gameObject);
                }
              }
              return output;
            },
            pointWithinHitArea: function (gameObject, x, y) {
              x += gameObject.displayOriginX;
              y += gameObject.displayOriginY;
              var input = gameObject.input;
              if (input && input.hitAreaCallback(input.hitArea, x, y, gameObject)) {
                input.localX = x;
                input.localY = y;
                return true;
              } else {
                return false;
              }
            },
            pointWithinInteractiveObject: function (object, x, y) {
              if (!object.hitArea) {
                return false;
              }
              x += object.gameObject.displayOriginX;
              y += object.gameObject.displayOriginY;
              object.localX = x;
              object.localY = y;
              return object.hitAreaCallback(object.hitArea, x, y, object);
            },
            transformPointer: function (pointer, pageX, pageY, wasMove) {
              var p0 = pointer.position;
              var p1 = pointer.prevPosition;
              p1.x = p0.x;
              p1.y = p0.y;
              var x = this.scaleManager.transformX(pageX);
              var y = this.scaleManager.transformY(pageY);
              var a = pointer.smoothFactor;
              if (!wasMove || a === 0) {
                p0.x = x;
                p0.y = y;
              } else {
                p0.x = x * a + p1.x * (1 - a);
                p0.y = y * a + p1.y * (1 - a);
              }
            },
            destroy: function () {
              this.events.removeAllListeners();
              this.game.events.off(GameEvents.PRE_RENDER);
              if (this.keyboard) {
                this.keyboard.destroy();
              }
              if (this.mouse) {
                this.mouse.destroy();
              }
              if (this.touch) {
                this.touch.destroy();
              }
              for (var i = 0; i < this.pointers.length; i++) {
                this.pointers[i].destroy();
              }
              this.pointers = [];
              this._tempHitTest = [];
              this._tempMatrix.destroy();
              this.canvas = null;
              this.game = null;
            }
          });
          module2.exports = InputManager;
        }, function (module2, exports2, __webpack_require__) {
          var ArrayRemove = __webpack_require__(93);
          var Class = __webpack_require__(0);
          var GameEvents = __webpack_require__(22);
          var InputEvents = __webpack_require__(51);
          var KeyCodes = __webpack_require__(143);
          var NOOP = __webpack_require__(1);
          var KeyboardManager = new Class({
            initialize: function KeyboardManager2(inputManager) {
              this.manager = inputManager;
              this.queue = [];
              this.preventDefault = true;
              this.captures = [];
              this.enabled = false;
              this.target;
              this.onKeyDown = NOOP;
              this.onKeyUp = NOOP;
              inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
            },
            boot: function () {
              var config = this.manager.config;
              this.enabled = config.inputKeyboard;
              this.target = config.inputKeyboardEventTarget;
              this.addCapture(config.inputKeyboardCapture);
              if (!this.target && window) {
                this.target = window;
              }
              if (this.enabled && this.target) {
                this.startListeners();
              }
              this.manager.game.events.on(GameEvents.POST_STEP, this.postUpdate, this);
            },
            startListeners: function () {
              var _this = this;
              this.onKeyDown = function (event) {
                if (event.defaultPrevented || !_this.enabled || !_this.manager) {
                  return;
                }
                _this.queue.push(event);
                _this.manager.events.emit(InputEvents.MANAGER_PROCESS);
                var modified = event.altKey || event.ctrlKey || event.shiftKey || event.metaKey;
                if (_this.preventDefault && !modified && _this.captures.indexOf(event.keyCode) > -1) {
                  event.preventDefault();
                }
              };
              this.onKeyUp = function (event) {
                if (event.defaultPrevented || !_this.enabled || !_this.manager) {
                  return;
                }
                _this.queue.push(event);
                _this.manager.events.emit(InputEvents.MANAGER_PROCESS);
                var modified = event.altKey || event.ctrlKey || event.shiftKey || event.metaKey;
                if (_this.preventDefault && !modified && _this.captures.indexOf(event.keyCode) > -1) {
                  event.preventDefault();
                }
              };
              var target = this.target;
              if (target) {
                target.addEventListener("keydown", this.onKeyDown, false);
                target.addEventListener("keyup", this.onKeyUp, false);
                this.enabled = true;
              }
            },
            stopListeners: function () {
              var target = this.target;
              target.removeEventListener("keydown", this.onKeyDown, false);
              target.removeEventListener("keyup", this.onKeyUp, false);
              this.enabled = false;
            },
            postUpdate: function () {
              this.queue = [];
            },
            addCapture: function (keycode) {
              if (typeof keycode === "string") {
                keycode = keycode.split(",");
              }
              if (!Array.isArray(keycode)) {
                keycode = [keycode];
              }
              var captures = this.captures;
              for (var i = 0; i < keycode.length; i++) {
                var code = keycode[i];
                if (typeof code === "string") {
                  code = KeyCodes[code.trim().toUpperCase()];
                }
                if (captures.indexOf(code) === -1) {
                  captures.push(code);
                }
              }
              this.preventDefault = captures.length > 0;
            },
            removeCapture: function (keycode) {
              if (typeof keycode === "string") {
                keycode = keycode.split(",");
              }
              if (!Array.isArray(keycode)) {
                keycode = [keycode];
              }
              var captures = this.captures;
              for (var i = 0; i < keycode.length; i++) {
                var code = keycode[i];
                if (typeof code === "string") {
                  code = KeyCodes[code.toUpperCase()];
                }
                ArrayRemove(captures, code);
              }
              this.preventDefault = captures.length > 0;
            },
            clearCaptures: function () {
              this.captures = [];
              this.preventDefault = false;
            },
            destroy: function () {
              this.stopListeners();
              this.clearCaptures();
              this.queue = [];
              this.manager.game.events.off(GameEvents.POST_RENDER, this.postUpdate, this);
              this.target = null;
              this.enabled = false;
              this.manager = null;
            }
          });
          module2.exports = KeyboardManager;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Features = __webpack_require__(191);
          var InputEvents = __webpack_require__(51);
          var NOOP = __webpack_require__(1);
          var MouseManager = new Class({
            initialize: function MouseManager2(inputManager) {
              this.manager = inputManager;
              this.preventDefaultDown = true;
              this.preventDefaultUp = true;
              this.preventDefaultMove = true;
              this.preventDefaultWheel = false;
              this.enabled = false;
              this.target;
              this.locked = false;
              this.onMouseMove = NOOP;
              this.onMouseDown = NOOP;
              this.onMouseUp = NOOP;
              this.onMouseDownWindow = NOOP;
              this.onMouseUpWindow = NOOP;
              this.onMouseOver = NOOP;
              this.onMouseOut = NOOP;
              this.onMouseWheel = NOOP;
              this.pointerLockChange = NOOP;
              this.isTop = true;
              inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
            },
            boot: function () {
              var config = this.manager.config;
              this.enabled = config.inputMouse;
              this.target = config.inputMouseEventTarget;
              this.passive = config.inputMousePassive;
              this.preventDefaultDown = config.inputMousePreventDefaultDown;
              this.preventDefaultUp = config.inputMousePreventDefaultUp;
              this.preventDefaultMove = config.inputMousePreventDefaultMove;
              this.preventDefaultWheel = config.inputMousePreventDefaultWheel;
              if (!this.target) {
                this.target = this.manager.game.canvas;
              } else if (typeof this.target === "string") {
                this.target = document.getElementById(this.target);
              }
              if (config.disableContextMenu) {
                this.disableContextMenu();
              }
              if (this.enabled && this.target) {
                this.startListeners();
              }
            },
            disableContextMenu: function () {
              document.body.addEventListener("contextmenu", function (event) {
                event.preventDefault();
                return false;
              });
              return this;
            },
            requestPointerLock: function () {
              if (Features.pointerLock) {
                var element = this.target;
                element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                element.requestPointerLock();
              }
            },
            releasePointerLock: function () {
              if (Features.pointerLock) {
                document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
                document.exitPointerLock();
              }
            },
            startListeners: function () {
              var target = this.target;
              if (!target) {
                return;
              }
              var _this = this;
              var manager = this.manager;
              var canvas = manager.canvas;
              var autoFocus = window && window.focus && manager.game.config.autoFocus;
              this.onMouseMove = function (event) {
                if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                  manager.onMouseMove(event);
                  if (_this.preventDefaultMove) {
                    event.preventDefault();
                  }
                }
              };
              this.onMouseDown = function (event) {
                if (autoFocus) {
                  window.focus();
                }
                if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                  manager.onMouseDown(event);
                  if (_this.preventDefaultDown && event.target === canvas) {
                    event.preventDefault();
                  }
                }
              };
              this.onMouseDownWindow = function (event) {
                if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas) {
                  manager.onMouseDown(event);
                }
              };
              this.onMouseUp = function (event) {
                if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                  manager.onMouseUp(event);
                  if (_this.preventDefaultUp && event.target === canvas) {
                    event.preventDefault();
                  }
                }
              };
              this.onMouseUpWindow = function (event) {
                if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas) {
                  manager.onMouseUp(event);
                }
              };
              this.onMouseOver = function (event) {
                if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                  manager.setCanvasOver(event);
                }
              };
              this.onMouseOut = function (event) {
                if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                  manager.setCanvasOut(event);
                }
              };
              this.onMouseWheel = function (event) {
                if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
                  manager.onMouseWheel(event);
                }
                if (_this.preventDefaultWheel && event.target === canvas) {
                  event.preventDefault();
                }
              };
              var passive = {
                passive: true
              };
              target.addEventListener("mousemove", this.onMouseMove);
              target.addEventListener("mousedown", this.onMouseDown);
              target.addEventListener("mouseup", this.onMouseUp);
              target.addEventListener("mouseover", this.onMouseOver, passive);
              target.addEventListener("mouseout", this.onMouseOut, passive);
              if (this.preventDefaultWheel) {
                target.addEventListener("wheel", this.onMouseWheel, {
                  passive: false
                });
              } else {
                target.addEventListener("wheel", this.onMouseWheel, passive);
              }
              if (window && manager.game.config.inputWindowEvents) {
                try {
                  window.top.addEventListener("mousedown", this.onMouseDownWindow, passive);
                  window.top.addEventListener("mouseup", this.onMouseUpWindow, passive);
                } catch (exception) {
                  window.addEventListener("mousedown", this.onMouseDownWindow, passive);
                  window.addEventListener("mouseup", this.onMouseUpWindow, passive);
                  this.isTop = false;
                }
              }
              if (Features.pointerLock) {
                this.pointerLockChange = function (event) {
                  var element = _this.target;
                  _this.locked = document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ? true : false;
                  manager.onPointerLockChange(event);
                };
                document.addEventListener("pointerlockchange", this.pointerLockChange, true);
                document.addEventListener("mozpointerlockchange", this.pointerLockChange, true);
                document.addEventListener("webkitpointerlockchange", this.pointerLockChange, true);
              }
              this.enabled = true;
            },
            stopListeners: function () {
              var target = this.target;
              target.removeEventListener("mousemove", this.onMouseMove);
              target.removeEventListener("mousedown", this.onMouseDown);
              target.removeEventListener("mouseup", this.onMouseUp);
              target.removeEventListener("mouseover", this.onMouseOver);
              target.removeEventListener("mouseout", this.onMouseOut);
              if (window) {
                target = this.isTop ? window.top : window;
                target.removeEventListener("mousedown", this.onMouseDownWindow);
                target.removeEventListener("mouseup", this.onMouseUpWindow);
              }
              if (Features.pointerLock) {
                document.removeEventListener("pointerlockchange", this.pointerLockChange, true);
                document.removeEventListener("mozpointerlockchange", this.pointerLockChange, true);
                document.removeEventListener("webkitpointerlockchange", this.pointerLockChange, true);
              }
            },
            destroy: function () {
              this.stopListeners();
              this.target = null;
              this.enabled = false;
              this.manager = null;
            }
          });
          module2.exports = MouseManager;
        }, function (module2, exports2, __webpack_require__) {
          var Angle = __webpack_require__(349);
          var Class = __webpack_require__(0);
          var Distance = __webpack_require__(50);
          var FuzzyEqual = __webpack_require__(124);
          var SmoothStepInterpolation = __webpack_require__(360);
          var Vector2 = __webpack_require__(3);
          var OS = __webpack_require__(105);
          var Pointer = new Class({
            initialize: function Pointer2(manager, id) {
              this.manager = manager;
              this.id = id;
              this.event;
              this.downElement;
              this.upElement;
              this.camera = null;
              this.button = 0;
              this.buttons = 0;
              this.position = new Vector2();
              this.prevPosition = new Vector2();
              this.midPoint = new Vector2(-1, -1);
              this.velocity = new Vector2();
              this.angle = 0;
              this.distance = 0;
              this.smoothFactor = 0;
              this.motionFactor = 0.2;
              this.worldX = 0;
              this.worldY = 0;
              this.moveTime = 0;
              this.downX = 0;
              this.downY = 0;
              this.downTime = 0;
              this.upX = 0;
              this.upY = 0;
              this.upTime = 0;
              this.primaryDown = false;
              this.isDown = false;
              this.wasTouch = false;
              this.wasCanceled = false;
              this.movementX = 0;
              this.movementY = 0;
              this.identifier = 0;
              this.pointerId = null;
              this.active = id === 0 ? true : false;
              this.locked = false;
              this.deltaX = 0;
              this.deltaY = 0;
              this.deltaZ = 0;
            },
            updateWorldPoint: function (camera) {
              var temp = camera.getWorldPoint(this.x, this.y);
              this.worldX = temp.x;
              this.worldY = temp.y;
              return this;
            },
            positionToCamera: function (camera, output) {
              return camera.getWorldPoint(this.x, this.y, output);
            },
            updateMotion: function () {
              var cx = this.position.x;
              var cy = this.position.y;
              var mx = this.midPoint.x;
              var my = this.midPoint.y;
              if (cx === mx && cy === my) {
                return;
              }
              var vx = SmoothStepInterpolation(this.motionFactor, mx, cx);
              var vy = SmoothStepInterpolation(this.motionFactor, my, cy);
              if (FuzzyEqual(vx, cx, 0.1)) {
                vx = cx;
              }
              if (FuzzyEqual(vy, cy, 0.1)) {
                vy = cy;
              }
              this.midPoint.set(vx, vy);
              var dx = cx - vx;
              var dy = cy - vy;
              this.velocity.set(dx, dy);
              this.angle = Angle(vx, vy, cx, cy);
              this.distance = Math.sqrt(dx * dx + dy * dy);
            },
            up: function (event) {
              if (("buttons" in event)) {
                this.buttons = event.buttons;
              }
              this.event = event;
              this.button = event.button;
              this.upElement = event.target;
              this.manager.transformPointer(this, event.pageX, event.pageY, false);
              if (event.button === 0) {
                this.primaryDown = false;
                this.upX = this.x;
                this.upY = this.y;
              }
              if (this.buttons === 0) {
                this.isDown = false;
                this.upTime = event.timeStamp;
                this.wasTouch = false;
              }
            },
            down: function (event) {
              if (("buttons" in event)) {
                this.buttons = event.buttons;
              }
              this.event = event;
              this.button = event.button;
              this.downElement = event.target;
              this.manager.transformPointer(this, event.pageX, event.pageY, false);
              if (event.button === 0) {
                this.primaryDown = true;
                this.downX = this.x;
                this.downY = this.y;
              }
              if (OS.macOS && event.ctrlKey) {
                this.buttons = 2;
                this.primaryDown = false;
              }
              if (!this.isDown) {
                this.isDown = true;
                this.downTime = event.timeStamp;
              }
              this.wasTouch = false;
            },
            move: function (event) {
              if (("buttons" in event)) {
                this.buttons = event.buttons;
              }
              this.event = event;
              this.manager.transformPointer(this, event.pageX, event.pageY, true);
              if (this.locked) {
                this.movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                this.movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
              }
              this.moveTime = event.timeStamp;
              this.wasTouch = false;
            },
            wheel: function (event) {
              if (("buttons" in event)) {
                this.buttons = event.buttons;
              }
              this.event = event;
              this.manager.transformPointer(this, event.pageX, event.pageY, false);
              this.deltaX = event.deltaX;
              this.deltaY = event.deltaY;
              this.deltaZ = event.deltaZ;
              this.wasTouch = false;
            },
            touchstart: function (touch, event) {
              if (touch["pointerId"]) {
                this.pointerId = touch.pointerId;
              }
              this.identifier = touch.identifier;
              this.target = touch.target;
              this.active = true;
              this.buttons = 1;
              this.event = event;
              this.downElement = touch.target;
              this.manager.transformPointer(this, touch.pageX, touch.pageY, false);
              this.primaryDown = true;
              this.downX = this.x;
              this.downY = this.y;
              this.downTime = event.timeStamp;
              this.isDown = true;
              this.wasTouch = true;
              this.wasCanceled = false;
              this.updateMotion();
            },
            touchmove: function (touch, event) {
              this.event = event;
              this.manager.transformPointer(this, touch.pageX, touch.pageY, true);
              this.moveTime = event.timeStamp;
              this.wasTouch = true;
              this.updateMotion();
            },
            touchend: function (touch, event) {
              this.buttons = 0;
              this.event = event;
              this.upElement = touch.target;
              this.manager.transformPointer(this, touch.pageX, touch.pageY, false);
              this.primaryDown = false;
              this.upX = this.x;
              this.upY = this.y;
              this.upTime = event.timeStamp;
              this.isDown = false;
              this.wasTouch = true;
              this.wasCanceled = false;
              this.active = false;
              this.updateMotion();
            },
            touchcancel: function (touch, event) {
              this.buttons = 0;
              this.event = event;
              this.upElement = touch.target;
              this.manager.transformPointer(this, touch.pageX, touch.pageY, false);
              this.primaryDown = false;
              this.upX = this.x;
              this.upY = this.y;
              this.upTime = event.timeStamp;
              this.isDown = false;
              this.wasTouch = true;
              this.wasCanceled = true;
              this.active = false;
            },
            noButtonDown: function () {
              return this.buttons === 0;
            },
            leftButtonDown: function () {
              return this.buttons & 1 ? true : false;
            },
            rightButtonDown: function () {
              return this.buttons & 2 ? true : false;
            },
            middleButtonDown: function () {
              return this.buttons & 4 ? true : false;
            },
            backButtonDown: function () {
              return this.buttons & 8 ? true : false;
            },
            forwardButtonDown: function () {
              return this.buttons & 16 ? true : false;
            },
            leftButtonReleased: function () {
              return this.button === 0 && !this.isDown;
            },
            rightButtonReleased: function () {
              return this.button === 2 && !this.isDown;
            },
            middleButtonReleased: function () {
              return this.button === 1 && !this.isDown;
            },
            backButtonReleased: function () {
              return this.button === 3 && !this.isDown;
            },
            forwardButtonReleased: function () {
              return this.button === 4 && !this.isDown;
            },
            getDistance: function () {
              if (this.isDown) {
                return Distance(this.downX, this.downY, this.x, this.y);
              } else {
                return Distance(this.downX, this.downY, this.upX, this.upY);
              }
            },
            getDistanceX: function () {
              if (this.isDown) {
                return Math.abs(this.downX - this.x);
              } else {
                return Math.abs(this.downX - this.upX);
              }
            },
            getDistanceY: function () {
              if (this.isDown) {
                return Math.abs(this.downY - this.y);
              } else {
                return Math.abs(this.downY - this.upY);
              }
            },
            getDuration: function () {
              if (this.isDown) {
                return this.manager.time - this.downTime;
              } else {
                return this.upTime - this.downTime;
              }
            },
            getAngle: function () {
              if (this.isDown) {
                return Angle(this.downX, this.downY, this.x, this.y);
              } else {
                return Angle(this.downX, this.downY, this.upX, this.upY);
              }
            },
            getInterpolatedPosition: function (steps, out) {
              if (steps === void 0) {
                steps = 10;
              }
              if (out === void 0) {
                out = [];
              }
              var prevX = this.prevPosition.x;
              var prevY = this.prevPosition.y;
              var curX = this.position.x;
              var curY = this.position.y;
              for (var i = 0; i < steps; i++) {
                var t = 1 / steps * i;
                out[i] = {
                  x: SmoothStepInterpolation(t, prevX, curX),
                  y: SmoothStepInterpolation(t, prevY, curY)
                };
              }
              return out;
            },
            destroy: function () {
              this.camera = null;
              this.manager = null;
              this.position = null;
            },
            x: {
              get: function () {
                return this.position.x;
              },
              set: function (value) {
                this.position.x = value;
              }
            },
            y: {
              get: function () {
                return this.position.y;
              },
              set: function (value) {
                this.position.y = value;
              }
            },
            time: {
              get: function () {
                return this.event ? this.event.timeStamp : 0;
              }
            }
          });
          module2.exports = Pointer;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var InputEvents = __webpack_require__(51);
          var NOOP = __webpack_require__(1);
          var TouchManager = new Class({
            initialize: function TouchManager2(inputManager) {
              this.manager = inputManager;
              this.capture = true;
              this.enabled = false;
              this.target;
              this.onTouchStart = NOOP;
              this.onTouchStartWindow = NOOP;
              this.onTouchMove = NOOP;
              this.onTouchEnd = NOOP;
              this.onTouchEndWindow = NOOP;
              this.onTouchCancel = NOOP;
              this.onTouchCancelWindow = NOOP;
              this.onTouchOver = NOOP;
              this.onTouchOut = NOOP;
              inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
            },
            boot: function () {
              var config = this.manager.config;
              this.enabled = config.inputTouch;
              this.target = config.inputTouchEventTarget;
              this.capture = config.inputTouchCapture;
              if (!this.target) {
                this.target = this.manager.game.canvas;
              }
              if (config.disableContextMenu) {
                this.disableContextMenu();
              }
              if (this.enabled && this.target) {
                this.startListeners();
              }
            },
            disableContextMenu: function () {
              document.body.addEventListener("contextmenu", function (event) {
                event.preventDefault();
                return false;
              });
              return this;
            },
            startListeners: function () {
              var _this = this;
              var canvas = this.manager.canvas;
              var autoFocus = window && window.focus && this.manager.game.config.autoFocus;
              this.onTouchStart = function (event) {
                if (autoFocus) {
                  window.focus();
                }
                if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                  _this.manager.onTouchStart(event);
                  if (_this.capture && event.cancelable && event.target === canvas) {
                    event.preventDefault();
                  }
                }
              };
              this.onTouchStartWindow = function (event) {
                if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled && event.target !== canvas) {
                  _this.manager.onTouchStart(event);
                }
              };
              this.onTouchMove = function (event) {
                if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                  _this.manager.onTouchMove(event);
                  if (_this.capture && event.cancelable) {
                    event.preventDefault();
                  }
                }
              };
              this.onTouchEnd = function (event) {
                if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                  _this.manager.onTouchEnd(event);
                  if (_this.capture && event.cancelable && event.target === canvas) {
                    event.preventDefault();
                  }
                }
              };
              this.onTouchEndWindow = function (event) {
                if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled && event.target !== canvas) {
                  _this.manager.onTouchEnd(event);
                }
              };
              this.onTouchCancel = function (event) {
                if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                  _this.manager.onTouchCancel(event);
                  if (_this.capture) {
                    event.preventDefault();
                  }
                }
              };
              this.onTouchCancelWindow = function (event) {
                if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                  _this.manager.onTouchCancel(event);
                }
              };
              this.onTouchOver = function (event) {
                if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                  _this.manager.setCanvasOver(event);
                }
              };
              this.onTouchOut = function (event) {
                if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
                  _this.manager.setCanvasOut(event);
                }
              };
              var target = this.target;
              if (!target) {
                return;
              }
              var passive = {
                passive: true
              };
              var nonPassive = {
                passive: false
              };
              target.addEventListener("touchstart", this.onTouchStart, this.capture ? nonPassive : passive);
              target.addEventListener("touchmove", this.onTouchMove, this.capture ? nonPassive : passive);
              target.addEventListener("touchend", this.onTouchEnd, this.capture ? nonPassive : passive);
              target.addEventListener("touchcancel", this.onTouchCancel, this.capture ? nonPassive : passive);
              target.addEventListener("touchover", this.onTouchOver, this.capture ? nonPassive : passive);
              target.addEventListener("touchout", this.onTouchOut, this.capture ? nonPassive : passive);
              if (window && this.manager.game.config.inputWindowEvents) {
                window.addEventListener("touchstart", this.onTouchStartWindow, nonPassive);
                window.addEventListener("touchend", this.onTouchEndWindow, nonPassive);
                window.addEventListener("touchcancel", this.onTouchCancelWindow, nonPassive);
              }
              this.enabled = true;
            },
            stopListeners: function () {
              var target = this.target;
              target.removeEventListener("touchstart", this.onTouchStart);
              target.removeEventListener("touchmove", this.onTouchMove);
              target.removeEventListener("touchend", this.onTouchEnd);
              target.removeEventListener("touchcancel", this.onTouchCancel);
              target.removeEventListener("touchover", this.onTouchOver);
              target.removeEventListener("touchout", this.onTouchOut);
              if (window) {
                window.removeEventListener("touchstart", this.onTouchStartWindow);
                window.removeEventListener("touchend", this.onTouchEndWindow);
              }
            },
            destroy: function () {
              this.stopListeners();
              this.target = null;
              this.enabled = false;
              this.manager = null;
            }
          });
          module2.exports = TouchManager;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GameEvents = __webpack_require__(22);
          var EventEmitter = __webpack_require__(9);
          var FileTypesManager = __webpack_require__(8);
          var GameObjectCreator = __webpack_require__(16);
          var GameObjectFactory = __webpack_require__(5);
          var GetFastValue = __webpack_require__(2);
          var PluginCache = __webpack_require__(24);
          var Remove = __webpack_require__(93);
          var PluginManager = new Class({
            Extends: EventEmitter,
            initialize: function PluginManager2(game) {
              EventEmitter.call(this);
              this.game = game;
              this.plugins = [];
              this.scenePlugins = [];
              this._pendingGlobal = [];
              this._pendingScene = [];
              if (game.isBooted) {
                this.boot();
              } else {
                game.events.once(GameEvents.BOOT, this.boot, this);
              }
            },
            boot: function () {
              var i;
              var entry;
              var key;
              var plugin;
              var start;
              var mapping;
              var data;
              var config = this.game.config;
              var list = config.installGlobalPlugins;
              list = list.concat(this._pendingGlobal);
              for (i = 0; i < list.length; i++) {
                entry = list[i];
                key = GetFastValue(entry, "key", null);
                plugin = GetFastValue(entry, "plugin", null);
                start = GetFastValue(entry, "start", false);
                mapping = GetFastValue(entry, "mapping", null);
                data = GetFastValue(entry, "data", null);
                if (key) {
                  if (plugin) {
                    this.install(key, plugin, start, mapping, data);
                  } else {
                    console.warn("Missing `plugin` for key: " + key);
                  }
                }
              }
              list = config.installScenePlugins;
              list = list.concat(this._pendingScene);
              for (i = 0; i < list.length; i++) {
                entry = list[i];
                key = GetFastValue(entry, "key", null);
                plugin = GetFastValue(entry, "plugin", null);
                mapping = GetFastValue(entry, "mapping", null);
                if (key) {
                  if (plugin) {
                    this.installScenePlugin(key, plugin, mapping);
                  } else {
                    console.warn("Missing `plugin` for key: " + key);
                  }
                }
              }
              this._pendingGlobal = [];
              this._pendingScene = [];
              this.game.events.once(GameEvents.DESTROY, this.destroy, this);
            },
            addToScene: function (sys, globalPlugins, scenePlugins) {
              var i;
              var pluginKey;
              var pluginList;
              var game = this.game;
              var scene = sys.scene;
              var map = sys.settings.map;
              var isBooted = sys.settings.isBooted;
              for (i = 0; i < globalPlugins.length; i++) {
                pluginKey = globalPlugins[i];
                if (game[pluginKey]) {
                  sys[pluginKey] = game[pluginKey];
                  if (map.hasOwnProperty(pluginKey)) {
                    scene[map[pluginKey]] = sys[pluginKey];
                  }
                } else if (pluginKey === "game" && map.hasOwnProperty(pluginKey)) {
                  scene[map[pluginKey]] = game;
                }
              }
              for (var s = 0; s < scenePlugins.length; s++) {
                pluginList = scenePlugins[s];
                for (i = 0; i < pluginList.length; i++) {
                  pluginKey = pluginList[i];
                  if (!PluginCache.hasCore(pluginKey)) {
                    continue;
                  }
                  var source = PluginCache.getCore(pluginKey);
                  var mapKey = source.mapping;
                  var plugin = new source.plugin(scene, this, mapKey);
                  sys[mapKey] = plugin;
                  if (source.custom) {
                    scene[mapKey] = plugin;
                  } else if (map.hasOwnProperty(mapKey)) {
                    scene[map[mapKey]] = plugin;
                  }
                  if (isBooted) {
                    plugin.boot();
                  }
                }
              }
              pluginList = this.plugins;
              for (i = 0; i < pluginList.length; i++) {
                var entry = pluginList[i];
                if (entry.mapping) {
                  scene[entry.mapping] = entry.plugin;
                }
              }
            },
            getDefaultScenePlugins: function () {
              var list = this.game.config.defaultPlugins;
              list = list.concat(this.scenePlugins);
              return list;
            },
            installScenePlugin: function (key, plugin, mapping, addToScene, fromLoader) {
              if (fromLoader === void 0) {
                fromLoader = false;
              }
              if (typeof plugin !== "function") {
                console.warn("Invalid Scene Plugin: " + key);
                return;
              }
              if (!PluginCache.hasCore(key)) {
                PluginCache.register(key, plugin, mapping, true);
                this.scenePlugins.push(key);
              } else if (!fromLoader && PluginCache.hasCore(key)) {
                console.warn("Scene Plugin key in use: " + key);
                return;
              }
              if (addToScene) {
                var instance = new plugin(addToScene, this, key);
                addToScene.sys[key] = instance;
                if (mapping && mapping !== "") {
                  addToScene[mapping] = instance;
                }
                instance.boot();
              }
            },
            install: function (key, plugin, start, mapping, data) {
              if (start === void 0) {
                start = false;
              }
              if (mapping === void 0) {
                mapping = null;
              }
              if (data === void 0) {
                data = null;
              }
              if (typeof plugin !== "function") {
                console.warn("Invalid Plugin: " + key);
                return null;
              }
              if (PluginCache.hasCustom(key)) {
                console.warn("Plugin key in use: " + key);
                return null;
              }
              if (mapping !== null) {
                start = true;
              }
              if (!this.game.isBooted) {
                this._pendingGlobal.push({
                  key,
                  plugin,
                  start,
                  mapping,
                  data
                });
              } else {
                PluginCache.registerCustom(key, plugin, mapping, data);
                if (start) {
                  return this.start(key);
                }
              }
              return null;
            },
            getIndex: function (key) {
              var list = this.plugins;
              for (var i = 0; i < list.length; i++) {
                var entry = list[i];
                if (entry.key === key) {
                  return i;
                }
              }
              return -1;
            },
            getEntry: function (key) {
              var idx = this.getIndex(key);
              if (idx !== -1) {
                return this.plugins[idx];
              }
            },
            isActive: function (key) {
              var entry = this.getEntry(key);
              return entry && entry.active;
            },
            start: function (key, runAs) {
              if (runAs === void 0) {
                runAs = key;
              }
              var entry = this.getEntry(runAs);
              if (entry && !entry.active) {
                entry.active = true;
                entry.plugin.start();
              } else if (!entry) {
                entry = this.createEntry(key, runAs);
              }
              return entry ? entry.plugin : null;
            },
            createEntry: function (key, runAs) {
              var entry = PluginCache.getCustom(key);
              if (entry) {
                var instance = new entry.plugin(this);
                entry = {
                  key: runAs,
                  plugin: instance,
                  active: true,
                  mapping: entry.mapping,
                  data: entry.data
                };
                this.plugins.push(entry);
                instance.init(entry.data);
                instance.start();
              }
              return entry;
            },
            stop: function (key) {
              var entry = this.getEntry(key);
              if (entry && entry.active) {
                entry.active = false;
                entry.plugin.stop();
              }
              return this;
            },
            get: function (key, autoStart) {
              if (autoStart === void 0) {
                autoStart = true;
              }
              var entry = this.getEntry(key);
              if (entry) {
                return entry.plugin;
              } else {
                var plugin = this.getClass(key);
                if (plugin && autoStart) {
                  entry = this.createEntry(key, key);
                  return entry ? entry.plugin : null;
                } else if (plugin) {
                  return plugin;
                }
              }
              return null;
            },
            getClass: function (key) {
              return PluginCache.getCustomClass(key);
            },
            removeGlobalPlugin: function (key) {
              var entry = this.getEntry(key);
              if (entry) {
                Remove(this.plugins, entry);
              }
              PluginCache.removeCustom(key);
            },
            removeScenePlugin: function (key) {
              Remove(this.scenePlugins, key);
              PluginCache.remove(key);
            },
            registerGameObject: function (key, factoryCallback, creatorCallback) {
              if (factoryCallback) {
                GameObjectFactory.register(key, factoryCallback);
              }
              if (creatorCallback) {
                GameObjectCreator.register(key, creatorCallback);
              }
              return this;
            },
            removeGameObject: function (key, removeFromFactory, removeFromCreator) {
              if (removeFromFactory === void 0) {
                removeFromFactory = true;
              }
              if (removeFromCreator === void 0) {
                removeFromCreator = true;
              }
              if (removeFromFactory) {
                GameObjectFactory.remove(key);
              }
              if (removeFromCreator) {
                GameObjectCreator.remove(key);
              }
              return this;
            },
            registerFileType: function (key, callback, addToScene) {
              FileTypesManager.register(key, callback);
              if (addToScene && addToScene.sys.load) {
                addToScene.sys.load[key] = callback;
              }
            },
            destroy: function () {
              for (var i = 0; i < this.plugins.length; i++) {
                this.plugins[i].plugin.destroy();
              }
              PluginCache.destroyCustomPlugins();
              if (this.game.noReturn) {
                PluginCache.destroyCorePlugins();
              }
              this.game = null;
              this.plugins = [];
              this.scenePlugins = [];
            }
          });
          module2.exports = PluginManager;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(201);
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(104);
          var GameEvents = __webpack_require__(22);
          var GetInnerHeight = __webpack_require__(401);
          var GetTarget = __webpack_require__(407);
          var GetScreenOrientation = __webpack_require__(402);
          var NOOP = __webpack_require__(1);
          var Rectangle = __webpack_require__(10);
          var Size = __webpack_require__(416);
          var SnapFloor = __webpack_require__(76);
          var Vector2 = __webpack_require__(3);
          var ScaleManager = new Class({
            Extends: EventEmitter,
            initialize: function ScaleManager2(game) {
              EventEmitter.call(this);
              this.game = game;
              this.canvas;
              this.canvasBounds = new Rectangle();
              this.parent = null;
              this.parentIsWindow = false;
              this.parentSize = new Size();
              this.gameSize = new Size();
              this.baseSize = new Size();
              this.displaySize = new Size();
              this.scaleMode = CONST.SCALE_MODE.NONE;
              this.zoom = 1;
              this._resetZoom = false;
              this.displayScale = new Vector2(1, 1);
              this.autoRound = false;
              this.autoCenter = CONST.CENTER.NO_CENTER;
              this.orientation = CONST.ORIENTATION.LANDSCAPE;
              this.fullscreen;
              this.fullscreenTarget = null;
              this._createdFullscreenTarget = false;
              this.dirty = false;
              this.resizeInterval = 500;
              this._lastCheck = 0;
              this._checkOrientation = false;
              this.listeners = {
                orientationChange: NOOP,
                windowResize: NOOP,
                fullScreenChange: NOOP,
                fullScreenError: NOOP
              };
            },
            preBoot: function () {
              this.parseConfig(this.game.config);
              this.game.events.once(GameEvents.BOOT, this.boot, this);
            },
            boot: function () {
              var game = this.game;
              this.canvas = game.canvas;
              this.fullscreen = game.device.fullscreen;
              if (this.scaleMode !== CONST.SCALE_MODE.RESIZE) {
                this.displaySize.setAspectMode(this.scaleMode);
              }
              if (this.scaleMode === CONST.SCALE_MODE.NONE) {
                this.resize(this.width, this.height);
              } else {
                this.getParentBounds();
                if (this.parentSize.width > 0 && this.parentSize.height > 0) {
                  this.displaySize.setParent(this.parentSize);
                }
                this.refresh();
              }
              game.events.on(GameEvents.PRE_STEP, this.step, this);
              game.events.once(GameEvents.READY, this.refresh, this);
              game.events.once(GameEvents.DESTROY, this.destroy, this);
              this.startListeners();
            },
            parseConfig: function (config) {
              this.getParent(config);
              this.getParentBounds();
              var width = config.width;
              var height = config.height;
              var scaleMode = config.scaleMode;
              var zoom = config.zoom;
              var autoRound = config.autoRound;
              if (typeof width === "string") {
                var parentWidth = this.parentSize.width;
                if (parentWidth === 0) {
                  parentWidth = window.innerWidth;
                }
                var parentScaleX = parseInt(width, 10) / 100;
                width = Math.floor(parentWidth * parentScaleX);
              }
              if (typeof height === "string") {
                var parentHeight = this.parentSize.height;
                if (parentHeight === 0) {
                  parentHeight = window.innerHeight;
                }
                var parentScaleY = parseInt(height, 10) / 100;
                height = Math.floor(parentHeight * parentScaleY);
              }
              this.scaleMode = scaleMode;
              this.autoRound = autoRound;
              this.autoCenter = config.autoCenter;
              this.resizeInterval = config.resizeInterval;
              if (autoRound) {
                width = Math.floor(width);
                height = Math.floor(height);
              }
              this.gameSize.setSize(width, height);
              if (zoom === CONST.ZOOM.MAX_ZOOM) {
                zoom = this.getMaxZoom();
              }
              this.zoom = zoom;
              if (zoom !== 1) {
                this._resetZoom = true;
              }
              this.baseSize.setSize(width, height);
              if (autoRound) {
                this.baseSize.width = Math.floor(this.baseSize.width);
                this.baseSize.height = Math.floor(this.baseSize.height);
              }
              if (config.minWidth > 0) {
                this.displaySize.setMin(config.minWidth * zoom, config.minHeight * zoom);
              }
              if (config.maxWidth > 0) {
                this.displaySize.setMax(config.maxWidth * zoom, config.maxHeight * zoom);
              }
              this.displaySize.setSize(width, height);
              this.orientation = GetScreenOrientation(width, height);
            },
            getParent: function (config) {
              var parent = config.parent;
              if (parent === null) {
                return;
              }
              this.parent = GetTarget(parent);
              this.parentIsWindow = this.parent === document.body;
              if (config.expandParent && config.scaleMode !== CONST.SCALE_MODE.NONE) {
                var DOMRect = this.parent.getBoundingClientRect();
                if (this.parentIsWindow || DOMRect.height === 0) {
                  document.documentElement.style.height = "100%";
                  document.body.style.height = "100%";
                  DOMRect = this.parent.getBoundingClientRect();
                  if (!this.parentIsWindow && DOMRect.height === 0) {
                    this.parent.style.overflow = "hidden";
                    this.parent.style.width = "100%";
                    this.parent.style.height = "100%";
                  }
                }
              }
              if (config.fullscreenTarget && !this.fullscreenTarget) {
                this.fullscreenTarget = GetTarget(config.fullscreenTarget);
              }
            },
            getParentBounds: function () {
              if (!this.parent) {
                return false;
              }
              var parentSize = this.parentSize;
              var DOMRect = this.parent.getBoundingClientRect();
              if (this.parentIsWindow && this.game.device.os.iOS) {
                DOMRect.height = GetInnerHeight(true);
              }
              var newWidth = DOMRect.width;
              var newHeight = DOMRect.height;
              if (parentSize.width !== newWidth || parentSize.height !== newHeight) {
                parentSize.setSize(newWidth, newHeight);
                return true;
              } else {
                return false;
              }
            },
            lockOrientation: function (orientation) {
              var lock = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;
              if (lock) {
                return lock.call(screen, orientation);
              }
              return false;
            },
            setParentSize: function (width, height) {
              this.parentSize.setSize(width, height);
              return this.refresh();
            },
            setGameSize: function (width, height) {
              var autoRound = this.autoRound;
              if (autoRound) {
                width = Math.floor(width);
                height = Math.floor(height);
              }
              var previousWidth = this.width;
              var previousHeight = this.height;
              this.gameSize.resize(width, height);
              this.baseSize.resize(width, height);
              if (autoRound) {
                this.baseSize.width = Math.floor(this.baseSize.width);
                this.baseSize.height = Math.floor(this.baseSize.height);
              }
              this.displaySize.setAspectRatio(width / height);
              this.canvas.width = this.baseSize.width;
              this.canvas.height = this.baseSize.height;
              return this.refresh(previousWidth, previousHeight);
            },
            resize: function (width, height) {
              var zoom = this.zoom;
              var autoRound = this.autoRound;
              if (autoRound) {
                width = Math.floor(width);
                height = Math.floor(height);
              }
              var previousWidth = this.width;
              var previousHeight = this.height;
              this.gameSize.resize(width, height);
              this.baseSize.resize(width, height);
              if (autoRound) {
                this.baseSize.width = Math.floor(this.baseSize.width);
                this.baseSize.height = Math.floor(this.baseSize.height);
              }
              this.displaySize.setSize(width * zoom, height * zoom);
              this.canvas.width = this.baseSize.width;
              this.canvas.height = this.baseSize.height;
              var style = this.canvas.style;
              var styleWidth = width * zoom;
              var styleHeight = height * zoom;
              if (autoRound) {
                styleWidth = Math.floor(styleWidth);
                styleHeight = Math.floor(styleHeight);
              }
              if (styleWidth !== width || styleHeight !== height) {
                style.width = styleWidth + "px";
                style.height = styleHeight + "px";
              }
              return this.refresh(previousWidth, previousHeight);
            },
            setZoom: function (value) {
              this.zoom = value;
              this._resetZoom = true;
              return this.refresh();
            },
            setMaxZoom: function () {
              this.zoom = this.getMaxZoom();
              this._resetZoom = true;
              return this.refresh();
            },
            refresh: function (previousWidth, previousHeight) {
              if (previousWidth === void 0) {
                previousWidth = this.width;
              }
              if (previousHeight === void 0) {
                previousHeight = this.height;
              }
              this.updateScale();
              this.updateBounds();
              this.updateOrientation();
              this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height);
              var domContainer = this.game.domContainer;
              if (domContainer) {
                this.baseSize.setCSS(domContainer);
                var canvasStyle = this.canvas.style;
                var domStyle = domContainer.style;
                domStyle.transform = "scale(" + this.displaySize.width / this.baseSize.width + "," + this.displaySize.height / this.baseSize.height + ")";
                domStyle.marginLeft = canvasStyle.marginLeft;
                domStyle.marginTop = canvasStyle.marginTop;
              }
              this.emit(Events.RESIZE, this.gameSize, this.baseSize, this.displaySize, previousWidth, previousHeight);
              return this;
            },
            updateOrientation: function () {
              if (this._checkOrientation) {
                this._checkOrientation = false;
                var newOrientation = GetScreenOrientation(this.width, this.height);
                if (newOrientation !== this.orientation) {
                  this.orientation = newOrientation;
                  this.emit(Events.ORIENTATION_CHANGE, newOrientation);
                }
              }
            },
            updateScale: function () {
              var style = this.canvas.style;
              var width = this.gameSize.width;
              var height = this.gameSize.height;
              var styleWidth;
              var styleHeight;
              var zoom = this.zoom;
              var autoRound = this.autoRound;
              if (this.scaleMode === CONST.SCALE_MODE.NONE) {
                this.displaySize.setSize(width * zoom, height * zoom);
                styleWidth = this.displaySize.width;
                styleHeight = this.displaySize.height;
                if (autoRound) {
                  styleWidth = Math.floor(styleWidth);
                  styleHeight = Math.floor(styleHeight);
                }
                if (this._resetZoom) {
                  style.width = styleWidth + "px";
                  style.height = styleHeight + "px";
                  this._resetZoom = false;
                }
              } else if (this.scaleMode === CONST.SCALE_MODE.RESIZE) {
                this.displaySize.setSize(this.parentSize.width, this.parentSize.height);
                this.gameSize.setSize(this.displaySize.width, this.displaySize.height);
                this.baseSize.setSize(this.displaySize.width, this.displaySize.height);
                styleWidth = this.displaySize.width;
                styleHeight = this.displaySize.height;
                if (autoRound) {
                  styleWidth = Math.floor(styleWidth);
                  styleHeight = Math.floor(styleHeight);
                }
                this.canvas.width = styleWidth;
                this.canvas.height = styleHeight;
              } else {
                this.displaySize.setSize(this.parentSize.width, this.parentSize.height);
                styleWidth = this.displaySize.width;
                styleHeight = this.displaySize.height;
                if (autoRound) {
                  styleWidth = Math.floor(styleWidth);
                  styleHeight = Math.floor(styleHeight);
                }
                style.width = styleWidth + "px";
                style.height = styleHeight + "px";
              }
              this.getParentBounds();
              this.updateCenter();
            },
            getMaxZoom: function () {
              var zoomH = SnapFloor(this.parentSize.width, this.gameSize.width, 0, true);
              var zoomV = SnapFloor(this.parentSize.height, this.gameSize.height, 0, true);
              return Math.max(Math.min(zoomH, zoomV), 1);
            },
            updateCenter: function () {
              var autoCenter = this.autoCenter;
              if (autoCenter === CONST.CENTER.NO_CENTER) {
                return;
              }
              var canvas = this.canvas;
              var style = canvas.style;
              var bounds = canvas.getBoundingClientRect();
              var width = bounds.width;
              var height = bounds.height;
              var offsetX = Math.floor((this.parentSize.width - width) / 2);
              var offsetY = Math.floor((this.parentSize.height - height) / 2);
              if (autoCenter === CONST.CENTER.CENTER_HORIZONTALLY) {
                offsetY = 0;
              } else if (autoCenter === CONST.CENTER.CENTER_VERTICALLY) {
                offsetX = 0;
              }
              style.marginLeft = offsetX + "px";
              style.marginTop = offsetY + "px";
            },
            updateBounds: function () {
              var bounds = this.canvasBounds;
              var clientRect = this.canvas.getBoundingClientRect();
              bounds.x = clientRect.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0);
              bounds.y = clientRect.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0);
              bounds.width = clientRect.width;
              bounds.height = clientRect.height;
            },
            transformX: function (pageX) {
              return (pageX - this.canvasBounds.left) * this.displayScale.x;
            },
            transformY: function (pageY) {
              return (pageY - this.canvasBounds.top) * this.displayScale.y;
            },
            startFullscreen: function (fullscreenOptions) {
              if (fullscreenOptions === void 0) {
                fullscreenOptions = {
                  navigationUI: "hide"
                };
              }
              var fullscreen = this.fullscreen;
              if (!fullscreen.available) {
                this.emit(Events.FULLSCREEN_UNSUPPORTED);
                return;
              }
              if (!fullscreen.active) {
                var fsTarget = this.getFullscreenTarget();
                if (fullscreen.keyboard) {
                  fsTarget[fullscreen.request](Element.ALLOW_KEYBOARD_INPUT);
                } else {
                  fsTarget[fullscreen.request](fullscreenOptions);
                }
              }
            },
            fullscreenSuccessHandler: function () {
              this.getParentBounds();
              this.refresh();
              this.emit(Events.ENTER_FULLSCREEN);
            },
            fullscreenErrorHandler: function (error) {
              this.removeFullscreenTarget();
              this.emit(Events.FULLSCREEN_FAILED, error);
            },
            getFullscreenTarget: function () {
              if (!this.fullscreenTarget) {
                var fsTarget = document.createElement("div");
                fsTarget.style.margin = "0";
                fsTarget.style.padding = "0";
                fsTarget.style.width = "100%";
                fsTarget.style.height = "100%";
                this.fullscreenTarget = fsTarget;
                this._createdFullscreenTarget = true;
              }
              if (this._createdFullscreenTarget) {
                var canvasParent = this.canvas.parentNode;
                canvasParent.insertBefore(this.fullscreenTarget, this.canvas);
                this.fullscreenTarget.appendChild(this.canvas);
              }
              return this.fullscreenTarget;
            },
            removeFullscreenTarget: function () {
              if (this._createdFullscreenTarget) {
                var fsTarget = this.fullscreenTarget;
                if (fsTarget && fsTarget.parentNode) {
                  var parent = fsTarget.parentNode;
                  parent.insertBefore(this.canvas, fsTarget);
                  parent.removeChild(fsTarget);
                }
              }
            },
            stopFullscreen: function () {
              var fullscreen = this.fullscreen;
              if (!fullscreen.available) {
                this.emit(Events.FULLSCREEN_UNSUPPORTED);
                return false;
              }
              if (fullscreen.active) {
                document[fullscreen.cancel]();
              }
              this.removeFullscreenTarget();
              this.getParentBounds();
              this.emit(Events.LEAVE_FULLSCREEN);
              this.refresh();
            },
            toggleFullscreen: function (fullscreenOptions) {
              if (this.fullscreen.active) {
                this.stopFullscreen();
              } else {
                this.startFullscreen(fullscreenOptions);
              }
            },
            startListeners: function () {
              var _this = this;
              var listeners = this.listeners;
              listeners.orientationChange = function () {
                _this.updateBounds();
                _this._checkOrientation = true;
                _this.dirty = true;
              };
              listeners.windowResize = function () {
                _this.updateBounds();
                _this.dirty = true;
              };
              window.addEventListener("orientationchange", listeners.orientationChange, false);
              window.addEventListener("resize", listeners.windowResize, false);
              if (this.fullscreen.available) {
                listeners.fullScreenChange = function (event) {
                  return _this.onFullScreenChange(event);
                };
                listeners.fullScreenError = function (event) {
                  return _this.onFullScreenError(event);
                };
                var vendors = ["webkit", "moz", ""];
                vendors.forEach(function (prefix) {
                  document.addEventListener(prefix + "fullscreenchange", listeners.fullScreenChange, false);
                  document.addEventListener(prefix + "fullscreenerror", listeners.fullScreenError, false);
                });
                document.addEventListener("MSFullscreenChange", listeners.fullScreenChange, false);
                document.addEventListener("MSFullscreenError", listeners.fullScreenError, false);
              }
            },
            onFullScreenChange: function () {
              if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement) {
                this.fullscreenSuccessHandler();
              } else {
                this.stopFullscreen();
              }
            },
            onFullScreenError: function () {
              this.removeFullscreenTarget();
            },
            step: function (time, delta) {
              if (!this.parent) {
                return;
              }
              this._lastCheck += delta;
              if (this.dirty || this._lastCheck > this.resizeInterval) {
                if (this.getParentBounds()) {
                  this.refresh();
                }
                this.dirty = false;
                this._lastCheck = 0;
              }
            },
            stopListeners: function () {
              var listeners = this.listeners;
              window.removeEventListener("orientationchange", listeners.orientationChange, false);
              window.removeEventListener("resize", listeners.windowResize, false);
              var vendors = ["webkit", "moz", ""];
              vendors.forEach(function (prefix) {
                document.removeEventListener(prefix + "fullscreenchange", listeners.fullScreenChange, false);
                document.removeEventListener(prefix + "fullscreenerror", listeners.fullScreenError, false);
              });
              document.removeEventListener("MSFullscreenChange", listeners.fullScreenChange, false);
              document.removeEventListener("MSFullscreenError", listeners.fullScreenError, false);
            },
            destroy: function () {
              this.removeAllListeners();
              this.stopListeners();
              this.game = null;
              this.canvas = null;
              this.canvasBounds = null;
              this.parent = null;
              this.fullscreenTarget = null;
              this.parentSize.destroy();
              this.gameSize.destroy();
              this.baseSize.destroy();
              this.displaySize.destroy();
            },
            isFullscreen: {
              get: function () {
                return this.fullscreen.active;
              }
            },
            width: {
              get: function () {
                return this.gameSize.width;
              }
            },
            height: {
              get: function () {
                return this.gameSize.height;
              }
            },
            isPortrait: {
              get: function () {
                return this.orientation === CONST.ORIENTATION.PORTRAIT;
              }
            },
            isLandscape: {
              get: function () {
                return this.orientation === CONST.ORIENTATION.LANDSCAPE;
              }
            },
            isGamePortrait: {
              get: function () {
                return this.height > this.width;
              }
            },
            isGameLandscape: {
              get: function () {
                return this.width > this.height;
              }
            }
          });
          module2.exports = ScaleManager;
        }, function (module2, exports2, __webpack_require__) {
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var SnapFloor = __webpack_require__(76);
          var Vector2 = __webpack_require__(3);
          var Size = new Class({
            initialize: function Size2(width, height, aspectMode, parent) {
              if (width === void 0) {
                width = 0;
              }
              if (height === void 0) {
                height = width;
              }
              if (aspectMode === void 0) {
                aspectMode = 0;
              }
              if (parent === void 0) {
                parent = null;
              }
              this._width = width;
              this._height = height;
              this._parent = parent;
              this.aspectMode = aspectMode;
              this.aspectRatio = height === 0 ? 1 : width / height;
              this.minWidth = 0;
              this.minHeight = 0;
              this.maxWidth = Number.MAX_VALUE;
              this.maxHeight = Number.MAX_VALUE;
              this.snapTo = new Vector2();
            },
            setAspectMode: function (value) {
              if (value === void 0) {
                value = 0;
              }
              this.aspectMode = value;
              return this.setSize(this._width, this._height);
            },
            setSnap: function (snapWidth, snapHeight) {
              if (snapWidth === void 0) {
                snapWidth = 0;
              }
              if (snapHeight === void 0) {
                snapHeight = snapWidth;
              }
              this.snapTo.set(snapWidth, snapHeight);
              return this.setSize(this._width, this._height);
            },
            setParent: function (parent) {
              this._parent = parent;
              return this.setSize(this._width, this._height);
            },
            setMin: function (width, height) {
              if (width === void 0) {
                width = 0;
              }
              if (height === void 0) {
                height = width;
              }
              this.minWidth = Clamp(width, 0, this.maxWidth);
              this.minHeight = Clamp(height, 0, this.maxHeight);
              return this.setSize(this._width, this._height);
            },
            setMax: function (width, height) {
              if (width === void 0) {
                width = Number.MAX_VALUE;
              }
              if (height === void 0) {
                height = width;
              }
              this.maxWidth = Clamp(width, this.minWidth, Number.MAX_VALUE);
              this.maxHeight = Clamp(height, this.minHeight, Number.MAX_VALUE);
              return this.setSize(this._width, this._height);
            },
            setSize: function (width, height) {
              if (width === void 0) {
                width = 0;
              }
              if (height === void 0) {
                height = width;
              }
              switch (this.aspectMode) {
                case Size.NONE:
                  this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
                  this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
                  this.aspectRatio = this._height === 0 ? 1 : this._width / this._height;
                  break;
                case Size.WIDTH_CONTROLS_HEIGHT:
                  this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
                  this._height = this.getNewHeight(this._width * (1 / this.aspectRatio), false);
                  break;
                case Size.HEIGHT_CONTROLS_WIDTH:
                  this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
                  this._width = this.getNewWidth(this._height * this.aspectRatio, false);
                  break;
                case Size.FIT:
                  this.constrain(width, height, true);
                  break;
                case Size.ENVELOP:
                  this.constrain(width, height, false);
                  break;
              }
              return this;
            },
            setAspectRatio: function (ratio) {
              this.aspectRatio = ratio;
              return this.setSize(this._width, this._height);
            },
            resize: function (width, height) {
              this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
              this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
              this.aspectRatio = this._height === 0 ? 1 : this._width / this._height;
              return this;
            },
            getNewWidth: function (value, checkParent) {
              if (checkParent === void 0) {
                checkParent = true;
              }
              value = Clamp(value, this.minWidth, this.maxWidth);
              if (checkParent && this._parent && value > this._parent.width) {
                value = Math.max(this.minWidth, this._parent.width);
              }
              return value;
            },
            getNewHeight: function (value, checkParent) {
              if (checkParent === void 0) {
                checkParent = true;
              }
              value = Clamp(value, this.minHeight, this.maxHeight);
              if (checkParent && this._parent && value > this._parent.height) {
                value = Math.max(this.minHeight, this._parent.height);
              }
              return value;
            },
            constrain: function (width, height, fit) {
              if (width === void 0) {
                width = 0;
              }
              if (height === void 0) {
                height = width;
              }
              if (fit === void 0) {
                fit = true;
              }
              width = this.getNewWidth(width);
              height = this.getNewHeight(height);
              var snap = this.snapTo;
              var newRatio = height === 0 ? 1 : width / height;
              if (fit && this.aspectRatio > newRatio || !fit && this.aspectRatio < newRatio) {
                width = SnapFloor(width, snap.x);
                height = width / this.aspectRatio;
                if (snap.y > 0) {
                  height = SnapFloor(height, snap.y);
                  width = height * this.aspectRatio;
                }
              } else if (fit && this.aspectRatio < newRatio || !fit && this.aspectRatio > newRatio) {
                height = SnapFloor(height, snap.y);
                width = height * this.aspectRatio;
                if (snap.x > 0) {
                  width = SnapFloor(width, snap.x);
                  height = width * (1 / this.aspectRatio);
                }
              }
              this._width = width;
              this._height = height;
              return this;
            },
            fitTo: function (width, height) {
              return this.constrain(width, height, true);
            },
            envelop: function (width, height) {
              return this.constrain(width, height, false);
            },
            setWidth: function (value) {
              return this.setSize(value, this._height);
            },
            setHeight: function (value) {
              return this.setSize(this._width, value);
            },
            toString: function () {
              return "[{ Size (width=" + this._width + " height=" + this._height + " aspectRatio=" + this.aspectRatio + " aspectMode=" + this.aspectMode + ") }]";
            },
            setCSS: function (element) {
              if (element && element.style) {
                element.style.width = this._width + "px";
                element.style.height = this._height + "px";
              }
            },
            copy: function (destination) {
              destination.setAspectMode(this.aspectMode);
              destination.aspectRatio = this.aspectRatio;
              return destination.setSize(this.width, this.height);
            },
            destroy: function () {
              this._parent = null;
              this.snapTo = null;
            },
            width: {
              get: function () {
                return this._width;
              },
              set: function (value) {
                this.setSize(value, this._height);
              }
            },
            height: {
              get: function () {
                return this._height;
              },
              set: function (value) {
                this.setSize(this._width, value);
              }
            }
          });
          Size.NONE = 0;
          Size.WIDTH_CONTROLS_HEIGHT = 1;
          Size.HEIGHT_CONTROLS_WIDTH = 2;
          Size.FIT = 3;
          Size.ENVELOP = 4;
          module2.exports = Size;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(144);
          var Events = __webpack_require__(20);
          var GameEvents = __webpack_require__(22);
          var GetValue = __webpack_require__(6);
          var LoaderEvents = __webpack_require__(95);
          var NOOP = __webpack_require__(1);
          var Scene = __webpack_require__(418);
          var Systems = __webpack_require__(204);
          var SceneManager = new Class({
            initialize: function SceneManager2(game, sceneConfig) {
              this.game = game;
              this.keys = {};
              this.scenes = [];
              this._pending = [];
              this._start = [];
              this._queue = [];
              this._data = {};
              this.isProcessing = false;
              this.isBooted = false;
              this.customViewports = 0;
              if (sceneConfig) {
                if (!Array.isArray(sceneConfig)) {
                  sceneConfig = [sceneConfig];
                }
                for (var i = 0; i < sceneConfig.length; i++) {
                  this._pending.push({
                    key: "default",
                    scene: sceneConfig[i],
                    autoStart: i === 0,
                    data: {}
                  });
                }
              }
              game.events.once(GameEvents.READY, this.bootQueue, this);
            },
            bootQueue: function () {
              if (this.isBooted) {
                return;
              }
              var i;
              var entry;
              var key;
              var sceneConfig;
              for (i = 0; i < this._pending.length; i++) {
                entry = this._pending[i];
                key = entry.key;
                sceneConfig = entry.scene;
                var newScene;
                if (sceneConfig instanceof Scene) {
                  newScene = this.createSceneFromInstance(key, sceneConfig);
                } else if (typeof sceneConfig === "object") {
                  newScene = this.createSceneFromObject(key, sceneConfig);
                } else if (typeof sceneConfig === "function") {
                  newScene = this.createSceneFromFunction(key, sceneConfig);
                }
                key = newScene.sys.settings.key;
                this.keys[key] = newScene;
                this.scenes.push(newScene);
                if (this._data[key]) {
                  newScene.sys.settings.data = this._data[key].data;
                  if (this._data[key].autoStart) {
                    entry.autoStart = true;
                  }
                }
                if (entry.autoStart || newScene.sys.settings.active) {
                  this._start.push(key);
                }
              }
              this._pending.length = 0;
              this._data = {};
              this.isBooted = true;
              for (i = 0; i < this._start.length; i++) {
                entry = this._start[i];
                this.start(entry);
              }
              this._start.length = 0;
            },
            processQueue: function () {
              var pendingLength = this._pending.length;
              var queueLength = this._queue.length;
              if (pendingLength === 0 && queueLength === 0) {
                return;
              }
              var i;
              var entry;
              if (pendingLength) {
                for (i = 0; i < pendingLength; i++) {
                  entry = this._pending[i];
                  this.add(entry.key, entry.scene, entry.autoStart, entry.data);
                }
                for (i = 0; i < this._start.length; i++) {
                  entry = this._start[i];
                  this.start(entry);
                }
                this._start.length = 0;
                this._pending.length = 0;
                return;
              }
              for (i = 0; i < this._queue.length; i++) {
                entry = this._queue[i];
                this[entry.op](entry.keyA, entry.keyB);
              }
              this._queue.length = 0;
            },
            add: function (key, sceneConfig, autoStart, data) {
              if (autoStart === void 0) {
                autoStart = false;
              }
              if (data === void 0) {
                data = {};
              }
              if (this.isProcessing || !this.isBooted) {
                this._pending.push({
                  key,
                  scene: sceneConfig,
                  autoStart,
                  data
                });
                if (!this.isBooted) {
                  this._data[key] = {
                    data
                  };
                }
                return null;
              }
              key = this.getKey(key, sceneConfig);
              var newScene;
              if (sceneConfig instanceof Scene) {
                newScene = this.createSceneFromInstance(key, sceneConfig);
              } else if (typeof sceneConfig === "object") {
                sceneConfig.key = key;
                newScene = this.createSceneFromObject(key, sceneConfig);
              } else if (typeof sceneConfig === "function") {
                newScene = this.createSceneFromFunction(key, sceneConfig);
              }
              newScene.sys.settings.data = data;
              key = newScene.sys.settings.key;
              this.keys[key] = newScene;
              this.scenes.push(newScene);
              if (autoStart || newScene.sys.settings.active) {
                if (this._pending.length) {
                  this._start.push(key);
                } else {
                  this.start(key);
                }
              }
              return newScene;
            },
            remove: function (key) {
              if (this.isProcessing) {
                this._queue.push({
                  op: "remove",
                  keyA: key,
                  keyB: null
                });
              } else {
                var sceneToRemove = this.getScene(key);
                if (!sceneToRemove || sceneToRemove.sys.isTransitioning()) {
                  return this;
                }
                var index = this.scenes.indexOf(sceneToRemove);
                var sceneKey = sceneToRemove.sys.settings.key;
                if (index > -1) {
                  delete this.keys[sceneKey];
                  this.scenes.splice(index, 1);
                  if (this._start.indexOf(sceneKey) > -1) {
                    index = this._start.indexOf(sceneKey);
                    this._start.splice(index, 1);
                  }
                  sceneToRemove.sys.destroy();
                }
              }
              return this;
            },
            bootScene: function (scene) {
              var sys = scene.sys;
              var settings = sys.settings;
              sys.sceneUpdate = NOOP;
              if (scene.init) {
                scene.init.call(scene, settings.data);
                settings.status = CONST.INIT;
                if (settings.isTransition) {
                  sys.events.emit(Events.TRANSITION_INIT, settings.transitionFrom, settings.transitionDuration);
                }
              }
              var loader;
              if (sys.load) {
                loader = sys.load;
                loader.reset();
              }
              if (loader && scene.preload) {
                scene.preload.call(scene);
                if (loader.list.size === 0) {
                  this.create(scene);
                } else {
                  settings.status = CONST.LOADING;
                  loader.once(LoaderEvents.COMPLETE, this.loadComplete, this);
                  loader.start();
                }
              } else {
                this.create(scene);
              }
            },
            loadComplete: function (loader) {
              this.create(loader.scene);
            },
            payloadComplete: function (loader) {
              this.bootScene(loader.scene);
            },
            update: function (time, delta) {
              this.processQueue();
              this.isProcessing = true;
              for (var i = this.scenes.length - 1; i >= 0; i--) {
                var sys = this.scenes[i].sys;
                if (sys.settings.status > CONST.START && sys.settings.status <= CONST.RUNNING) {
                  sys.step(time, delta);
                }
              }
            },
            render: function (renderer) {
              for (var i = 0; i < this.scenes.length; i++) {
                var sys = this.scenes[i].sys;
                if (sys.settings.visible && sys.settings.status >= CONST.LOADING && sys.settings.status < CONST.SLEEPING) {
                  sys.render(renderer);
                }
              }
              this.isProcessing = false;
            },
            create: function (scene) {
              var sys = scene.sys;
              var settings = sys.settings;
              if (scene.create) {
                settings.status = CONST.CREATING;
                scene.create.call(scene, settings.data);
                if (settings.status === CONST.DESTROYED) {
                  return;
                }
              }
              if (settings.isTransition) {
                sys.events.emit(Events.TRANSITION_START, settings.transitionFrom, settings.transitionDuration);
              }
              if (scene.update) {
                sys.sceneUpdate = scene.update;
              }
              settings.status = CONST.RUNNING;
              sys.events.emit(Events.CREATE, scene);
            },
            createSceneFromFunction: function (key, scene) {
              var newScene = new scene();
              if (newScene instanceof Scene) {
                var configKey = newScene.sys.settings.key;
                if (configKey !== "") {
                  key = configKey;
                }
                if (this.keys.hasOwnProperty(key)) {
                  throw new Error("Cannot add a Scene with duplicate key: " + key);
                }
                return this.createSceneFromInstance(key, newScene);
              } else {
                newScene.sys = new Systems(newScene);
                newScene.sys.settings.key = key;
                newScene.sys.init(this.game);
                return newScene;
              }
            },
            createSceneFromInstance: function (key, newScene) {
              var configKey = newScene.sys.settings.key;
              if (configKey === "") {
                newScene.sys.settings.key = key;
              }
              newScene.sys.init(this.game);
              return newScene;
            },
            createSceneFromObject: function (key, sceneConfig) {
              var newScene = new Scene(sceneConfig);
              var configKey = newScene.sys.settings.key;
              if (configKey !== "") {
                key = configKey;
              } else {
                newScene.sys.settings.key = key;
              }
              newScene.sys.init(this.game);
              var defaults = ["init", "preload", "create", "update", "render"];
              for (var i = 0; i < defaults.length; i++) {
                var sceneCallback = GetValue(sceneConfig, defaults[i], null);
                if (sceneCallback) {
                  newScene[defaults[i]] = sceneCallback;
                }
              }
              if (sceneConfig.hasOwnProperty("extend")) {
                for (var propertyKey in sceneConfig.extend) {
                  if (!sceneConfig.extend.hasOwnProperty(propertyKey)) {
                    continue;
                  }
                  var value = sceneConfig.extend[propertyKey];
                  if (propertyKey === "data" && newScene.hasOwnProperty("data") && typeof value === "object") {
                    newScene.data.merge(value);
                  } else if (propertyKey !== "sys") {
                    newScene[propertyKey] = value;
                  }
                }
              }
              return newScene;
            },
            getKey: function (key, sceneConfig) {
              if (!key) {
                key = "default";
              }
              if (typeof sceneConfig === "function") {
                return key;
              } else if (sceneConfig instanceof Scene) {
                key = sceneConfig.sys.settings.key;
              } else if (typeof sceneConfig === "object" && sceneConfig.hasOwnProperty("key")) {
                key = sceneConfig.key;
              }
              if (this.keys.hasOwnProperty(key)) {
                throw new Error("Cannot add a Scene with duplicate key: " + key);
              } else {
                return key;
              }
            },
            getScenes: function (isActive, inReverse) {
              if (isActive === void 0) {
                isActive = true;
              }
              if (inReverse === void 0) {
                inReverse = false;
              }
              var out = [];
              var scenes = this.scenes;
              for (var i = 0; i < scenes.length; i++) {
                var scene = scenes[i];
                if (scene && (!isActive || isActive && scene.sys.isActive())) {
                  out.push(scene);
                }
              }
              return inReverse ? out.reverse() : out;
            },
            getScene: function (key) {
              if (typeof key === "string") {
                if (this.keys[key]) {
                  return this.keys[key];
                }
              } else {
                for (var i = 0; i < this.scenes.length; i++) {
                  if (key === this.scenes[i]) {
                    return key;
                  }
                }
              }
              return null;
            },
            isActive: function (key) {
              var scene = this.getScene(key);
              if (scene) {
                return scene.sys.isActive();
              }
              return null;
            },
            isPaused: function (key) {
              var scene = this.getScene(key);
              if (scene) {
                return scene.sys.isPaused();
              }
              return null;
            },
            isVisible: function (key) {
              var scene = this.getScene(key);
              if (scene) {
                return scene.sys.isVisible();
              }
              return null;
            },
            isSleeping: function (key) {
              var scene = this.getScene(key);
              if (scene) {
                return scene.sys.isSleeping();
              }
              return null;
            },
            pause: function (key, data) {
              var scene = this.getScene(key);
              if (scene) {
                scene.sys.pause(data);
              }
              return this;
            },
            resume: function (key, data) {
              var scene = this.getScene(key);
              if (scene) {
                scene.sys.resume(data);
              }
              return this;
            },
            sleep: function (key, data) {
              var scene = this.getScene(key);
              if (scene && !scene.sys.isTransitioning()) {
                scene.sys.sleep(data);
              }
              return this;
            },
            wake: function (key, data) {
              var scene = this.getScene(key);
              if (scene) {
                scene.sys.wake(data);
              }
              return this;
            },
            run: function (key, data) {
              var scene = this.getScene(key);
              if (!scene) {
                for (var i = 0; i < this._pending.length; i++) {
                  if (this._pending[i].key === key) {
                    this.queueOp("start", key, data);
                    break;
                  }
                }
                return this;
              }
              if (scene.sys.isSleeping()) {
                scene.sys.wake(data);
              } else if (scene.sys.isPaused()) {
                scene.sys.resume(data);
              } else {
                this.start(key, data);
              }
            },
            start: function (key, data) {
              if (!this.isBooted) {
                this._data[key] = {
                  autoStart: true,
                  data
                };
                return this;
              }
              var scene = this.getScene(key);
              if (scene) {
                var sys = scene.sys;
                if (sys.isActive() || sys.isPaused()) {
                  sys.shutdown();
                  sys.sceneUpdate = NOOP;
                  sys.start(data);
                } else {
                  sys.sceneUpdate = NOOP;
                  sys.start(data);
                  var loader;
                  if (sys.load) {
                    loader = sys.load;
                  }
                  if (loader && sys.settings.hasOwnProperty("pack")) {
                    loader.reset();
                    if (loader.addPack({
                      payload: sys.settings.pack
                    })) {
                      sys.settings.status = CONST.LOADING;
                      loader.once(LoaderEvents.COMPLETE, this.payloadComplete, this);
                      loader.start();
                      return this;
                    }
                  }
                }
                this.bootScene(scene);
              }
              return this;
            },
            stop: function (key, data) {
              var scene = this.getScene(key);
              if (scene && !scene.sys.isTransitioning()) {
                scene.sys.shutdown(data);
              }
              return this;
            },
            switch: function (from, to) {
              var sceneA = this.getScene(from);
              var sceneB = this.getScene(to);
              if (sceneA && sceneB && sceneA !== sceneB) {
                this.sleep(from);
                if (this.isSleeping(to)) {
                  this.wake(to);
                } else {
                  this.start(to);
                }
              }
              return this;
            },
            getAt: function (index) {
              return this.scenes[index];
            },
            getIndex: function (key) {
              var scene = this.getScene(key);
              return this.scenes.indexOf(scene);
            },
            bringToTop: function (key) {
              if (this.isProcessing) {
                this._queue.push({
                  op: "bringToTop",
                  keyA: key,
                  keyB: null
                });
              } else {
                var index = this.getIndex(key);
                if (index !== -1 && index < this.scenes.length) {
                  var scene = this.getScene(key);
                  this.scenes.splice(index, 1);
                  this.scenes.push(scene);
                }
              }
              return this;
            },
            sendToBack: function (key) {
              if (this.isProcessing) {
                this._queue.push({
                  op: "sendToBack",
                  keyA: key,
                  keyB: null
                });
              } else {
                var index = this.getIndex(key);
                if (index !== -1 && index > 0) {
                  var scene = this.getScene(key);
                  this.scenes.splice(index, 1);
                  this.scenes.unshift(scene);
                }
              }
              return this;
            },
            moveDown: function (key) {
              if (this.isProcessing) {
                this._queue.push({
                  op: "moveDown",
                  keyA: key,
                  keyB: null
                });
              } else {
                var indexA = this.getIndex(key);
                if (indexA > 0) {
                  var indexB = indexA - 1;
                  var sceneA = this.getScene(key);
                  var sceneB = this.getAt(indexB);
                  this.scenes[indexA] = sceneB;
                  this.scenes[indexB] = sceneA;
                }
              }
              return this;
            },
            moveUp: function (key) {
              if (this.isProcessing) {
                this._queue.push({
                  op: "moveUp",
                  keyA: key,
                  keyB: null
                });
              } else {
                var indexA = this.getIndex(key);
                if (indexA < this.scenes.length - 1) {
                  var indexB = indexA + 1;
                  var sceneA = this.getScene(key);
                  var sceneB = this.getAt(indexB);
                  this.scenes[indexA] = sceneB;
                  this.scenes[indexB] = sceneA;
                }
              }
              return this;
            },
            moveAbove: function (keyA, keyB) {
              if (keyA === keyB) {
                return this;
              }
              if (this.isProcessing) {
                this._queue.push({
                  op: "moveAbove",
                  keyA,
                  keyB
                });
              } else {
                var indexA = this.getIndex(keyA);
                var indexB = this.getIndex(keyB);
                if (indexA !== -1 && indexB !== -1) {
                  var tempScene = this.getAt(indexB);
                  this.scenes.splice(indexB, 1);
                  this.scenes.splice(indexA + 1, 0, tempScene);
                }
              }
              return this;
            },
            moveBelow: function (keyA, keyB) {
              if (keyA === keyB) {
                return this;
              }
              if (this.isProcessing) {
                this._queue.push({
                  op: "moveBelow",
                  keyA,
                  keyB
                });
              } else {
                var indexA = this.getIndex(keyA);
                var indexB = this.getIndex(keyB);
                if (indexA !== -1 && indexB !== -1) {
                  var tempScene = this.getAt(indexB);
                  this.scenes.splice(indexB, 1);
                  if (indexA === 0) {
                    this.scenes.unshift(tempScene);
                  } else {
                    this.scenes.splice(indexA, 0, tempScene);
                  }
                }
              }
              return this;
            },
            queueOp: function (op, keyA, keyB) {
              this._queue.push({
                op,
                keyA,
                keyB
              });
              return this;
            },
            swapPosition: function (keyA, keyB) {
              if (keyA === keyB) {
                return this;
              }
              if (this.isProcessing) {
                this._queue.push({
                  op: "swapPosition",
                  keyA,
                  keyB
                });
              } else {
                var indexA = this.getIndex(keyA);
                var indexB = this.getIndex(keyB);
                if (indexA !== indexB && indexA !== -1 && indexB !== -1) {
                  var tempScene = this.getAt(indexA);
                  this.scenes[indexA] = this.scenes[indexB];
                  this.scenes[indexB] = tempScene;
                }
              }
              return this;
            },
            dump: function () {
              var out = [];
              var map = ["pending", "init", "start", "loading", "creating", "running", "paused", "sleeping", "shutdown", "destroyed"];
              for (var i = 0; i < this.scenes.length; i++) {
                var sys = this.scenes[i].sys;
                var key = sys.settings.visible && (sys.settings.status === CONST.RUNNING || sys.settings.status === CONST.PAUSED) ? "[*] " : "[-] ";
                key += sys.settings.key + " (" + map[sys.settings.status] + ")";
                out.push(key);
              }
              console.log(out.join("\n"));
            },
            destroy: function () {
              for (var i = 0; i < this.scenes.length; i++) {
                var sys = this.scenes[i].sys;
                sys.destroy();
              }
              this.update = NOOP;
              this.scenes = [];
              this._pending = [];
              this._start = [];
              this._queue = [];
              this.game = null;
            }
          });
          module2.exports = SceneManager;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Systems = __webpack_require__(204);
          var Scene = new Class({
            initialize: function Scene2(config) {
              this.sys = new Systems(this, config);
              this.game;
              this.anims;
              this.cache;
              this.registry;
              this.sound;
              this.textures;
              this.events;
              this.cameras;
              this.add;
              this.make;
              this.scene;
              this.children;
              this.lights;
              this.data;
              this.input;
              this.load;
              this.time;
              this.tweens;
              this.physics;
              this.matter;
              if (false) {}
              this.scale;
              this.plugins;
              this.renderer;
            },
            update: function () {}
          });
          module2.exports = Scene;
        }, function (module2, exports2, __webpack_require__) {
          var GetFastValue = __webpack_require__(2);
          var UppercaseFirst = __webpack_require__(205);
          var GetPhysicsPlugins = function (sys) {
            var defaultSystem = sys.game.config.defaultPhysicsSystem;
            var sceneSystems = GetFastValue(sys.settings, "physics", false);
            if (!defaultSystem && !sceneSystems) {
              return;
            }
            var output = [];
            if (defaultSystem) {
              output.push(UppercaseFirst(defaultSystem + "Physics"));
            }
            if (sceneSystems) {
              for (var key in sceneSystems) {
                key = UppercaseFirst(key.concat("Physics"));
                if (output.indexOf(key) === -1) {
                  output.push(key);
                }
              }
            }
            return output;
          };
          module2.exports = GetPhysicsPlugins;
        }, function (module2, exports2, __webpack_require__) {
          var GetFastValue = __webpack_require__(2);
          var GetScenePlugins = function (sys) {
            var defaultPlugins = sys.plugins.getDefaultScenePlugins();
            var scenePlugins = GetFastValue(sys.settings, "plugins", false);
            if (Array.isArray(scenePlugins)) {
              return scenePlugins;
            } else if (defaultPlugins) {
              return defaultPlugins;
            } else {
              return [];
            }
          };
          module2.exports = GetScenePlugins;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(144);
          var GetValue = __webpack_require__(6);
          var Merge = __webpack_require__(127);
          var InjectionMap = __webpack_require__(978);
          var Settings = {
            create: function (config) {
              if (typeof config === "string") {
                config = {
                  key: config
                };
              } else if (config === void 0) {
                config = {};
              }
              return {
                status: CONST.PENDING,
                key: GetValue(config, "key", ""),
                active: GetValue(config, "active", false),
                visible: GetValue(config, "visible", true),
                isBooted: false,
                isTransition: false,
                transitionFrom: null,
                transitionDuration: 0,
                transitionAllowInput: true,
                data: {},
                pack: GetValue(config, "pack", false),
                cameras: GetValue(config, "cameras", null),
                map: GetValue(config, "map", Merge(InjectionMap, GetValue(config, "mapAdd", {}))),
                physics: GetValue(config, "physics", {}),
                loader: GetValue(config, "loader", {}),
                plugins: GetValue(config, "plugins", false),
                input: GetValue(config, "input", {})
              };
            }
          };
          module2.exports = Settings;
        }, function (module2, exports2, __webpack_require__) {
          var CanvasPool = __webpack_require__(31);
          var CanvasTexture = __webpack_require__(423);
          var Class = __webpack_require__(0);
          var Color = __webpack_require__(38);
          var CONST = __webpack_require__(33);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(106);
          var GameEvents = __webpack_require__(22);
          var GenerateTexture = __webpack_require__(388);
          var GetValue = __webpack_require__(6);
          var Parser = __webpack_require__(425);
          var Texture = __webpack_require__(206);
          var TextureManager = new Class({
            Extends: EventEmitter,
            initialize: function TextureManager2(game) {
              EventEmitter.call(this);
              this.game = game;
              this.name = "TextureManager";
              this.list = {};
              this._tempCanvas = CanvasPool.create2D(this, 1, 1);
              this._tempContext = this._tempCanvas.getContext("2d");
              this._pending = 0;
              game.events.once(GameEvents.BOOT, this.boot, this);
            },
            boot: function () {
              this._pending = 3;
              this.on(Events.LOAD, this.updatePending, this);
              this.on(Events.ERROR, this.updatePending, this);
              var config = this.game.config;
              this.addBase64("__DEFAULT", config.defaultImage);
              this.addBase64("__MISSING", config.missingImage);
              this.addBase64("__WHITE", config.whiteImage);
              this.game.events.once(GameEvents.DESTROY, this.destroy, this);
            },
            updatePending: function () {
              this._pending--;
              if (this._pending === 0) {
                this.off(Events.LOAD);
                this.off(Events.ERROR);
                this.emit(Events.READY);
              }
            },
            checkKey: function (key) {
              if (this.exists(key)) {
                console.error("Texture key already in use: " + key);
                return false;
              }
              return true;
            },
            remove: function (key) {
              if (typeof key === "string") {
                if (this.exists(key)) {
                  key = this.get(key);
                } else {
                  console.warn("No texture found matching key: " + key);
                  return this;
                }
              }
              if (this.list.hasOwnProperty(key.key)) {
                key.destroy();
                this.emit(Events.REMOVE, key.key);
              }
              return this;
            },
            removeKey: function (key) {
              if (this.list.hasOwnProperty(key)) {
                delete this.list[key];
              }
              return this;
            },
            addBase64: function (key, data) {
              if (this.checkKey(key)) {
                var _this = this;
                var image = new Image();
                image.onerror = function () {
                  _this.emit(Events.ERROR, key);
                };
                image.onload = function () {
                  var texture = _this.create(key, image);
                  Parser.Image(texture, 0);
                  _this.emit(Events.ADD, key, texture);
                  _this.emit(Events.LOAD, key, texture);
                };
                image.src = data;
              }
              return this;
            },
            getBase64: function (key, frame, type, encoderOptions) {
              if (type === void 0) {
                type = "image/png";
              }
              if (encoderOptions === void 0) {
                encoderOptions = 0.92;
              }
              var data = "";
              var textureFrame = this.getFrame(key, frame);
              if (textureFrame && (textureFrame.source.isRenderTexture || textureFrame.source.isGLTexture)) {
                console.warn("Cannot getBase64 from WebGL Texture");
              } else if (textureFrame) {
                var cd = textureFrame.canvasData;
                var canvas = CanvasPool.create2D(this, cd.width, cd.height);
                var ctx = canvas.getContext("2d");
                ctx.drawImage(textureFrame.source.image, cd.x, cd.y, cd.width, cd.height, 0, 0, cd.width, cd.height);
                data = canvas.toDataURL(type, encoderOptions);
                CanvasPool.remove(canvas);
              }
              return data;
            },
            addImage: function (key, source, dataSource) {
              var texture = null;
              if (this.checkKey(key)) {
                texture = this.create(key, source);
                Parser.Image(texture, 0);
                if (dataSource) {
                  texture.setDataSource(dataSource);
                }
                this.emit(Events.ADD, key, texture);
              }
              return texture;
            },
            addGLTexture: function (key, glTexture, width, height) {
              var texture = null;
              if (this.checkKey(key)) {
                if (width === void 0) {
                  width = glTexture.width;
                }
                if (height === void 0) {
                  height = glTexture.height;
                }
                texture = this.create(key, glTexture, width, height);
                texture.add("__BASE", 0, 0, 0, width, height);
                this.emit(Events.ADD, key, texture);
              }
              return texture;
            },
            addRenderTexture: function (key, renderTexture) {
              var texture = null;
              if (this.checkKey(key)) {
                texture = this.create(key, renderTexture);
                texture.add("__BASE", 0, 0, 0, renderTexture.width, renderTexture.height);
                this.emit(Events.ADD, key, texture);
              }
              return texture;
            },
            generate: function (key, config) {
              if (this.checkKey(key)) {
                var canvas = CanvasPool.create(this, 1, 1);
                config.canvas = canvas;
                GenerateTexture(config);
                return this.addCanvas(key, canvas);
              } else {
                return null;
              }
            },
            createCanvas: function (key, width, height) {
              if (width === void 0) {
                width = 256;
              }
              if (height === void 0) {
                height = 256;
              }
              if (this.checkKey(key)) {
                var canvas = CanvasPool.create(this, width, height, CONST.CANVAS, true);
                return this.addCanvas(key, canvas);
              }
              return null;
            },
            addCanvas: function (key, source, skipCache) {
              if (skipCache === void 0) {
                skipCache = false;
              }
              var texture = null;
              if (skipCache) {
                texture = new CanvasTexture(this, key, source, source.width, source.height);
              } else if (this.checkKey(key)) {
                texture = new CanvasTexture(this, key, source, source.width, source.height);
                this.list[key] = texture;
                this.emit(Events.ADD, key, texture);
              }
              return texture;
            },
            addAtlas: function (key, source, data, dataSource) {
              if (Array.isArray(data.textures) || Array.isArray(data.frames)) {
                return this.addAtlasJSONArray(key, source, data, dataSource);
              } else {
                return this.addAtlasJSONHash(key, source, data, dataSource);
              }
            },
            addAtlasJSONArray: function (key, source, data, dataSource) {
              var texture = null;
              if (this.checkKey(key)) {
                texture = this.create(key, source);
                if (Array.isArray(data)) {
                  var singleAtlasFile = data.length === 1;
                  for (var i = 0; i < texture.source.length; i++) {
                    var atlasData = singleAtlasFile ? data[0] : data[i];
                    Parser.JSONArray(texture, i, atlasData);
                  }
                } else {
                  Parser.JSONArray(texture, 0, data);
                }
                if (dataSource) {
                  texture.setDataSource(dataSource);
                }
                this.emit(Events.ADD, key, texture);
              }
              return texture;
            },
            addAtlasJSONHash: function (key, source, data, dataSource) {
              var texture = null;
              if (this.checkKey(key)) {
                texture = this.create(key, source);
                if (Array.isArray(data)) {
                  for (var i = 0; i < data.length; i++) {
                    Parser.JSONHash(texture, i, data[i]);
                  }
                } else {
                  Parser.JSONHash(texture, 0, data);
                }
                if (dataSource) {
                  texture.setDataSource(dataSource);
                }
                this.emit(Events.ADD, key, texture);
              }
              return texture;
            },
            addAtlasXML: function (key, source, data, dataSource) {
              var texture = null;
              if (this.checkKey(key)) {
                texture = this.create(key, source);
                Parser.AtlasXML(texture, 0, data);
                if (dataSource) {
                  texture.setDataSource(dataSource);
                }
                this.emit(Events.ADD, key, texture);
              }
              return texture;
            },
            addUnityAtlas: function (key, source, data, dataSource) {
              var texture = null;
              if (this.checkKey(key)) {
                texture = this.create(key, source);
                Parser.UnityYAML(texture, 0, data);
                if (dataSource) {
                  texture.setDataSource(dataSource);
                }
                this.emit(Events.ADD, key, texture);
              }
              return texture;
            },
            addSpriteSheet: function (key, source, config) {
              var texture = null;
              if (this.checkKey(key)) {
                texture = this.create(key, source);
                var width = texture.source[0].width;
                var height = texture.source[0].height;
                Parser.SpriteSheet(texture, 0, 0, 0, width, height, config);
                this.emit(Events.ADD, key, texture);
              }
              return texture;
            },
            addSpriteSheetFromAtlas: function (key, config) {
              if (!this.checkKey(key)) {
                return null;
              }
              var atlasKey = GetValue(config, "atlas", null);
              var atlasFrame = GetValue(config, "frame", null);
              if (!atlasKey || !atlasFrame) {
                return;
              }
              var atlas = this.get(atlasKey);
              var sheet = atlas.get(atlasFrame);
              if (sheet) {
                var texture = this.create(key, sheet.source.image);
                if (sheet.trimmed) {
                  Parser.SpriteSheetFromAtlas(texture, sheet, config);
                } else {
                  Parser.SpriteSheet(texture, 0, sheet.cutX, sheet.cutY, sheet.cutWidth, sheet.cutHeight, config);
                }
                this.emit(Events.ADD, key, texture);
                return texture;
              }
            },
            create: function (key, source, width, height) {
              var texture = null;
              if (this.checkKey(key)) {
                texture = new Texture(this, key, source, width, height);
                this.list[key] = texture;
              }
              return texture;
            },
            exists: function (key) {
              return this.list.hasOwnProperty(key);
            },
            get: function (key) {
              if (key === void 0) {
                key = "__DEFAULT";
              }
              if (this.list[key]) {
                return this.list[key];
              } else if (key instanceof Texture) {
                return key;
              } else {
                return this.list["__MISSING"];
              }
            },
            cloneFrame: function (key, frame) {
              if (this.list[key]) {
                return this.list[key].get(frame).clone();
              }
            },
            getFrame: function (key, frame) {
              if (this.list[key]) {
                return this.list[key].get(frame);
              }
            },
            getTextureKeys: function () {
              var output = [];
              for (var key in this.list) {
                if (key !== "__DEFAULT" && key !== "__MISSING") {
                  output.push(key);
                }
              }
              return output;
            },
            getPixel: function (x, y, key, frame) {
              var textureFrame = this.getFrame(key, frame);
              if (textureFrame) {
                x -= textureFrame.x;
                y -= textureFrame.y;
                var data = textureFrame.data.cut;
                x += data.x;
                y += data.y;
                if (x >= data.x && x < data.r && y >= data.y && y < data.b) {
                  var ctx = this._tempContext;
                  ctx.clearRect(0, 0, 1, 1);
                  ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);
                  var rgb = ctx.getImageData(0, 0, 1, 1);
                  return new Color(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);
                }
              }
              return null;
            },
            getPixelAlpha: function (x, y, key, frame) {
              var textureFrame = this.getFrame(key, frame);
              if (textureFrame) {
                x -= textureFrame.x;
                y -= textureFrame.y;
                var data = textureFrame.data.cut;
                x += data.x;
                y += data.y;
                if (x >= data.x && x < data.r && y >= data.y && y < data.b) {
                  var ctx = this._tempContext;
                  ctx.clearRect(0, 0, 1, 1);
                  ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);
                  var rgb = ctx.getImageData(0, 0, 1, 1);
                  return rgb.data[3];
                }
              }
              return null;
            },
            setTexture: function (gameObject, key, frame) {
              if (this.list[key]) {
                gameObject.texture = this.list[key];
                gameObject.frame = gameObject.texture.get(frame);
              }
              return gameObject;
            },
            renameTexture: function (currentKey, newKey) {
              var texture = this.get(currentKey);
              if (texture && currentKey !== newKey) {
                texture.key = newKey;
                this.list[newKey] = texture;
                delete this.list[currentKey];
                return true;
              }
              return false;
            },
            each: function (callback, scope) {
              var args = [null];
              for (var i = 1; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              for (var texture in this.list) {
                args[0] = this.list[texture];
                callback.apply(scope, args);
              }
            },
            destroy: function () {
              for (var texture in this.list) {
                this.list[texture].destroy();
              }
              this.list = {};
              this.game = null;
              CanvasPool.remove(this._tempCanvas);
            }
          });
          module2.exports = TextureManager;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Clamp = __webpack_require__(18);
          var Color = __webpack_require__(38);
          var CONST = __webpack_require__(33);
          var IsSizePowerOfTwo = __webpack_require__(138);
          var Texture = __webpack_require__(206);
          var CanvasTexture = new Class({
            Extends: Texture,
            initialize: function CanvasTexture2(manager, key, source, width, height) {
              Texture.call(this, manager, key, source, width, height);
              this.add("__BASE", 0, 0, 0, width, height);
              this._source = this.frames["__BASE"].source;
              this.canvas = this._source.image;
              this.context = this.canvas.getContext("2d");
              this.width = width;
              this.height = height;
              this.imageData = this.context.getImageData(0, 0, width, height);
              this.data = null;
              if (this.imageData) {
                this.data = this.imageData.data;
              }
              this.pixels = null;
              this.buffer;
              if (this.data) {
                if (this.imageData.data.buffer) {
                  this.buffer = this.imageData.data.buffer;
                  this.pixels = new Uint32Array(this.buffer);
                } else if (window.ArrayBuffer) {
                  this.buffer = new ArrayBuffer(this.imageData.data.length);
                  this.pixels = new Uint32Array(this.buffer);
                } else {
                  this.pixels = this.imageData.data;
                }
              }
            },
            update: function () {
              this.imageData = this.context.getImageData(0, 0, this.width, this.height);
              this.data = this.imageData.data;
              if (this.imageData.data.buffer) {
                this.buffer = this.imageData.data.buffer;
                this.pixels = new Uint32Array(this.buffer);
              } else if (window.ArrayBuffer) {
                this.buffer = new ArrayBuffer(this.imageData.data.length);
                this.pixels = new Uint32Array(this.buffer);
              } else {
                this.pixels = this.imageData.data;
              }
              if (this.manager.game.config.renderType === CONST.WEBGL) {
                this.refresh();
              }
              return this;
            },
            draw: function (x, y, source) {
              this.context.drawImage(source, x, y);
              return this.update();
            },
            drawFrame: function (key, frame, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              var textureFrame = this.manager.getFrame(key, frame);
              if (textureFrame) {
                var cd = textureFrame.canvasData;
                var width = textureFrame.cutWidth;
                var height = textureFrame.cutHeight;
                var res = textureFrame.source.resolution;
                this.context.drawImage(textureFrame.source.image, cd.x, cd.y, width, height, x, y, width / res, height / res);
                return this.update();
              } else {
                return this;
              }
            },
            setPixel: function (x, y, red, green, blue, alpha) {
              if (alpha === void 0) {
                alpha = 255;
              }
              x = Math.abs(Math.floor(x));
              y = Math.abs(Math.floor(y));
              var index = this.getIndex(x, y);
              if (index > -1) {
                var imageData = this.context.getImageData(x, y, 1, 1);
                imageData.data[0] = red;
                imageData.data[1] = green;
                imageData.data[2] = blue;
                imageData.data[3] = alpha;
                this.context.putImageData(imageData, x, y);
              }
              return this;
            },
            putData: function (imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
              if (dirtyX === void 0) {
                dirtyX = 0;
              }
              if (dirtyY === void 0) {
                dirtyY = 0;
              }
              if (dirtyWidth === void 0) {
                dirtyWidth = imageData.width;
              }
              if (dirtyHeight === void 0) {
                dirtyHeight = imageData.height;
              }
              this.context.putImageData(imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
              return this;
            },
            getData: function (x, y, width, height) {
              x = Clamp(Math.floor(x), 0, this.width - 1);
              y = Clamp(Math.floor(y), 0, this.height - 1);
              width = Clamp(width, 1, this.width - x);
              height = Clamp(height, 1, this.height - y);
              var imageData = this.context.getImageData(x, y, width, height);
              return imageData;
            },
            getPixel: function (x, y, out) {
              if (!out) {
                out = new Color();
              }
              var index = this.getIndex(x, y);
              if (index > -1) {
                var data = this.data;
                var r = data[index + 0];
                var g = data[index + 1];
                var b = data[index + 2];
                var a = data[index + 3];
                out.setTo(r, g, b, a);
              }
              return out;
            },
            getPixels: function (x, y, width, height) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = this.width;
              }
              if (height === void 0) {
                height = width;
              }
              x = Math.abs(Math.round(x));
              y = Math.abs(Math.round(y));
              var left = Clamp(x, 0, this.width);
              var right = Clamp(x + width, 0, this.width);
              var top = Clamp(y, 0, this.height);
              var bottom = Clamp(y + height, 0, this.height);
              var pixel = new Color();
              var out = [];
              for (var py = top; py < bottom; py++) {
                var row = [];
                for (var px = left; px < right; px++) {
                  pixel = this.getPixel(px, py, pixel);
                  row.push({
                    x: px,
                    y: py,
                    color: pixel.color,
                    alpha: pixel.alphaGL
                  });
                }
                out.push(row);
              }
              return out;
            },
            getIndex: function (x, y) {
              x = Math.abs(Math.round(x));
              y = Math.abs(Math.round(y));
              if (x < this.width && y < this.height) {
                return (x + y * this.width) * 4;
              } else {
                return -1;
              }
            },
            refresh: function () {
              this._source.update();
              return this;
            },
            getCanvas: function () {
              return this.canvas;
            },
            getContext: function () {
              return this.context;
            },
            clear: function (x, y, width, height) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = this.width;
              }
              if (height === void 0) {
                height = this.height;
              }
              this.context.clearRect(x, y, width, height);
              return this.update();
            },
            setSize: function (width, height) {
              if (height === void 0) {
                height = width;
              }
              if (width !== this.width || height !== this.height) {
                this.canvas.width = width;
                this.canvas.height = height;
                this._source.width = width;
                this._source.height = height;
                this._source.isPowerOf2 = IsSizePowerOfTwo(width, height);
                this.frames["__BASE"].setSize(width, height, 0, 0);
                this.width = width;
                this.height = height;
                this.refresh();
              }
              return this;
            },
            destroy: function () {
              Texture.prototype.destroy.call(this);
              this._source = null;
              this.canvas = null;
              this.context = null;
              this.imageData = null;
              this.data = null;
              this.pixels = null;
              this.buffer = null;
            }
          });
          module2.exports = CanvasTexture;
        }, function (module2, exports2, __webpack_require__) {
          var CanvasPool = __webpack_require__(31);
          var Class = __webpack_require__(0);
          var IsSizePowerOfTwo = __webpack_require__(138);
          var ScaleModes = __webpack_require__(168);
          var TextureSource = new Class({
            initialize: function TextureSource2(texture, source, width, height, flipY) {
              if (flipY === void 0) {
                flipY = false;
              }
              var game = texture.manager.game;
              this.renderer = game.renderer;
              this.texture = texture;
              this.source = source;
              this.image = source;
              this.compressionAlgorithm = null;
              this.resolution = 1;
              this.width = width || source.naturalWidth || source.videoWidth || source.width || 0;
              this.height = height || source.naturalHeight || source.videoHeight || source.height || 0;
              this.scaleMode = ScaleModes.DEFAULT;
              this.isCanvas = source instanceof HTMLCanvasElement;
              this.isVideo = window.hasOwnProperty("HTMLVideoElement") && source instanceof HTMLVideoElement;
              this.isRenderTexture = source.type === "RenderTexture";
              this.isGLTexture = window.hasOwnProperty("WebGLTexture") && source instanceof WebGLTexture;
              this.isPowerOf2 = IsSizePowerOfTwo(this.width, this.height);
              this.glTexture = null;
              this.glIndex = 0;
              this.glIndexCounter = -1;
              this.flipY = flipY;
              this.init(game);
            },
            init: function (game) {
              var renderer = this.renderer;
              if (renderer) {
                if (renderer.gl) {
                  if (this.isCanvas) {
                    this.glTexture = renderer.createCanvasTexture(this.image, false, this.flipY);
                  } else if (this.isVideo) {
                    this.glTexture = renderer.createVideoTexture(this.image, false, this.flipY);
                  } else if (this.isRenderTexture) {
                    this.image = this.source.canvas;
                    this.glTexture = renderer.createTextureFromSource(null, this.width, this.height, this.scaleMode);
                  } else if (this.isGLTexture) {
                    this.glTexture = this.source;
                  } else {
                    this.glTexture = renderer.createTextureFromSource(this.image, this.width, this.height, this.scaleMode);
                  }
                } else if (this.isRenderTexture) {
                  this.image = this.source.canvas;
                }
              }
              if (!game.config.antialias) {
                this.setFilter(1);
              }
            },
            setFilter: function (filterMode) {
              if (this.renderer.gl) {
                this.renderer.setTextureFilter(this.glTexture, filterMode);
              }
              this.scaleMode = filterMode;
            },
            setFlipY: function (value) {
              if (value === void 0) {
                value = true;
              }
              this.flipY = value;
              return this;
            },
            update: function () {
              var gl = this.renderer.gl;
              if (gl && this.isCanvas) {
                this.glTexture = this.renderer.updateCanvasTexture(this.image, this.glTexture, this.flipY);
              } else if (gl && this.isVideo) {
                this.glTexture = this.renderer.updateVideoTexture(this.image, this.glTexture, this.flipY);
              }
            },
            destroy: function () {
              if (this.glTexture) {
                this.renderer.deleteTexture(this.glTexture, true);
              }
              if (this.isCanvas) {
                CanvasPool.remove(this.image);
              }
              this.renderer = null;
              this.texture = null;
              this.source = null;
              this.image = null;
              this.glTexture = null;
            }
          });
          module2.exports = TextureSource;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            AtlasXML: __webpack_require__(979),
            Canvas: __webpack_require__(980),
            Image: __webpack_require__(981),
            JSONArray: __webpack_require__(982),
            JSONHash: __webpack_require__(983),
            SpriteSheet: __webpack_require__(984),
            SpriteSheetFromAtlas: __webpack_require__(985),
            UnityYAML: __webpack_require__(986)
          };
        }, function (module2, exports2, __webpack_require__) {
          var HTML5AudioSoundManager = __webpack_require__(427);
          var NoAudioSoundManager = __webpack_require__(430);
          var WebAudioSoundManager = __webpack_require__(432);
          var SoundManagerCreator = {
            create: function (game) {
              var audioConfig = game.config.audio;
              var deviceAudio = game.device.audio;
              if (audioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
                return new NoAudioSoundManager(game);
              }
              if (deviceAudio.webAudio && !audioConfig.disableWebAudio) {
                return new WebAudioSoundManager(game);
              }
              return new HTML5AudioSoundManager(game);
            }
          };
          module2.exports = SoundManagerCreator;
        }, function (module2, exports2, __webpack_require__) {
          var BaseSoundManager = __webpack_require__(145);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(70);
          var HTML5AudioSound = __webpack_require__(429);
          var HTML5AudioSoundManager = new Class({
            Extends: BaseSoundManager,
            initialize: function HTML5AudioSoundManager2(game) {
              this.override = true;
              this.audioPlayDelay = 0.1;
              this.loopEndOffset = 0.05;
              this.onBlurPausedSounds = [];
              this.locked = ("ontouchstart" in window);
              this.lockedActionsQueue = this.locked ? [] : null;
              this._mute = false;
              this._volume = 1;
              BaseSoundManager.call(this, game);
            },
            add: function (key, config) {
              var sound = new HTML5AudioSound(this, key, config);
              this.sounds.push(sound);
              return sound;
            },
            unlock: function () {
              this.locked = false;
              var _this = this;
              this.game.cache.audio.entries.each(function (key, tags) {
                for (var i = 0; i < tags.length; i++) {
                  if (tags[i].dataset.locked === "true") {
                    _this.locked = true;
                    return false;
                  }
                }
                return true;
              });
              if (!this.locked) {
                return;
              }
              var moved = false;
              var detectMove = function () {
                moved = true;
              };
              var unlock = function () {
                if (moved) {
                  moved = false;
                  return;
                }
                document.body.removeEventListener("touchmove", detectMove);
                document.body.removeEventListener("touchend", unlock);
                var lockedTags = [];
                _this.game.cache.audio.entries.each(function (key, tags) {
                  for (var i = 0; i < tags.length; i++) {
                    var tag = tags[i];
                    if (tag.dataset.locked === "true") {
                      lockedTags.push(tag);
                    }
                  }
                  return true;
                });
                if (lockedTags.length === 0) {
                  return;
                }
                var lastTag = lockedTags[lockedTags.length - 1];
                lastTag.oncanplaythrough = function () {
                  lastTag.oncanplaythrough = null;
                  lockedTags.forEach(function (tag) {
                    tag.dataset.locked = "false";
                  });
                  _this.unlocked = true;
                };
                lockedTags.forEach(function (tag) {
                  tag.load();
                });
              };
              this.once(Events.UNLOCKED, function () {
                this.forEachActiveSound(function (sound) {
                  if (sound.currentMarker === null && sound.duration === 0) {
                    sound.duration = sound.tags[0].duration;
                  }
                  sound.totalDuration = sound.tags[0].duration;
                });
                while (this.lockedActionsQueue.length) {
                  var lockedAction = this.lockedActionsQueue.shift();
                  if (lockedAction.sound[lockedAction.prop].apply) {
                    lockedAction.sound[lockedAction.prop].apply(lockedAction.sound, lockedAction.value || []);
                  } else {
                    lockedAction.sound[lockedAction.prop] = lockedAction.value;
                  }
                }
              }, this);
              document.body.addEventListener("touchmove", detectMove, false);
              document.body.addEventListener("touchend", unlock, false);
            },
            onBlur: function () {
              this.forEachActiveSound(function (sound) {
                if (sound.isPlaying) {
                  this.onBlurPausedSounds.push(sound);
                  sound.onBlur();
                }
              });
            },
            onFocus: function () {
              this.onBlurPausedSounds.forEach(function (sound) {
                sound.onFocus();
              });
              this.onBlurPausedSounds.length = 0;
            },
            destroy: function () {
              BaseSoundManager.prototype.destroy.call(this);
              this.onBlurPausedSounds.length = 0;
              this.onBlurPausedSounds = null;
            },
            isLocked: function (sound, prop, value) {
              if (sound.tags[0].dataset.locked === "true") {
                this.lockedActionsQueue.push({
                  sound,
                  prop,
                  value
                });
                return true;
              }
              return false;
            },
            setMute: function (value) {
              this.mute = value;
              return this;
            },
            mute: {
              get: function () {
                return this._mute;
              },
              set: function (value) {
                this._mute = value;
                this.forEachActiveSound(function (sound) {
                  sound.updateMute();
                });
                this.emit(Events.GLOBAL_MUTE, this, value);
              }
            },
            setVolume: function (value) {
              this.volume = value;
              return this;
            },
            volume: {
              get: function () {
                return this._volume;
              },
              set: function (value) {
                this._volume = value;
                this.forEachActiveSound(function (sound) {
                  sound.updateVolume();
                });
                this.emit(Events.GLOBAL_VOLUME, this, value);
              }
            }
          });
          module2.exports = HTML5AudioSoundManager;
        }, function (module2, exports2, __webpack_require__) {
          var SafeRange = __webpack_require__(78);
          var GetFirst = function (array, property, value, startIndex, endIndex) {
            if (startIndex === void 0) {
              startIndex = 0;
            }
            if (endIndex === void 0) {
              endIndex = array.length;
            }
            if (SafeRange(array, startIndex, endIndex)) {
              for (var i = startIndex; i < endIndex; i++) {
                var child = array[i];
                if (!property || property && value === void 0 && child.hasOwnProperty(property) || property && value !== void 0 && child[property] === value) {
                  return child;
                }
              }
            }
            return null;
          };
          module2.exports = GetFirst;
        }, function (module2, exports2, __webpack_require__) {
          var BaseSound = __webpack_require__(146);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(70);
          var Clamp = __webpack_require__(18);
          var HTML5AudioSound = new Class({
            Extends: BaseSound,
            initialize: function HTML5AudioSound2(manager, key, config) {
              if (config === void 0) {
                config = {};
              }
              this.tags = manager.game.cache.audio.get(key);
              if (!this.tags) {
                throw new Error('There is no audio asset with key "' + key + '" in the audio cache');
              }
              this.audio = null;
              this.startTime = 0;
              this.previousTime = 0;
              this.duration = this.tags[0].duration;
              this.totalDuration = this.tags[0].duration;
              BaseSound.call(this, manager, key, config);
            },
            play: function (markerName, config) {
              if (this.manager.isLocked(this, "play", [markerName, config])) {
                return false;
              }
              if (!BaseSound.prototype.play.call(this, markerName, config)) {
                return false;
              }
              if (!this.pickAndPlayAudioTag()) {
                return false;
              }
              this.emit(Events.PLAY, this);
              return true;
            },
            pause: function () {
              if (this.manager.isLocked(this, "pause")) {
                return false;
              }
              if (this.startTime > 0) {
                return false;
              }
              if (!BaseSound.prototype.pause.call(this)) {
                return false;
              }
              this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0);
              this.stopAndReleaseAudioTag();
              this.emit(Events.PAUSE, this);
              return true;
            },
            resume: function () {
              if (this.manager.isLocked(this, "resume")) {
                return false;
              }
              if (this.startTime > 0) {
                return false;
              }
              if (!BaseSound.prototype.resume.call(this)) {
                return false;
              }
              if (!this.pickAndPlayAudioTag()) {
                return false;
              }
              this.emit(Events.RESUME, this);
              return true;
            },
            stop: function () {
              if (this.manager.isLocked(this, "stop")) {
                return false;
              }
              if (!BaseSound.prototype.stop.call(this)) {
                return false;
              }
              this.stopAndReleaseAudioTag();
              this.emit(Events.STOP, this);
              return true;
            },
            pickAndPlayAudioTag: function () {
              if (!this.pickAudioTag()) {
                this.reset();
                return false;
              }
              var seek = this.currentConfig.seek;
              var delay = this.currentConfig.delay;
              var offset = (this.currentMarker ? this.currentMarker.start : 0) + seek;
              this.previousTime = offset;
              this.audio.currentTime = offset;
              this.applyConfig();
              if (delay === 0) {
                this.startTime = 0;
                if (this.audio.paused) {
                  this.playCatchPromise();
                }
              } else {
                this.startTime = window.performance.now() + delay * 1e3;
                if (!this.audio.paused) {
                  this.audio.pause();
                }
              }
              this.resetConfig();
              return true;
            },
            pickAudioTag: function () {
              if (this.audio) {
                return true;
              }
              for (var i = 0; i < this.tags.length; i++) {
                var audio = this.tags[i];
                if (audio.dataset.used === "false") {
                  audio.dataset.used = "true";
                  this.audio = audio;
                  return true;
                }
              }
              if (!this.manager.override) {
                return false;
              }
              var otherSounds = [];
              this.manager.forEachActiveSound(function (sound) {
                if (sound.key === this.key && sound.audio) {
                  otherSounds.push(sound);
                }
              }, this);
              otherSounds.sort(function (a1, a2) {
                if (a1.loop === a2.loop) {
                  return a2.seek / a2.duration - a1.seek / a1.duration;
                }
                return a1.loop ? 1 : -1;
              });
              var selectedSound = otherSounds[0];
              this.audio = selectedSound.audio;
              selectedSound.reset();
              selectedSound.audio = null;
              selectedSound.startTime = 0;
              selectedSound.previousTime = 0;
              return true;
            },
            playCatchPromise: function () {
              var playPromise = this.audio.play();
              if (playPromise) {
                playPromise.catch(function (reason) {
                  console.warn(reason);
                });
              }
            },
            stopAndReleaseAudioTag: function () {
              this.startTime = 0;
              this.previousTime = 0;
              if (this.audio) {
                this.audio.pause();
                this.audio.dataset.used = "false";
                this.audio = null;
              }
            },
            reset: function () {
              BaseSound.prototype.stop.call(this);
            },
            onBlur: function () {
              this.isPlaying = false;
              this.isPaused = true;
              this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0);
              this.currentConfig.delay = Math.max(0, (this.startTime - window.performance.now()) / 1e3);
              this.stopAndReleaseAudioTag();
            },
            onFocus: function () {
              this.isPlaying = true;
              this.isPaused = false;
              this.pickAndPlayAudioTag();
            },
            update: function (time) {
              if (!this.isPlaying) {
                return;
              }
              if (this.startTime > 0) {
                if (this.startTime < time - this.manager.audioPlayDelay) {
                  this.audio.currentTime += Math.max(0, time - this.startTime) / 1e3;
                  this.startTime = 0;
                  this.previousTime = this.audio.currentTime;
                  this.playCatchPromise();
                }
                return;
              }
              var startTime = this.currentMarker ? this.currentMarker.start : 0;
              var endTime = startTime + this.duration;
              var currentTime = this.audio.currentTime;
              if (this.currentConfig.loop) {
                if (currentTime >= endTime - this.manager.loopEndOffset) {
                  this.audio.currentTime = startTime + Math.max(0, currentTime - endTime);
                  currentTime = this.audio.currentTime;
                } else if (currentTime < startTime) {
                  this.audio.currentTime += startTime;
                  currentTime = this.audio.currentTime;
                }
                if (currentTime < this.previousTime) {
                  this.emit(Events.LOOPED, this);
                }
              } else if (currentTime >= endTime) {
                this.reset();
                this.stopAndReleaseAudioTag();
                this.emit(Events.COMPLETE, this);
                return;
              }
              this.previousTime = currentTime;
            },
            destroy: function () {
              BaseSound.prototype.destroy.call(this);
              this.tags = null;
              if (this.audio) {
                this.stopAndReleaseAudioTag();
              }
            },
            updateMute: function () {
              if (this.audio) {
                this.audio.muted = this.currentConfig.mute || this.manager.mute;
              }
            },
            updateVolume: function () {
              if (this.audio) {
                this.audio.volume = Clamp(this.currentConfig.volume * this.manager.volume, 0, 1);
              }
            },
            calculateRate: function () {
              BaseSound.prototype.calculateRate.call(this);
              if (this.audio) {
                this.audio.playbackRate = this.totalRate;
              }
            },
            mute: {
              get: function () {
                return this.currentConfig.mute;
              },
              set: function (value) {
                this.currentConfig.mute = value;
                if (this.manager.isLocked(this, "mute", value)) {
                  return;
                }
                this.updateMute();
                this.emit(Events.MUTE, this, value);
              }
            },
            setMute: function (value) {
              this.mute = value;
              return this;
            },
            volume: {
              get: function () {
                return this.currentConfig.volume;
              },
              set: function (value) {
                this.currentConfig.volume = value;
                if (this.manager.isLocked(this, "volume", value)) {
                  return;
                }
                this.updateVolume();
                this.emit(Events.VOLUME, this, value);
              }
            },
            setVolume: function (value) {
              this.volume = value;
              return this;
            },
            rate: {
              get: function () {
                return this.currentConfig.rate;
              },
              set: function (value) {
                this.currentConfig.rate = value;
                if (this.manager.isLocked(this, Events.RATE, value)) {
                  return;
                } else {
                  this.calculateRate();
                  this.emit(Events.RATE, this, value);
                }
              }
            },
            setRate: function (value) {
              this.rate = value;
              return this;
            },
            detune: {
              get: function () {
                return this.currentConfig.detune;
              },
              set: function (value) {
                this.currentConfig.detune = value;
                if (this.manager.isLocked(this, Events.DETUNE, value)) {
                  return;
                } else {
                  this.calculateRate();
                  this.emit(Events.DETUNE, this, value);
                }
              }
            },
            setDetune: function (value) {
              this.detune = value;
              return this;
            },
            seek: {
              get: function () {
                if (this.isPlaying) {
                  return this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0);
                } else if (this.isPaused) {
                  return this.currentConfig.seek;
                } else {
                  return 0;
                }
              },
              set: function (value) {
                if (this.manager.isLocked(this, "seek", value)) {
                  return;
                }
                if (this.startTime > 0) {
                  return;
                }
                if (this.isPlaying || this.isPaused) {
                  value = Math.min(Math.max(0, value), this.duration);
                  if (this.isPlaying) {
                    this.previousTime = value;
                    this.audio.currentTime = value;
                  } else if (this.isPaused) {
                    this.currentConfig.seek = value;
                  }
                  this.emit(Events.SEEK, this, value);
                }
              }
            },
            setSeek: function (value) {
              this.seek = value;
              return this;
            },
            loop: {
              get: function () {
                return this.currentConfig.loop;
              },
              set: function (value) {
                this.currentConfig.loop = value;
                if (this.manager.isLocked(this, "loop", value)) {
                  return;
                }
                if (this.audio) {
                  this.audio.loop = value;
                }
                this.emit(Events.LOOP, this, value);
              }
            },
            setLoop: function (value) {
              this.loop = value;
              return this;
            },
            pan: {
              get: function () {
                return this.currentConfig.pan;
              },
              set: function (value) {
                this.currentConfig.pan = value;
                this.emit(Events.PAN, this, value);
              }
            },
            setPan: function (value) {
              this.pan = value;
              return this;
            }
          });
          module2.exports = HTML5AudioSound;
        }, function (module2, exports2, __webpack_require__) {
          var BaseSoundManager = __webpack_require__(145);
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var NoAudioSound = __webpack_require__(431);
          var NOOP = __webpack_require__(1);
          var NoAudioSoundManager = new Class({
            Extends: EventEmitter,
            initialize: function NoAudioSoundManager2(game) {
              EventEmitter.call(this);
              this.game = game;
              this.sounds = [];
              this.mute = false;
              this.volume = 1;
              this.rate = 1;
              this.detune = 0;
              this.pauseOnBlur = true;
              this.locked = false;
            },
            add: function (key, config) {
              var sound = new NoAudioSound(this, key, config);
              this.sounds.push(sound);
              return sound;
            },
            addAudioSprite: function (key, config) {
              var sound = this.add(key, config);
              sound.spritemap = {};
              return sound;
            },
            play: function (key, extra) {
              return false;
            },
            playAudioSprite: function (key, spriteName, config) {
              return false;
            },
            remove: function (sound) {
              return BaseSoundManager.prototype.remove.call(this, sound);
            },
            removeByKey: function (key) {
              return BaseSoundManager.prototype.removeByKey.call(this, key);
            },
            pauseAll: NOOP,
            resumeAll: NOOP,
            stopAll: NOOP,
            update: NOOP,
            setRate: NOOP,
            setDetune: NOOP,
            setMute: NOOP,
            setVolume: NOOP,
            forEachActiveSound: function (callbackfn, scope) {
              BaseSoundManager.prototype.forEachActiveSound.call(this, callbackfn, scope);
            },
            destroy: function () {
              BaseSoundManager.prototype.destroy.call(this);
            }
          });
          module2.exports = NoAudioSoundManager;
        }, function (module2, exports2, __webpack_require__) {
          var BaseSound = __webpack_require__(146);
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Extend = __webpack_require__(17);
          var returnFalse = function () {
            return false;
          };
          var returnNull = function () {
            return null;
          };
          var returnThis = function () {
            return this;
          };
          var NoAudioSound = new Class({
            Extends: EventEmitter,
            initialize: function NoAudioSound2(manager, key, config) {
              if (config === void 0) {
                config = {};
              }
              EventEmitter.call(this);
              this.manager = manager;
              this.key = key;
              this.isPlaying = false;
              this.isPaused = false;
              this.totalRate = 1;
              this.duration = 0;
              this.totalDuration = 0;
              this.config = Extend({
                mute: false,
                volume: 1,
                rate: 1,
                detune: 0,
                seek: 0,
                loop: false,
                delay: 0,
                pan: 0
              }, config);
              this.currentConfig = this.config;
              this.mute = false;
              this.volume = 1;
              this.rate = 1;
              this.detune = 0;
              this.seek = 0;
              this.loop = false;
              this.pan = 0;
              this.markers = {};
              this.currentMarker = null;
              this.pendingRemove = false;
            },
            addMarker: returnFalse,
            updateMarker: returnFalse,
            removeMarker: returnNull,
            play: returnFalse,
            pause: returnFalse,
            resume: returnFalse,
            stop: returnFalse,
            destroy: function () {
              BaseSound.prototype.destroy.call(this);
            },
            setMute: returnThis,
            setVolume: returnThis,
            setRate: returnThis,
            setDetune: returnThis,
            setSeek: returnThis,
            setLoop: returnThis,
            setPan: returnThis
          });
          module2.exports = NoAudioSound;
        }, function (module2, exports2, __webpack_require__) {
          var Base64ToArrayBuffer = __webpack_require__(433);
          var BaseSoundManager = __webpack_require__(145);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(70);
          var GameEvents = __webpack_require__(22);
          var WebAudioSound = __webpack_require__(434);
          var WebAudioSoundManager = new Class({
            Extends: BaseSoundManager,
            initialize: function WebAudioSoundManager2(game) {
              this.context = this.createAudioContext(game);
              this.masterMuteNode = this.context.createGain();
              this.masterVolumeNode = this.context.createGain();
              this.masterMuteNode.connect(this.masterVolumeNode);
              this.masterVolumeNode.connect(this.context.destination);
              this.destination = this.masterMuteNode;
              this.locked = this.context.state === "suspended" && (("ontouchstart" in window) || ("onclick" in window));
              BaseSoundManager.call(this, game);
              if (this.locked && game.isBooted) {
                this.unlock();
              } else {
                game.events.once(GameEvents.BOOT, this.unlock, this);
              }
            },
            createAudioContext: function (game) {
              var audioConfig = game.config.audio;
              if (audioConfig.context) {
                audioConfig.context.resume();
                return audioConfig.context;
              }
              if (window.hasOwnProperty("AudioContext")) {
                return new AudioContext();
              } else if (window.hasOwnProperty("webkitAudioContext")) {
                return new window.webkitAudioContext();
              }
            },
            setAudioContext: function (context) {
              if (this.context) {
                this.context.close();
              }
              if (this.masterMuteNode) {
                this.masterMuteNode.disconnect();
              }
              if (this.masterVolumeNode) {
                this.masterVolumeNode.disconnect();
              }
              this.context = context;
              this.masterMuteNode = context.createGain();
              this.masterVolumeNode = context.createGain();
              this.masterMuteNode.connect(this.masterVolumeNode);
              this.masterVolumeNode.connect(context.destination);
              this.destination = this.masterMuteNode;
              return this;
            },
            add: function (key, config) {
              var sound = new WebAudioSound(this, key, config);
              this.sounds.push(sound);
              return sound;
            },
            decodeAudio: function (audioKey, audioData) {
              var audioFiles;
              if (!Array.isArray(audioKey)) {
                audioFiles = [{
                  key: audioKey,
                  data: audioData
                }];
              } else {
                audioFiles = audioKey;
              }
              var cache = this.game.cache.audio;
              var remaining = audioFiles.length;
              for (var i = 0; i < audioFiles.length; i++) {
                var entry = audioFiles[i];
                var key = entry.key;
                var data = entry.data;
                if (typeof data === "string") {
                  data = Base64ToArrayBuffer(data);
                }
                var success = (function (key2, audioBuffer) {
                  cache.add(key2, audioBuffer);
                  this.emit(Events.DECODED, key2);
                  remaining--;
                  if (remaining === 0) {
                    this.emit(Events.DECODED_ALL);
                  }
                }).bind(this, key);
                var failure = (function (key2, error) {
                  console.error("Error decoding audio: " + key2 + " - ", error ? error.message : "");
                  remaining--;
                  if (remaining === 0) {
                    this.emit(Events.DECODED_ALL);
                  }
                }).bind(this, key);
                this.context.decodeAudioData(data, success, failure);
              }
            },
            unlock: function () {
              var _this = this;
              var body = document.body;
              var unlockHandler = function unlockHandler2() {
                if (_this.context && body) {
                  var bodyRemove = body.removeEventListener;
                  _this.context.resume().then(function () {
                    bodyRemove("touchstart", unlockHandler2);
                    bodyRemove("touchend", unlockHandler2);
                    bodyRemove("click", unlockHandler2);
                    bodyRemove("keydown", unlockHandler2);
                    _this.unlocked = true;
                  }, function () {
                    bodyRemove("touchstart", unlockHandler2);
                    bodyRemove("touchend", unlockHandler2);
                    bodyRemove("click", unlockHandler2);
                    bodyRemove("keydown", unlockHandler2);
                  });
                }
              };
              if (body) {
                body.addEventListener("touchstart", unlockHandler, false);
                body.addEventListener("touchend", unlockHandler, false);
                body.addEventListener("click", unlockHandler, false);
                body.addEventListener("keydown", unlockHandler, false);
              }
            },
            onBlur: function () {
              if (!this.locked) {
                this.context.suspend();
              }
            },
            onFocus: function () {
              var context = this.context;
              if ((context.state === "suspended" || context.state === "interrupted") && !this.locked) {
                context.resume();
              }
            },
            update: function (time, delta) {
              BaseSoundManager.prototype.update.call(this, time, delta);
              var context = this.context;
              if (context && context.state === "interrupted") {
                context.resume();
              }
            },
            destroy: function () {
              this.destination = null;
              this.masterVolumeNode.disconnect();
              this.masterVolumeNode = null;
              this.masterMuteNode.disconnect();
              this.masterMuteNode = null;
              if (this.game.config.audio.context) {
                this.context.suspend();
              } else {
                var _this = this;
                this.context.close().then(function () {
                  _this.context = null;
                });
              }
              BaseSoundManager.prototype.destroy.call(this);
            },
            setMute: function (value) {
              this.mute = value;
              return this;
            },
            mute: {
              get: function () {
                return this.masterMuteNode.gain.value === 0;
              },
              set: function (value) {
                this.masterMuteNode.gain.setValueAtTime(value ? 0 : 1, 0);
                this.emit(Events.GLOBAL_MUTE, this, value);
              }
            },
            setVolume: function (value) {
              this.volume = value;
              return this;
            },
            volume: {
              get: function () {
                return this.masterVolumeNode.gain.value;
              },
              set: function (value) {
                this.masterVolumeNode.gain.setValueAtTime(value, 0);
                this.emit(Events.GLOBAL_VOLUME, this, value);
              }
            }
          });
          module2.exports = WebAudioSoundManager;
        }, function (module2, exports2) {
          var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          var lookup = new Uint8Array(256);
          for (var i = 0; i < chars.length; i++) {
            lookup[chars.charCodeAt(i)] = i;
          }
          var Base64ToArrayBuffer = function (base64) {
            base64 = base64.substr(base64.indexOf(",") + 1);
            var len = base64.length;
            var bufferLength = len * 0.75;
            var p3 = 0;
            var encoded1;
            var encoded2;
            var encoded3;
            var encoded4;
            if (base64[len - 1] === "=") {
              bufferLength--;
              if (base64[len - 2] === "=") {
                bufferLength--;
              }
            }
            var arrayBuffer = new ArrayBuffer(bufferLength);
            var bytes = new Uint8Array(arrayBuffer);
            for (var i2 = 0; i2 < len; i2 += 4) {
              encoded1 = lookup[base64.charCodeAt(i2)];
              encoded2 = lookup[base64.charCodeAt(i2 + 1)];
              encoded3 = lookup[base64.charCodeAt(i2 + 2)];
              encoded4 = lookup[base64.charCodeAt(i2 + 3)];
              bytes[p3++] = encoded1 << 2 | encoded2 >> 4;
              bytes[p3++] = (encoded2 & 15) << 4 | encoded3 >> 2;
              bytes[p3++] = (encoded3 & 3) << 6 | encoded4 & 63;
            }
            return arrayBuffer;
          };
          module2.exports = Base64ToArrayBuffer;
        }, function (module2, exports2, __webpack_require__) {
          var BaseSound = __webpack_require__(146);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(70);
          var WebAudioSound = new Class({
            Extends: BaseSound,
            initialize: function WebAudioSound2(manager, key, config) {
              if (config === void 0) {
                config = {};
              }
              this.audioBuffer = manager.game.cache.audio.get(key);
              if (!this.audioBuffer) {
                throw new Error('Audio key "' + key + '" missing from cache');
              }
              this.source = null;
              this.loopSource = null;
              this.muteNode = manager.context.createGain();
              this.volumeNode = manager.context.createGain();
              this.pannerNode = null;
              this.playTime = 0;
              this.startTime = 0;
              this.loopTime = 0;
              this.rateUpdates = [];
              this.hasEnded = false;
              this.hasLooped = false;
              this.muteNode.connect(this.volumeNode);
              if (manager.context.createStereoPanner) {
                this.pannerNode = manager.context.createStereoPanner();
                this.volumeNode.connect(this.pannerNode);
                this.pannerNode.connect(manager.destination);
              } else {
                this.volumeNode.connect(manager.destination);
              }
              this.duration = this.audioBuffer.duration;
              this.totalDuration = this.audioBuffer.duration;
              BaseSound.call(this, manager, key, config);
            },
            play: function (markerName, config) {
              if (!BaseSound.prototype.play.call(this, markerName, config)) {
                return false;
              }
              this.stopAndRemoveBufferSource();
              this.createAndStartBufferSource();
              this.emit(Events.PLAY, this);
              return true;
            },
            pause: function () {
              if (this.manager.context.currentTime < this.startTime) {
                return false;
              }
              if (!BaseSound.prototype.pause.call(this)) {
                return false;
              }
              this.currentConfig.seek = this.getCurrentTime();
              this.stopAndRemoveBufferSource();
              this.emit(Events.PAUSE, this);
              return true;
            },
            resume: function () {
              if (this.manager.context.currentTime < this.startTime) {
                return false;
              }
              if (!BaseSound.prototype.resume.call(this)) {
                return false;
              }
              this.createAndStartBufferSource();
              this.emit(Events.RESUME, this);
              return true;
            },
            stop: function () {
              if (!BaseSound.prototype.stop.call(this)) {
                return false;
              }
              this.stopAndRemoveBufferSource();
              this.emit(Events.STOP, this);
              return true;
            },
            createAndStartBufferSource: function () {
              var seek = this.currentConfig.seek;
              var delay = this.currentConfig.delay;
              var when = this.manager.context.currentTime + delay;
              var offset = (this.currentMarker ? this.currentMarker.start : 0) + seek;
              var duration = this.duration - seek;
              this.playTime = when - seek;
              this.startTime = when;
              this.source = this.createBufferSource();
              this.applyConfig();
              this.source.start(Math.max(0, when), Math.max(0, offset), Math.max(0, duration));
              this.resetConfig();
            },
            createAndStartLoopBufferSource: function () {
              var when = this.getLoopTime();
              var offset = this.currentMarker ? this.currentMarker.start : 0;
              var duration = this.duration;
              this.loopTime = when;
              this.loopSource = this.createBufferSource();
              this.loopSource.playbackRate.setValueAtTime(this.totalRate, 0);
              this.loopSource.start(Math.max(0, when), Math.max(0, offset), Math.max(0, duration));
            },
            createBufferSource: function () {
              var _this = this;
              var source = this.manager.context.createBufferSource();
              source.buffer = this.audioBuffer;
              source.connect(this.muteNode);
              source.onended = function (ev) {
                if (ev.target === _this.source) {
                  if (_this.currentConfig.loop) {
                    _this.hasLooped = true;
                  } else {
                    _this.hasEnded = true;
                  }
                }
              };
              return source;
            },
            stopAndRemoveBufferSource: function () {
              if (this.source) {
                this.source.stop();
                this.source.disconnect();
                this.source = null;
              }
              this.playTime = 0;
              this.startTime = 0;
              this.stopAndRemoveLoopBufferSource();
            },
            stopAndRemoveLoopBufferSource: function () {
              if (this.loopSource) {
                this.loopSource.stop();
                this.loopSource.disconnect();
                this.loopSource = null;
              }
              this.loopTime = 0;
            },
            applyConfig: function () {
              this.rateUpdates.length = 0;
              this.rateUpdates.push({
                time: 0,
                rate: 1
              });
              BaseSound.prototype.applyConfig.call(this);
            },
            update: function () {
              if (this.hasEnded) {
                this.hasEnded = false;
                BaseSound.prototype.stop.call(this);
                this.stopAndRemoveBufferSource();
                this.emit(Events.COMPLETE, this);
              } else if (this.hasLooped) {
                this.hasLooped = false;
                this.source = this.loopSource;
                this.loopSource = null;
                this.playTime = this.startTime = this.loopTime;
                this.rateUpdates.length = 0;
                this.rateUpdates.push({
                  time: 0,
                  rate: this.totalRate
                });
                this.createAndStartLoopBufferSource();
                this.emit(Events.LOOPED, this);
              }
            },
            destroy: function () {
              BaseSound.prototype.destroy.call(this);
              this.audioBuffer = null;
              this.stopAndRemoveBufferSource();
              this.muteNode.disconnect();
              this.muteNode = null;
              this.volumeNode.disconnect();
              this.volumeNode = null;
              if (this.pannerNode) {
                this.pannerNode.disconnect();
                this.pannerNode = null;
              }
              this.rateUpdates.length = 0;
              this.rateUpdates = null;
            },
            calculateRate: function () {
              BaseSound.prototype.calculateRate.call(this);
              var now = this.manager.context.currentTime;
              if (this.source && typeof this.totalRate === "number") {
                this.source.playbackRate.setValueAtTime(this.totalRate, now);
              }
              if (this.isPlaying) {
                this.rateUpdates.push({
                  time: Math.max(this.startTime, now) - this.playTime,
                  rate: this.totalRate
                });
                if (this.loopSource) {
                  this.stopAndRemoveLoopBufferSource();
                  this.createAndStartLoopBufferSource();
                }
              }
            },
            getCurrentTime: function () {
              var currentTime = 0;
              for (var i = 0; i < this.rateUpdates.length; i++) {
                var nextTime = 0;
                if (i < this.rateUpdates.length - 1) {
                  nextTime = this.rateUpdates[i + 1].time;
                } else {
                  nextTime = this.manager.context.currentTime - this.playTime;
                }
                currentTime += (nextTime - this.rateUpdates[i].time) * this.rateUpdates[i].rate;
              }
              return currentTime;
            },
            getLoopTime: function () {
              var lastRateUpdateCurrentTime = 0;
              for (var i = 0; i < this.rateUpdates.length - 1; i++) {
                lastRateUpdateCurrentTime += (this.rateUpdates[i + 1].time - this.rateUpdates[i].time) * this.rateUpdates[i].rate;
              }
              var lastRateUpdate = this.rateUpdates[this.rateUpdates.length - 1];
              return this.playTime + lastRateUpdate.time + (this.duration - lastRateUpdateCurrentTime) / lastRateUpdate.rate;
            },
            rate: {
              get: function () {
                return this.currentConfig.rate;
              },
              set: function (value) {
                this.currentConfig.rate = value;
                this.calculateRate();
                this.emit(Events.RATE, this, value);
              }
            },
            setRate: function (value) {
              this.rate = value;
              return this;
            },
            detune: {
              get: function () {
                return this.currentConfig.detune;
              },
              set: function (value) {
                this.currentConfig.detune = value;
                this.calculateRate();
                this.emit(Events.DETUNE, this, value);
              }
            },
            setDetune: function (value) {
              this.detune = value;
              return this;
            },
            mute: {
              get: function () {
                return this.muteNode.gain.value === 0;
              },
              set: function (value) {
                this.currentConfig.mute = value;
                this.muteNode.gain.setValueAtTime(value ? 0 : 1, 0);
                this.emit(Events.MUTE, this, value);
              }
            },
            setMute: function (value) {
              this.mute = value;
              return this;
            },
            volume: {
              get: function () {
                return this.volumeNode.gain.value;
              },
              set: function (value) {
                this.currentConfig.volume = value;
                this.volumeNode.gain.setValueAtTime(value, 0);
                this.emit(Events.VOLUME, this, value);
              }
            },
            setVolume: function (value) {
              this.volume = value;
              return this;
            },
            seek: {
              get: function () {
                if (this.isPlaying) {
                  if (this.manager.context.currentTime < this.startTime) {
                    return this.startTime - this.playTime;
                  }
                  return this.getCurrentTime();
                } else if (this.isPaused) {
                  return this.currentConfig.seek;
                } else {
                  return 0;
                }
              },
              set: function (value) {
                if (this.manager.context.currentTime < this.startTime) {
                  return;
                }
                if (this.isPlaying || this.isPaused) {
                  value = Math.min(Math.max(0, value), this.duration);
                  this.currentConfig.seek = value;
                  if (this.isPlaying) {
                    this.stopAndRemoveBufferSource();
                    this.createAndStartBufferSource();
                  }
                  this.emit(Events.SEEK, this, value);
                }
              }
            },
            setSeek: function (value) {
              this.seek = value;
              return this;
            },
            loop: {
              get: function () {
                return this.currentConfig.loop;
              },
              set: function (value) {
                this.currentConfig.loop = value;
                if (this.isPlaying) {
                  this.stopAndRemoveLoopBufferSource();
                  if (value) {
                    this.createAndStartLoopBufferSource();
                  }
                }
                this.emit(Events.LOOP, this, value);
              }
            },
            setLoop: function (value) {
              this.loop = value;
              return this;
            },
            pan: {
              get: function () {
                if (this.pannerNode) {
                  return this.pannerNode.pan.value;
                } else {
                  return 0;
                }
              },
              set: function (value) {
                this.currentConfig.pan = value;
                if (this.pannerNode) {
                  this.pannerNode.pan.setValueAtTime(value, this.manager.context.currentTime);
                }
                this.emit(Events.PAN, this, value);
              }
            },
            setPan: function (value) {
              this.pan = value;
              return this;
            }
          });
          module2.exports = WebAudioSound;
        }, function (module2, exports2) {
          var TransposeMatrix = function (array) {
            var sourceRowCount = array.length;
            var sourceColCount = array[0].length;
            var result = new Array(sourceColCount);
            for (var i = 0; i < sourceColCount; i++) {
              result[i] = new Array(sourceRowCount);
              for (var j = sourceRowCount - 1; j > -1; j--) {
                result[i][j] = array[j][i];
              }
            }
            return result;
          };
          module2.exports = TransposeMatrix;
        }, function (module2, exports2) {
          function swap(arr, i, j) {
            var tmp = arr[i];
            arr[i] = arr[j];
            arr[j] = tmp;
          }
          function defaultCompare(a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
          }
          var QuickSelect = function (arr, k, left, right, compare) {
            if (left === void 0) {
              left = 0;
            }
            if (right === void 0) {
              right = arr.length - 1;
            }
            if (compare === void 0) {
              compare = defaultCompare;
            }
            while (right > left) {
              if (right - left > 600) {
                var n = right - left + 1;
                var m = k - left + 1;
                var z = Math.log(n);
                var s = 0.5 * Math.exp(2 * z / 3);
                var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
                var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
                var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
                QuickSelect(arr, k, newLeft, newRight, compare);
              }
              var t = arr[k];
              var i = left;
              var j = right;
              swap(arr, left, k);
              if (compare(arr[right], t) > 0) {
                swap(arr, left, right);
              }
              while (i < j) {
                swap(arr, i, j);
                i++;
                j--;
                while (compare(arr[i], t) < 0) {
                  i++;
                }
                while (compare(arr[j], t) > 0) {
                  j--;
                }
              }
              if (compare(arr[left], t) === 0) {
                swap(arr, left, j);
              } else {
                j++;
                swap(arr, j, right);
              }
              if (j <= k) {
                left = j + 1;
              }
              if (k <= j) {
                right = j - 1;
              }
            }
          };
          module2.exports = QuickSelect;
        }, function (module2, exports2, __webpack_require__) {
          var GetValue = __webpack_require__(6);
          var Shuffle = __webpack_require__(131);
          var BuildChunk = function (a, b, qty) {
            var out = [];
            for (var aIndex = 0; aIndex < a.length; aIndex++) {
              for (var bIndex = 0; bIndex < b.length; bIndex++) {
                for (var i = 0; i < qty; i++) {
                  out.push({
                    a: a[aIndex],
                    b: b[bIndex]
                  });
                }
              }
            }
            return out;
          };
          var Range = function (a, b, options) {
            var max = GetValue(options, "max", 0);
            var qty = GetValue(options, "qty", 1);
            var random = GetValue(options, "random", false);
            var randomB = GetValue(options, "randomB", false);
            var repeat = GetValue(options, "repeat", 0);
            var yoyo = GetValue(options, "yoyo", false);
            var out = [];
            if (randomB) {
              Shuffle(b);
            }
            if (repeat === -1) {
              if (max === 0) {
                repeat = 0;
              } else {
                var total = a.length * b.length * qty;
                if (yoyo) {
                  total *= 2;
                }
                repeat = Math.ceil(max / total);
              }
            }
            for (var i = 0; i <= repeat; i++) {
              var chunk = BuildChunk(a, b, qty);
              if (random) {
                Shuffle(chunk);
              }
              out = out.concat(chunk);
              if (yoyo) {
                chunk.reverse();
                out = out.concat(chunk);
              }
            }
            if (max) {
              out.splice(max);
            }
            return out;
          };
          module2.exports = Range;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            PROCESS_QUEUE_ADD: __webpack_require__(1041),
            PROCESS_QUEUE_REMOVE: __webpack_require__(1042)
          };
        }, function (module2, exports2, __webpack_require__) {
          var GetAdvancedValue = __webpack_require__(13);
          var BuildGameObjectAnimation = function (sprite, config) {
            var animConfig = GetAdvancedValue(config, "anims", null);
            if (animConfig === null) {
              return sprite;
            }
            if (typeof animConfig === "string") {
              sprite.anims.play(animConfig);
            } else if (typeof animConfig === "object") {
              var anims = sprite.anims;
              var key = GetAdvancedValue(animConfig, "key", void 0);
              if (key) {
                var startFrame = GetAdvancedValue(animConfig, "startFrame", void 0);
                var delay = GetAdvancedValue(animConfig, "delay", 0);
                var repeat = GetAdvancedValue(animConfig, "repeat", 0);
                var repeatDelay = GetAdvancedValue(animConfig, "repeatDelay", 0);
                var yoyo = GetAdvancedValue(animConfig, "yoyo", false);
                var play = GetAdvancedValue(animConfig, "play", false);
                var delayedPlay = GetAdvancedValue(animConfig, "delayedPlay", 0);
                var playConfig = {
                  key,
                  delay,
                  repeat,
                  repeatDelay,
                  yoyo,
                  startFrame
                };
                if (play) {
                  anims.play(playConfig);
                } else if (delayedPlay > 0) {
                  anims.playAfterDelay(playConfig, delayedPlay);
                } else {
                  anims.load(playConfig);
                }
              }
            }
            return sprite;
          };
          module2.exports = BuildGameObjectAnimation;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Frame = __webpack_require__(109);
          var Bob = new Class({
            initialize: function Bob2(blitter, x, y, frame, visible) {
              this.parent = blitter;
              this.x = x;
              this.y = y;
              this.frame = frame;
              this.data = {};
              this.tint = 16777215;
              this._visible = visible;
              this._alpha = 1;
              this.flipX = false;
              this.flipY = false;
            },
            setFrame: function (frame) {
              if (frame === void 0) {
                this.frame = this.parent.frame;
              } else if (frame instanceof Frame && frame.texture === this.parent.texture) {
                this.frame = frame;
              } else {
                this.frame = this.parent.texture.get(frame);
              }
              return this;
            },
            resetFlip: function () {
              this.flipX = false;
              this.flipY = false;
              return this;
            },
            reset: function (x, y, frame) {
              this.x = x;
              this.y = y;
              this.flipX = false;
              this.flipY = false;
              this._alpha = 1;
              this._visible = true;
              this.parent.dirty = true;
              if (frame) {
                this.setFrame(frame);
              }
              return this;
            },
            setPosition: function (x, y) {
              this.x = x;
              this.y = y;
              return this;
            },
            setFlipX: function (value) {
              this.flipX = value;
              return this;
            },
            setFlipY: function (value) {
              this.flipY = value;
              return this;
            },
            setFlip: function (x, y) {
              this.flipX = x;
              this.flipY = y;
              return this;
            },
            setVisible: function (value) {
              this.visible = value;
              return this;
            },
            setAlpha: function (value) {
              this.alpha = value;
              return this;
            },
            setTint: function (value) {
              this.tint = value;
              return this;
            },
            destroy: function () {
              this.parent.dirty = true;
              this.parent.children.remove(this);
              this.parent = void 0;
              this.frame = void 0;
              this.data = void 0;
            },
            visible: {
              get: function () {
                return this._visible;
              },
              set: function (value) {
                this.parent.dirty |= this._visible !== value;
                this._visible = value;
              }
            },
            alpha: {
              get: function () {
                return this._alpha;
              },
              set: function (value) {
                this.parent.dirty |= this._alpha > 0 !== value > 0;
                this._alpha = value;
              }
            }
          });
          module2.exports = Bob;
        }, function (module2, exports2, __webpack_require__) {
          var Rectangle = __webpack_require__(10);
          var Union = function (rectA, rectB, out) {
            if (out === void 0) {
              out = new Rectangle();
            }
            var x = Math.min(rectA.x, rectB.x);
            var y = Math.min(rectA.y, rectB.y);
            var w = Math.max(rectA.right, rectB.right) - x;
            var h = Math.max(rectA.bottom, rectB.bottom) - y;
            return out.setTo(x, y, w, h);
          };
          module2.exports = Union;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var DOMElementRender = __webpack_require__(1055);
          var GameObject = __webpack_require__(15);
          var IsPlainObject = __webpack_require__(7);
          var RemoveFromDOM = __webpack_require__(202);
          var SCENE_EVENTS = __webpack_require__(20);
          var Vector4 = __webpack_require__(140);
          var DOMElement = new Class({
            Extends: GameObject,
            Mixins: [Components.AlphaSingle, Components.BlendMode, Components.Depth, Components.Origin, Components.ScrollFactor, Components.Transform, Components.Visible, DOMElementRender],
            initialize: function DOMElement2(scene, x, y, element, style, innerText) {
              GameObject.call(this, scene, "DOMElement");
              this.parent = scene.sys.game.domContainer;
              this.cache = scene.sys.cache.html;
              this.node;
              this.transformOnly = false;
              this.skewX = 0;
              this.skewY = 0;
              this.rotate3d = new Vector4();
              this.rotate3dAngle = "deg";
              this.pointerEvents = "auto";
              this.width = 0;
              this.height = 0;
              this.displayWidth = 0;
              this.displayHeight = 0;
              this.handler = this.dispatchNativeEvent.bind(this);
              this.setPosition(x, y);
              if (typeof element === "string") {
                if (element[0] === "#") {
                  this.setElement(element.substr(1), style, innerText);
                } else {
                  this.createElement(element, style, innerText);
                }
              } else if (element) {
                this.setElement(element, style, innerText);
              }
              scene.sys.events.on(SCENE_EVENTS.SLEEP, this.handleSceneEvent, this);
              scene.sys.events.on(SCENE_EVENTS.WAKE, this.handleSceneEvent, this);
            },
            addedToScene: function () {
              this.scene.sys.updateList.add(this);
            },
            removedFromScene: function () {
              this.scene.sys.updateList.remove(this);
            },
            handleSceneEvent: function (sys) {
              var node = this.node;
              var style = node.style;
              if (node) {
                style.display = sys.settings.visible ? "block" : "none";
              }
            },
            setSkew: function (x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = x;
              }
              this.skewX = x;
              this.skewY = y;
              return this;
            },
            setPerspective: function (value) {
              this.parent.style.perspective = value + "px";
              return this;
            },
            perspective: {
              get: function () {
                return parseFloat(this.parent.style.perspective);
              },
              set: function (value) {
                this.parent.style.perspective = value + "px";
              }
            },
            addListener: function (events) {
              if (this.node) {
                events = events.split(" ");
                for (var i = 0; i < events.length; i++) {
                  this.node.addEventListener(events[i], this.handler, false);
                }
              }
              return this;
            },
            removeListener: function (events) {
              if (this.node) {
                events = events.split(" ");
                for (var i = 0; i < events.length; i++) {
                  this.node.removeEventListener(events[i], this.handler);
                }
              }
              return this;
            },
            dispatchNativeEvent: function (event) {
              this.emit(event.type, event);
            },
            createElement: function (tagName, style, innerText) {
              return this.setElement(document.createElement(tagName), style, innerText);
            },
            setElement: function (element, style, innerText) {
              this.removeElement();
              var target;
              if (typeof element === "string") {
                if (element[0] === "#") {
                  element = element.substr(1);
                }
                target = document.getElementById(element);
              } else if (typeof element === "object" && element.nodeType === 1) {
                target = element;
              }
              if (!target) {
                return this;
              }
              this.node = target;
              if (style && IsPlainObject(style)) {
                for (var key in style) {
                  target.style[key] = style[key];
                }
              } else if (typeof style === "string") {
                target.style = style;
              }
              target.style.zIndex = "0";
              target.style.display = "inline";
              target.style.position = "absolute";
              target.phaser = this;
              if (this.parent) {
                this.parent.appendChild(target);
              }
              if (innerText) {
                target.innerText = innerText;
              }
              return this.updateSize();
            },
            createFromCache: function (key, tagName) {
              var html = this.cache.get(key);
              if (html) {
                this.createFromHTML(html, tagName);
              }
              return this;
            },
            createFromHTML: function (html, tagName) {
              if (tagName === void 0) {
                tagName = "div";
              }
              this.removeElement();
              var element = document.createElement(tagName);
              this.node = element;
              element.style.zIndex = "0";
              element.style.display = "inline";
              element.style.position = "absolute";
              element.phaser = this;
              if (this.parent) {
                this.parent.appendChild(element);
              }
              element.innerHTML = html;
              return this.updateSize();
            },
            removeElement: function () {
              if (this.node) {
                RemoveFromDOM(this.node);
                this.node = null;
              }
              return this;
            },
            updateSize: function () {
              var node = this.node;
              var nodeBounds = node.getBoundingClientRect();
              this.width = node.clientWidth;
              this.height = node.clientHeight;
              this.displayWidth = nodeBounds.width || 0;
              this.displayHeight = nodeBounds.height || 0;
              return this;
            },
            getChildByProperty: function (property, value) {
              if (this.node) {
                var children = this.node.querySelectorAll("*");
                for (var i = 0; i < children.length; i++) {
                  if (children[i][property] === value) {
                    return children[i];
                  }
                }
              }
              return null;
            },
            getChildByID: function (id) {
              return this.getChildByProperty("id", id);
            },
            getChildByName: function (name) {
              return this.getChildByProperty("name", name);
            },
            setClassName: function (className) {
              if (this.node) {
                this.node.className = className;
                this.updateSize();
              }
              return this;
            },
            setText: function (text) {
              if (this.node) {
                this.node.innerText = text;
                this.updateSize();
              }
              return this;
            },
            setHTML: function (html) {
              if (this.node) {
                this.node.innerHTML = html;
                this.updateSize();
              }
              return this;
            },
            preUpdate: function () {
              var parent = this.parentContainer;
              var node = this.node;
              if (node && parent && !parent.willRender()) {
                node.style.display = "none";
              }
            },
            willRender: function () {
              return true;
            },
            preDestroy: function () {
              this.removeElement();
              this.scene.sys.events.off(SCENE_EVENTS.SLEEP, this.handleSceneEvent, this);
              this.scene.sys.events.off(SCENE_EVENTS.WAKE, this.handleSceneEvent, this);
            }
          });
          module2.exports = DOMElement;
        }, function (module2, exports2, __webpack_require__) {
          var CSSBlendModes = __webpack_require__(1056);
          var GameObject = __webpack_require__(15);
          var TransformMatrix = __webpack_require__(25);
          var tempMatrix1 = new TransformMatrix();
          var tempMatrix2 = new TransformMatrix();
          var tempMatrix3 = new TransformMatrix();
          var DOMElementCSSRenderer = function (renderer, src, camera, parentMatrix) {
            if (!src.node) {
              return;
            }
            var style = src.node.style;
            var settings = src.scene.sys.settings;
            if (!style || !settings.visible || GameObject.RENDER_MASK !== src.renderFlags || src.cameraFilter !== 0 && src.cameraFilter & camera.id || src.parentContainer && !src.parentContainer.willRender()) {
              style.display = "none";
              return;
            }
            var parent = src.parentContainer;
            var alpha = camera.alpha * src.alpha;
            if (parent) {
              alpha *= parent.alpha;
            }
            var camMatrix = tempMatrix1;
            var srcMatrix = tempMatrix2;
            var calcMatrix = tempMatrix3;
            var dx = 0;
            var dy = 0;
            var tx = "0%";
            var ty = "0%";
            if (parentMatrix) {
              dx = src.width * src.scaleX * src.originX;
              dy = src.height * src.scaleY * src.originY;
              srcMatrix.applyITRS(src.x - dx, src.y - dy, src.rotation, src.scaleX, src.scaleY);
              camMatrix.copyFrom(camera.matrix);
              camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);
              srcMatrix.e = src.x - dx;
              srcMatrix.f = src.y - dy;
              camMatrix.multiply(srcMatrix, calcMatrix);
            } else {
              dx = src.width * src.originX;
              dy = src.height * src.originY;
              srcMatrix.applyITRS(src.x - dx, src.y - dy, src.rotation, src.scaleX, src.scaleY);
              camMatrix.copyFrom(camera.matrix);
              tx = 100 * src.originX + "%";
              ty = 100 * src.originY + "%";
              srcMatrix.e -= camera.scrollX * src.scrollFactorX;
              srcMatrix.f -= camera.scrollY * src.scrollFactorY;
              camMatrix.multiply(srcMatrix, calcMatrix);
            }
            if (!src.transformOnly) {
              style.display = "block";
              style.opacity = alpha;
              style.zIndex = src._depth;
              style.pointerEvents = src.pointerEvents;
              style.mixBlendMode = CSSBlendModes[src._blendMode];
            }
            style.transform = calcMatrix.getCSSMatrix() + " skew(" + src.skewX + "rad, " + src.skewY + "rad) rotate3d(" + src.rotate3d.x + "," + src.rotate3d.y + "," + src.rotate3d.z + "," + src.rotate3d.w + src.rotate3dAngle + ")";
            style.transformOrigin = tx + " " + ty;
          };
          module2.exports = DOMElementCSSRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var ExternRender = __webpack_require__(1060);
          var Extern = new Class({
            Extends: GameObject,
            Mixins: [Components.Alpha, Components.BlendMode, Components.Depth, Components.Flip, Components.Origin, Components.ScrollFactor, Components.Size, Components.Texture, Components.Tint, Components.Transform, Components.Visible, ExternRender],
            initialize: function Extern2(scene) {
              GameObject.call(this, scene, "Extern");
            },
            addedToScene: function () {
              this.scene.sys.updateList.add(this);
            },
            removedFromScene: function () {
              this.scene.sys.updateList.remove(this);
            },
            preUpdate: function () {},
            render: function () {}
          });
          module2.exports = Extern;
        }, function (module2, exports2, __webpack_require__) {
          var CircumferencePoint = __webpack_require__(218);
          var FromPercent = __webpack_require__(98);
          var MATH_CONST = __webpack_require__(14);
          var Point = __webpack_require__(4);
          var GetPoint = function (ellipse, position, out) {
            if (out === void 0) {
              out = new Point();
            }
            var angle = FromPercent(position, 0, MATH_CONST.PI2);
            return CircumferencePoint(ellipse, angle, out);
          };
          module2.exports = GetPoint;
        }, function (module2, exports2, __webpack_require__) {
          var Circumference = __webpack_require__(447);
          var CircumferencePoint = __webpack_require__(218);
          var FromPercent = __webpack_require__(98);
          var MATH_CONST = __webpack_require__(14);
          var GetPoints = function (ellipse, quantity, stepRate, out) {
            if (out === void 0) {
              out = [];
            }
            if (!quantity && stepRate > 0) {
              quantity = Circumference(ellipse) / stepRate;
            }
            for (var i = 0; i < quantity; i++) {
              var angle = FromPercent(i / quantity, 0, MATH_CONST.PI2);
              out.push(CircumferencePoint(ellipse, angle));
            }
            return out;
          };
          module2.exports = GetPoints;
        }, function (module2, exports2) {
          var Circumference = function (ellipse) {
            var rx = ellipse.width / 2;
            var ry = ellipse.height / 2;
            var h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);
            return Math.PI * (rx + ry) * (1 + 3 * h / (10 + Math.sqrt(4 - 3 * h)));
          };
          module2.exports = Circumference;
        }, function (module2, exports2, __webpack_require__) {
          var Commands = __webpack_require__(217);
          var SetTransform = __webpack_require__(30);
          var GraphicsCanvasRenderer = function (renderer, src, camera, parentMatrix, renderTargetCtx, allowClip) {
            var commandBuffer = src.commandBuffer;
            var commandBufferLength = commandBuffer.length;
            var ctx = renderTargetCtx || renderer.currentContext;
            if (commandBufferLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              return;
            }
            camera.addToRenderList(src);
            var lineAlpha = 1;
            var fillAlpha = 1;
            var lineColor = 0;
            var fillColor = 0;
            var lineWidth = 1;
            var red = 0;
            var green = 0;
            var blue = 0;
            ctx.beginPath();
            for (var index = 0; index < commandBufferLength; ++index) {
              var commandID = commandBuffer[index];
              switch (commandID) {
                case Commands.ARC:
                  ctx.arc(commandBuffer[index + 1], commandBuffer[index + 2], commandBuffer[index + 3], commandBuffer[index + 4], commandBuffer[index + 5], commandBuffer[index + 6]);
                  index += 7;
                  break;
                case Commands.LINE_STYLE:
                  lineWidth = commandBuffer[index + 1];
                  lineColor = commandBuffer[index + 2];
                  lineAlpha = commandBuffer[index + 3];
                  red = (lineColor & 16711680) >>> 16;
                  green = (lineColor & 65280) >>> 8;
                  blue = lineColor & 255;
                  ctx.strokeStyle = "rgba(" + red + "," + green + "," + blue + "," + lineAlpha + ")";
                  ctx.lineWidth = lineWidth;
                  index += 3;
                  break;
                case Commands.FILL_STYLE:
                  fillColor = commandBuffer[index + 1];
                  fillAlpha = commandBuffer[index + 2];
                  red = (fillColor & 16711680) >>> 16;
                  green = (fillColor & 65280) >>> 8;
                  blue = fillColor & 255;
                  ctx.fillStyle = "rgba(" + red + "," + green + "," + blue + "," + fillAlpha + ")";
                  index += 2;
                  break;
                case Commands.BEGIN_PATH:
                  ctx.beginPath();
                  break;
                case Commands.CLOSE_PATH:
                  ctx.closePath();
                  break;
                case Commands.FILL_PATH:
                  if (!allowClip) {
                    ctx.fill();
                  }
                  break;
                case Commands.STROKE_PATH:
                  if (!allowClip) {
                    ctx.stroke();
                  }
                  break;
                case Commands.FILL_RECT:
                  if (!allowClip) {
                    ctx.fillRect(commandBuffer[index + 1], commandBuffer[index + 2], commandBuffer[index + 3], commandBuffer[index + 4]);
                  } else {
                    ctx.rect(commandBuffer[index + 1], commandBuffer[index + 2], commandBuffer[index + 3], commandBuffer[index + 4]);
                  }
                  index += 4;
                  break;
                case Commands.FILL_TRIANGLE:
                  ctx.beginPath();
                  ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                  ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
                  ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
                  ctx.closePath();
                  if (!allowClip) {
                    ctx.fill();
                  }
                  index += 6;
                  break;
                case Commands.STROKE_TRIANGLE:
                  ctx.beginPath();
                  ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                  ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
                  ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
                  ctx.closePath();
                  if (!allowClip) {
                    ctx.stroke();
                  }
                  index += 6;
                  break;
                case Commands.LINE_TO:
                  ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                  index += 2;
                  break;
                case Commands.MOVE_TO:
                  ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                  index += 2;
                  break;
                case Commands.LINE_FX_TO:
                  ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                  index += 5;
                  break;
                case Commands.MOVE_FX_TO:
                  ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                  index += 5;
                  break;
                case Commands.SAVE:
                  ctx.save();
                  break;
                case Commands.RESTORE:
                  ctx.restore();
                  break;
                case Commands.TRANSLATE:
                  ctx.translate(commandBuffer[index + 1], commandBuffer[index + 2]);
                  index += 2;
                  break;
                case Commands.SCALE:
                  ctx.scale(commandBuffer[index + 1], commandBuffer[index + 2]);
                  index += 2;
                  break;
                case Commands.ROTATE:
                  ctx.rotate(commandBuffer[index + 1]);
                  index += 1;
                  break;
                case Commands.GRADIENT_FILL_STYLE:
                  index += 5;
                  break;
                case Commands.GRADIENT_LINE_STYLE:
                  index += 6;
                  break;
              }
            }
            ctx.restore();
          };
          module2.exports = GraphicsCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var FloatBetween = __webpack_require__(137);
          var GetEaseFunction = __webpack_require__(80);
          var GetFastValue = __webpack_require__(2);
          var Wrap = __webpack_require__(68);
          var EmitterOp = new Class({
            initialize: function EmitterOp2(config, key, defaultValue, emitOnly) {
              if (emitOnly === void 0) {
                emitOnly = false;
              }
              this.propertyKey = key;
              this.propertyValue = defaultValue;
              this.defaultValue = defaultValue;
              this.steps = 0;
              this.counter = 0;
              this.start = 0;
              this.end = 0;
              this.ease;
              this.emitOnly = emitOnly;
              this.onEmit = this.defaultEmit;
              this.onUpdate = this.defaultUpdate;
              this.loadConfig(config);
            },
            loadConfig: function (config, newKey) {
              if (config === void 0) {
                config = {};
              }
              if (newKey) {
                this.propertyKey = newKey;
              }
              this.propertyValue = GetFastValue(config, this.propertyKey, this.defaultValue);
              this.setMethods();
              if (this.emitOnly) {
                this.onUpdate = this.defaultUpdate;
              }
            },
            toJSON: function () {
              return this.propertyValue;
            },
            onChange: function (value) {
              this.propertyValue = value;
              return this.setMethods();
            },
            setMethods: function () {
              var value = this.propertyValue;
              var t = typeof value;
              this.onEmit = this.defaultEmit;
              this.onUpdate = this.defaultUpdate;
              if (t === "number") {
                this.onEmit = this.staticValueEmit;
                this.onUpdate = this.staticValueUpdate;
              } else if (Array.isArray(value)) {
                this.onEmit = this.randomStaticValueEmit;
              } else if (t === "function") {
                if (this.emitOnly) {
                  this.onEmit = value;
                } else {
                  this.onUpdate = value;
                }
              } else if (t === "object" && this.hasBoth(value, "start", "end")) {
                this.start = value.start;
                this.end = value.end;
                var isRandom = this.has(value, "random");
                if (isRandom) {
                  this.onEmit = this.randomRangedValueEmit;
                }
                if (this.has(value, "steps")) {
                  this.steps = value.steps;
                  this.counter = this.start;
                  this.onEmit = this.steppedEmit;
                } else {
                  var easeType = this.has(value, "ease") ? value.ease : "Linear";
                  this.ease = GetEaseFunction(easeType, value.easeParams);
                  if (!isRandom) {
                    this.onEmit = this.easedValueEmit;
                  }
                  this.onUpdate = this.easeValueUpdate;
                }
              } else if (t === "object" && this.hasBoth(value, "min", "max")) {
                this.start = value.min;
                this.end = value.max;
                this.onEmit = this.randomRangedValueEmit;
              } else if (t === "object" && this.has(value, "random")) {
                var rnd = value.random;
                if (Array.isArray(rnd)) {
                  this.start = rnd[0];
                  this.end = rnd[1];
                }
                this.onEmit = this.randomRangedValueEmit;
              } else if (t === "object" && this.hasEither(value, "onEmit", "onUpdate")) {
                if (this.has(value, "onEmit")) {
                  this.onEmit = value.onEmit;
                }
                if (this.has(value, "onUpdate")) {
                  this.onUpdate = value.onUpdate;
                }
              }
              return this;
            },
            has: function (object, key) {
              return object.hasOwnProperty(key);
            },
            hasBoth: function (object, key1, key2) {
              return object.hasOwnProperty(key1) && object.hasOwnProperty(key2);
            },
            hasEither: function (object, key1, key2) {
              return object.hasOwnProperty(key1) || object.hasOwnProperty(key2);
            },
            defaultEmit: function (particle, key, value) {
              return value;
            },
            defaultUpdate: function (particle, key, t, value) {
              return value;
            },
            staticValueEmit: function () {
              return this.propertyValue;
            },
            staticValueUpdate: function () {
              return this.propertyValue;
            },
            randomStaticValueEmit: function () {
              var randomIndex = Math.floor(Math.random() * this.propertyValue.length);
              return this.propertyValue[randomIndex];
            },
            randomRangedValueEmit: function (particle, key) {
              var value = FloatBetween(this.start, this.end);
              if (particle && particle.data[key]) {
                particle.data[key].min = value;
              }
              return value;
            },
            steppedEmit: function () {
              var current = this.counter;
              var next = this.counter + (this.end - this.start) / this.steps;
              this.counter = Wrap(next, this.start, this.end);
              return current;
            },
            easedValueEmit: function (particle, key) {
              if (particle && particle.data[key]) {
                var data = particle.data[key];
                data.min = this.start;
                data.max = this.end;
              }
              return this.start;
            },
            easeValueUpdate: function (particle, key, t) {
              var data = particle.data[key];
              return (data.max - data.min) * this.ease(t) + data.min;
            }
          });
          module2.exports = EmitterOp;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var GravityWell = new Class({
            initialize: function GravityWell2(x, y, power, epsilon, gravity) {
              if (typeof x === "object") {
                var config = x;
                x = GetFastValue(config, "x", 0);
                y = GetFastValue(config, "y", 0);
                power = GetFastValue(config, "power", 0);
                epsilon = GetFastValue(config, "epsilon", 100);
                gravity = GetFastValue(config, "gravity", 50);
              } else {
                if (x === void 0) {
                  x = 0;
                }
                if (y === void 0) {
                  y = 0;
                }
                if (power === void 0) {
                  power = 0;
                }
                if (epsilon === void 0) {
                  epsilon = 100;
                }
                if (gravity === void 0) {
                  gravity = 50;
                }
              }
              this.x = x;
              this.y = y;
              this.active = true;
              this._gravity = gravity;
              this._power = 0;
              this._epsilon = 0;
              this.power = power;
              this.epsilon = epsilon;
            },
            update: function (particle, delta) {
              var x = this.x - particle.x;
              var y = this.y - particle.y;
              var dSq = x * x + y * y;
              if (dSq === 0) {
                return;
              }
              var d = Math.sqrt(dSq);
              if (dSq < this._epsilon) {
                dSq = this._epsilon;
              }
              var factor = this._power * delta / (dSq * d) * 100;
              particle.velocityX += x * factor;
              particle.velocityY += y * factor;
            },
            epsilon: {
              get: function () {
                return Math.sqrt(this._epsilon);
              },
              set: function (value) {
                this._epsilon = value * value;
              }
            },
            power: {
              get: function () {
                return this._power / this._gravity;
              },
              set: function (value) {
                this._power = value * this._gravity;
              }
            },
            gravity: {
              get: function () {
                return this._gravity;
              },
              set: function (value) {
                var pwr = this.power;
                this._gravity = value;
                this.power = pwr;
              }
            }
          });
          module2.exports = GravityWell;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var DegToRad = __webpack_require__(36);
          var DistanceBetween = __webpack_require__(50);
          var Particle = new Class({
            initialize: function Particle2(emitter) {
              this.emitter = emitter;
              this.frame = null;
              this.x = 0;
              this.y = 0;
              this.velocityX = 0;
              this.velocityY = 0;
              this.accelerationX = 0;
              this.accelerationY = 0;
              this.maxVelocityX = 1e4;
              this.maxVelocityY = 1e4;
              this.bounce = 0;
              this.scaleX = 1;
              this.scaleY = 1;
              this.alpha = 1;
              this.angle = 0;
              this.rotation = 0;
              this.tint = 16777215;
              this.life = 1e3;
              this.lifeCurrent = 1e3;
              this.delayCurrent = 0;
              this.lifeT = 0;
              this.data = {
                tint: {
                  min: 16777215,
                  max: 16777215,
                  current: 16777215
                },
                alpha: {
                  min: 1,
                  max: 1
                },
                rotate: {
                  min: 0,
                  max: 0
                },
                scaleX: {
                  min: 1,
                  max: 1
                },
                scaleY: {
                  min: 1,
                  max: 1
                }
              };
            },
            isAlive: function () {
              return this.lifeCurrent > 0;
            },
            resetPosition: function () {
              this.x = 0;
              this.y = 0;
            },
            fire: function (x, y) {
              var emitter = this.emitter;
              this.frame = emitter.getFrame();
              if (emitter.emitZone) {
                emitter.emitZone.getPoint(this);
              }
              if (x === void 0) {
                this.x += emitter.x.onEmit(this, "x");
              } else {
                this.x += x;
              }
              if (y === void 0) {
                this.y += emitter.y.onEmit(this, "y");
              } else {
                this.y += y;
              }
              this.life = emitter.lifespan.onEmit(this, "lifespan");
              this.lifeCurrent = this.life;
              this.lifeT = 0;
              var sx = emitter.speedX.onEmit(this, "speedX");
              var sy = emitter.speedY ? emitter.speedY.onEmit(this, "speedY") : sx;
              if (emitter.radial) {
                var rad = DegToRad(emitter.angle.onEmit(this, "angle"));
                this.velocityX = Math.cos(rad) * Math.abs(sx);
                this.velocityY = Math.sin(rad) * Math.abs(sy);
              } else if (emitter.moveTo) {
                var mx = emitter.moveToX.onEmit(this, "moveToX");
                var my = emitter.moveToY ? emitter.moveToY.onEmit(this, "moveToY") : mx;
                var angle = Math.atan2(my - this.y, mx - this.x);
                var speed = DistanceBetween(this.x, this.y, mx, my) / (this.life / 1e3);
                this.velocityX = Math.cos(angle) * speed;
                this.velocityY = Math.sin(angle) * speed;
              } else {
                this.velocityX = sx;
                this.velocityY = sy;
              }
              if (emitter.acceleration) {
                this.accelerationX = emitter.accelerationX.onEmit(this, "accelerationX");
                this.accelerationY = emitter.accelerationY.onEmit(this, "accelerationY");
              }
              this.maxVelocityX = emitter.maxVelocityX.onEmit(this, "maxVelocityX");
              this.maxVelocityY = emitter.maxVelocityY.onEmit(this, "maxVelocityY");
              this.delayCurrent = emitter.delay.onEmit(this, "delay");
              this.scaleX = emitter.scaleX.onEmit(this, "scaleX");
              this.scaleY = emitter.scaleY ? emitter.scaleY.onEmit(this, "scaleY") : this.scaleX;
              this.angle = emitter.rotate.onEmit(this, "rotate");
              this.rotation = DegToRad(this.angle);
              this.bounce = emitter.bounce.onEmit(this, "bounce");
              this.alpha = emitter.alpha.onEmit(this, "alpha");
              this.tint = emitter.tint.onEmit(this, "tint");
            },
            computeVelocity: function (emitter, delta, step, processors) {
              var vx = this.velocityX;
              var vy = this.velocityY;
              var ax = this.accelerationX;
              var ay = this.accelerationY;
              var mx = this.maxVelocityX;
              var my = this.maxVelocityY;
              vx += emitter.gravityX * step;
              vy += emitter.gravityY * step;
              if (ax) {
                vx += ax * step;
              }
              if (ay) {
                vy += ay * step;
              }
              if (vx > mx) {
                vx = mx;
              } else if (vx < -mx) {
                vx = -mx;
              }
              if (vy > my) {
                vy = my;
              } else if (vy < -my) {
                vy = -my;
              }
              this.velocityX = vx;
              this.velocityY = vy;
              for (var i = 0; i < processors.length; i++) {
                processors[i].update(this, delta, step);
              }
            },
            checkBounds: function (emitter) {
              var bounds = emitter.bounds;
              var bounce = -this.bounce;
              if (this.x < bounds.x && emitter.collideLeft) {
                this.x = bounds.x;
                this.velocityX *= bounce;
              } else if (this.x > bounds.right && emitter.collideRight) {
                this.x = bounds.right;
                this.velocityX *= bounce;
              }
              if (this.y < bounds.y && emitter.collideTop) {
                this.y = bounds.y;
                this.velocityY *= bounce;
              } else if (this.y > bounds.bottom && emitter.collideBottom) {
                this.y = bounds.bottom;
                this.velocityY *= bounce;
              }
            },
            update: function (delta, step, processors) {
              if (this.delayCurrent > 0) {
                this.delayCurrent -= delta;
                return false;
              }
              var emitter = this.emitter;
              var t = 1 - this.lifeCurrent / this.life;
              this.lifeT = t;
              this.computeVelocity(emitter, delta, step, processors);
              this.x += this.velocityX * step;
              this.y += this.velocityY * step;
              if (emitter.bounds) {
                this.checkBounds(emitter);
              }
              if (emitter.deathZone && emitter.deathZone.willKill(this)) {
                this.lifeCurrent = 0;
                return true;
              }
              this.scaleX = emitter.scaleX.onUpdate(this, "scaleX", t, this.scaleX);
              if (emitter.scaleY) {
                this.scaleY = emitter.scaleY.onUpdate(this, "scaleY", t, this.scaleY);
              } else {
                this.scaleY = this.scaleX;
              }
              this.angle = emitter.rotate.onUpdate(this, "rotate", t, this.angle);
              this.rotation = DegToRad(this.angle);
              this.alpha = emitter.alpha.onUpdate(this, "alpha", t, this.alpha);
              this.tint = emitter.tint.onUpdate(this, "tint", t, this.tint);
              this.lifeCurrent -= delta;
              return this.lifeCurrent <= 0;
            }
          });
          module2.exports = Particle;
        }, function (module2, exports2, __webpack_require__) {
          var BlendModes = __webpack_require__(35);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var DeathZone = __webpack_require__(453);
          var EdgeZone = __webpack_require__(454);
          var EmitterOp = __webpack_require__(449);
          var GetFastValue = __webpack_require__(2);
          var GetRandom = __webpack_require__(210);
          var HasAny = __webpack_require__(455);
          var HasValue = __webpack_require__(126);
          var Particle = __webpack_require__(451);
          var RandomZone = __webpack_require__(456);
          var Rectangle = __webpack_require__(10);
          var StableSort = __webpack_require__(79);
          var Vector2 = __webpack_require__(3);
          var Wrap = __webpack_require__(68);
          var ParticleEmitter = new Class({
            Mixins: [Components.BlendMode, Components.Mask, Components.ScrollFactor, Components.Visible],
            initialize: function ParticleEmitter2(manager, config) {
              this.manager = manager;
              this.texture = manager.texture;
              this.frames = [manager.defaultFrame];
              this.defaultFrame = manager.defaultFrame;
              this.configFastMap = ["active", "blendMode", "collideBottom", "collideLeft", "collideRight", "collideTop", "deathCallback", "deathCallbackScope", "emitCallback", "emitCallbackScope", "follow", "frequency", "gravityX", "gravityY", "maxParticles", "name", "on", "particleBringToTop", "particleClass", "radial", "timeScale", "trackVisible", "visible"];
              this.configOpMap = ["accelerationX", "accelerationY", "angle", "alpha", "bounce", "delay", "lifespan", "maxVelocityX", "maxVelocityY", "moveToX", "moveToY", "quantity", "rotate", "scaleX", "scaleY", "speedX", "speedY", "tint", "x", "y"];
              this.name = "";
              this.particleClass = Particle;
              this.x = new EmitterOp(config, "x", 0, true);
              this.y = new EmitterOp(config, "y", 0, true);
              this.radial = true;
              this.gravityX = 0;
              this.gravityY = 0;
              this.acceleration = false;
              this.accelerationX = new EmitterOp(config, "accelerationX", 0, true);
              this.accelerationY = new EmitterOp(config, "accelerationY", 0, true);
              this.maxVelocityX = new EmitterOp(config, "maxVelocityX", 1e4, true);
              this.maxVelocityY = new EmitterOp(config, "maxVelocityY", 1e4, true);
              this.speedX = new EmitterOp(config, "speedX", 0, true);
              this.speedY = new EmitterOp(config, "speedY", 0, true);
              this.moveTo = false;
              this.moveToX = new EmitterOp(config, "moveToX", 0, true);
              this.moveToY = new EmitterOp(config, "moveToY", 0, true);
              this.bounce = new EmitterOp(config, "bounce", 0, true);
              this.scaleX = new EmitterOp(config, "scaleX", 1);
              this.scaleY = new EmitterOp(config, "scaleY", 1);
              this.tint = new EmitterOp(config, "tint", 16777215);
              this.alpha = new EmitterOp(config, "alpha", 1);
              this.lifespan = new EmitterOp(config, "lifespan", 1e3, true);
              this.angle = new EmitterOp(config, "angle", {
                min: 0,
                max: 360
              }, true);
              this.rotate = new EmitterOp(config, "rotate", 0);
              this.emitCallback = null;
              this.emitCallbackScope = null;
              this.deathCallback = null;
              this.deathCallbackScope = null;
              this.maxParticles = 0;
              this.quantity = new EmitterOp(config, "quantity", 1, true);
              this.delay = new EmitterOp(config, "delay", 0, true);
              this.frequency = 0;
              this.on = true;
              this.particleBringToTop = true;
              this.timeScale = 1;
              this.emitZone = null;
              this.deathZone = null;
              this.bounds = null;
              this.collideLeft = true;
              this.collideRight = true;
              this.collideTop = true;
              this.collideBottom = true;
              this.active = true;
              this.visible = true;
              this.blendMode = BlendModes.NORMAL;
              this.follow = null;
              this.followOffset = new Vector2();
              this.trackVisible = false;
              this.currentFrame = 0;
              this.randomFrame = true;
              this.frameQuantity = 1;
              this.dead = [];
              this.alive = [];
              this._counter = 0;
              this._frameCounter = 0;
              if (config) {
                this.fromJSON(config);
              }
            },
            fromJSON: function (config) {
              if (!config) {
                return this;
              }
              var i = 0;
              var key = "";
              for (i = 0; i < this.configFastMap.length; i++) {
                key = this.configFastMap[i];
                if (HasValue(config, key)) {
                  this[key] = GetFastValue(config, key);
                }
              }
              for (i = 0; i < this.configOpMap.length; i++) {
                key = this.configOpMap[i];
                if (HasValue(config, key)) {
                  this[key].loadConfig(config);
                }
              }
              this.acceleration = this.accelerationX.propertyValue !== 0 || this.accelerationY.propertyValue !== 0;
              this.moveTo = this.moveToX.propertyValue !== 0 || this.moveToY.propertyValue !== 0;
              if (HasValue(config, "speed")) {
                this.speedX.loadConfig(config, "speed");
                this.speedY = null;
              }
              if (HasAny(config, ["speedX", "speedY"]) || this.moveTo) {
                this.radial = false;
              }
              if (HasValue(config, "scale")) {
                this.scaleX.loadConfig(config, "scale");
                this.scaleY = null;
              }
              if (HasValue(config, "callbackScope")) {
                var callbackScope = GetFastValue(config, "callbackScope", null);
                this.emitCallbackScope = callbackScope;
                this.deathCallbackScope = callbackScope;
              }
              if (HasValue(config, "emitZone")) {
                this.setEmitZone(config.emitZone);
              }
              if (HasValue(config, "deathZone")) {
                this.setDeathZone(config.deathZone);
              }
              if (HasValue(config, "bounds")) {
                this.setBounds(config.bounds);
              }
              if (HasValue(config, "followOffset")) {
                this.followOffset.setFromObject(GetFastValue(config, "followOffset", 0));
              }
              if (HasValue(config, "frame")) {
                this.setFrame(config.frame);
              }
              if (HasValue(config, "reserve")) {
                this.reserve(config.reserve);
              }
              return this;
            },
            toJSON: function (output) {
              if (output === void 0) {
                output = {};
              }
              var i = 0;
              var key = "";
              for (i = 0; i < this.configFastMap.length; i++) {
                key = this.configFastMap[i];
                output[key] = this[key];
              }
              for (i = 0; i < this.configOpMap.length; i++) {
                key = this.configOpMap[i];
                if (this[key]) {
                  output[key] = this[key].toJSON();
                }
              }
              if (!this.speedY) {
                delete output.speedX;
                output.speed = this.speedX.toJSON();
              }
              if (!this.scaleY) {
                delete output.scaleX;
                output.scale = this.scaleX.toJSON();
              }
              return output;
            },
            startFollow: function (target, offsetX, offsetY, trackVisible) {
              if (offsetX === void 0) {
                offsetX = 0;
              }
              if (offsetY === void 0) {
                offsetY = 0;
              }
              if (trackVisible === void 0) {
                trackVisible = false;
              }
              this.follow = target;
              this.followOffset.set(offsetX, offsetY);
              this.trackVisible = trackVisible;
              return this;
            },
            stopFollow: function () {
              this.follow = null;
              this.followOffset.set(0, 0);
              this.trackVisible = false;
              return this;
            },
            getFrame: function () {
              if (this.frames.length === 1) {
                return this.defaultFrame;
              } else if (this.randomFrame) {
                return GetRandom(this.frames);
              } else {
                var frame = this.frames[this.currentFrame];
                this._frameCounter++;
                if (this._frameCounter === this.frameQuantity) {
                  this._frameCounter = 0;
                  this.currentFrame = Wrap(this.currentFrame + 1, 0, this._frameLength);
                }
                return frame;
              }
            },
            setFrame: function (frames, pickRandom, quantity) {
              if (pickRandom === void 0) {
                pickRandom = true;
              }
              if (quantity === void 0) {
                quantity = 1;
              }
              this.randomFrame = pickRandom;
              this.frameQuantity = quantity;
              this.currentFrame = 0;
              this._frameCounter = 0;
              var t = typeof frames;
              if (Array.isArray(frames) || t === "string" || t === "number") {
                this.manager.setEmitterFrames(frames, this);
              } else if (t === "object") {
                var frameConfig = frames;
                frames = GetFastValue(frameConfig, "frames", null);
                if (frames) {
                  this.manager.setEmitterFrames(frames, this);
                }
                var isCycle = GetFastValue(frameConfig, "cycle", false);
                this.randomFrame = isCycle ? false : true;
                this.frameQuantity = GetFastValue(frameConfig, "quantity", quantity);
              }
              this._frameLength = this.frames.length;
              if (this._frameLength === 1) {
                this.frameQuantity = 1;
                this.randomFrame = false;
              }
              return this;
            },
            setRadial: function (value) {
              if (value === void 0) {
                value = true;
              }
              this.radial = value;
              return this;
            },
            setPosition: function (x, y) {
              this.x.onChange(x);
              this.y.onChange(y);
              return this;
            },
            setBounds: function (x, y, width, height) {
              if (typeof x === "object") {
                var obj = x;
                x = obj.x;
                y = obj.y;
                width = HasValue(obj, "w") ? obj.w : obj.width;
                height = HasValue(obj, "h") ? obj.h : obj.height;
              }
              if (this.bounds) {
                this.bounds.setTo(x, y, width, height);
              } else {
                this.bounds = new Rectangle(x, y, width, height);
              }
              return this;
            },
            setSpeedX: function (value) {
              this.speedX.onChange(value);
              this.radial = false;
              return this;
            },
            setSpeedY: function (value) {
              if (this.speedY) {
                this.speedY.onChange(value);
                this.radial = false;
              }
              return this;
            },
            setSpeed: function (value) {
              this.speedX.onChange(value);
              this.speedY = null;
              this.radial = true;
              return this;
            },
            setScaleX: function (value) {
              this.scaleX.onChange(value);
              return this;
            },
            setScaleY: function (value) {
              this.scaleY.onChange(value);
              return this;
            },
            setScale: function (value) {
              this.scaleX.onChange(value);
              this.scaleY = null;
              return this;
            },
            setGravityX: function (value) {
              this.gravityX = value;
              return this;
            },
            setGravityY: function (value) {
              this.gravityY = value;
              return this;
            },
            setGravity: function (x, y) {
              this.gravityX = x;
              this.gravityY = y;
              return this;
            },
            setAlpha: function (value) {
              this.alpha.onChange(value);
              return this;
            },
            setTint: function (value) {
              this.tint.onChange(value);
              return this;
            },
            setEmitterAngle: function (value) {
              this.angle.onChange(value);
              return this;
            },
            setAngle: function (value) {
              this.angle.onChange(value);
              return this;
            },
            setLifespan: function (value) {
              this.lifespan.onChange(value);
              return this;
            },
            setQuantity: function (quantity) {
              this.quantity.onChange(quantity);
              return this;
            },
            setFrequency: function (frequency, quantity) {
              this.frequency = frequency;
              this._counter = 0;
              if (quantity) {
                this.quantity.onChange(quantity);
              }
              return this;
            },
            setEmitZone: function (zoneConfig) {
              if (zoneConfig === void 0) {
                this.emitZone = null;
              } else {
                var type = GetFastValue(zoneConfig, "type", "random");
                var source = GetFastValue(zoneConfig, "source", null);
                switch (type) {
                  case "random":
                    this.emitZone = new RandomZone(source);
                    break;
                  case "edge":
                    var quantity = GetFastValue(zoneConfig, "quantity", 1);
                    var stepRate = GetFastValue(zoneConfig, "stepRate", 0);
                    var yoyo = GetFastValue(zoneConfig, "yoyo", false);
                    var seamless = GetFastValue(zoneConfig, "seamless", true);
                    this.emitZone = new EdgeZone(source, quantity, stepRate, yoyo, seamless);
                    break;
                }
              }
              return this;
            },
            setDeathZone: function (zoneConfig) {
              if (zoneConfig === void 0) {
                this.deathZone = null;
              } else {
                var type = GetFastValue(zoneConfig, "type", "onEnter");
                var source = GetFastValue(zoneConfig, "source", null);
                if (source && typeof source.contains === "function") {
                  var killOnEnter = type === "onEnter" ? true : false;
                  this.deathZone = new DeathZone(source, killOnEnter);
                }
              }
              return this;
            },
            reserve: function (particleCount) {
              var dead = this.dead;
              for (var i = 0; i < particleCount; i++) {
                dead.push(new this.particleClass(this));
              }
              return this;
            },
            getAliveParticleCount: function () {
              return this.alive.length;
            },
            getDeadParticleCount: function () {
              return this.dead.length;
            },
            getParticleCount: function () {
              return this.getAliveParticleCount() + this.getDeadParticleCount();
            },
            atLimit: function () {
              return this.maxParticles > 0 && this.getParticleCount() === this.maxParticles;
            },
            onParticleEmit: function (callback, context) {
              if (callback === void 0) {
                this.emitCallback = null;
                this.emitCallbackScope = null;
              } else if (typeof callback === "function") {
                this.emitCallback = callback;
                if (context) {
                  this.emitCallbackScope = context;
                }
              }
              return this;
            },
            onParticleDeath: function (callback, context) {
              if (callback === void 0) {
                this.deathCallback = null;
                this.deathCallbackScope = null;
              } else if (typeof callback === "function") {
                this.deathCallback = callback;
                if (context) {
                  this.deathCallbackScope = context;
                }
              }
              return this;
            },
            killAll: function () {
              var dead = this.dead;
              var alive = this.alive;
              while (alive.length > 0) {
                dead.push(alive.pop());
              }
              return this;
            },
            forEachAlive: function (callback, context) {
              var alive = this.alive;
              var length = alive.length;
              for (var index = 0; index < length; ++index) {
                callback.call(context, alive[index], this);
              }
              return this;
            },
            forEachDead: function (callback, context) {
              var dead = this.dead;
              var length = dead.length;
              for (var index = 0; index < length; ++index) {
                callback.call(context, dead[index], this);
              }
              return this;
            },
            start: function () {
              this.on = true;
              this._counter = 0;
              return this;
            },
            stop: function () {
              this.on = false;
              return this;
            },
            pause: function () {
              this.active = false;
              return this;
            },
            resume: function () {
              this.active = true;
              return this;
            },
            remove: function () {
              this.manager.removeEmitter(this);
              return this;
            },
            depthSort: function () {
              StableSort(this.alive, this.depthSortCallback);
              return this;
            },
            flow: function (frequency, count) {
              if (count === void 0) {
                count = 1;
              }
              this.frequency = frequency;
              this.quantity.onChange(count);
              return this.start();
            },
            explode: function (count, x, y) {
              this.frequency = -1;
              return this.emitParticle(count, x, y);
            },
            emitParticleAt: function (x, y, count) {
              return this.emitParticle(count, x, y);
            },
            emitParticle: function (count, x, y) {
              if (this.atLimit()) {
                return;
              }
              if (count === void 0) {
                count = this.quantity.onEmit();
              }
              var dead = this.dead;
              var followX = this.follow ? this.follow.x + this.followOffset.x : x;
              var followY = this.follow ? this.follow.y + this.followOffset.y : y;
              for (var i = 0; i < count; i++) {
                var particle = dead.pop();
                if (!particle) {
                  particle = new this.particleClass(this);
                }
                particle.fire(followX, followY);
                if (this.particleBringToTop) {
                  this.alive.push(particle);
                } else {
                  this.alive.unshift(particle);
                }
                if (this.emitCallback) {
                  this.emitCallback.call(this.emitCallbackScope, particle, this);
                }
                if (this.atLimit()) {
                  break;
                }
              }
              return particle;
            },
            preUpdate: function (time, delta) {
              delta *= this.timeScale;
              var step = delta / 1e3;
              if (this.trackVisible) {
                this.visible = this.follow.visible;
              }
              var processors = this.manager.getProcessors();
              var particles = this.alive;
              var dead = this.dead;
              var i = 0;
              var rip = [];
              var length = particles.length;
              for (i = 0; i < length; i++) {
                var particle = particles[i];
                if (particle.update(delta, step, processors)) {
                  rip.push({
                    index: i,
                    particle
                  });
                }
              }
              length = rip.length;
              if (length > 0) {
                var deathCallback = this.deathCallback;
                var deathCallbackScope = this.deathCallbackScope;
                for (i = length - 1; i >= 0; i--) {
                  var entry = rip[i];
                  particles.splice(entry.index, 1);
                  dead.push(entry.particle);
                  if (deathCallback) {
                    deathCallback.call(deathCallbackScope, entry.particle);
                  }
                  entry.particle.resetPosition();
                }
              }
              if (!this.on) {
                return;
              }
              if (this.frequency === 0) {
                this.emitParticle();
              } else if (this.frequency > 0) {
                this._counter -= delta;
                if (this._counter <= 0) {
                  this.emitParticle();
                  this._counter = this.frequency - Math.abs(this._counter);
                }
              }
            },
            depthSortCallback: function (a, b) {
              return a.y - b.y;
            }
          });
          module2.exports = ParticleEmitter;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var DeathZone = new Class({
            initialize: function DeathZone2(source, killOnEnter) {
              this.source = source;
              this.killOnEnter = killOnEnter;
            },
            willKill: function (particle) {
              var withinZone = this.source.contains(particle.x, particle.y);
              return withinZone && this.killOnEnter || !withinZone && !this.killOnEnter;
            }
          });
          module2.exports = DeathZone;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var EdgeZone = new Class({
            initialize: function EdgeZone2(source, quantity, stepRate, yoyo, seamless) {
              if (yoyo === void 0) {
                yoyo = false;
              }
              if (seamless === void 0) {
                seamless = true;
              }
              this.source = source;
              this.points = [];
              this.quantity = quantity;
              this.stepRate = stepRate;
              this.yoyo = yoyo;
              this.counter = -1;
              this.seamless = seamless;
              this._length = 0;
              this._direction = 0;
              this.updateSource();
            },
            updateSource: function () {
              this.points = this.source.getPoints(this.quantity, this.stepRate);
              if (this.seamless) {
                var a = this.points[0];
                var b = this.points[this.points.length - 1];
                if (a.x === b.x && a.y === b.y) {
                  this.points.pop();
                }
              }
              var oldLength = this._length;
              this._length = this.points.length;
              if (this._length < oldLength && this.counter > this._length) {
                this.counter = this._length - 1;
              }
              return this;
            },
            changeSource: function (source) {
              this.source = source;
              return this.updateSource();
            },
            getPoint: function (particle) {
              if (this._direction === 0) {
                this.counter++;
                if (this.counter >= this._length) {
                  if (this.yoyo) {
                    this._direction = 1;
                    this.counter = this._length - 1;
                  } else {
                    this.counter = 0;
                  }
                }
              } else {
                this.counter--;
                if (this.counter === -1) {
                  if (this.yoyo) {
                    this._direction = 0;
                    this.counter = 0;
                  } else {
                    this.counter = this._length - 1;
                  }
                }
              }
              var point = this.points[this.counter];
              if (point) {
                particle.x = point.x;
                particle.y = point.y;
              }
            }
          });
          module2.exports = EdgeZone;
        }, function (module2, exports2) {
          var HasAny = function (source, keys) {
            for (var i = 0; i < keys.length; i++) {
              if (source.hasOwnProperty(keys[i])) {
                return true;
              }
            }
            return false;
          };
          module2.exports = HasAny;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Vector2 = __webpack_require__(3);
          var RandomZone = new Class({
            initialize: function RandomZone2(source) {
              this.source = source;
              this._tempVec = new Vector2();
            },
            getPoint: function (particle) {
              var vec = this._tempVec;
              this.source.getRandomPoint(vec);
              particle.x = vec.x;
              particle.y = vec.y;
            }
          });
          module2.exports = RandomZone;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var Sprite = __webpack_require__(73);
          var PathFollower = new Class({
            Extends: Sprite,
            Mixins: [Components.PathFollower],
            initialize: function PathFollower2(scene, path, x, y, texture, frame) {
              Sprite.call(this, scene, x, y, texture, frame);
              this.path = path;
            },
            preUpdate: function (time, delta) {
              this.anims.update(time, delta);
              this.pathUpdate(time);
            }
          });
          module2.exports = PathFollower;
        }, function (module2, exports2) {
          var GetTextSize = function (text, size, lines) {
            var canvas = text.canvas;
            var context = text.context;
            var style = text.style;
            var lineWidths = [];
            var maxLineWidth = 0;
            var drawnLines = lines.length;
            if (style.maxLines > 0 && style.maxLines < lines.length) {
              drawnLines = style.maxLines;
            }
            style.syncFont(canvas, context);
            for (var i = 0; i < drawnLines; i++) {
              var lineWidth = style.strokeThickness;
              lineWidth += context.measureText(lines[i]).width;
              if (style.wordWrap) {
                lineWidth -= context.measureText(" ").width;
              }
              lineWidths[i] = Math.ceil(lineWidth);
              maxLineWidth = Math.max(maxLineWidth, lineWidths[i]);
            }
            var lineHeight = size.fontSize + style.strokeThickness;
            var height = lineHeight * drawnLines;
            var lineSpacing = text.lineSpacing;
            if (drawnLines > 1) {
              height += lineSpacing * (drawnLines - 1);
            }
            return {
              width: maxLineWidth,
              height,
              lines: drawnLines,
              lineWidths,
              lineSpacing,
              lineHeight
            };
          };
          module2.exports = GetTextSize;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GetAdvancedValue = __webpack_require__(13);
          var GetValue = __webpack_require__(6);
          var MeasureText = __webpack_require__(460);
          var propertyMap = {
            fontFamily: ["fontFamily", "Courier"],
            fontSize: ["fontSize", "16px"],
            fontStyle: ["fontStyle", ""],
            backgroundColor: ["backgroundColor", null],
            color: ["color", "#fff"],
            stroke: ["stroke", "#fff"],
            strokeThickness: ["strokeThickness", 0],
            shadowOffsetX: ["shadow.offsetX", 0],
            shadowOffsetY: ["shadow.offsetY", 0],
            shadowColor: ["shadow.color", "#000"],
            shadowBlur: ["shadow.blur", 0],
            shadowStroke: ["shadow.stroke", false],
            shadowFill: ["shadow.fill", false],
            align: ["align", "left"],
            maxLines: ["maxLines", 0],
            fixedWidth: ["fixedWidth", 0],
            fixedHeight: ["fixedHeight", 0],
            resolution: ["resolution", 0],
            rtl: ["rtl", false],
            testString: ["testString", "|M\xC3\u2030qgy"],
            baselineX: ["baselineX", 1.2],
            baselineY: ["baselineY", 1.4],
            wordWrapWidth: ["wordWrap.width", null],
            wordWrapCallback: ["wordWrap.callback", null],
            wordWrapCallbackScope: ["wordWrap.callbackScope", null],
            wordWrapUseAdvanced: ["wordWrap.useAdvancedWrap", false]
          };
          var TextStyle = new Class({
            initialize: function TextStyle2(text, style) {
              this.parent = text;
              this.fontFamily;
              this.fontSize;
              this.fontStyle;
              this.backgroundColor;
              this.color;
              this.stroke;
              this.strokeThickness;
              this.shadowOffsetX;
              this.shadowOffsetY;
              this.shadowColor;
              this.shadowBlur;
              this.shadowStroke;
              this.shadowFill;
              this.align;
              this.maxLines;
              this.fixedWidth;
              this.fixedHeight;
              this.resolution;
              this.rtl;
              this.testString;
              this.baselineX;
              this.baselineY;
              this.wordWrapWidth;
              this.wordWrapCallback;
              this.wordWrapCallbackScope;
              this.wordWrapUseAdvanced;
              this._font;
              this.setStyle(style, false, true);
              var metrics = GetValue(style, "metrics", false);
              if (metrics) {
                this.metrics = {
                  ascent: GetValue(metrics, "ascent", 0),
                  descent: GetValue(metrics, "descent", 0),
                  fontSize: GetValue(metrics, "fontSize", 0)
                };
              } else {
                this.metrics = MeasureText(this);
              }
            },
            setStyle: function (style, updateText, setDefaults) {
              if (updateText === void 0) {
                updateText = true;
              }
              if (setDefaults === void 0) {
                setDefaults = false;
              }
              if (style && style.hasOwnProperty("fontSize") && typeof style.fontSize === "number") {
                style.fontSize = style.fontSize.toString() + "px";
              }
              for (var key in propertyMap) {
                var value = setDefaults ? propertyMap[key][1] : this[key];
                if (key === "wordWrapCallback" || key === "wordWrapCallbackScope") {
                  this[key] = GetValue(style, propertyMap[key][0], value);
                } else {
                  this[key] = GetAdvancedValue(style, propertyMap[key][0], value);
                }
              }
              var font = GetValue(style, "font", null);
              if (font !== null) {
                this.setFont(font, false);
              }
              this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim();
              var fill = GetValue(style, "fill", null);
              if (fill !== null) {
                this.color = fill;
              }
              if (updateText) {
                return this.update(true);
              } else {
                return this.parent;
              }
            },
            syncFont: function (canvas, context) {
              context.font = this._font;
            },
            syncStyle: function (canvas, context) {
              context.textBaseline = "alphabetic";
              context.fillStyle = this.color;
              context.strokeStyle = this.stroke;
              context.lineWidth = this.strokeThickness;
              context.lineCap = "round";
              context.lineJoin = "round";
            },
            syncShadow: function (context, enabled) {
              if (enabled) {
                context.shadowOffsetX = this.shadowOffsetX;
                context.shadowOffsetY = this.shadowOffsetY;
                context.shadowColor = this.shadowColor;
                context.shadowBlur = this.shadowBlur;
              } else {
                context.shadowOffsetX = 0;
                context.shadowOffsetY = 0;
                context.shadowColor = 0;
                context.shadowBlur = 0;
              }
            },
            update: function (recalculateMetrics) {
              if (recalculateMetrics) {
                this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim();
                this.metrics = MeasureText(this);
              }
              return this.parent.updateText();
            },
            setFont: function (font, updateText) {
              if (updateText === void 0) {
                updateText = true;
              }
              var fontFamily = font;
              var fontSize = "";
              var fontStyle = "";
              if (typeof font !== "string") {
                fontFamily = GetValue(font, "fontFamily", "Courier");
                fontSize = GetValue(font, "fontSize", "16px");
                fontStyle = GetValue(font, "fontStyle", "");
              } else {
                var fontSplit = font.split(" ");
                var i = 0;
                fontStyle = fontSplit.length > 2 ? fontSplit[i++] : "";
                fontSize = fontSplit[i++] || "16px";
                fontFamily = fontSplit[i++] || "Courier";
              }
              if (fontFamily !== this.fontFamily || fontSize !== this.fontSize || fontStyle !== this.fontStyle) {
                this.fontFamily = fontFamily;
                this.fontSize = fontSize;
                this.fontStyle = fontStyle;
                if (updateText) {
                  this.update(true);
                }
              }
              return this.parent;
            },
            setFontFamily: function (family) {
              if (this.fontFamily !== family) {
                this.fontFamily = family;
                this.update(true);
              }
              return this.parent;
            },
            setFontStyle: function (style) {
              if (this.fontStyle !== style) {
                this.fontStyle = style;
                this.update(true);
              }
              return this.parent;
            },
            setFontSize: function (size) {
              if (typeof size === "number") {
                size = size.toString() + "px";
              }
              if (this.fontSize !== size) {
                this.fontSize = size;
                this.update(true);
              }
              return this.parent;
            },
            setTestString: function (string) {
              this.testString = string;
              return this.update(true);
            },
            setFixedSize: function (width, height) {
              this.fixedWidth = width;
              this.fixedHeight = height;
              if (width) {
                this.parent.width = width;
              }
              if (height) {
                this.parent.height = height;
              }
              return this.update(false);
            },
            setBackgroundColor: function (color) {
              this.backgroundColor = color;
              return this.update(false);
            },
            setFill: function (color) {
              this.color = color;
              return this.update(false);
            },
            setColor: function (color) {
              this.color = color;
              return this.update(false);
            },
            setResolution: function (value) {
              this.resolution = value;
              return this.update(false);
            },
            setStroke: function (color, thickness) {
              if (thickness === void 0) {
                thickness = this.strokeThickness;
              }
              if (color === void 0 && this.strokeThickness !== 0) {
                this.strokeThickness = 0;
                this.update(true);
              } else if (this.stroke !== color || this.strokeThickness !== thickness) {
                this.stroke = color;
                this.strokeThickness = thickness;
                this.update(true);
              }
              return this.parent;
            },
            setShadow: function (x, y, color, blur, shadowStroke, shadowFill) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (color === void 0) {
                color = "#000";
              }
              if (blur === void 0) {
                blur = 0;
              }
              if (shadowStroke === void 0) {
                shadowStroke = false;
              }
              if (shadowFill === void 0) {
                shadowFill = true;
              }
              this.shadowOffsetX = x;
              this.shadowOffsetY = y;
              this.shadowColor = color;
              this.shadowBlur = blur;
              this.shadowStroke = shadowStroke;
              this.shadowFill = shadowFill;
              return this.update(false);
            },
            setShadowOffset: function (x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = x;
              }
              this.shadowOffsetX = x;
              this.shadowOffsetY = y;
              return this.update(false);
            },
            setShadowColor: function (color) {
              if (color === void 0) {
                color = "#000";
              }
              this.shadowColor = color;
              return this.update(false);
            },
            setShadowBlur: function (blur) {
              if (blur === void 0) {
                blur = 0;
              }
              this.shadowBlur = blur;
              return this.update(false);
            },
            setShadowStroke: function (enabled) {
              this.shadowStroke = enabled;
              return this.update(false);
            },
            setShadowFill: function (enabled) {
              this.shadowFill = enabled;
              return this.update(false);
            },
            setWordWrapWidth: function (width, useAdvancedWrap) {
              if (useAdvancedWrap === void 0) {
                useAdvancedWrap = false;
              }
              this.wordWrapWidth = width;
              this.wordWrapUseAdvanced = useAdvancedWrap;
              return this.update(false);
            },
            setWordWrapCallback: function (callback, scope) {
              if (scope === void 0) {
                scope = null;
              }
              this.wordWrapCallback = callback;
              this.wordWrapCallbackScope = scope;
              return this.update(false);
            },
            setAlign: function (align) {
              if (align === void 0) {
                align = "left";
              }
              this.align = align;
              return this.update(false);
            },
            setMaxLines: function (max) {
              if (max === void 0) {
                max = 0;
              }
              this.maxLines = max;
              return this.update(false);
            },
            getTextMetrics: function () {
              var metrics = this.metrics;
              return {
                ascent: metrics.ascent,
                descent: metrics.descent,
                fontSize: metrics.fontSize
              };
            },
            toJSON: function () {
              var output = {};
              for (var key in propertyMap) {
                output[key] = this[key];
              }
              output.metrics = this.getTextMetrics();
              return output;
            },
            destroy: function () {
              this.parent = void 0;
            }
          });
          module2.exports = TextStyle;
        }, function (module2, exports2, __webpack_require__) {
          var CanvasPool = __webpack_require__(31);
          var MeasureText = function (textStyle) {
            var canvas = CanvasPool.create(this);
            var context = canvas.getContext("2d");
            textStyle.syncFont(canvas, context);
            var metrics = context.measureText(textStyle.testString);
            if (("actualBoundingBoxAscent" in metrics)) {
              var ascent = metrics.actualBoundingBoxAscent;
              var descent = metrics.actualBoundingBoxDescent;
              CanvasPool.remove(canvas);
              return {
                ascent,
                descent,
                fontSize: ascent + descent
              };
            }
            var width = Math.ceil(metrics.width * textStyle.baselineX);
            var baseline = width;
            var height = 2 * baseline;
            baseline = baseline * textStyle.baselineY | 0;
            canvas.width = width;
            canvas.height = height;
            context.fillStyle = "#f00";
            context.fillRect(0, 0, width, height);
            context.font = textStyle._font;
            context.textBaseline = "alphabetic";
            context.fillStyle = "#000";
            context.fillText(textStyle.testString, 0, baseline);
            var output = {
              ascent: 0,
              descent: 0,
              fontSize: 0
            };
            var imagedata = context.getImageData(0, 0, width, height);
            if (!imagedata) {
              output.ascent = baseline;
              output.descent = baseline + 6;
              output.fontSize = output.ascent + output.descent;
              CanvasPool.remove(canvas);
              return output;
            }
            var pixels = imagedata.data;
            var numPixels = pixels.length;
            var line = width * 4;
            var i;
            var j;
            var idx = 0;
            var stop = false;
            for (i = 0; i < baseline; i++) {
              for (j = 0; j < line; j += 4) {
                if (pixels[idx + j] !== 255) {
                  stop = true;
                  break;
                }
              }
              if (!stop) {
                idx += line;
              } else {
                break;
              }
            }
            output.ascent = baseline - i;
            idx = numPixels - line;
            stop = false;
            for (i = height; i > baseline; i--) {
              for (j = 0; j < line; j += 4) {
                if (pixels[idx + j] !== 255) {
                  stop = true;
                  break;
                }
              }
              if (!stop) {
                idx -= line;
              } else {
                break;
              }
            }
            output.descent = i - baseline;
            output.fontSize = output.ascent + output.descent;
            CanvasPool.remove(canvas);
            return output;
          };
          module2.exports = MeasureText;
        }, function (module2, exports2, __webpack_require__) {
          var ArcRender = __webpack_require__(1097);
          var Class = __webpack_require__(0);
          var DegToRad = __webpack_require__(36);
          var Earcut = __webpack_require__(59);
          var GeomCircle = __webpack_require__(65);
          var MATH_CONST = __webpack_require__(14);
          var Shape = __webpack_require__(34);
          var Arc = new Class({
            Extends: Shape,
            Mixins: [ArcRender],
            initialize: function Arc2(scene, x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (radius === void 0) {
                radius = 128;
              }
              if (startAngle === void 0) {
                startAngle = 0;
              }
              if (endAngle === void 0) {
                endAngle = 360;
              }
              if (anticlockwise === void 0) {
                anticlockwise = false;
              }
              Shape.call(this, scene, "Arc", new GeomCircle(0, 0, radius));
              this._startAngle = startAngle;
              this._endAngle = endAngle;
              this._anticlockwise = anticlockwise;
              this._iterations = 0.01;
              this.setPosition(x, y);
              var diameter = this.geom.radius * 2;
              this.setSize(diameter, diameter);
              if (fillColor !== void 0) {
                this.setFillStyle(fillColor, fillAlpha);
              }
              this.updateDisplayOrigin();
              this.updateData();
            },
            iterations: {
              get: function () {
                return this._iterations;
              },
              set: function (value) {
                this._iterations = value;
                this.updateData();
              }
            },
            radius: {
              get: function () {
                return this.geom.radius;
              },
              set: function (value) {
                this.geom.radius = value;
                var diameter = value * 2;
                this.setSize(diameter, diameter);
                this.updateDisplayOrigin();
                this.updateData();
              }
            },
            startAngle: {
              get: function () {
                return this._startAngle;
              },
              set: function (value) {
                this._startAngle = value;
                this.updateData();
              }
            },
            endAngle: {
              get: function () {
                return this._endAngle;
              },
              set: function (value) {
                this._endAngle = value;
                this.updateData();
              }
            },
            anticlockwise: {
              get: function () {
                return this._anticlockwise;
              },
              set: function (value) {
                this._anticlockwise = value;
                this.updateData();
              }
            },
            setRadius: function (value) {
              this.radius = value;
              return this;
            },
            setIterations: function (value) {
              if (value === void 0) {
                value = 0.01;
              }
              this.iterations = value;
              return this;
            },
            setStartAngle: function (angle, anticlockwise) {
              this._startAngle = angle;
              if (anticlockwise !== void 0) {
                this._anticlockwise = anticlockwise;
              }
              return this.updateData();
            },
            setEndAngle: function (angle, anticlockwise) {
              this._endAngle = angle;
              if (anticlockwise !== void 0) {
                this._anticlockwise = anticlockwise;
              }
              return this.updateData();
            },
            updateData: function () {
              var step = this._iterations;
              var iteration = step;
              var radius = this.geom.radius;
              var startAngle = DegToRad(this._startAngle);
              var endAngle = DegToRad(this._endAngle);
              var anticlockwise = this._anticlockwise;
              var x = radius;
              var y = radius;
              endAngle -= startAngle;
              if (anticlockwise) {
                if (endAngle < -MATH_CONST.PI2) {
                  endAngle = -MATH_CONST.PI2;
                } else if (endAngle > 0) {
                  endAngle = -MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;
                }
              } else if (endAngle > MATH_CONST.PI2) {
                endAngle = MATH_CONST.PI2;
              } else if (endAngle < 0) {
                endAngle = MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;
              }
              var path = [x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius];
              var ta;
              while (iteration < 1) {
                ta = endAngle * iteration + startAngle;
                path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius);
                iteration += step;
              }
              ta = endAngle + startAngle;
              path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius);
              path.push(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius);
              this.pathIndexes = Earcut(path);
              this.pathData = path;
              return this;
            }
          });
          module2.exports = Arc;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CurveRender = __webpack_require__(1100);
          var Earcut = __webpack_require__(59);
          var Rectangle = __webpack_require__(10);
          var Shape = __webpack_require__(34);
          var Curve = new Class({
            Extends: Shape,
            Mixins: [CurveRender],
            initialize: function Curve2(scene, x, y, curve, fillColor, fillAlpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              Shape.call(this, scene, "Curve", curve);
              this._smoothness = 32;
              this._curveBounds = new Rectangle();
              this.closePath = false;
              this.setPosition(x, y);
              if (fillColor !== void 0) {
                this.setFillStyle(fillColor, fillAlpha);
              }
              this.updateData();
            },
            smoothness: {
              get: function () {
                return this._smoothness;
              },
              set: function (value) {
                this._smoothness = value;
                this.updateData();
              }
            },
            setSmoothness: function (value) {
              this._smoothness = value;
              return this.updateData();
            },
            updateData: function () {
              var bounds = this._curveBounds;
              var smoothness = this._smoothness;
              this.geom.getBounds(bounds, smoothness);
              this.setSize(bounds.width, bounds.height);
              this.updateDisplayOrigin();
              var path = [];
              var points = this.geom.getPoints(smoothness);
              for (var i = 0; i < points.length; i++) {
                path.push(points[i].x, points[i].y);
              }
              path.push(points[0].x, points[0].y);
              this.pathIndexes = Earcut(path);
              this.pathData = path;
              return this;
            }
          });
          module2.exports = Curve;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Earcut = __webpack_require__(59);
          var EllipseRender = __webpack_require__(1103);
          var GeomEllipse = __webpack_require__(111);
          var Shape = __webpack_require__(34);
          var Ellipse = new Class({
            Extends: Shape,
            Mixins: [EllipseRender],
            initialize: function Ellipse2(scene, x, y, width, height, fillColor, fillAlpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = 128;
              }
              if (height === void 0) {
                height = 128;
              }
              Shape.call(this, scene, "Ellipse", new GeomEllipse(width / 2, height / 2, width, height));
              this._smoothness = 64;
              this.setPosition(x, y);
              this.width = width;
              this.height = height;
              if (fillColor !== void 0) {
                this.setFillStyle(fillColor, fillAlpha);
              }
              this.updateDisplayOrigin();
              this.updateData();
            },
            smoothness: {
              get: function () {
                return this._smoothness;
              },
              set: function (value) {
                this._smoothness = value;
                this.updateData();
              }
            },
            setSize: function (width, height) {
              this.width = width;
              this.height = height;
              this.geom.setPosition(width / 2, height / 2);
              this.geom.setSize(width, height);
              return this.updateData();
            },
            setSmoothness: function (value) {
              this._smoothness = value;
              return this.updateData();
            },
            updateData: function () {
              var path = [];
              var points = this.geom.getPoints(this._smoothness);
              for (var i = 0; i < points.length; i++) {
                path.push(points[i].x, points[i].y);
              }
              path.push(points[0].x, points[0].y);
              this.pathIndexes = Earcut(path);
              this.pathData = path;
              return this;
            }
          });
          module2.exports = Ellipse;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Shape = __webpack_require__(34);
          var GridRender = __webpack_require__(1106);
          var Grid = new Class({
            Extends: Shape,
            Mixins: [GridRender],
            initialize: function Grid2(scene, x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = 128;
              }
              if (height === void 0) {
                height = 128;
              }
              if (cellWidth === void 0) {
                cellWidth = 32;
              }
              if (cellHeight === void 0) {
                cellHeight = 32;
              }
              Shape.call(this, scene, "Grid", null);
              this.cellWidth = cellWidth;
              this.cellHeight = cellHeight;
              this.showCells = true;
              this.outlineFillColor = 0;
              this.outlineFillAlpha = 0;
              this.showOutline = true;
              this.showAltCells = false;
              this.altFillColor;
              this.altFillAlpha;
              this.setPosition(x, y);
              this.setSize(width, height);
              this.setFillStyle(fillColor, fillAlpha);
              if (outlineFillColor !== void 0) {
                this.setOutlineStyle(outlineFillColor, outlineFillAlpha);
              }
              this.updateDisplayOrigin();
            },
            setFillStyle: function (fillColor, fillAlpha) {
              if (fillAlpha === void 0) {
                fillAlpha = 1;
              }
              if (fillColor === void 0) {
                this.showCells = false;
              } else {
                this.fillColor = fillColor;
                this.fillAlpha = fillAlpha;
                this.showCells = true;
              }
              return this;
            },
            setAltFillStyle: function (fillColor, fillAlpha) {
              if (fillAlpha === void 0) {
                fillAlpha = 1;
              }
              if (fillColor === void 0) {
                this.showAltCells = false;
              } else {
                this.altFillColor = fillColor;
                this.altFillAlpha = fillAlpha;
                this.showAltCells = true;
              }
              return this;
            },
            setOutlineStyle: function (fillColor, fillAlpha) {
              if (fillAlpha === void 0) {
                fillAlpha = 1;
              }
              if (fillColor === void 0) {
                this.showOutline = false;
              } else {
                this.outlineFillColor = fillColor;
                this.outlineFillAlpha = fillAlpha;
                this.showOutline = true;
              }
              return this;
            }
          });
          module2.exports = Grid;
        }, function (module2, exports2, __webpack_require__) {
          var IsoBoxRender = __webpack_require__(1109);
          var Class = __webpack_require__(0);
          var Shape = __webpack_require__(34);
          var IsoBox = new Class({
            Extends: Shape,
            Mixins: [IsoBoxRender],
            initialize: function IsoBox2(scene, x, y, size, height, fillTop, fillLeft, fillRight) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (size === void 0) {
                size = 48;
              }
              if (height === void 0) {
                height = 32;
              }
              if (fillTop === void 0) {
                fillTop = 15658734;
              }
              if (fillLeft === void 0) {
                fillLeft = 10066329;
              }
              if (fillRight === void 0) {
                fillRight = 13421772;
              }
              Shape.call(this, scene, "IsoBox", null);
              this.projection = 4;
              this.fillTop = fillTop;
              this.fillLeft = fillLeft;
              this.fillRight = fillRight;
              this.showTop = true;
              this.showLeft = true;
              this.showRight = true;
              this.isFilled = true;
              this.setPosition(x, y);
              this.setSize(size, height);
              this.updateDisplayOrigin();
            },
            setProjection: function (value) {
              this.projection = value;
              return this;
            },
            setFaces: function (showTop, showLeft, showRight) {
              if (showTop === void 0) {
                showTop = true;
              }
              if (showLeft === void 0) {
                showLeft = true;
              }
              if (showRight === void 0) {
                showRight = true;
              }
              this.showTop = showTop;
              this.showLeft = showLeft;
              this.showRight = showRight;
              return this;
            },
            setFillStyle: function (fillTop, fillLeft, fillRight) {
              this.fillTop = fillTop;
              this.fillLeft = fillLeft;
              this.fillRight = fillRight;
              this.isFilled = true;
              return this;
            }
          });
          module2.exports = IsoBox;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var IsoTriangleRender = __webpack_require__(1112);
          var Shape = __webpack_require__(34);
          var IsoTriangle = new Class({
            Extends: Shape,
            Mixins: [IsoTriangleRender],
            initialize: function IsoTriangle2(scene, x, y, size, height, reversed, fillTop, fillLeft, fillRight) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (size === void 0) {
                size = 48;
              }
              if (height === void 0) {
                height = 32;
              }
              if (reversed === void 0) {
                reversed = false;
              }
              if (fillTop === void 0) {
                fillTop = 15658734;
              }
              if (fillLeft === void 0) {
                fillLeft = 10066329;
              }
              if (fillRight === void 0) {
                fillRight = 13421772;
              }
              Shape.call(this, scene, "IsoTriangle", null);
              this.projection = 4;
              this.fillTop = fillTop;
              this.fillLeft = fillLeft;
              this.fillRight = fillRight;
              this.showTop = true;
              this.showLeft = true;
              this.showRight = true;
              this.isReversed = reversed;
              this.isFilled = true;
              this.setPosition(x, y);
              this.setSize(size, height);
              this.updateDisplayOrigin();
            },
            setProjection: function (value) {
              this.projection = value;
              return this;
            },
            setReversed: function (reversed) {
              this.isReversed = reversed;
              return this;
            },
            setFaces: function (showTop, showLeft, showRight) {
              if (showTop === void 0) {
                showTop = true;
              }
              if (showLeft === void 0) {
                showLeft = true;
              }
              if (showRight === void 0) {
                showRight = true;
              }
              this.showTop = showTop;
              this.showLeft = showLeft;
              this.showRight = showRight;
              return this;
            },
            setFillStyle: function (fillTop, fillLeft, fillRight) {
              this.fillTop = fillTop;
              this.fillLeft = fillLeft;
              this.fillRight = fillRight;
              this.isFilled = true;
              return this;
            }
          });
          module2.exports = IsoTriangle;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Shape = __webpack_require__(34);
          var GeomLine = __webpack_require__(47);
          var LineRender = __webpack_require__(1115);
          var Line = new Class({
            Extends: Shape,
            Mixins: [LineRender],
            initialize: function Line2(scene, x, y, x1, y1, x2, y2, strokeColor, strokeAlpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (x1 === void 0) {
                x1 = 0;
              }
              if (y1 === void 0) {
                y1 = 0;
              }
              if (x2 === void 0) {
                x2 = 128;
              }
              if (y2 === void 0) {
                y2 = 0;
              }
              Shape.call(this, scene, "Line", new GeomLine(x1, y1, x2, y2));
              var width = Math.max(1, this.geom.right - this.geom.left);
              var height = Math.max(1, this.geom.bottom - this.geom.top);
              this.lineWidth = 1;
              this._startWidth = 1;
              this._endWidth = 1;
              this.setPosition(x, y);
              this.setSize(width, height);
              if (strokeColor !== void 0) {
                this.setStrokeStyle(1, strokeColor, strokeAlpha);
              }
              this.updateDisplayOrigin();
            },
            setLineWidth: function (startWidth, endWidth) {
              if (endWidth === void 0) {
                endWidth = startWidth;
              }
              this._startWidth = startWidth;
              this._endWidth = endWidth;
              this.lineWidth = startWidth;
              return this;
            },
            setTo: function (x1, y1, x2, y2) {
              this.geom.setTo(x1, y1, x2, y2);
              return this;
            }
          });
          module2.exports = Line;
        }, function (module2, exports2, __webpack_require__) {
          var PolygonRender = __webpack_require__(1118);
          var Class = __webpack_require__(0);
          var Earcut = __webpack_require__(59);
          var GetAABB = __webpack_require__(469);
          var GeomPolygon = __webpack_require__(227);
          var Shape = __webpack_require__(34);
          var Smooth = __webpack_require__(472);
          var Polygon = new Class({
            Extends: Shape,
            Mixins: [PolygonRender],
            initialize: function Polygon2(scene, x, y, points, fillColor, fillAlpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              Shape.call(this, scene, "Polygon", new GeomPolygon(points));
              var bounds = GetAABB(this.geom);
              this.setPosition(x, y);
              this.setSize(bounds.width, bounds.height);
              if (fillColor !== void 0) {
                this.setFillStyle(fillColor, fillAlpha);
              }
              this.updateDisplayOrigin();
              this.updateData();
            },
            smooth: function (iterations) {
              if (iterations === void 0) {
                iterations = 1;
              }
              for (var i = 0; i < iterations; i++) {
                Smooth(this.geom);
              }
              return this.updateData();
            },
            updateData: function () {
              var path = [];
              var points = this.geom.points;
              for (var i = 0; i < points.length; i++) {
                path.push(points[i].x, points[i].y);
              }
              path.push(points[0].x, points[0].y);
              this.pathIndexes = Earcut(path);
              this.pathData = path;
              return this;
            }
          });
          module2.exports = Polygon;
        }, function (module2, exports2, __webpack_require__) {
          var Rectangle = __webpack_require__(10);
          var GetAABB = function (polygon, out) {
            if (out === void 0) {
              out = new Rectangle();
            }
            var minX = Infinity;
            var minY = Infinity;
            var maxX = -minX;
            var maxY = -minY;
            var p3;
            for (var i = 0; i < polygon.points.length; i++) {
              p3 = polygon.points[i];
              minX = Math.min(minX, p3.x);
              minY = Math.min(minY, p3.y);
              maxX = Math.max(maxX, p3.x);
              maxY = Math.max(maxY, p3.y);
            }
            out.x = minX;
            out.y = minY;
            out.width = maxX - minX;
            out.height = maxY - minY;
            return out;
          };
          module2.exports = GetAABB;
        }, function (module2, exports2, __webpack_require__) {
          var Length = __webpack_require__(67);
          var Line = __webpack_require__(47);
          var Perimeter = __webpack_require__(471);
          var GetPoints = function (polygon, quantity, stepRate, out) {
            if (out === void 0) {
              out = [];
            }
            var points = polygon.points;
            var perimeter = Perimeter(polygon);
            if (!quantity && stepRate > 0) {
              quantity = perimeter / stepRate;
            }
            for (var i = 0; i < quantity; i++) {
              var position = perimeter * (i / quantity);
              var accumulatedPerimeter = 0;
              for (var j = 0; j < points.length; j++) {
                var pointA = points[j];
                var pointB = points[(j + 1) % points.length];
                var line = new Line(pointA.x, pointA.y, pointB.x, pointB.y);
                var length = Length(line);
                if (position < accumulatedPerimeter || position > accumulatedPerimeter + length) {
                  accumulatedPerimeter += length;
                  continue;
                }
                var point = line.getPoint((position - accumulatedPerimeter) / length);
                out.push(point);
                break;
              }
            }
            return out;
          };
          module2.exports = GetPoints;
        }, function (module2, exports2, __webpack_require__) {
          var Length = __webpack_require__(67);
          var Line = __webpack_require__(47);
          var Perimeter = function (polygon) {
            var points = polygon.points;
            var perimeter = 0;
            for (var i = 0; i < points.length; i++) {
              var pointA = points[i];
              var pointB = points[(i + 1) % points.length];
              var line = new Line(pointA.x, pointA.y, pointB.x, pointB.y);
              perimeter += Length(line);
            }
            return perimeter;
          };
          module2.exports = Perimeter;
        }, function (module2, exports2) {
          var copy = function (out, a) {
            out[0] = a[0];
            out[1] = a[1];
            return out;
          };
          var Smooth = function (polygon) {
            var i;
            var points = [];
            var data = polygon.points;
            for (i = 0; i < data.length; i++) {
              points.push([data[i].x, data[i].y]);
            }
            var output = [];
            if (points.length > 0) {
              output.push(copy([0, 0], points[0]));
            }
            for (i = 0; i < points.length - 1; i++) {
              var p0 = points[i];
              var p1 = points[i + 1];
              var p0x = p0[0];
              var p0y = p0[1];
              var p1x = p1[0];
              var p1y = p1[1];
              output.push([0.85 * p0x + 0.15 * p1x, 0.85 * p0y + 0.15 * p1y]);
              output.push([0.15 * p0x + 0.85 * p1x, 0.15 * p0y + 0.85 * p1y]);
            }
            if (points.length > 1) {
              output.push(copy([0, 0], points[points.length - 1]));
            }
            return polygon.setTo(output);
          };
          module2.exports = Smooth;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GeomRectangle = __webpack_require__(10);
          var Shape = __webpack_require__(34);
          var RectangleRender = __webpack_require__(1121);
          var Rectangle = new Class({
            Extends: Shape,
            Mixins: [RectangleRender],
            initialize: function Rectangle2(scene, x, y, width, height, fillColor, fillAlpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = 128;
              }
              if (height === void 0) {
                height = 128;
              }
              Shape.call(this, scene, "Rectangle", new GeomRectangle(0, 0, width, height));
              this.setPosition(x, y);
              this.setSize(width, height);
              if (fillColor !== void 0) {
                this.setFillStyle(fillColor, fillAlpha);
              }
              this.updateDisplayOrigin();
              this.updateData();
            },
            setSize: function (width, height) {
              this.width = width;
              this.height = height;
              this.geom.setSize(width, height);
              this.updateData();
              return this;
            },
            updateData: function () {
              var path = [];
              var rect = this.geom;
              var line = this._tempLine;
              rect.getLineA(line);
              path.push(line.x1, line.y1, line.x2, line.y2);
              rect.getLineB(line);
              path.push(line.x2, line.y2);
              rect.getLineC(line);
              path.push(line.x2, line.y2);
              rect.getLineD(line);
              path.push(line.x2, line.y2);
              this.pathData = path;
              return this;
            }
          });
          module2.exports = Rectangle;
        }, function (module2, exports2, __webpack_require__) {
          var StarRender = __webpack_require__(1124);
          var Class = __webpack_require__(0);
          var Earcut = __webpack_require__(59);
          var Shape = __webpack_require__(34);
          var Star = new Class({
            Extends: Shape,
            Mixins: [StarRender],
            initialize: function Star2(scene, x, y, points, innerRadius, outerRadius, fillColor, fillAlpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (points === void 0) {
                points = 5;
              }
              if (innerRadius === void 0) {
                innerRadius = 32;
              }
              if (outerRadius === void 0) {
                outerRadius = 64;
              }
              Shape.call(this, scene, "Star", null);
              this._points = points;
              this._innerRadius = innerRadius;
              this._outerRadius = outerRadius;
              this.setPosition(x, y);
              this.setSize(outerRadius * 2, outerRadius * 2);
              if (fillColor !== void 0) {
                this.setFillStyle(fillColor, fillAlpha);
              }
              this.updateDisplayOrigin();
              this.updateData();
            },
            setPoints: function (value) {
              this._points = value;
              return this.updateData();
            },
            setInnerRadius: function (value) {
              this._innerRadius = value;
              return this.updateData();
            },
            setOuterRadius: function (value) {
              this._outerRadius = value;
              return this.updateData();
            },
            points: {
              get: function () {
                return this._points;
              },
              set: function (value) {
                this._points = value;
                this.updateData();
              }
            },
            innerRadius: {
              get: function () {
                return this._innerRadius;
              },
              set: function (value) {
                this._innerRadius = value;
                this.updateData();
              }
            },
            outerRadius: {
              get: function () {
                return this._outerRadius;
              },
              set: function (value) {
                this._outerRadius = value;
                this.updateData();
              }
            },
            updateData: function () {
              var path = [];
              var points = this._points;
              var innerRadius = this._innerRadius;
              var outerRadius = this._outerRadius;
              var rot = Math.PI / 2 * 3;
              var step = Math.PI / points;
              var x = outerRadius;
              var y = outerRadius;
              path.push(x, y + -outerRadius);
              for (var i = 0; i < points; i++) {
                path.push(x + Math.cos(rot) * outerRadius, y + Math.sin(rot) * outerRadius);
                rot += step;
                path.push(x + Math.cos(rot) * innerRadius, y + Math.sin(rot) * innerRadius);
                rot += step;
              }
              path.push(x, y + -outerRadius);
              this.pathIndexes = Earcut(path);
              this.pathData = path;
              return this;
            }
          });
          module2.exports = Star;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Shape = __webpack_require__(34);
          var GeomTriangle = __webpack_require__(82);
          var TriangleRender = __webpack_require__(1127);
          var Triangle = new Class({
            Extends: Shape,
            Mixins: [TriangleRender],
            initialize: function Triangle2(scene, x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (x1 === void 0) {
                x1 = 0;
              }
              if (y1 === void 0) {
                y1 = 128;
              }
              if (x2 === void 0) {
                x2 = 64;
              }
              if (y2 === void 0) {
                y2 = 0;
              }
              if (x3 === void 0) {
                x3 = 128;
              }
              if (y3 === void 0) {
                y3 = 128;
              }
              Shape.call(this, scene, "Triangle", new GeomTriangle(x1, y1, x2, y2, x3, y3));
              var width = this.geom.right - this.geom.left;
              var height = this.geom.bottom - this.geom.top;
              this.setPosition(x, y);
              this.setSize(width, height);
              if (fillColor !== void 0) {
                this.setFillStyle(fillColor, fillAlpha);
              }
              this.updateDisplayOrigin();
              this.updateData();
            },
            setTo: function (x1, y1, x2, y2, x3, y3) {
              this.geom.setTo(x1, y1, x2, y2, x3, y3);
              return this.updateData();
            },
            updateData: function () {
              var path = [];
              var tri = this.geom;
              var line = this._tempLine;
              tri.getLineA(line);
              path.push(line.x1, line.y1, line.x2, line.y2);
              tri.getLineB(line);
              path.push(line.x2, line.y2);
              tri.getLineC(line);
              path.push(line.x2, line.y2);
              this.pathData = path;
              return this;
            }
          });
          module2.exports = Triangle;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var Length = __webpack_require__(67);
          var GetPoint = function (triangle, position, out) {
            if (out === void 0) {
              out = new Point();
            }
            var line1 = triangle.getLineA();
            var line2 = triangle.getLineB();
            var line3 = triangle.getLineC();
            if (position <= 0 || position >= 1) {
              out.x = line1.x1;
              out.y = line1.y1;
              return out;
            }
            var length1 = Length(line1);
            var length2 = Length(line2);
            var length3 = Length(line3);
            var perimeter = length1 + length2 + length3;
            var p3 = perimeter * position;
            var localPosition = 0;
            if (p3 < length1) {
              localPosition = p3 / length1;
              out.x = line1.x1 + (line1.x2 - line1.x1) * localPosition;
              out.y = line1.y1 + (line1.y2 - line1.y1) * localPosition;
            } else if (p3 > length1 + length2) {
              p3 -= length1 + length2;
              localPosition = p3 / length3;
              out.x = line3.x1 + (line3.x2 - line3.x1) * localPosition;
              out.y = line3.y1 + (line3.y2 - line3.y1) * localPosition;
            } else {
              p3 -= length1;
              localPosition = p3 / length2;
              out.x = line2.x1 + (line2.x2 - line2.x1) * localPosition;
              out.y = line2.y1 + (line2.y2 - line2.y1) * localPosition;
            }
            return out;
          };
          module2.exports = GetPoint;
        }, function (module2, exports2, __webpack_require__) {
          var Length = __webpack_require__(67);
          var Point = __webpack_require__(4);
          var GetPoints = function (triangle, quantity, stepRate, out) {
            if (out === void 0) {
              out = [];
            }
            var line1 = triangle.getLineA();
            var line2 = triangle.getLineB();
            var line3 = triangle.getLineC();
            var length1 = Length(line1);
            var length2 = Length(line2);
            var length3 = Length(line3);
            var perimeter = length1 + length2 + length3;
            if (!quantity && stepRate > 0) {
              quantity = perimeter / stepRate;
            }
            for (var i = 0; i < quantity; i++) {
              var p3 = perimeter * (i / quantity);
              var localPosition = 0;
              var point = new Point();
              if (p3 < length1) {
                localPosition = p3 / length1;
                point.x = line1.x1 + (line1.x2 - line1.x1) * localPosition;
                point.y = line1.y1 + (line1.y2 - line1.y1) * localPosition;
              } else if (p3 > length1 + length2) {
                p3 -= length1 + length2;
                localPosition = p3 / length3;
                point.x = line3.x1 + (line3.x2 - line3.x1) * localPosition;
                point.y = line3.y1 + (line3.y2 - line3.y1) * localPosition;
              } else {
                p3 -= length1;
                localPosition = p3 / length2;
                point.x = line2.x1 + (line2.x2 - line2.x1) * localPosition;
                point.y = line2.y1 + (line2.y2 - line2.y1) * localPosition;
              }
              out.push(point);
            }
            return out;
          };
          module2.exports = GetPoints;
        }, function (module2, exports2) {
          var SetValue = function (source, key, value) {
            if (!source || typeof source === "number") {
              return false;
            } else if (source.hasOwnProperty(key)) {
              source[key] = value;
              return true;
            } else if (key.indexOf(".") !== -1) {
              var keys = key.split(".");
              var parent = source;
              var prev = source;
              for (var i = 0; i < keys.length; i++) {
                if (parent.hasOwnProperty(keys[i])) {
                  prev = parent;
                  parent = parent[keys[i]];
                } else {
                  return false;
                }
              }
              prev[keys[keys.length - 1]] = value;
              return true;
            }
            return false;
          };
          module2.exports = SetValue;
        }, function (module2, exports2, __webpack_require__) {
          var Face = __webpack_require__(116);
          var Vertex = __webpack_require__(117);
          var GenerateVerts = function (vertices, uvs, indicies, containsZ, normals, colors, alphas) {
            if (containsZ === void 0) {
              containsZ = false;
            }
            if (colors === void 0) {
              colors = 16777215;
            }
            if (alphas === void 0) {
              alphas = 1;
            }
            if (vertices.length !== uvs.length) {
              console.warn("GenerateVerts: vertices and uvs count not equal");
              return;
            }
            var result = {
              faces: [],
              vertices: []
            };
            var i;
            var x;
            var y;
            var z;
            var u;
            var v;
            var color;
            var alpha;
            var normalX;
            var normalY;
            var normalZ;
            var iInc = containsZ ? 3 : 2;
            var isColorArray = Array.isArray(colors);
            var isAlphaArray = Array.isArray(alphas);
            if (Array.isArray(indicies) && indicies.length > 0) {
              for (i = 0; i < indicies.length; i++) {
                var index1 = indicies[i];
                var index2 = indicies[i] * 2;
                var index3 = indicies[i] * iInc;
                x = vertices[index3];
                y = vertices[index3 + 1];
                z = containsZ ? vertices[index3 + 2] : 0;
                u = uvs[index2];
                v = uvs[index2 + 1];
                color = isColorArray ? colors[index1] : colors;
                alpha = isAlphaArray ? alphas[index1] : alphas;
                normalX = 0;
                normalY = 0;
                normalZ = 0;
                if (normals) {
                  normalX = normals[index3];
                  normalY = normals[index3 + 1];
                  normalZ = containsZ ? normals[index3 + 2] : 0;
                }
                result.vertices.push(new Vertex(x, y, z, u, v, color, alpha, normalX, normalY, normalZ));
              }
            } else {
              var uvIndex = 0;
              var colorIndex = 0;
              for (i = 0; i < vertices.length; i += iInc) {
                x = vertices[i];
                y = vertices[i + 1];
                z = containsZ ? vertices[i + 2] : 0;
                u = uvs[uvIndex];
                v = uvs[uvIndex + 1];
                color = isColorArray ? colors[colorIndex] : colors;
                alpha = isAlphaArray ? alphas[colorIndex] : alphas;
                normalX = 0;
                normalY = 0;
                normalZ = 0;
                if (normals) {
                  normalX = normals[i];
                  normalY = normals[i + 1];
                  normalZ = containsZ ? normals[i + 2] : 0;
                }
                result.vertices.push(new Vertex(x, y, z, u, v, color, alpha, normalX, normalY, normalZ));
                uvIndex += 2;
                colorIndex++;
              }
            }
            for (i = 0; i < result.vertices.length; i += 3) {
              var vert1 = result.vertices[i];
              var vert2 = result.vertices[i + 1];
              var vert3 = result.vertices[i + 2];
              result.faces.push(new Face(vert1, vert2, vert3));
            }
            return result;
          };
          module2.exports = GenerateVerts;
        }, function (module2, exports2, __webpack_require__) {
          var Face = __webpack_require__(116);
          var Matrix4 = __webpack_require__(69);
          var Vector3 = __webpack_require__(39);
          var Vertex = __webpack_require__(117);
          var tempPosition = new Vector3();
          var tempRotation = new Vector3();
          var tempMatrix = new Matrix4();
          var GenerateObjVerts = function (data, mesh, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp) {
            if (scale === void 0) {
              scale = 1;
            }
            if (x === void 0) {
              x = 0;
            }
            if (y === void 0) {
              y = 0;
            }
            if (z === void 0) {
              z = 0;
            }
            if (rotateX === void 0) {
              rotateX = 0;
            }
            if (rotateY === void 0) {
              rotateY = 0;
            }
            if (rotateZ === void 0) {
              rotateZ = 0;
            }
            if (zIsUp === void 0) {
              zIsUp = true;
            }
            var result = {
              faces: [],
              verts: []
            };
            var materials = data.materials;
            tempPosition.set(x, y, z);
            tempRotation.set(rotateX, rotateY, rotateZ);
            tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, zIsUp);
            for (var m = 0; m < data.models.length; m++) {
              var model = data.models[m];
              var vertices = model.vertices;
              var textureCoords = model.textureCoords;
              var faces = model.faces;
              for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                var v1 = face.vertices[0];
                var v2 = face.vertices[1];
                var v3 = face.vertices[2];
                var m1 = vertices[v1.vertexIndex];
                var m2 = vertices[v2.vertexIndex];
                var m3 = vertices[v3.vertexIndex];
                var t1 = v1.textureCoordsIndex;
                var t2 = v2.textureCoordsIndex;
                var t3 = v3.textureCoordsIndex;
                var uv1 = t1 === -1 ? {
                  u: 0,
                  v: 1
                } : textureCoords[t1];
                var uv2 = t2 === -1 ? {
                  u: 0,
                  v: 0
                } : textureCoords[t2];
                var uv3 = t3 === -1 ? {
                  u: 1,
                  v: 1
                } : textureCoords[t3];
                var color = 16777215;
                if (face.material !== "" && materials[face.material]) {
                  color = materials[face.material];
                }
                var vert1 = new Vertex(m1.x * scale, m1.y * scale, m1.z * scale, uv1.u, uv1.v, color).transformMat4(tempMatrix);
                var vert2 = new Vertex(m2.x * scale, m2.y * scale, m2.z * scale, uv2.u, uv2.v, color).transformMat4(tempMatrix);
                var vert3 = new Vertex(m3.x * scale, m3.y * scale, m3.z * scale, uv3.u, uv3.v, color).transformMat4(tempMatrix);
                result.verts.push(vert1, vert2, vert3);
                result.faces.push(new Face(vert1, vert2, vert3));
              }
            }
            if (mesh) {
              mesh.faces = mesh.faces.concat(result.faces);
              mesh.vertices = mesh.vertices.concat(result.verts);
            }
            return result;
          };
          module2.exports = GenerateObjVerts;
        }, function (module2, exports2, __webpack_require__) {
          var Circle = __webpack_require__(65);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var RGB = __webpack_require__(200);
          var Utils = __webpack_require__(12);
          var Light = new Class({
            Extends: Circle,
            Mixins: [Components.ScrollFactor, Components.Visible],
            initialize: function Light2(x, y, radius, r, g, b, intensity) {
              Circle.call(this, x, y, radius);
              this.color = new RGB(r, g, b);
              this.intensity = intensity;
              this.renderFlags = 15;
              this.cameraFilter = 0;
              this.setScrollFactor(1, 1);
            },
            willRender: function (camera) {
              return !(Light.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
            },
            setColor: function (rgb) {
              var color = Utils.getFloatsFromUintRGB(rgb);
              this.color.set(color[0], color[1], color[2]);
              return this;
            },
            setIntensity: function (intensity) {
              this.intensity = intensity;
              return this;
            },
            setRadius: function (radius) {
              this.radius = radius;
              return this;
            }
          });
          Light.RENDER_MASK = 15;
          module2.exports = Light;
        }, function (module2, exports2, __webpack_require__) {
          var CircleToRectangle = __webpack_require__(151);
          var Class = __webpack_require__(0);
          var DistanceBetween = __webpack_require__(50);
          var Light = __webpack_require__(481);
          var PointLight = __webpack_require__(150);
          var RGB = __webpack_require__(200);
          var SpliceOne = __webpack_require__(74);
          var StableSort = __webpack_require__(79);
          var Utils = __webpack_require__(12);
          var LightsManager = new Class({
            initialize: function LightsManager2() {
              this.lights = [];
              this.ambientColor = new RGB(0.1, 0.1, 0.1);
              this.active = false;
              this.maxLights = -1;
              this.visibleLights = 0;
            },
            addPointLight: function (x, y, color, radius, intensity, attenuation) {
              return this.systems.displayList.add(new PointLight(this.scene, x, y, color, radius, intensity, attenuation));
            },
            enable: function () {
              if (this.maxLights === -1) {
                this.maxLights = this.systems.renderer.config.maxLights;
              }
              this.active = true;
              return this;
            },
            disable: function () {
              this.active = false;
              return this;
            },
            getLights: function (camera) {
              var lights = this.lights;
              var worldView = camera.worldView;
              var visibleLights = [];
              for (var i = 0; i < lights.length; i++) {
                var light = lights[i];
                if (light.willRender(camera) && CircleToRectangle(light, worldView)) {
                  visibleLights.push({
                    light,
                    distance: DistanceBetween(light.x, light.y, worldView.centerX, worldView.centerY)
                  });
                }
              }
              if (visibleLights.length > this.maxLights) {
                StableSort(visibleLights, this.sortByDistance);
                visibleLights = visibleLights.slice(0, this.maxLights);
              }
              this.visibleLights = visibleLights.length;
              return visibleLights;
            },
            sortByDistance: function (a, b) {
              return a.distance >= b.distance;
            },
            setAmbientColor: function (rgb) {
              var color = Utils.getFloatsFromUintRGB(rgb);
              this.ambientColor.set(color[0], color[1], color[2]);
              return this;
            },
            getMaxVisibleLights: function () {
              return this.maxLights;
            },
            getLightCount: function () {
              return this.lights.length;
            },
            addLight: function (x, y, radius, rgb, intensity) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (radius === void 0) {
                radius = 128;
              }
              if (rgb === void 0) {
                rgb = 16777215;
              }
              if (intensity === void 0) {
                intensity = 1;
              }
              var color = Utils.getFloatsFromUintRGB(rgb);
              var light = new Light(x, y, radius, color[0], color[1], color[2], intensity);
              this.lights.push(light);
              return light;
            },
            removeLight: function (light) {
              var index = this.lights.indexOf(light);
              if (index >= 0) {
                SpliceOne(this.lights, index);
              }
              return this;
            },
            shutdown: function () {
              this.lights.length = 0;
            },
            destroy: function () {
              this.shutdown();
            }
          });
          module2.exports = LightsManager;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(56);
          var Extend = __webpack_require__(17);
          var Geom = {
            Circle: __webpack_require__(1191),
            Ellipse: __webpack_require__(1201),
            Intersects: __webpack_require__(484),
            Line: __webpack_require__(1221),
            Mesh: __webpack_require__(1243),
            Point: __webpack_require__(1246),
            Polygon: __webpack_require__(1260),
            Rectangle: __webpack_require__(502),
            Triangle: __webpack_require__(1293)
          };
          Geom = Extend(false, Geom, CONST);
          module2.exports = Geom;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            CircleToCircle: __webpack_require__(231),
            CircleToRectangle: __webpack_require__(151),
            GetCircleToCircle: __webpack_require__(1211),
            GetCircleToRectangle: __webpack_require__(1212),
            GetLineToCircle: __webpack_require__(232),
            GetLineToLine: __webpack_require__(485),
            GetLineToPoints: __webpack_require__(486),
            GetLineToPolygon: __webpack_require__(487),
            GetLineToRectangle: __webpack_require__(234),
            GetRaysFromPointToPolygon: __webpack_require__(1213),
            GetRectangleIntersection: __webpack_require__(1214),
            GetRectangleToRectangle: __webpack_require__(1215),
            GetRectangleToTriangle: __webpack_require__(1216),
            GetTriangleToCircle: __webpack_require__(1217),
            GetTriangleToLine: __webpack_require__(492),
            GetTriangleToTriangle: __webpack_require__(1218),
            LineToCircle: __webpack_require__(233),
            LineToLine: __webpack_require__(96),
            LineToRectangle: __webpack_require__(488),
            PointToLine: __webpack_require__(496),
            PointToLineSegment: __webpack_require__(1219),
            RectangleToRectangle: __webpack_require__(152),
            RectangleToTriangle: __webpack_require__(489),
            RectangleToValues: __webpack_require__(1220),
            TriangleToCircle: __webpack_require__(491),
            TriangleToLine: __webpack_require__(493),
            TriangleToTriangle: __webpack_require__(494)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Vector3 = __webpack_require__(39);
          var GetLineToLine = function (line1, line2, out) {
            var x1 = line1.x1;
            var y1 = line1.y1;
            var x2 = line1.x2;
            var y2 = line1.y2;
            var x3 = line2.x1;
            var y3 = line2.y1;
            var x4 = line2.x2;
            var y4 = line2.y2;
            var dx1 = x2 - x1;
            var dy1 = y2 - y1;
            var dx2 = x4 - x3;
            var dy2 = y4 - y3;
            var denom = dy2 * dx1 - dx2 * dy1;
            if (dx1 === 0 || denom === 0) {
              return false;
            }
            var T2 = (dx1 * (y3 - y1) + dy1 * (x1 - x3)) / (dx2 * dy1 - dy2 * dx1);
            var T1 = (x3 + dx2 * T2 - x1) / dx1;
            if (T1 < 0 || T2 < 0 || T2 > 1) {
              return null;
            }
            if (out === void 0) {
              out = new Vector3();
            }
            return out.set(x1 + dx1 * T1, y1 + dy1 * T1, T1);
          };
          module2.exports = GetLineToLine;
        }, function (module2, exports2, __webpack_require__) {
          var Vector3 = __webpack_require__(39);
          var GetLineToLine = __webpack_require__(485);
          var Line = __webpack_require__(47);
          var segment = new Line();
          var tempIntersect = new Vector3();
          var GetLineToPoints = function (line, points, out) {
            if (out === void 0) {
              out = new Vector3();
            }
            var closestIntersect = false;
            out.set();
            tempIntersect.set();
            var prev = points[0];
            for (var i = 1; i < points.length; i++) {
              var current = points[i];
              segment.setTo(prev.x, prev.y, current.x, current.y);
              prev = current;
              if (GetLineToLine(line, segment, tempIntersect)) {
                if (!closestIntersect || tempIntersect.z < out.z) {
                  out.copy(tempIntersect);
                  closestIntersect = true;
                }
              }
            }
            return closestIntersect ? out : null;
          };
          module2.exports = GetLineToPoints;
        }, function (module2, exports2, __webpack_require__) {
          var Vector3 = __webpack_require__(39);
          var Vector4 = __webpack_require__(140);
          var GetLineToPoints = __webpack_require__(486);
          var tempIntersect = new Vector3();
          var GetLineToPolygon = function (line, polygons, out) {
            if (out === void 0) {
              out = new Vector4();
            }
            if (!Array.isArray(polygons)) {
              polygons = [polygons];
            }
            var closestIntersect = false;
            out.set();
            tempIntersect.set();
            for (var i = 0; i < polygons.length; i++) {
              if (GetLineToPoints(line, polygons[i].points, tempIntersect)) {
                if (!closestIntersect || tempIntersect.z < out.z) {
                  out.set(tempIntersect.x, tempIntersect.y, tempIntersect.z, i);
                  closestIntersect = true;
                }
              }
            }
            return closestIntersect ? out : null;
          };
          module2.exports = GetLineToPolygon;
        }, function (module2, exports2) {
          var LineToRectangle = function (line, rect) {
            var x1 = line.x1;
            var y1 = line.y1;
            var x2 = line.x2;
            var y2 = line.y2;
            var bx1 = rect.x;
            var by1 = rect.y;
            var bx2 = rect.right;
            var by2 = rect.bottom;
            var t = 0;
            if (x1 >= bx1 && x1 <= bx2 && y1 >= by1 && y1 <= by2 || x2 >= bx1 && x2 <= bx2 && y2 >= by1 && y2 <= by2) {
              return true;
            }
            if (x1 < bx1 && x2 >= bx1) {
              t = y1 + (y2 - y1) * (bx1 - x1) / (x2 - x1);
              if (t > by1 && t <= by2) {
                return true;
              }
            } else if (x1 > bx2 && x2 <= bx2) {
              t = y1 + (y2 - y1) * (bx2 - x1) / (x2 - x1);
              if (t >= by1 && t <= by2) {
                return true;
              }
            }
            if (y1 < by1 && y2 >= by1) {
              t = x1 + (x2 - x1) * (by1 - y1) / (y2 - y1);
              if (t >= bx1 && t <= bx2) {
                return true;
              }
            } else if (y1 > by2 && y2 <= by2) {
              t = x1 + (x2 - x1) * (by2 - y1) / (y2 - y1);
              if (t >= bx1 && t <= bx2) {
                return true;
              }
            }
            return false;
          };
          module2.exports = LineToRectangle;
        }, function (module2, exports2, __webpack_require__) {
          var LineToLine = __webpack_require__(96);
          var Contains = __webpack_require__(57);
          var ContainsArray = __webpack_require__(235);
          var Decompose = __webpack_require__(490);
          var RectangleToTriangle = function (rect, triangle) {
            if (triangle.left > rect.right || triangle.right < rect.left || triangle.top > rect.bottom || triangle.bottom < rect.top) {
              return false;
            }
            var triA = triangle.getLineA();
            var triB = triangle.getLineB();
            var triC = triangle.getLineC();
            if (Contains(rect, triA.x1, triA.y1) || Contains(rect, triA.x2, triA.y2)) {
              return true;
            }
            if (Contains(rect, triB.x1, triB.y1) || Contains(rect, triB.x2, triB.y2)) {
              return true;
            }
            if (Contains(rect, triC.x1, triC.y1) || Contains(rect, triC.x2, triC.y2)) {
              return true;
            }
            var rectA = rect.getLineA();
            var rectB = rect.getLineB();
            var rectC = rect.getLineC();
            var rectD = rect.getLineD();
            if (LineToLine(triA, rectA) || LineToLine(triA, rectB) || LineToLine(triA, rectC) || LineToLine(triA, rectD)) {
              return true;
            }
            if (LineToLine(triB, rectA) || LineToLine(triB, rectB) || LineToLine(triB, rectC) || LineToLine(triB, rectD)) {
              return true;
            }
            if (LineToLine(triC, rectA) || LineToLine(triC, rectB) || LineToLine(triC, rectC) || LineToLine(triC, rectD)) {
              return true;
            }
            var points = Decompose(rect);
            var within = ContainsArray(triangle, points, true);
            return within.length > 0;
          };
          module2.exports = RectangleToTriangle;
        }, function (module2, exports2) {
          var Decompose = function (rect, out) {
            if (out === void 0) {
              out = [];
            }
            out.push({
              x: rect.x,
              y: rect.y
            });
            out.push({
              x: rect.right,
              y: rect.y
            });
            out.push({
              x: rect.right,
              y: rect.bottom
            });
            out.push({
              x: rect.x,
              y: rect.bottom
            });
            return out;
          };
          module2.exports = Decompose;
        }, function (module2, exports2, __webpack_require__) {
          var LineToCircle = __webpack_require__(233);
          var Contains = __webpack_require__(115);
          var TriangleToCircle = function (triangle, circle) {
            if (triangle.left > circle.right || triangle.right < circle.left || triangle.top > circle.bottom || triangle.bottom < circle.top) {
              return false;
            }
            if (Contains(triangle, circle.x, circle.y)) {
              return true;
            }
            if (LineToCircle(triangle.getLineA(), circle)) {
              return true;
            }
            if (LineToCircle(triangle.getLineB(), circle)) {
              return true;
            }
            if (LineToCircle(triangle.getLineC(), circle)) {
              return true;
            }
            return false;
          };
          module2.exports = TriangleToCircle;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var TriangleToLine = __webpack_require__(493);
          var LineToLine = __webpack_require__(96);
          var GetTriangleToLine = function (triangle, line, out) {
            if (out === void 0) {
              out = [];
            }
            if (TriangleToLine(triangle, line)) {
              var lineA = triangle.getLineA();
              var lineB = triangle.getLineB();
              var lineC = triangle.getLineC();
              var output = [new Point(), new Point(), new Point()];
              var result = [LineToLine(lineA, line, output[0]), LineToLine(lineB, line, output[1]), LineToLine(lineC, line, output[2])];
              for (var i = 0; i < 3; i++) {
                if (result[i]) {
                  out.push(output[i]);
                }
              }
            }
            return out;
          };
          module2.exports = GetTriangleToLine;
        }, function (module2, exports2, __webpack_require__) {
          var LineToLine = __webpack_require__(96);
          var TriangleToLine = function (triangle, line) {
            if (triangle.contains(line.x1, line.y1) || triangle.contains(line.x2, line.y2)) {
              return true;
            }
            if (LineToLine(triangle.getLineA(), line)) {
              return true;
            }
            if (LineToLine(triangle.getLineB(), line)) {
              return true;
            }
            if (LineToLine(triangle.getLineC(), line)) {
              return true;
            }
            return false;
          };
          module2.exports = TriangleToLine;
        }, function (module2, exports2, __webpack_require__) {
          var ContainsArray = __webpack_require__(235);
          var Decompose = __webpack_require__(495);
          var LineToLine = __webpack_require__(96);
          var TriangleToTriangle = function (triangleA, triangleB) {
            if (triangleA.left > triangleB.right || triangleA.right < triangleB.left || triangleA.top > triangleB.bottom || triangleA.bottom < triangleB.top) {
              return false;
            }
            var lineAA = triangleA.getLineA();
            var lineAB = triangleA.getLineB();
            var lineAC = triangleA.getLineC();
            var lineBA = triangleB.getLineA();
            var lineBB = triangleB.getLineB();
            var lineBC = triangleB.getLineC();
            if (LineToLine(lineAA, lineBA) || LineToLine(lineAA, lineBB) || LineToLine(lineAA, lineBC)) {
              return true;
            }
            if (LineToLine(lineAB, lineBA) || LineToLine(lineAB, lineBB) || LineToLine(lineAB, lineBC)) {
              return true;
            }
            if (LineToLine(lineAC, lineBA) || LineToLine(lineAC, lineBB) || LineToLine(lineAC, lineBC)) {
              return true;
            }
            var points = Decompose(triangleA);
            var within = ContainsArray(triangleB, points, true);
            if (within.length > 0) {
              return true;
            }
            points = Decompose(triangleB);
            within = ContainsArray(triangleA, points, true);
            if (within.length > 0) {
              return true;
            }
            return false;
          };
          module2.exports = TriangleToTriangle;
        }, function (module2, exports2) {
          var Decompose = function (triangle, out) {
            if (out === void 0) {
              out = [];
            }
            out.push({
              x: triangle.x1,
              y: triangle.y1
            });
            out.push({
              x: triangle.x2,
              y: triangle.y2
            });
            out.push({
              x: triangle.x3,
              y: triangle.y3
            });
            return out;
          };
          module2.exports = Decompose;
        }, function (module2, exports2) {
          var PointToLine = function (point, line, lineThickness) {
            if (lineThickness === void 0) {
              lineThickness = 1;
            }
            var x1 = line.x1;
            var y1 = line.y1;
            var x2 = line.x2;
            var y2 = line.y2;
            var px = point.x;
            var py = point.y;
            var L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
            if (L2 === 0) {
              return false;
            }
            var r = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / L2;
            if (r < 0) {
              return Math.sqrt((x1 - px) * (x1 - px) + (y1 - py) * (y1 - py)) <= lineThickness;
            } else if (r >= 0 && r <= 1) {
              var s = ((y1 - py) * (x2 - x1) - (x1 - px) * (y2 - y1)) / L2;
              return Math.abs(s) * Math.sqrt(L2) <= lineThickness;
            } else {
              return Math.sqrt((x2 - px) * (x2 - px) + (y2 - py) * (y2 - py)) <= lineThickness;
            }
          };
          module2.exports = PointToLine;
        }, function (module2, exports2, __webpack_require__) {
          var MATH_CONST = __webpack_require__(14);
          var Wrap = __webpack_require__(68);
          var Angle = __webpack_require__(97);
          var NormalAngle = function (line) {
            var angle = Angle(line) - MATH_CONST.TAU;
            return Wrap(angle, -Math.PI, Math.PI);
          };
          module2.exports = NormalAngle;
        }, function (module2, exports2) {
          var flip = true;
          var defaultModelName = "untitled";
          var currentGroup = "";
          var currentMaterial = "";
          function stripComments(line) {
            var idx = line.indexOf("#");
            return idx > -1 ? line.substring(0, idx) : line;
          }
          function currentModel(result) {
            if (result.models.length === 0) {
              result.models.push({
                faces: [],
                name: defaultModelName,
                textureCoords: [],
                vertexNormals: [],
                vertices: []
              });
            }
            currentGroup = "";
            return result.models[result.models.length - 1];
          }
          function parseObject(lineItems, result) {
            var modelName = lineItems.length >= 2 ? lineItems[1] : defaultModelName;
            result.models.push({
              faces: [],
              name: modelName,
              textureCoords: [],
              vertexNormals: [],
              vertices: []
            });
            currentGroup = "";
          }
          function parseGroup(lineItems) {
            if (lineItems.length === 2) {
              currentGroup = lineItems[1];
            }
          }
          function parseVertexCoords(lineItems, result) {
            var len = lineItems.length;
            var x = len >= 2 ? parseFloat(lineItems[1]) : 0;
            var y = len >= 3 ? parseFloat(lineItems[2]) : 0;
            var z = len >= 4 ? parseFloat(lineItems[3]) : 0;
            currentModel(result).vertices.push({
              x,
              y,
              z
            });
          }
          function parseTextureCoords(lineItems, result) {
            var len = lineItems.length;
            var u = len >= 2 ? parseFloat(lineItems[1]) : 0;
            var v = len >= 3 ? parseFloat(lineItems[2]) : 0;
            var w = len >= 4 ? parseFloat(lineItems[3]) : 0;
            if (isNaN(u)) {
              u = 0;
            }
            if (isNaN(v)) {
              v = 0;
            }
            if (isNaN(w)) {
              w = 0;
            }
            if (flip) {
              v = 1 - v;
            }
            currentModel(result).textureCoords.push({
              u,
              v,
              w
            });
          }
          function parseVertexNormal(lineItems, result) {
            var len = lineItems.length;
            var x = len >= 2 ? parseFloat(lineItems[1]) : 0;
            var y = len >= 3 ? parseFloat(lineItems[2]) : 0;
            var z = len >= 4 ? parseFloat(lineItems[3]) : 0;
            currentModel(result).vertexNormals.push({
              x,
              y,
              z
            });
          }
          function parsePolygon(lineItems, result) {
            var totalVertices = lineItems.length - 1;
            if (totalVertices < 3) {
              return;
            }
            var face = {
              group: currentGroup,
              material: currentMaterial,
              vertices: []
            };
            for (var i = 0; i < totalVertices; i++) {
              var vertexString = lineItems[i + 1];
              var vertexValues = vertexString.split("/");
              var vvLen = vertexValues.length;
              if (vvLen < 1 || vvLen > 3) {
                continue;
              }
              var vertexIndex = 0;
              var textureCoordsIndex = 0;
              var vertexNormalIndex = 0;
              vertexIndex = parseInt(vertexValues[0], 10);
              if (vvLen > 1 && vertexValues[1] !== "") {
                textureCoordsIndex = parseInt(vertexValues[1], 10);
              }
              if (vvLen > 2) {
                vertexNormalIndex = parseInt(vertexValues[2], 10);
              }
              if (vertexIndex !== 0) {
                if (vertexIndex < 0) {
                  vertexIndex = currentModel(result).vertices.length + 1 + vertexIndex;
                }
                textureCoordsIndex -= 1;
                vertexIndex -= 1;
                vertexNormalIndex -= 1;
                face.vertices.push({
                  textureCoordsIndex,
                  vertexIndex,
                  vertexNormalIndex
                });
              }
            }
            currentModel(result).faces.push(face);
          }
          function parseMtlLib(lineItems, result) {
            if (lineItems.length >= 2) {
              result.materialLibraries.push(lineItems[1]);
            }
          }
          function parseUseMtl(lineItems) {
            if (lineItems.length >= 2) {
              currentMaterial = lineItems[1];
            }
          }
          var ParseObj = function (data, flipUV) {
            if (flipUV === void 0) {
              flipUV = true;
            }
            flip = flipUV;
            var result = {
              materials: {},
              materialLibraries: [],
              models: []
            };
            currentGroup = "";
            currentMaterial = "";
            var lines = data.split("\n");
            for (var i = 0; i < lines.length; i++) {
              var line = stripComments(lines[i]);
              var lineItems = line.replace(/\s\s+/g, " ").trim().split(" ");
              switch (lineItems[0].toLowerCase()) {
                case "o":
                  parseObject(lineItems, result);
                  break;
                case "g":
                  parseGroup(lineItems);
                  break;
                case "v":
                  parseVertexCoords(lineItems, result);
                  break;
                case "vt":
                  parseTextureCoords(lineItems, result);
                  break;
                case "vn":
                  parseVertexNormal(lineItems, result);
                  break;
                case "f":
                  parsePolygon(lineItems, result);
                  break;
                case "mtllib":
                  parseMtlLib(lineItems, result);
                  break;
                case "usemtl":
                  parseUseMtl(lineItems);
                  break;
              }
            }
            return result;
          };
          module2.exports = ParseObj;
        }, function (module2, exports2, __webpack_require__) {
          var GetColor = __webpack_require__(103);
          var ParseObjMaterial = function (mtl) {
            var output = {};
            var lines = mtl.split("\n");
            var currentMaterial = "";
            for (var i = 0; i < lines.length; i++) {
              var line = lines[i].trim();
              if (line.indexOf("#") === 0 || line === "") {
                continue;
              }
              var lineItems = line.replace(/\s\s+/g, " ").trim().split(" ");
              switch (lineItems[0].toLowerCase()) {
                case "newmtl":
                  {
                    currentMaterial = lineItems[1];
                    break;
                  }
                case "kd":
                  {
                    var r = Math.floor(lineItems[1] * 255);
                    var g = lineItems.length >= 2 ? Math.floor(lineItems[2] * 255) : r;
                    var b = lineItems.length >= 3 ? Math.floor(lineItems[3] * 255) : r;
                    output[currentMaterial] = GetColor(r, g, b);
                    break;
                  }
              }
            }
            return output;
          };
          module2.exports = ParseObjMaterial;
        }, function (module2, exports2) {
          var GetMagnitude = function (point) {
            return Math.sqrt(point.x * point.x + point.y * point.y);
          };
          module2.exports = GetMagnitude;
        }, function (module2, exports2) {
          var GetMagnitudeSq = function (point) {
            return point.x * point.x + point.y * point.y;
          };
          module2.exports = GetMagnitudeSq;
        }, function (module2, exports2, __webpack_require__) {
          var Rectangle = __webpack_require__(10);
          Rectangle.Area = __webpack_require__(1267);
          Rectangle.Ceil = __webpack_require__(1268);
          Rectangle.CeilAll = __webpack_require__(1269);
          Rectangle.CenterOn = __webpack_require__(190);
          Rectangle.Clone = __webpack_require__(1270);
          Rectangle.Contains = __webpack_require__(57);
          Rectangle.ContainsPoint = __webpack_require__(1271);
          Rectangle.ContainsRect = __webpack_require__(503);
          Rectangle.CopyFrom = __webpack_require__(1272);
          Rectangle.Decompose = __webpack_require__(490);
          Rectangle.Equals = __webpack_require__(1273);
          Rectangle.FitInside = __webpack_require__(1274);
          Rectangle.FitOutside = __webpack_require__(1275);
          Rectangle.Floor = __webpack_require__(1276);
          Rectangle.FloorAll = __webpack_require__(1277);
          Rectangle.FromPoints = __webpack_require__(199);
          Rectangle.FromXY = __webpack_require__(1278);
          Rectangle.GetAspectRatio = __webpack_require__(237);
          Rectangle.GetCenter = __webpack_require__(1279);
          Rectangle.GetPoint = __webpack_require__(171);
          Rectangle.GetPoints = __webpack_require__(306);
          Rectangle.GetSize = __webpack_require__(1280);
          Rectangle.Inflate = __webpack_require__(1281);
          Rectangle.Intersection = __webpack_require__(1282);
          Rectangle.MarchingAnts = __webpack_require__(316);
          Rectangle.MergePoints = __webpack_require__(1283);
          Rectangle.MergeRect = __webpack_require__(1284);
          Rectangle.MergeXY = __webpack_require__(1285);
          Rectangle.Offset = __webpack_require__(1286);
          Rectangle.OffsetPoint = __webpack_require__(1287);
          Rectangle.Overlaps = __webpack_require__(1288);
          Rectangle.Perimeter = __webpack_require__(130);
          Rectangle.PerimeterPoint = __webpack_require__(1289);
          Rectangle.Random = __webpack_require__(174);
          Rectangle.RandomOutside = __webpack_require__(1290);
          Rectangle.SameDimensions = __webpack_require__(1291);
          Rectangle.Scale = __webpack_require__(1292);
          Rectangle.Union = __webpack_require__(441);
          module2.exports = Rectangle;
        }, function (module2, exports2) {
          var ContainsRect = function (rectA, rectB) {
            if (rectB.width * rectB.height > rectA.width * rectA.height) {
              return false;
            }
            return rectB.x > rectA.x && rectB.x < rectA.right && (rectB.right > rectA.x && rectB.right < rectA.right) && (rectB.y > rectA.y && rectB.y < rectA.bottom) && (rectB.bottom > rectA.y && rectB.bottom < rectA.bottom);
          };
          module2.exports = ContainsRect;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var Centroid = function (triangle, out) {
            if (out === void 0) {
              out = new Point();
            }
            out.x = (triangle.x1 + triangle.x2 + triangle.x3) / 3;
            out.y = (triangle.y1 + triangle.y2 + triangle.y3) / 3;
            return out;
          };
          module2.exports = Centroid;
        }, function (module2, exports2) {
          var Offset = function (triangle, x, y) {
            triangle.x1 += x;
            triangle.y1 += y;
            triangle.x2 += x;
            triangle.y2 += y;
            triangle.x3 += x;
            triangle.y3 += y;
            return triangle;
          };
          module2.exports = Offset;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          function getLength(x1, y1, x2, y2) {
            var x = x1 - x2;
            var y = y1 - y2;
            var magnitude = x * x + y * y;
            return Math.sqrt(magnitude);
          }
          var InCenter = function (triangle, out) {
            if (out === void 0) {
              out = new Point();
            }
            var x1 = triangle.x1;
            var y1 = triangle.y1;
            var x2 = triangle.x2;
            var y2 = triangle.y2;
            var x3 = triangle.x3;
            var y3 = triangle.y3;
            var d1 = getLength(x3, y3, x2, y2);
            var d2 = getLength(x1, y1, x3, y3);
            var d3 = getLength(x2, y2, x1, y1);
            var p3 = d1 + d2 + d3;
            out.x = (x1 * d1 + x2 * d2 + x3 * d3) / p3;
            out.y = (y1 * d1 + y2 * d2 + y3 * d3) / p3;
            return out;
          };
          module2.exports = InCenter;
        }, function (module2, exports2) {
          var CreatePixelPerfectHandler = function (textureManager, alphaTolerance) {
            return function (hitArea, x, y, gameObject) {
              var alpha = textureManager.getPixelAlpha(x, y, gameObject.texture.key, gameObject.frame.name);
              return alpha && alpha >= alphaTolerance;
            };
          };
          module2.exports = CreatePixelPerfectHandler;
        }, function (module2, exports2) {
          var CreateInteractiveObject = function (gameObject, hitArea, hitAreaCallback) {
            return {
              gameObject,
              enabled: true,
              alwaysEnabled: false,
              draggable: false,
              dropZone: false,
              cursor: false,
              target: null,
              camera: null,
              hitArea,
              hitAreaCallback,
              hitAreaDebug: null,
              customHitArea: false,
              localX: 0,
              localY: 0,
              dragState: 0,
              dragStartX: 0,
              dragStartY: 0,
              dragStartXGlobal: 0,
              dragStartYGlobal: 0,
              dragX: 0,
              dragY: 0
            };
          };
          module2.exports = CreateInteractiveObject;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Axis = new Class({
            initialize: function Axis2(pad, index) {
              this.pad = pad;
              this.events = pad.events;
              this.index = index;
              this.value = 0;
              this.threshold = 0.1;
            },
            update: function (value) {
              this.value = value;
            },
            getValue: function () {
              return Math.abs(this.value) < this.threshold ? 0 : this.value;
            },
            destroy: function () {
              this.pad = null;
              this.events = null;
            }
          });
          module2.exports = Axis;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(239);
          var Button2 = new Class({
            initialize: function Button3(pad, index) {
              this.pad = pad;
              this.events = pad.manager;
              this.index = index;
              this.value = 0;
              this.threshold = 1;
              this.pressed = false;
            },
            update: function (value) {
              this.value = value;
              var pad = this.pad;
              var index = this.index;
              if (value >= this.threshold) {
                if (!this.pressed) {
                  this.pressed = true;
                  this.events.emit(Events.BUTTON_DOWN, pad, this, value);
                  this.pad.emit(Events.GAMEPAD_BUTTON_DOWN, index, value, this);
                }
              } else if (this.pressed) {
                this.pressed = false;
                this.events.emit(Events.BUTTON_UP, pad, this, value);
                this.pad.emit(Events.GAMEPAD_BUTTON_UP, index, value, this);
              }
            },
            destroy: function () {
              this.pad = null;
              this.events = null;
            }
          });
          module2.exports = Button2;
        }, function (module2, exports2, __webpack_require__) {
          var Axis = __webpack_require__(509);
          var Button2 = __webpack_require__(510);
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Vector2 = __webpack_require__(3);
          var Gamepad = new Class({
            Extends: EventEmitter,
            initialize: function Gamepad2(manager, pad) {
              EventEmitter.call(this);
              this.manager = manager;
              this.pad = pad;
              this.id = pad.id;
              this.index = pad.index;
              var buttons = [];
              for (var i = 0; i < pad.buttons.length; i++) {
                buttons.push(new Button2(this, i));
              }
              this.buttons = buttons;
              var axes = [];
              for (i = 0; i < pad.axes.length; i++) {
                axes.push(new Axis(this, i));
              }
              this.axes = axes;
              this.vibration = pad.vibrationActuator;
              var _noButton = {
                value: 0,
                pressed: false
              };
              this._LCLeft = buttons[14] ? buttons[14] : _noButton;
              this._LCRight = buttons[15] ? buttons[15] : _noButton;
              this._LCTop = buttons[12] ? buttons[12] : _noButton;
              this._LCBottom = buttons[13] ? buttons[13] : _noButton;
              this._RCLeft = buttons[2] ? buttons[2] : _noButton;
              this._RCRight = buttons[1] ? buttons[1] : _noButton;
              this._RCTop = buttons[3] ? buttons[3] : _noButton;
              this._RCBottom = buttons[0] ? buttons[0] : _noButton;
              this._FBLeftTop = buttons[4] ? buttons[4] : _noButton;
              this._FBLeftBottom = buttons[6] ? buttons[6] : _noButton;
              this._FBRightTop = buttons[5] ? buttons[5] : _noButton;
              this._FBRightBottom = buttons[7] ? buttons[7] : _noButton;
              var _noAxis = {
                value: 0
              };
              this._HAxisLeft = axes[0] ? axes[0] : _noAxis;
              this._VAxisLeft = axes[1] ? axes[1] : _noAxis;
              this._HAxisRight = axes[2] ? axes[2] : _noAxis;
              this._VAxisRight = axes[3] ? axes[3] : _noAxis;
              this.leftStick = new Vector2();
              this.rightStick = new Vector2();
              this._created = performance.now();
            },
            getAxisTotal: function () {
              return this.axes.length;
            },
            getAxisValue: function (index) {
              return this.axes[index].getValue();
            },
            setAxisThreshold: function (value) {
              for (var i = 0; i < this.axes.length; i++) {
                this.axes[i].threshold = value;
              }
            },
            getButtonTotal: function () {
              return this.buttons.length;
            },
            getButtonValue: function (index) {
              return this.buttons[index].value;
            },
            isButtonDown: function (index) {
              return this.buttons[index].pressed;
            },
            update: function (pad) {
              if (pad.timestamp < this._created) {
                return;
              }
              var i;
              var localButtons = this.buttons;
              var gamepadButtons = pad.buttons;
              var len = localButtons.length;
              for (i = 0; i < len; i++) {
                localButtons[i].update(gamepadButtons[i].value);
              }
              var localAxes = this.axes;
              var gamepadAxes = pad.axes;
              len = localAxes.length;
              for (i = 0; i < len; i++) {
                localAxes[i].update(gamepadAxes[i]);
              }
              if (len >= 2) {
                this.leftStick.set(localAxes[0].getValue(), localAxes[1].getValue());
                if (len >= 4) {
                  this.rightStick.set(localAxes[2].getValue(), localAxes[3].getValue());
                }
              }
            },
            destroy: function () {
              this.removeAllListeners();
              this.manager = null;
              this.pad = null;
              var i;
              for (i = 0; i < this.buttons.length; i++) {
                this.buttons[i].destroy();
              }
              for (i = 0; i < this.axes.length; i++) {
                this.axes[i].destroy();
              }
              this.buttons = [];
              this.axes = [];
            },
            connected: {
              get: function () {
                return this.pad.connected;
              }
            },
            timestamp: {
              get: function () {
                return this.pad.timestamp;
              }
            },
            left: {
              get: function () {
                return this._LCLeft.pressed;
              }
            },
            right: {
              get: function () {
                return this._LCRight.pressed;
              }
            },
            up: {
              get: function () {
                return this._LCTop.pressed;
              }
            },
            down: {
              get: function () {
                return this._LCBottom.pressed;
              }
            },
            A: {
              get: function () {
                return this._RCBottom.pressed;
              }
            },
            Y: {
              get: function () {
                return this._RCTop.pressed;
              }
            },
            X: {
              get: function () {
                return this._RCLeft.pressed;
              }
            },
            B: {
              get: function () {
                return this._RCRight.pressed;
              }
            },
            L1: {
              get: function () {
                return this._FBLeftTop.value;
              }
            },
            L2: {
              get: function () {
                return this._FBLeftBottom.value;
              }
            },
            R1: {
              get: function () {
                return this._FBRightTop.value;
              }
            },
            R2: {
              get: function () {
                return this._FBRightBottom.value;
              }
            }
          });
          module2.exports = Gamepad;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(154);
          var Key = new Class({
            Extends: EventEmitter,
            initialize: function Key2(plugin, keyCode) {
              EventEmitter.call(this);
              this.plugin = plugin;
              this.keyCode = keyCode;
              this.originalEvent = void 0;
              this.enabled = true;
              this.isDown = false;
              this.isUp = true;
              this.altKey = false;
              this.ctrlKey = false;
              this.shiftKey = false;
              this.metaKey = false;
              this.location = 0;
              this.timeDown = 0;
              this.duration = 0;
              this.timeUp = 0;
              this.emitOnRepeat = false;
              this.repeats = 0;
              this._justDown = false;
              this._justUp = false;
              this._tick = -1;
            },
            setEmitOnRepeat: function (value) {
              this.emitOnRepeat = value;
              return this;
            },
            onDown: function (event) {
              this.originalEvent = event;
              if (!this.enabled) {
                return;
              }
              this.altKey = event.altKey;
              this.ctrlKey = event.ctrlKey;
              this.shiftKey = event.shiftKey;
              this.metaKey = event.metaKey;
              this.location = event.location;
              this.repeats++;
              if (!this.isDown) {
                this.isDown = true;
                this.isUp = false;
                this.timeDown = event.timeStamp;
                this.duration = 0;
                this._justDown = true;
                this._justUp = false;
                this.emit(Events.DOWN, this, event);
              } else if (this.emitOnRepeat) {
                this.emit(Events.DOWN, this, event);
              }
            },
            onUp: function (event) {
              this.originalEvent = event;
              if (!this.enabled) {
                return;
              }
              this.isDown = false;
              this.isUp = true;
              this.timeUp = event.timeStamp;
              this.duration = this.timeUp - this.timeDown;
              this.repeats = 0;
              this._justDown = false;
              this._justUp = true;
              this._tick = -1;
              this.emit(Events.UP, this, event);
            },
            reset: function () {
              this.preventDefault = true;
              this.enabled = true;
              this.isDown = false;
              this.isUp = true;
              this.altKey = false;
              this.ctrlKey = false;
              this.shiftKey = false;
              this.metaKey = false;
              this.timeDown = 0;
              this.duration = 0;
              this.timeUp = 0;
              this.repeats = 0;
              this._justDown = false;
              this._justUp = false;
              this._tick = -1;
              return this;
            },
            getDuration: function () {
              if (this.isDown) {
                return this.plugin.game.loop.time - this.timeDown;
              } else {
                return 0;
              }
            },
            destroy: function () {
              this.removeAllListeners();
              this.originalEvent = null;
              this.plugin = null;
            }
          });
          module2.exports = Key;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(154);
          var GetFastValue = __webpack_require__(2);
          var ProcessKeyCombo = __webpack_require__(514);
          var ResetKeyCombo = __webpack_require__(516);
          var KeyCombo = new Class({
            initialize: function KeyCombo2(keyboardPlugin, keys, config) {
              if (config === void 0) {
                config = {};
              }
              if (keys.length < 2) {
                return false;
              }
              this.manager = keyboardPlugin;
              this.enabled = true;
              this.keyCodes = [];
              for (var i = 0; i < keys.length; i++) {
                var char2 = keys[i];
                if (typeof char2 === "string") {
                  this.keyCodes.push(char2.toUpperCase().charCodeAt(0));
                } else if (typeof char2 === "number") {
                  this.keyCodes.push(char2);
                } else if (char2.hasOwnProperty("keyCode")) {
                  this.keyCodes.push(char2.keyCode);
                }
              }
              this.current = this.keyCodes[0];
              this.index = 0;
              this.size = this.keyCodes.length;
              this.timeLastMatched = 0;
              this.matched = false;
              this.timeMatched = 0;
              this.resetOnWrongKey = GetFastValue(config, "resetOnWrongKey", true);
              this.maxKeyDelay = GetFastValue(config, "maxKeyDelay", 0);
              this.resetOnMatch = GetFastValue(config, "resetOnMatch", false);
              this.deleteOnMatch = GetFastValue(config, "deleteOnMatch", false);
              var _this = this;
              var onKeyDownHandler = function (event) {
                if (_this.matched || !_this.enabled) {
                  return;
                }
                var matched = ProcessKeyCombo(event, _this);
                if (matched) {
                  _this.manager.emit(Events.COMBO_MATCH, _this, event);
                  if (_this.resetOnMatch) {
                    ResetKeyCombo(_this);
                  } else if (_this.deleteOnMatch) {
                    _this.destroy();
                  }
                }
              };
              this.onKeyDown = onKeyDownHandler;
              this.manager.on(Events.ANY_KEY_DOWN, this.onKeyDown);
            },
            progress: {
              get: function () {
                return this.index / this.size;
              }
            },
            destroy: function () {
              this.enabled = false;
              this.keyCodes = [];
              this.manager.off(Events.ANY_KEY_DOWN, this.onKeyDown);
              this.manager = null;
            }
          });
          module2.exports = KeyCombo;
        }, function (module2, exports2, __webpack_require__) {
          var AdvanceKeyCombo = __webpack_require__(515);
          var ProcessKeyCombo = function (event, combo) {
            if (combo.matched) {
              return true;
            }
            var comboMatched = false;
            var keyMatched = false;
            if (event.keyCode === combo.current) {
              if (combo.index > 0 && combo.maxKeyDelay > 0) {
                var timeLimit = combo.timeLastMatched + combo.maxKeyDelay;
                if (event.timeStamp <= timeLimit) {
                  keyMatched = true;
                  comboMatched = AdvanceKeyCombo(event, combo);
                }
              } else {
                keyMatched = true;
                comboMatched = AdvanceKeyCombo(event, combo);
              }
            }
            if (!keyMatched && combo.resetOnWrongKey) {
              combo.index = 0;
              combo.current = combo.keyCodes[0];
            }
            if (comboMatched) {
              combo.timeLastMatched = event.timeStamp;
              combo.matched = true;
              combo.timeMatched = event.timeStamp;
            }
            return comboMatched;
          };
          module2.exports = ProcessKeyCombo;
        }, function (module2, exports2) {
          var AdvanceKeyCombo = function (event, combo) {
            combo.timeLastMatched = event.timeStamp;
            combo.index++;
            if (combo.index === combo.size) {
              return true;
            } else {
              combo.current = combo.keyCodes[combo.index];
              return false;
            }
          };
          module2.exports = AdvanceKeyCombo;
        }, function (module2, exports2) {
          var ResetKeyCombo = function (combo) {
            combo.current = combo.keyCodes[0];
            combo.index = 0;
            combo.timeLastMatched = 0;
            combo.matched = false;
            combo.timeMatched = 0;
            return combo;
          };
          module2.exports = ResetKeyCombo;
        }, function (module2, exports2, __webpack_require__) {
          var MergeXHRSettings = __webpack_require__(240);
          var XHRLoader = function (file, globalXHRSettings) {
            var config = MergeXHRSettings(globalXHRSettings, file.xhrSettings);
            var xhr = new XMLHttpRequest();
            xhr.open("GET", file.src, config.async, config.user, config.password);
            xhr.responseType = file.xhrSettings.responseType;
            xhr.timeout = config.timeout;
            if (config.headers) {
              for (var key in config.headers) {
                xhr.setRequestHeader(key, config.headers[key]);
              }
            }
            if (config.header && config.headerValue) {
              xhr.setRequestHeader(config.header, config.headerValue);
            }
            if (config.requestedWith) {
              xhr.setRequestHeader("X-Requested-With", config.requestedWith);
            }
            if (config.overrideMimeType) {
              xhr.overrideMimeType(config.overrideMimeType);
            }
            if (config.withCredentials) {
              xhr.withCredentials = true;
            }
            xhr.onload = file.onLoad.bind(file, xhr);
            xhr.onerror = file.onError.bind(file, xhr);
            xhr.onprogress = file.onProgress.bind(file);
            xhr.send();
            return xhr;
          };
          module2.exports = XHRLoader;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var HTML5AudioFile = __webpack_require__(519);
          var IsPlainObject = __webpack_require__(7);
          var AudioFile = new Class({
            Extends: File,
            initialize: function AudioFile2(loader, key, urlConfig, xhrSettings, audioContext) {
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                xhrSettings = GetFastValue(config, "xhrSettings");
                audioContext = GetFastValue(config, "context", audioContext);
              }
              var fileConfig = {
                type: "audio",
                cache: loader.cacheManager.audio,
                extension: urlConfig.type,
                responseType: "arraybuffer",
                key,
                url: urlConfig.url,
                xhrSettings,
                config: {
                  context: audioContext
                }
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function () {
              this.state = CONST.FILE_PROCESSING;
              var _this = this;
              this.config.context.decodeAudioData(this.xhrLoader.response, function (audioBuffer) {
                _this.data = audioBuffer;
                _this.onProcessComplete();
              }, function (e) {
                console.error("Error decoding audio: " + _this.key + " - ", e ? e.message : null);
                _this.onProcessError();
              });
              this.config.context = null;
            }
          });
          AudioFile.create = function (loader, key, urls, config, xhrSettings) {
            var game = loader.systems.game;
            var audioConfig = game.config.audio;
            var deviceAudio = game.device.audio;
            if (IsPlainObject(key)) {
              urls = GetFastValue(key, "url", []);
              config = GetFastValue(key, "config", {});
            }
            var urlConfig = AudioFile.getAudioURL(game, urls);
            if (!urlConfig) {
              return null;
            }
            if (deviceAudio.webAudio && !audioConfig.disableWebAudio) {
              return new AudioFile(loader, key, urlConfig, xhrSettings, game.sound.context);
            } else {
              return new HTML5AudioFile(loader, key, urlConfig, config);
            }
          };
          AudioFile.getAudioURL = function (game, urls) {
            if (!Array.isArray(urls)) {
              urls = [urls];
            }
            for (var i = 0; i < urls.length; i++) {
              var url = GetFastValue(urls[i], "url", urls[i]);
              if (url.indexOf("blob:") === 0 || url.indexOf("data:") === 0) {
                return {
                  url,
                  type: ""
                };
              }
              var audioType = url.match(/\.([a-zA-Z0-9]+)($|\?)/);
              audioType = GetFastValue(urls[i], "type", audioType ? audioType[1] : "").toLowerCase();
              if (game.device.audio[audioType]) {
                return {
                  url,
                  type: audioType
                };
              }
            }
            return null;
          };
          FileTypesManager.register("audio", function (key, urls, config, xhrSettings) {
            var game = this.systems.game;
            var audioConfig = game.config.audio;
            var deviceAudio = game.device.audio;
            if (audioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
              return this;
            }
            var audioFile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                audioFile = AudioFile.create(this, key[i]);
                if (audioFile) {
                  this.addFile(audioFile);
                }
              }
            } else {
              audioFile = AudioFile.create(this, key, urls, config, xhrSettings);
              if (audioFile) {
                this.addFile(audioFile);
              }
            }
            return this;
          });
          module2.exports = AudioFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(95);
          var File = __webpack_require__(23);
          var GetFastValue = __webpack_require__(2);
          var GetURL = __webpack_require__(155);
          var IsPlainObject = __webpack_require__(7);
          var HTML5AudioFile = new Class({
            Extends: File,
            initialize: function HTML5AudioFile2(loader, key, urlConfig, audioConfig) {
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                audioConfig = GetFastValue(config, "config", audioConfig);
              }
              var fileConfig = {
                type: "audio",
                cache: loader.cacheManager.audio,
                extension: urlConfig.type,
                key,
                url: urlConfig.url,
                config: audioConfig
              };
              File.call(this, loader, fileConfig);
              this.locked = ("ontouchstart" in window);
              this.loaded = false;
              this.filesLoaded = 0;
              this.filesTotal = 0;
            },
            onLoad: function () {
              if (this.loaded) {
                return;
              }
              this.loaded = true;
              this.loader.nextFile(this, true);
            },
            onError: function () {
              for (var i = 0; i < this.data.length; i++) {
                var audio = this.data[i];
                audio.oncanplaythrough = null;
                audio.onerror = null;
              }
              this.loader.nextFile(this, false);
            },
            onProgress: function (event) {
              var audio = event.target;
              audio.oncanplaythrough = null;
              audio.onerror = null;
              this.filesLoaded++;
              this.percentComplete = Math.min(this.filesLoaded / this.filesTotal, 1);
              this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);
              if (this.filesLoaded === this.filesTotal) {
                this.onLoad();
              }
            },
            load: function () {
              this.data = [];
              var instances = this.config && this.config.instances || 1;
              this.filesTotal = instances;
              this.filesLoaded = 0;
              this.percentComplete = 0;
              for (var i = 0; i < instances; i++) {
                var audio = new Audio();
                if (!audio.dataset) {
                  audio.dataset = {};
                }
                audio.dataset.name = this.key + ("0" + i).slice(-2);
                audio.dataset.used = "false";
                if (this.locked) {
                  audio.dataset.locked = "true";
                } else {
                  audio.dataset.locked = "false";
                  audio.preload = "auto";
                  audio.oncanplaythrough = this.onProgress.bind(this);
                  audio.onerror = this.onError.bind(this);
                }
                this.data.push(audio);
              }
              for (i = 0; i < this.data.length; i++) {
                audio = this.data[i];
                audio.src = GetURL(this, this.loader.baseURL);
                if (!this.locked) {
                  audio.load();
                }
              }
              if (this.locked) {
                setTimeout(this.onLoad.bind(this));
              }
            }
          });
          module2.exports = HTML5AudioFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var ScriptFile = new Class({
            Extends: File,
            initialize: function ScriptFile2(loader, key, url, xhrSettings) {
              var extension = "js";
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                url = GetFastValue(config, "url");
                xhrSettings = GetFastValue(config, "xhrSettings");
                extension = GetFastValue(config, "extension", extension);
              }
              var fileConfig = {
                type: "script",
                cache: false,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function () {
              this.state = CONST.FILE_PROCESSING;
              this.data = document.createElement("script");
              this.data.language = "javascript";
              this.data.type = "text/javascript";
              this.data.defer = false;
              this.data.text = this.xhrLoader.responseText;
              document.head.appendChild(this.data);
              this.onProcessComplete();
            }
          });
          FileTypesManager.register("script", function (key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new ScriptFile(this, key[i]));
              }
            } else {
              this.addFile(new ScriptFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = ScriptFile;
        }, function (module2, exports2, __webpack_require__) {
          var ArcadeImage = __webpack_require__(522);
          var ArcadeSprite = __webpack_require__(157);
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(62);
          var PhysicsGroup = __webpack_require__(524);
          var StaticPhysicsGroup = __webpack_require__(525);
          var Factory = new Class({
            initialize: function Factory2(world) {
              this.world = world;
              this.scene = world.scene;
              this.sys = world.scene.sys;
            },
            collider: function (object1, object2, collideCallback, processCallback, callbackContext) {
              return this.world.addCollider(object1, object2, collideCallback, processCallback, callbackContext);
            },
            overlap: function (object1, object2, collideCallback, processCallback, callbackContext) {
              return this.world.addOverlap(object1, object2, collideCallback, processCallback, callbackContext);
            },
            existing: function (gameObject, isStatic) {
              var type = isStatic ? CONST.STATIC_BODY : CONST.DYNAMIC_BODY;
              this.world.enableBody(gameObject, type);
              return gameObject;
            },
            staticImage: function (x, y, key, frame) {
              var image = new ArcadeImage(this.scene, x, y, key, frame);
              this.sys.displayList.add(image);
              this.world.enableBody(image, CONST.STATIC_BODY);
              return image;
            },
            image: function (x, y, key, frame) {
              var image = new ArcadeImage(this.scene, x, y, key, frame);
              this.sys.displayList.add(image);
              this.world.enableBody(image, CONST.DYNAMIC_BODY);
              return image;
            },
            staticSprite: function (x, y, key, frame) {
              var sprite = new ArcadeSprite(this.scene, x, y, key, frame);
              this.sys.displayList.add(sprite);
              this.sys.updateList.add(sprite);
              this.world.enableBody(sprite, CONST.STATIC_BODY);
              return sprite;
            },
            sprite: function (x, y, key, frame) {
              var sprite = new ArcadeSprite(this.scene, x, y, key, frame);
              this.sys.displayList.add(sprite);
              this.sys.updateList.add(sprite);
              this.world.enableBody(sprite, CONST.DYNAMIC_BODY);
              return sprite;
            },
            staticGroup: function (children, config) {
              return this.sys.updateList.add(new StaticPhysicsGroup(this.world, this.world.scene, children, config));
            },
            group: function (children, config) {
              return this.sys.updateList.add(new PhysicsGroup(this.world, this.world.scene, children, config));
            },
            destroy: function () {
              this.world = null;
              this.scene = null;
              this.sys = null;
            }
          });
          module2.exports = Factory;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(243);
          var Image2 = __webpack_require__(125);
          var ArcadeImage = new Class({
            Extends: Image2,
            Mixins: [Components.Acceleration, Components.Angular, Components.Bounce, Components.Debug, Components.Drag, Components.Enable, Components.Friction, Components.Gravity, Components.Immovable, Components.Mass, Components.Pushable, Components.Size, Components.Velocity],
            initialize: function ArcadeImage2(scene, x, y, texture, frame) {
              Image2.call(this, scene, x, y, texture, frame);
              this.body = null;
            }
          });
          module2.exports = ArcadeImage;
        }, function (module2, exports2, __webpack_require__) {
          var OverlapRect = __webpack_require__(244);
          var Circle = __webpack_require__(65);
          var CircleToCircle = __webpack_require__(231);
          var CircleToRectangle = __webpack_require__(151);
          var OverlapCirc = function (world, x, y, radius, includeDynamic, includeStatic) {
            var bodiesInRect = OverlapRect(world, x - radius, y - radius, 2 * radius, 2 * radius, includeDynamic, includeStatic);
            if (bodiesInRect.length === 0) {
              return bodiesInRect;
            }
            var area = new Circle(x, y, radius);
            var circFromBody = new Circle();
            var bodiesInArea = [];
            for (var i = 0; i < bodiesInRect.length; i++) {
              var body = bodiesInRect[i];
              if (body.isCircle) {
                circFromBody.setTo(body.center.x, body.center.y, body.halfWidth);
                if (CircleToCircle(area, circFromBody)) {
                  bodiesInArea.push(body);
                }
              } else if (CircleToRectangle(area, body)) {
                bodiesInArea.push(body);
              }
            }
            return bodiesInArea;
          };
          module2.exports = OverlapCirc;
        }, function (module2, exports2, __webpack_require__) {
          var ArcadeSprite = __webpack_require__(157);
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(62);
          var GetFastValue = __webpack_require__(2);
          var Group = __webpack_require__(113);
          var IsPlainObject = __webpack_require__(7);
          var PhysicsGroup = new Class({
            Extends: Group,
            initialize: function PhysicsGroup2(world, scene, children, config) {
              if (!children && !config) {
                config = {
                  internalCreateCallback: this.createCallbackHandler,
                  internalRemoveCallback: this.removeCallbackHandler
                };
              } else if (IsPlainObject(children)) {
                config = children;
                children = null;
                config.internalCreateCallback = this.createCallbackHandler;
                config.internalRemoveCallback = this.removeCallbackHandler;
              } else if (Array.isArray(children) && IsPlainObject(children[0])) {
                config = children[0];
                var _this = this;
                children.forEach(function (singleConfig) {
                  singleConfig.internalCreateCallback = _this.createCallbackHandler;
                  singleConfig.internalRemoveCallback = _this.removeCallbackHandler;
                });
                children = null;
              } else {
                config = {
                  internalCreateCallback: this.createCallbackHandler,
                  internalRemoveCallback: this.removeCallbackHandler
                };
              }
              this.world = world;
              config.classType = GetFastValue(config, "classType", ArcadeSprite);
              this.physicsType = CONST.DYNAMIC_BODY;
              this.defaults = {
                setCollideWorldBounds: GetFastValue(config, "collideWorldBounds", false),
                setBoundsRectangle: GetFastValue(config, "customBoundsRectangle", null),
                setAccelerationX: GetFastValue(config, "accelerationX", 0),
                setAccelerationY: GetFastValue(config, "accelerationY", 0),
                setAllowDrag: GetFastValue(config, "allowDrag", true),
                setAllowGravity: GetFastValue(config, "allowGravity", true),
                setAllowRotation: GetFastValue(config, "allowRotation", true),
                setBounceX: GetFastValue(config, "bounceX", 0),
                setBounceY: GetFastValue(config, "bounceY", 0),
                setDragX: GetFastValue(config, "dragX", 0),
                setDragY: GetFastValue(config, "dragY", 0),
                setEnable: GetFastValue(config, "enable", true),
                setGravityX: GetFastValue(config, "gravityX", 0),
                setGravityY: GetFastValue(config, "gravityY", 0),
                setFrictionX: GetFastValue(config, "frictionX", 0),
                setFrictionY: GetFastValue(config, "frictionY", 0),
                setMaxVelocityX: GetFastValue(config, "maxVelocityX", 1e4),
                setMaxVelocityY: GetFastValue(config, "maxVelocityY", 1e4),
                setVelocityX: GetFastValue(config, "velocityX", 0),
                setVelocityY: GetFastValue(config, "velocityY", 0),
                setAngularVelocity: GetFastValue(config, "angularVelocity", 0),
                setAngularAcceleration: GetFastValue(config, "angularAcceleration", 0),
                setAngularDrag: GetFastValue(config, "angularDrag", 0),
                setMass: GetFastValue(config, "mass", 1),
                setImmovable: GetFastValue(config, "immovable", false)
              };
              Group.call(this, scene, children, config);
              this.type = "PhysicsGroup";
            },
            createCallbackHandler: function (child) {
              if (!child.body) {
                this.world.enableBody(child, CONST.DYNAMIC_BODY);
              }
              var body = child.body;
              for (var key in this.defaults) {
                body[key](this.defaults[key]);
              }
            },
            removeCallbackHandler: function (child) {
              if (child.body) {
                this.world.disableBody(child);
              }
            },
            setVelocity: function (x, y, step) {
              if (step === void 0) {
                step = 0;
              }
              var items = this.getChildren();
              for (var i = 0; i < items.length; i++) {
                items[i].body.velocity.set(x + i * step, y + i * step);
              }
              return this;
            },
            setVelocityX: function (value, step) {
              if (step === void 0) {
                step = 0;
              }
              var items = this.getChildren();
              for (var i = 0; i < items.length; i++) {
                items[i].body.velocity.x = value + i * step;
              }
              return this;
            },
            setVelocityY: function (value, step) {
              if (step === void 0) {
                step = 0;
              }
              var items = this.getChildren();
              for (var i = 0; i < items.length; i++) {
                items[i].body.velocity.y = value + i * step;
              }
              return this;
            }
          });
          module2.exports = PhysicsGroup;
        }, function (module2, exports2, __webpack_require__) {
          var ArcadeSprite = __webpack_require__(157);
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(62);
          var GetFastValue = __webpack_require__(2);
          var Group = __webpack_require__(113);
          var IsPlainObject = __webpack_require__(7);
          var StaticPhysicsGroup = new Class({
            Extends: Group,
            initialize: function StaticPhysicsGroup2(world, scene, children, config) {
              if (!children && !config) {
                config = {
                  internalCreateCallback: this.createCallbackHandler,
                  internalRemoveCallback: this.removeCallbackHandler,
                  createMultipleCallback: this.createMultipleCallbackHandler,
                  classType: ArcadeSprite
                };
              } else if (IsPlainObject(children)) {
                config = children;
                children = null;
                config.internalCreateCallback = this.createCallbackHandler;
                config.internalRemoveCallback = this.removeCallbackHandler;
                config.createMultipleCallback = this.createMultipleCallbackHandler;
                config.classType = GetFastValue(config, "classType", ArcadeSprite);
              } else if (Array.isArray(children) && IsPlainObject(children[0])) {
                config = children;
                children = null;
                config.forEach(function (singleConfig) {
                  singleConfig.internalCreateCallback = this.createCallbackHandler;
                  singleConfig.internalRemoveCallback = this.removeCallbackHandler;
                  singleConfig.createMultipleCallback = this.createMultipleCallbackHandler;
                  singleConfig.classType = GetFastValue(singleConfig, "classType", ArcadeSprite);
                });
              } else {
                config = {
                  internalCreateCallback: this.createCallbackHandler,
                  internalRemoveCallback: this.removeCallbackHandler
                };
              }
              this.world = world;
              this.physicsType = CONST.STATIC_BODY;
              Group.call(this, scene, children, config);
              this.type = "StaticPhysicsGroup";
            },
            createCallbackHandler: function (child) {
              if (!child.body) {
                this.world.enableBody(child, CONST.STATIC_BODY);
              }
            },
            removeCallbackHandler: function (child) {
              if (child.body) {
                this.world.disableBody(child);
              }
            },
            createMultipleCallbackHandler: function () {
              this.refresh();
            },
            refresh: function () {
              var children = this.children.entries;
              for (var i = 0; i < children.length; i++) {
                children[i].body.reset();
              }
              return this;
            }
          });
          module2.exports = StaticPhysicsGroup;
        }, function (module2, exports2, __webpack_require__) {
          var AngleBetweenPoints = __webpack_require__(350);
          var Body = __webpack_require__(527);
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var Collider = __webpack_require__(528);
          var CONST = __webpack_require__(62);
          var DistanceBetween = __webpack_require__(50);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(245);
          var FuzzyEqual = __webpack_require__(124);
          var FuzzyGreaterThan = __webpack_require__(354);
          var FuzzyLessThan = __webpack_require__(355);
          var GetOverlapX = __webpack_require__(246);
          var GetOverlapY = __webpack_require__(247);
          var GetTilesWithinWorldXY = __webpack_require__(529);
          var GetValue = __webpack_require__(6);
          var MATH_CONST = __webpack_require__(14);
          var ProcessQueue = __webpack_require__(211);
          var ProcessTileCallbacks = __webpack_require__(530);
          var Rectangle = __webpack_require__(10);
          var RTree = __webpack_require__(531);
          var SeparateTile = __webpack_require__(532);
          var SeparateX = __webpack_require__(537);
          var SeparateY = __webpack_require__(538);
          var Set = __webpack_require__(149);
          var StaticBody = __webpack_require__(539);
          var TileIntersectsBody = __webpack_require__(248);
          var TransformMatrix = __webpack_require__(25);
          var Vector2 = __webpack_require__(3);
          var Wrap = __webpack_require__(68);
          var World = new Class({
            Extends: EventEmitter,
            initialize: function World2(scene, config) {
              EventEmitter.call(this);
              this.scene = scene;
              this.bodies = new Set();
              this.staticBodies = new Set();
              this.pendingDestroy = new Set();
              this.colliders = new ProcessQueue();
              this.gravity = new Vector2(GetValue(config, "gravity.x", 0), GetValue(config, "gravity.y", 0));
              this.bounds = new Rectangle(GetValue(config, "x", 0), GetValue(config, "y", 0), GetValue(config, "width", scene.sys.scale.width), GetValue(config, "height", scene.sys.scale.height));
              this.checkCollision = {
                up: GetValue(config, "checkCollision.up", true),
                down: GetValue(config, "checkCollision.down", true),
                left: GetValue(config, "checkCollision.left", true),
                right: GetValue(config, "checkCollision.right", true)
              };
              this.fps = GetValue(config, "fps", 60);
              this.fixedStep = GetValue(config, "fixedStep", true);
              this._elapsed = 0;
              this._frameTime = 1 / this.fps;
              this._frameTimeMS = 1e3 * this._frameTime;
              this.stepsLastFrame = 0;
              this.timeScale = GetValue(config, "timeScale", 1);
              this.OVERLAP_BIAS = GetValue(config, "overlapBias", 4);
              this.TILE_BIAS = GetValue(config, "tileBias", 16);
              this.forceX = GetValue(config, "forceX", false);
              this.isPaused = GetValue(config, "isPaused", false);
              this._total = 0;
              this.drawDebug = GetValue(config, "debug", false);
              this.debugGraphic;
              this.defaults = {
                debugShowBody: GetValue(config, "debugShowBody", true),
                debugShowStaticBody: GetValue(config, "debugShowStaticBody", true),
                debugShowVelocity: GetValue(config, "debugShowVelocity", true),
                bodyDebugColor: GetValue(config, "debugBodyColor", 16711935),
                staticBodyDebugColor: GetValue(config, "debugStaticBodyColor", 255),
                velocityDebugColor: GetValue(config, "debugVelocityColor", 65280)
              };
              this.maxEntries = GetValue(config, "maxEntries", 16);
              this.useTree = GetValue(config, "useTree", true);
              this.tree = new RTree(this.maxEntries);
              this.staticTree = new RTree(this.maxEntries);
              this.treeMinMax = {
                minX: 0,
                minY: 0,
                maxX: 0,
                maxY: 0
              };
              this._tempMatrix = new TransformMatrix();
              this._tempMatrix2 = new TransformMatrix();
              if (this.drawDebug) {
                this.createDebugGraphic();
              }
            },
            enable: function (object, bodyType) {
              if (bodyType === void 0) {
                bodyType = CONST.DYNAMIC_BODY;
              }
              if (!Array.isArray(object)) {
                object = [object];
              }
              for (var i = 0; i < object.length; i++) {
                var entry = object[i];
                if (entry.isParent) {
                  var children = entry.getChildren();
                  for (var c = 0; c < children.length; c++) {
                    var child = children[c];
                    if (child.isParent) {
                      this.enable(child, bodyType);
                    } else {
                      this.enableBody(child, bodyType);
                    }
                  }
                } else {
                  this.enableBody(entry, bodyType);
                }
              }
            },
            enableBody: function (object, bodyType) {
              if (bodyType === void 0) {
                bodyType = CONST.DYNAMIC_BODY;
              }
              if (!object.body) {
                if (bodyType === CONST.DYNAMIC_BODY) {
                  object.body = new Body(this, object);
                } else if (bodyType === CONST.STATIC_BODY) {
                  object.body = new StaticBody(this, object);
                }
              }
              this.add(object.body);
              return object;
            },
            add: function (body) {
              if (body.physicsType === CONST.DYNAMIC_BODY) {
                this.bodies.set(body);
              } else if (body.physicsType === CONST.STATIC_BODY) {
                this.staticBodies.set(body);
                this.staticTree.insert(body);
              }
              body.enable = true;
              return body;
            },
            disable: function (object) {
              if (!Array.isArray(object)) {
                object = [object];
              }
              for (var i = 0; i < object.length; i++) {
                var entry = object[i];
                if (entry.isParent) {
                  var children = entry.getChildren();
                  for (var c = 0; c < children.length; c++) {
                    var child = children[c];
                    if (child.isParent) {
                      this.disable(child);
                    } else {
                      this.disableBody(child.body);
                    }
                  }
                } else {
                  this.disableBody(entry.body);
                }
              }
            },
            disableBody: function (body) {
              this.remove(body);
              body.enable = false;
            },
            remove: function (body) {
              if (body.physicsType === CONST.DYNAMIC_BODY) {
                this.tree.remove(body);
                this.bodies.delete(body);
              } else if (body.physicsType === CONST.STATIC_BODY) {
                this.staticBodies.delete(body);
                this.staticTree.remove(body);
              }
            },
            createDebugGraphic: function () {
              var graphic = this.scene.sys.add.graphics({
                x: 0,
                y: 0
              });
              graphic.setDepth(Number.MAX_VALUE);
              this.debugGraphic = graphic;
              this.drawDebug = true;
              return graphic;
            },
            setBounds: function (x, y, width, height, checkLeft, checkRight, checkUp, checkDown) {
              this.bounds.setTo(x, y, width, height);
              if (checkLeft !== void 0) {
                this.setBoundsCollision(checkLeft, checkRight, checkUp, checkDown);
              }
              return this;
            },
            setBoundsCollision: function (left, right, up, down) {
              if (left === void 0) {
                left = true;
              }
              if (right === void 0) {
                right = true;
              }
              if (up === void 0) {
                up = true;
              }
              if (down === void 0) {
                down = true;
              }
              this.checkCollision.left = left;
              this.checkCollision.right = right;
              this.checkCollision.up = up;
              this.checkCollision.down = down;
              return this;
            },
            pause: function () {
              this.isPaused = true;
              this.emit(Events.PAUSE);
              return this;
            },
            resume: function () {
              this.isPaused = false;
              this.emit(Events.RESUME);
              return this;
            },
            addCollider: function (object1, object2, collideCallback, processCallback, callbackContext) {
              if (collideCallback === void 0) {
                collideCallback = null;
              }
              if (processCallback === void 0) {
                processCallback = null;
              }
              if (callbackContext === void 0) {
                callbackContext = collideCallback;
              }
              var collider = new Collider(this, false, object1, object2, collideCallback, processCallback, callbackContext);
              this.colliders.add(collider);
              return collider;
            },
            addOverlap: function (object1, object2, collideCallback, processCallback, callbackContext) {
              if (collideCallback === void 0) {
                collideCallback = null;
              }
              if (processCallback === void 0) {
                processCallback = null;
              }
              if (callbackContext === void 0) {
                callbackContext = collideCallback;
              }
              var collider = new Collider(this, true, object1, object2, collideCallback, processCallback, callbackContext);
              this.colliders.add(collider);
              return collider;
            },
            removeCollider: function (collider) {
              this.colliders.remove(collider);
              return this;
            },
            setFPS: function (framerate) {
              this.fps = framerate;
              this._frameTime = 1 / this.fps;
              this._frameTimeMS = 1e3 * this._frameTime;
              return this;
            },
            update: function (time, delta) {
              if (this.isPaused || this.bodies.size === 0) {
                return;
              }
              var i;
              var fixedDelta = this._frameTime;
              var msPerFrame = this._frameTimeMS * this.timeScale;
              this._elapsed += delta;
              var body;
              var bodies = this.bodies.entries;
              var willStep = this._elapsed >= msPerFrame;
              if (!this.fixedStep) {
                fixedDelta = delta * 1e-3;
                willStep = true;
                this._elapsed = 0;
              }
              for (i = 0; i < bodies.length; i++) {
                body = bodies[i];
                if (body.enable) {
                  body.preUpdate(willStep, fixedDelta);
                }
              }
              if (willStep) {
                this._elapsed -= msPerFrame;
                this.stepsLastFrame = 1;
                if (this.useTree) {
                  this.tree.clear();
                  this.tree.load(bodies);
                }
                var colliders = this.colliders.update();
                for (i = 0; i < colliders.length; i++) {
                  var collider = colliders[i];
                  if (collider.active) {
                    collider.update();
                  }
                }
                this.emit(Events.WORLD_STEP, fixedDelta);
              }
              while (this._elapsed >= msPerFrame) {
                this._elapsed -= msPerFrame;
                this.step(fixedDelta);
              }
            },
            step: function (delta) {
              var i;
              var body;
              var bodies = this.bodies.entries;
              var len = bodies.length;
              for (i = 0; i < len; i++) {
                body = bodies[i];
                if (body.enable) {
                  body.update(delta);
                }
              }
              if (this.useTree) {
                this.tree.clear();
                this.tree.load(bodies);
              }
              var colliders = this.colliders.update();
              for (i = 0; i < colliders.length; i++) {
                var collider = colliders[i];
                if (collider.active) {
                  collider.update();
                }
              }
              this.emit(Events.WORLD_STEP, delta);
              this.stepsLastFrame++;
            },
            postUpdate: function () {
              var i;
              var body;
              var bodies = this.bodies.entries;
              var len = bodies.length;
              var dynamic = this.bodies;
              var staticBodies = this.staticBodies;
              if (this.stepsLastFrame) {
                this.stepsLastFrame = 0;
                for (i = 0; i < len; i++) {
                  body = bodies[i];
                  if (body.enable) {
                    body.postUpdate();
                  }
                }
              }
              if (this.drawDebug) {
                var graphics = this.debugGraphic;
                graphics.clear();
                for (i = 0; i < len; i++) {
                  body = bodies[i];
                  if (body.willDrawDebug()) {
                    body.drawDebug(graphics);
                  }
                }
                bodies = staticBodies.entries;
                len = bodies.length;
                for (i = 0; i < len; i++) {
                  body = bodies[i];
                  if (body.willDrawDebug()) {
                    body.drawDebug(graphics);
                  }
                }
              }
              var pending = this.pendingDestroy;
              if (pending.size > 0) {
                var dynamicTree = this.tree;
                var staticTree = this.staticTree;
                bodies = pending.entries;
                len = bodies.length;
                for (i = 0; i < len; i++) {
                  body = bodies[i];
                  if (body.physicsType === CONST.DYNAMIC_BODY) {
                    dynamicTree.remove(body);
                    dynamic.delete(body);
                  } else if (body.physicsType === CONST.STATIC_BODY) {
                    staticTree.remove(body);
                    staticBodies.delete(body);
                  }
                  body.world = void 0;
                  body.gameObject = void 0;
                }
                pending.clear();
              }
            },
            updateMotion: function (body, delta) {
              if (body.allowRotation) {
                this.computeAngularVelocity(body, delta);
              }
              this.computeVelocity(body, delta);
            },
            computeAngularVelocity: function (body, delta) {
              var velocity = body.angularVelocity;
              var acceleration = body.angularAcceleration;
              var drag = body.angularDrag;
              var max = body.maxAngular;
              if (acceleration) {
                velocity += acceleration * delta;
              } else if (body.allowDrag && drag) {
                drag *= delta;
                if (FuzzyGreaterThan(velocity - drag, 0, 0.1)) {
                  velocity -= drag;
                } else if (FuzzyLessThan(velocity + drag, 0, 0.1)) {
                  velocity += drag;
                } else {
                  velocity = 0;
                }
              }
              velocity = Clamp(velocity, -max, max);
              var velocityDelta = velocity - body.angularVelocity;
              body.angularVelocity += velocityDelta;
              body.rotation += body.angularVelocity * delta;
            },
            computeVelocity: function (body, delta) {
              var velocityX = body.velocity.x;
              var accelerationX = body.acceleration.x;
              var dragX = body.drag.x;
              var maxX = body.maxVelocity.x;
              var velocityY = body.velocity.y;
              var accelerationY = body.acceleration.y;
              var dragY = body.drag.y;
              var maxY = body.maxVelocity.y;
              var speed = body.speed;
              var maxSpeed = body.maxSpeed;
              var allowDrag = body.allowDrag;
              var useDamping = body.useDamping;
              if (body.allowGravity) {
                velocityX += (this.gravity.x + body.gravity.x) * delta;
                velocityY += (this.gravity.y + body.gravity.y) * delta;
              }
              if (accelerationX) {
                velocityX += accelerationX * delta;
              } else if (allowDrag && dragX) {
                if (useDamping) {
                  dragX = Math.pow(dragX, delta);
                  velocityX *= dragX;
                  speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
                  if (FuzzyEqual(speed, 0, 1e-3)) {
                    velocityX = 0;
                  }
                } else {
                  dragX *= delta;
                  if (FuzzyGreaterThan(velocityX - dragX, 0, 0.01)) {
                    velocityX -= dragX;
                  } else if (FuzzyLessThan(velocityX + dragX, 0, 0.01)) {
                    velocityX += dragX;
                  } else {
                    velocityX = 0;
                  }
                }
              }
              if (accelerationY) {
                velocityY += accelerationY * delta;
              } else if (allowDrag && dragY) {
                if (useDamping) {
                  dragY = Math.pow(dragY, delta);
                  velocityY *= dragY;
                  speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
                  if (FuzzyEqual(speed, 0, 1e-3)) {
                    velocityY = 0;
                  }
                } else {
                  dragY *= delta;
                  if (FuzzyGreaterThan(velocityY - dragY, 0, 0.01)) {
                    velocityY -= dragY;
                  } else if (FuzzyLessThan(velocityY + dragY, 0, 0.01)) {
                    velocityY += dragY;
                  } else {
                    velocityY = 0;
                  }
                }
              }
              velocityX = Clamp(velocityX, -maxX, maxX);
              velocityY = Clamp(velocityY, -maxY, maxY);
              body.velocity.set(velocityX, velocityY);
              if (maxSpeed > -1 && speed > maxSpeed) {
                body.velocity.normalize().scale(maxSpeed);
                speed = maxSpeed;
              }
              body.speed = speed;
            },
            separate: function (body1, body2, processCallback, callbackContext, overlapOnly, intersects) {
              if (!intersects && !body1.enable || !body2.enable || body1.checkCollision.none || body2.checkCollision.none || !this.intersects(body1, body2)) {
                return false;
              }
              if (processCallback && processCallback.call(callbackContext, body1.gameObject, body2.gameObject) === false) {
                return false;
              }
              if (body1.isCircle && body2.isCircle) {
                return this.separateCircle(body1, body2, overlapOnly);
              }
              if (body1.isCircle !== body2.isCircle) {
                var bodyRect = body1.isCircle ? body2 : body1;
                var bodyCircle = body1.isCircle ? body1 : body2;
                var rect = {
                  x: bodyRect.x,
                  y: bodyRect.y,
                  right: bodyRect.right,
                  bottom: bodyRect.bottom
                };
                var circle = bodyCircle.center;
                if (circle.y < rect.y || circle.y > rect.bottom) {
                  if (circle.x < rect.x || circle.x > rect.right) {
                    return this.separateCircle(body1, body2, overlapOnly);
                  }
                }
              }
              var resultX = false;
              var resultY = false;
              if (overlapOnly) {
                resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);
                resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);
              } else if (this.forceX || Math.abs(this.gravity.y + body1.gravity.y) < Math.abs(this.gravity.x + body1.gravity.x)) {
                resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);
                if (this.intersects(body1, body2)) {
                  resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);
                }
              } else {
                resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);
                if (this.intersects(body1, body2)) {
                  resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);
                }
              }
              var result = resultX || resultY;
              if (result) {
                if (overlapOnly) {
                  if (body1.onOverlap || body2.onOverlap) {
                    this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2);
                  }
                } else if (body1.onCollide || body2.onCollide) {
                  this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2);
                }
              }
              return result;
            },
            separateCircle: function (body1, body2, overlapOnly, bias) {
              GetOverlapX(body1, body2, false, bias);
              GetOverlapY(body1, body2, false, bias);
              var overlap = 0;
              if (body1.isCircle !== body2.isCircle) {
                var rect = {
                  x: body2.isCircle ? body1.position.x : body2.position.x,
                  y: body2.isCircle ? body1.position.y : body2.position.y,
                  right: body2.isCircle ? body1.right : body2.right,
                  bottom: body2.isCircle ? body1.bottom : body2.bottom
                };
                var circle = {
                  x: body1.isCircle ? body1.center.x : body2.center.x,
                  y: body1.isCircle ? body1.center.y : body2.center.y,
                  radius: body1.isCircle ? body1.halfWidth : body2.halfWidth
                };
                if (circle.y < rect.y) {
                  if (circle.x < rect.x) {
                    overlap = DistanceBetween(circle.x, circle.y, rect.x, rect.y) - circle.radius;
                  } else if (circle.x > rect.right) {
                    overlap = DistanceBetween(circle.x, circle.y, rect.right, rect.y) - circle.radius;
                  }
                } else if (circle.y > rect.bottom) {
                  if (circle.x < rect.x) {
                    overlap = DistanceBetween(circle.x, circle.y, rect.x, rect.bottom) - circle.radius;
                  } else if (circle.x > rect.right) {
                    overlap = DistanceBetween(circle.x, circle.y, rect.right, rect.bottom) - circle.radius;
                  }
                }
                overlap *= -1;
              } else {
                overlap = body1.halfWidth + body2.halfWidth - DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y);
              }
              body1.overlapR = overlap;
              body2.overlapR = overlap;
              if (overlapOnly || overlap === 0 || body1.immovable && body2.immovable || body1.customSeparateX || body2.customSeparateX) {
                if (overlap !== 0 && (body1.onOverlap || body2.onOverlap)) {
                  this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2);
                }
                return overlap !== 0;
              }
              var dx = body1.center.x - body2.center.x;
              var dy = body1.center.y - body2.center.y;
              var d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
              var nx = (body2.center.x - body1.center.x) / d || 0;
              var ny = (body2.center.y - body1.center.y) / d || 0;
              var p3 = 2 * (body1.velocity.x * nx + body1.velocity.y * ny - body2.velocity.x * nx - body2.velocity.y * ny) / (body1.mass + body2.mass);
              if (body1.immovable || body2.immovable) {
                p3 *= 2;
              }
              if (!body1.immovable) {
                body1.velocity.x = body1.velocity.x - p3 / body1.mass * nx;
                body1.velocity.y = body1.velocity.y - p3 / body1.mass * ny;
              }
              if (!body2.immovable) {
                body2.velocity.x = body2.velocity.x + p3 / body2.mass * nx;
                body2.velocity.y = body2.velocity.y + p3 / body2.mass * ny;
              }
              if (!body1.immovable && !body2.immovable) {
                overlap /= 2;
              }
              var angle = AngleBetweenPoints(body1.center, body2.center);
              var overlapX = (overlap + MATH_CONST.EPSILON) * Math.cos(angle);
              var overlapY = (overlap + MATH_CONST.EPSILON) * Math.sin(angle);
              if (!body1.immovable) {
                body1.x -= overlapX;
                body1.y -= overlapY;
                body1.updateCenter();
              }
              if (!body2.immovable) {
                body2.x += overlapX;
                body2.y += overlapY;
                body2.updateCenter();
              }
              body1.velocity.x *= body1.bounce.x;
              body1.velocity.y *= body1.bounce.y;
              body2.velocity.x *= body2.bounce.x;
              body2.velocity.y *= body2.bounce.y;
              if (body1.onCollide || body2.onCollide) {
                this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2);
              }
              return true;
            },
            intersects: function (body1, body2) {
              if (body1 === body2) {
                return false;
              }
              if (!body1.isCircle && !body2.isCircle) {
                return !(body1.right <= body2.position.x || body1.bottom <= body2.position.y || body1.position.x >= body2.right || body1.position.y >= body2.bottom);
              } else if (body1.isCircle) {
                if (body2.isCircle) {
                  return DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y) <= body1.halfWidth + body2.halfWidth;
                } else {
                  return this.circleBodyIntersects(body1, body2);
                }
              } else {
                return this.circleBodyIntersects(body2, body1);
              }
            },
            circleBodyIntersects: function (circle, body) {
              var x = Clamp(circle.center.x, body.left, body.right);
              var y = Clamp(circle.center.y, body.top, body.bottom);
              var dx = (circle.center.x - x) * (circle.center.x - x);
              var dy = (circle.center.y - y) * (circle.center.y - y);
              return dx + dy <= circle.halfWidth * circle.halfWidth;
            },
            overlap: function (object1, object2, overlapCallback, processCallback, callbackContext) {
              if (overlapCallback === void 0) {
                overlapCallback = null;
              }
              if (processCallback === void 0) {
                processCallback = null;
              }
              if (callbackContext === void 0) {
                callbackContext = overlapCallback;
              }
              return this.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);
            },
            collide: function (object1, object2, collideCallback, processCallback, callbackContext) {
              if (collideCallback === void 0) {
                collideCallback = null;
              }
              if (processCallback === void 0) {
                processCallback = null;
              }
              if (callbackContext === void 0) {
                callbackContext = collideCallback;
              }
              return this.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);
            },
            collideObjects: function (object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {
              var i;
              var j;
              if (object1.isParent && object1.physicsType === void 0) {
                object1 = object1.children.entries;
              }
              if (object2 && object2.isParent && object2.physicsType === void 0) {
                object2 = object2.children.entries;
              }
              var object1isArray = Array.isArray(object1);
              var object2isArray = Array.isArray(object2);
              this._total = 0;
              if (!object1isArray && !object2isArray) {
                this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
              } else if (!object1isArray && object2isArray) {
                for (i = 0; i < object2.length; i++) {
                  this.collideHandler(object1, object2[i], collideCallback, processCallback, callbackContext, overlapOnly);
                }
              } else if (object1isArray && !object2isArray) {
                if (!object2) {
                  for (i = 0; i < object1.length; i++) {
                    var child = object1[i];
                    for (j = i + 1; j < object1.length; j++) {
                      if (i === j) {
                        continue;
                      }
                      this.collideHandler(child, object1[j], collideCallback, processCallback, callbackContext, overlapOnly);
                    }
                  }
                } else {
                  for (i = 0; i < object1.length; i++) {
                    this.collideHandler(object1[i], object2, collideCallback, processCallback, callbackContext, overlapOnly);
                  }
                }
              } else {
                for (i = 0; i < object1.length; i++) {
                  for (j = 0; j < object2.length; j++) {
                    this.collideHandler(object1[i], object2[j], collideCallback, processCallback, callbackContext, overlapOnly);
                  }
                }
              }
              return this._total > 0;
            },
            collideHandler: function (object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {
              if (object2 === void 0 && object1.isParent) {
                return this.collideGroupVsGroup(object1, object1, collideCallback, processCallback, callbackContext, overlapOnly);
              }
              if (!object1 || !object2) {
                return false;
              }
              if (object1.body) {
                if (object2.body) {
                  return this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                } else if (object2.isParent) {
                  return this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                } else if (object2.isTilemap) {
                  return this.collideSpriteVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                }
              } else if (object1.isParent) {
                if (object2.body) {
                  return this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
                } else if (object2.isParent) {
                  return this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                } else if (object2.isTilemap) {
                  return this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                }
              } else if (object1.isTilemap) {
                if (object2.body) {
                  return this.collideSpriteVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
                } else if (object2.isParent) {
                  return this.collideGroupVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
                }
              }
            },
            collideSpriteVsSprite: function (sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly) {
              if (!sprite1.body || !sprite2.body) {
                return false;
              }
              if (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly)) {
                if (collideCallback) {
                  collideCallback.call(callbackContext, sprite1, sprite2);
                }
                this._total++;
              }
              return true;
            },
            collideSpriteVsGroup: function (sprite, group, collideCallback, processCallback, callbackContext, overlapOnly) {
              var bodyA = sprite.body;
              if (group.length === 0 || !bodyA || !bodyA.enable || bodyA.checkCollision.none) {
                return;
              }
              var i;
              var len;
              var bodyB;
              if (this.useTree || group.physicsType === CONST.STATIC_BODY) {
                var minMax = this.treeMinMax;
                minMax.minX = bodyA.left;
                minMax.minY = bodyA.top;
                minMax.maxX = bodyA.right;
                minMax.maxY = bodyA.bottom;
                var results = group.physicsType === CONST.DYNAMIC_BODY ? this.tree.search(minMax) : this.staticTree.search(minMax);
                len = results.length;
                for (i = 0; i < len; i++) {
                  bodyB = results[i];
                  if (bodyA === bodyB || !bodyB.enable || bodyB.checkCollision.none || !group.contains(bodyB.gameObject)) {
                    continue;
                  }
                  if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly, true)) {
                    if (collideCallback) {
                      collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);
                    }
                    this._total++;
                  }
                }
              } else {
                var children = group.getChildren();
                var skipIndex = group.children.entries.indexOf(sprite);
                len = children.length;
                for (i = 0; i < len; i++) {
                  bodyB = children[i].body;
                  if (!bodyB || i === skipIndex || !bodyB.enable) {
                    continue;
                  }
                  if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly)) {
                    if (collideCallback) {
                      collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);
                    }
                    this._total++;
                  }
                }
              }
            },
            collideGroupVsTilemapLayer: function (group, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) {
              var children = group.getChildren();
              if (children.length === 0) {
                return false;
              }
              var didCollide = false;
              for (var i = 0; i < children.length; i++) {
                if (children[i].body) {
                  if (this.collideSpriteVsTilemapLayer(children[i], tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly)) {
                    didCollide = true;
                  }
                }
              }
              return didCollide;
            },
            collideTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext) {
              if (!sprite.body.enable || tiles.length === 0) {
                return false;
              } else {
                return this.collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, false, false);
              }
            },
            overlapTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext) {
              if (!sprite.body.enable || tiles.length === 0) {
                return false;
              } else {
                return this.collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, true, false);
              }
            },
            collideSpriteVsTilemapLayer: function (sprite, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) {
              var body = sprite.body;
              if (!body.enable || body.checkCollision.none) {
                return false;
              }
              var x = body.position.x;
              var y = body.position.y;
              var w = body.width;
              var h = body.height;
              var layerData = tilemapLayer.layer;
              if (layerData.tileWidth > layerData.baseTileWidth) {
                var xDiff = (layerData.tileWidth - layerData.baseTileWidth) * tilemapLayer.scaleX;
                x -= xDiff;
                w += xDiff;
              }
              if (layerData.tileHeight > layerData.baseTileHeight) {
                var yDiff = (layerData.tileHeight - layerData.baseTileHeight) * tilemapLayer.scaleY;
                h += yDiff;
              }
              var mapData = GetTilesWithinWorldXY(x, y, w, h, null, tilemapLayer.scene.cameras.main, tilemapLayer.layer);
              if (mapData.length === 0) {
                return false;
              } else {
                return this.collideSpriteVsTilesHandler(sprite, mapData, collideCallback, processCallback, callbackContext, overlapOnly, true);
              }
            },
            collideSpriteVsTilesHandler: function (sprite, tiles, collideCallback, processCallback, callbackContext, overlapOnly, isLayer) {
              var body = sprite.body;
              var tile;
              var tileWorldRect = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
              };
              var tilemapLayer;
              var collision = false;
              for (var i = 0; i < tiles.length; i++) {
                tile = tiles[i];
                tilemapLayer = tile.tilemapLayer;
                var point = tilemapLayer.tileToWorldXY(tile.x, tile.y);
                tileWorldRect.left = point.x;
                tileWorldRect.top = point.y;
                if (tile.baseHeight !== tile.height) {
                  tileWorldRect.top -= (tile.height - tile.baseHeight) * tilemapLayer.scaleY;
                }
                tileWorldRect.right = tileWorldRect.left + tile.width * tilemapLayer.scaleX;
                tileWorldRect.bottom = tileWorldRect.top + tile.height * tilemapLayer.scaleY;
                if (TileIntersectsBody(tileWorldRect, body) && (!processCallback || processCallback.call(callbackContext, sprite, tile)) && ProcessTileCallbacks(tile, sprite) && (overlapOnly || SeparateTile(i, body, tile, tileWorldRect, tilemapLayer, this.TILE_BIAS, isLayer))) {
                  this._total++;
                  collision = true;
                  if (collideCallback) {
                    collideCallback.call(callbackContext, sprite, tile);
                  }
                  if (overlapOnly && body.onOverlap) {
                    this.emit(Events.TILE_OVERLAP, sprite, tile, body);
                  } else if (body.onCollide) {
                    this.emit(Events.TILE_COLLIDE, sprite, tile, body);
                  }
                }
              }
              return collision;
            },
            collideGroupVsGroup: function (group1, group2, collideCallback, processCallback, callbackContext, overlapOnly) {
              if (group1.length === 0 || group2.length === 0) {
                return;
              }
              var children = group1.getChildren();
              for (var i = 0; i < children.length; i++) {
                this.collideSpriteVsGroup(children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);
              }
            },
            wrap: function (object, padding) {
              if (object.body) {
                this.wrapObject(object, padding);
              } else if (object.getChildren) {
                this.wrapArray(object.getChildren(), padding);
              } else if (Array.isArray(object)) {
                this.wrapArray(object, padding);
              } else {
                this.wrapObject(object, padding);
              }
            },
            wrapArray: function (objects, padding) {
              for (var i = 0; i < objects.length; i++) {
                this.wrapObject(objects[i], padding);
              }
            },
            wrapObject: function (object, padding) {
              if (padding === void 0) {
                padding = 0;
              }
              object.x = Wrap(object.x, this.bounds.left - padding, this.bounds.right + padding);
              object.y = Wrap(object.y, this.bounds.top - padding, this.bounds.bottom + padding);
            },
            shutdown: function () {
              this.tree.clear();
              this.staticTree.clear();
              this.bodies.clear();
              this.staticBodies.clear();
              this.colliders.destroy();
              this.removeAllListeners();
            },
            destroy: function () {
              this.shutdown();
              this.scene = null;
            }
          });
          module2.exports = World;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(62);
          var Events = __webpack_require__(245);
          var RadToDeg = __webpack_require__(196);
          var Rectangle = __webpack_require__(10);
          var RectangleContains = __webpack_require__(57);
          var Vector2 = __webpack_require__(3);
          var Body = new Class({
            initialize: function Body2(world, gameObject) {
              var width = gameObject.displayWidth ? gameObject.displayWidth : 64;
              var height = gameObject.displayHeight ? gameObject.displayHeight : 64;
              this.world = world;
              this.gameObject = gameObject;
              this.transform = {
                x: gameObject.x,
                y: gameObject.y,
                rotation: gameObject.angle,
                scaleX: gameObject.scaleX,
                scaleY: gameObject.scaleY,
                displayOriginX: gameObject.displayOriginX,
                displayOriginY: gameObject.displayOriginY
              };
              this.debugShowBody = world.defaults.debugShowBody;
              this.debugShowVelocity = world.defaults.debugShowVelocity;
              this.debugBodyColor = world.defaults.bodyDebugColor;
              this.enable = true;
              this.isCircle = false;
              this.radius = 0;
              this.offset = new Vector2();
              this.position = new Vector2(gameObject.x - gameObject.scaleX * gameObject.displayOriginX, gameObject.y - gameObject.scaleY * gameObject.displayOriginY);
              this.prev = this.position.clone();
              this.prevFrame = this.position.clone();
              this.allowRotation = true;
              this.rotation = gameObject.angle;
              this.preRotation = gameObject.angle;
              this.width = width;
              this.height = height;
              this.sourceWidth = width;
              this.sourceHeight = height;
              if (gameObject.frame) {
                this.sourceWidth = gameObject.frame.realWidth;
                this.sourceHeight = gameObject.frame.realHeight;
              }
              this.halfWidth = Math.abs(width / 2);
              this.halfHeight = Math.abs(height / 2);
              this.center = new Vector2(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
              this.velocity = new Vector2();
              this.newVelocity = new Vector2();
              this.deltaMax = new Vector2();
              this.acceleration = new Vector2();
              this.allowDrag = true;
              this.drag = new Vector2();
              this.allowGravity = true;
              this.gravity = new Vector2();
              this.bounce = new Vector2();
              this.worldBounce = null;
              this.customBoundsRectangle = world.bounds;
              this.onWorldBounds = false;
              this.onCollide = false;
              this.onOverlap = false;
              this.maxVelocity = new Vector2(1e4, 1e4);
              this.maxSpeed = -1;
              this.friction = new Vector2(1, 0);
              this.useDamping = false;
              this.angularVelocity = 0;
              this.angularAcceleration = 0;
              this.angularDrag = 0;
              this.maxAngular = 1e3;
              this.mass = 1;
              this.angle = 0;
              this.speed = 0;
              this.facing = CONST.FACING_NONE;
              this.immovable = false;
              this.pushable = true;
              this.moves = true;
              this.customSeparateX = false;
              this.customSeparateY = false;
              this.overlapX = 0;
              this.overlapY = 0;
              this.overlapR = 0;
              this.embedded = false;
              this.collideWorldBounds = false;
              this.checkCollision = {
                none: false,
                up: true,
                down: true,
                left: true,
                right: true
              };
              this.touching = {
                none: true,
                up: false,
                down: false,
                left: false,
                right: false
              };
              this.wasTouching = {
                none: true,
                up: false,
                down: false,
                left: false,
                right: false
              };
              this.blocked = {
                none: true,
                up: false,
                down: false,
                left: false,
                right: false
              };
              this.syncBounds = false;
              this.physicsType = CONST.DYNAMIC_BODY;
              this._sx = gameObject.scaleX;
              this._sy = gameObject.scaleY;
              this._dx = 0;
              this._dy = 0;
              this._tx = 0;
              this._ty = 0;
              this._bounds = new Rectangle();
            },
            updateBounds: function () {
              var sprite = this.gameObject;
              var transform = this.transform;
              if (sprite.parentContainer) {
                var matrix = sprite.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2);
                transform.x = matrix.tx;
                transform.y = matrix.ty;
                transform.rotation = RadToDeg(matrix.rotation);
                transform.scaleX = matrix.scaleX;
                transform.scaleY = matrix.scaleY;
                transform.displayOriginX = sprite.displayOriginX;
                transform.displayOriginY = sprite.displayOriginY;
              } else {
                transform.x = sprite.x;
                transform.y = sprite.y;
                transform.rotation = sprite.angle;
                transform.scaleX = sprite.scaleX;
                transform.scaleY = sprite.scaleY;
                transform.displayOriginX = sprite.displayOriginX;
                transform.displayOriginY = sprite.displayOriginY;
              }
              var recalc = false;
              if (this.syncBounds) {
                var b = sprite.getBounds(this._bounds);
                this.width = b.width;
                this.height = b.height;
                recalc = true;
              } else {
                var asx = Math.abs(transform.scaleX);
                var asy = Math.abs(transform.scaleY);
                if (this._sx !== asx || this._sy !== asy) {
                  this.width = this.sourceWidth * asx;
                  this.height = this.sourceHeight * asy;
                  this._sx = asx;
                  this._sy = asy;
                  recalc = true;
                }
              }
              if (recalc) {
                this.halfWidth = Math.floor(this.width / 2);
                this.halfHeight = Math.floor(this.height / 2);
                this.updateCenter();
              }
            },
            updateCenter: function () {
              this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
            },
            updateFromGameObject: function () {
              this.updateBounds();
              var transform = this.transform;
              this.position.x = transform.x + transform.scaleX * (this.offset.x - transform.displayOriginX);
              this.position.y = transform.y + transform.scaleY * (this.offset.y - transform.displayOriginY);
              this.updateCenter();
            },
            resetFlags: function (clear) {
              if (clear === void 0) {
                clear = false;
              }
              var wasTouching = this.wasTouching;
              var touching = this.touching;
              var blocked = this.blocked;
              if (clear) {
                wasTouching.none = true;
                wasTouching.up = false;
                wasTouching.down = false;
                wasTouching.left = false;
                wasTouching.right = false;
              } else {
                wasTouching.none = touching.none;
                wasTouching.up = touching.up;
                wasTouching.down = touching.down;
                wasTouching.left = touching.left;
                wasTouching.right = touching.right;
              }
              touching.none = true;
              touching.up = false;
              touching.down = false;
              touching.left = false;
              touching.right = false;
              blocked.none = true;
              blocked.up = false;
              blocked.down = false;
              blocked.left = false;
              blocked.right = false;
              this.overlapR = 0;
              this.overlapX = 0;
              this.overlapY = 0;
              this.embedded = false;
            },
            preUpdate: function (willStep, delta) {
              if (willStep) {
                this.resetFlags();
              }
              this.updateFromGameObject();
              this.rotation = this.transform.rotation;
              this.preRotation = this.rotation;
              if (this.moves) {
                this.prev.x = this.position.x;
                this.prev.y = this.position.y;
                this.prevFrame.x = this.position.x;
                this.prevFrame.y = this.position.y;
              }
              if (willStep) {
                this.update(delta);
              }
            },
            update: function (delta) {
              this.prev.x = this.position.x;
              this.prev.y = this.position.y;
              if (this.moves) {
                this.world.updateMotion(this, delta);
                var vx = this.velocity.x;
                var vy = this.velocity.y;
                this.newVelocity.set(vx * delta, vy * delta);
                this.position.add(this.newVelocity);
                this.updateCenter();
                this.angle = Math.atan2(vy, vx);
                this.speed = Math.sqrt(vx * vx + vy * vy);
                if (this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds) {
                  this.world.emit(Events.WORLD_BOUNDS, this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right);
                }
              }
              this._dx = this.position.x - this.prev.x;
              this._dy = this.position.y - this.prev.y;
            },
            postUpdate: function () {
              var dx = this.position.x - this.prevFrame.x;
              var dy = this.position.y - this.prevFrame.y;
              if (this.moves) {
                var mx = this.deltaMax.x;
                var my = this.deltaMax.y;
                if (mx !== 0 && dx !== 0) {
                  if (dx < 0 && dx < -mx) {
                    dx = -mx;
                  } else if (dx > 0 && dx > mx) {
                    dx = mx;
                  }
                }
                if (my !== 0 && dy !== 0) {
                  if (dy < 0 && dy < -my) {
                    dy = -my;
                  } else if (dy > 0 && dy > my) {
                    dy = my;
                  }
                }
                this.gameObject.x += dx;
                this.gameObject.y += dy;
              }
              if (dx < 0) {
                this.facing = CONST.FACING_LEFT;
              } else if (dx > 0) {
                this.facing = CONST.FACING_RIGHT;
              }
              if (dy < 0) {
                this.facing = CONST.FACING_UP;
              } else if (dy > 0) {
                this.facing = CONST.FACING_DOWN;
              }
              if (this.allowRotation) {
                this.gameObject.angle += this.deltaZ();
              }
              this._tx = dx;
              this._ty = dy;
            },
            setBoundsRectangle: function (bounds) {
              this.customBoundsRectangle = !bounds ? this.world.bounds : bounds;
              return this;
            },
            checkWorldBounds: function () {
              var pos = this.position;
              var bounds = this.customBoundsRectangle;
              var check = this.world.checkCollision;
              var bx = this.worldBounce ? -this.worldBounce.x : -this.bounce.x;
              var by = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
              var wasSet = false;
              if (pos.x < bounds.x && check.left) {
                pos.x = bounds.x;
                this.velocity.x *= bx;
                this.blocked.left = true;
                wasSet = true;
              } else if (this.right > bounds.right && check.right) {
                pos.x = bounds.right - this.width;
                this.velocity.x *= bx;
                this.blocked.right = true;
                wasSet = true;
              }
              if (pos.y < bounds.y && check.up) {
                pos.y = bounds.y;
                this.velocity.y *= by;
                this.blocked.up = true;
                wasSet = true;
              } else if (this.bottom > bounds.bottom && check.down) {
                pos.y = bounds.bottom - this.height;
                this.velocity.y *= by;
                this.blocked.down = true;
                wasSet = true;
              }
              if (wasSet) {
                this.blocked.none = false;
                this.updateCenter();
              }
              return wasSet;
            },
            setOffset: function (x, y) {
              if (y === void 0) {
                y = x;
              }
              this.offset.set(x, y);
              return this;
            },
            setSize: function (width, height, center) {
              if (center === void 0) {
                center = true;
              }
              var gameObject = this.gameObject;
              if (!width && gameObject.frame) {
                width = gameObject.frame.realWidth;
              }
              if (!height && gameObject.frame) {
                height = gameObject.frame.realHeight;
              }
              this.sourceWidth = width;
              this.sourceHeight = height;
              this.width = this.sourceWidth * this._sx;
              this.height = this.sourceHeight * this._sy;
              this.halfWidth = Math.floor(this.width / 2);
              this.halfHeight = Math.floor(this.height / 2);
              this.updateCenter();
              if (center && gameObject.getCenter) {
                var ox = (gameObject.width - width) / 2;
                var oy = (gameObject.height - height) / 2;
                this.offset.set(ox, oy);
              }
              this.isCircle = false;
              this.radius = 0;
              return this;
            },
            setCircle: function (radius, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = this.offset.x;
              }
              if (offsetY === void 0) {
                offsetY = this.offset.y;
              }
              if (radius > 0) {
                this.isCircle = true;
                this.radius = radius;
                this.sourceWidth = radius * 2;
                this.sourceHeight = radius * 2;
                this.width = this.sourceWidth * this._sx;
                this.height = this.sourceHeight * this._sy;
                this.halfWidth = Math.floor(this.width / 2);
                this.halfHeight = Math.floor(this.height / 2);
                this.offset.set(offsetX, offsetY);
                this.updateCenter();
              } else {
                this.isCircle = false;
              }
              return this;
            },
            reset: function (x, y) {
              this.stop();
              var gameObject = this.gameObject;
              gameObject.setPosition(x, y);
              if (gameObject.getTopLeft) {
                gameObject.getTopLeft(this.position);
              } else {
                this.position.set(x, y);
              }
              this.prev.copy(this.position);
              this.prevFrame.copy(this.position);
              this.rotation = gameObject.angle;
              this.preRotation = gameObject.angle;
              this.updateBounds();
              this.updateCenter();
              this.resetFlags(true);
            },
            stop: function () {
              this.velocity.set(0);
              this.acceleration.set(0);
              this.speed = 0;
              this.angularVelocity = 0;
              this.angularAcceleration = 0;
              return this;
            },
            getBounds: function (obj) {
              obj.x = this.x;
              obj.y = this.y;
              obj.right = this.right;
              obj.bottom = this.bottom;
              return obj;
            },
            hitTest: function (x, y) {
              if (!this.isCircle) {
                return RectangleContains(this, x, y);
              }
              if (this.radius > 0 && x >= this.left && x <= this.right && y >= this.top && y <= this.bottom) {
                var dx = (this.center.x - x) * (this.center.x - x);
                var dy = (this.center.y - y) * (this.center.y - y);
                return dx + dy <= this.radius * this.radius;
              }
              return false;
            },
            onFloor: function () {
              return this.blocked.down;
            },
            onCeiling: function () {
              return this.blocked.up;
            },
            onWall: function () {
              return this.blocked.left || this.blocked.right;
            },
            deltaAbsX: function () {
              return this._dx > 0 ? this._dx : -this._dx;
            },
            deltaAbsY: function () {
              return this._dy > 0 ? this._dy : -this._dy;
            },
            deltaX: function () {
              return this._dx;
            },
            deltaY: function () {
              return this._dy;
            },
            deltaXFinal: function () {
              return this._tx;
            },
            deltaYFinal: function () {
              return this._ty;
            },
            deltaZ: function () {
              return this.rotation - this.preRotation;
            },
            destroy: function () {
              this.enable = false;
              if (this.world) {
                this.world.pendingDestroy.set(this);
              }
            },
            drawDebug: function (graphic) {
              var pos = this.position;
              var x = pos.x + this.halfWidth;
              var y = pos.y + this.halfHeight;
              if (this.debugShowBody) {
                graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor);
                if (this.isCircle) {
                  graphic.strokeCircle(x, y, this.width / 2);
                } else {
                  if (this.checkCollision.up) {
                    graphic.lineBetween(pos.x, pos.y, pos.x + this.width, pos.y);
                  }
                  if (this.checkCollision.right) {
                    graphic.lineBetween(pos.x + this.width, pos.y, pos.x + this.width, pos.y + this.height);
                  }
                  if (this.checkCollision.down) {
                    graphic.lineBetween(pos.x, pos.y + this.height, pos.x + this.width, pos.y + this.height);
                  }
                  if (this.checkCollision.left) {
                    graphic.lineBetween(pos.x, pos.y, pos.x, pos.y + this.height);
                  }
                }
              }
              if (this.debugShowVelocity) {
                graphic.lineStyle(graphic.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1);
                graphic.lineBetween(x, y, x + this.velocity.x / 2, y + this.velocity.y / 2);
              }
            },
            willDrawDebug: function () {
              return this.debugShowBody || this.debugShowVelocity;
            },
            setCollideWorldBounds: function (value, bounceX, bounceY, onWorldBounds) {
              if (value === void 0) {
                value = true;
              }
              this.collideWorldBounds = value;
              var setBounceX = bounceX !== void 0;
              var setBounceY = bounceY !== void 0;
              if (setBounceX || setBounceY) {
                if (!this.worldBounce) {
                  this.worldBounce = new Vector2();
                }
                if (setBounceX) {
                  this.worldBounce.x = bounceX;
                }
                if (setBounceY) {
                  this.worldBounce.y = bounceY;
                }
              }
              if (onWorldBounds !== void 0) {
                this.onWorldBounds = onWorldBounds;
              }
              return this;
            },
            setVelocity: function (x, y) {
              this.velocity.set(x, y);
              x = this.velocity.x;
              y = this.velocity.y;
              this.speed = Math.sqrt(x * x + y * y);
              return this;
            },
            setVelocityX: function (value) {
              this.velocity.x = value;
              var x = value;
              var y = this.velocity.y;
              this.speed = Math.sqrt(x * x + y * y);
              return this;
            },
            setVelocityY: function (value) {
              this.velocity.y = value;
              var x = this.velocity.x;
              var y = value;
              this.speed = Math.sqrt(x * x + y * y);
              return this;
            },
            setMaxVelocity: function (x, y) {
              this.maxVelocity.set(x, y);
              return this;
            },
            setMaxVelocityX: function (value) {
              this.maxVelocity.x = value;
              return this;
            },
            setMaxVelocityY: function (value) {
              this.maxVelocity.y = value;
              return this;
            },
            setMaxSpeed: function (value) {
              this.maxSpeed = value;
              return this;
            },
            setBounce: function (x, y) {
              this.bounce.set(x, y);
              return this;
            },
            setBounceX: function (value) {
              this.bounce.x = value;
              return this;
            },
            setBounceY: function (value) {
              this.bounce.y = value;
              return this;
            },
            setAcceleration: function (x, y) {
              this.acceleration.set(x, y);
              return this;
            },
            setAccelerationX: function (value) {
              this.acceleration.x = value;
              return this;
            },
            setAccelerationY: function (value) {
              this.acceleration.y = value;
              return this;
            },
            setAllowDrag: function (value) {
              if (value === void 0) {
                value = true;
              }
              this.allowDrag = value;
              return this;
            },
            setAllowGravity: function (value) {
              if (value === void 0) {
                value = true;
              }
              this.allowGravity = value;
              return this;
            },
            setAllowRotation: function (value) {
              if (value === void 0) {
                value = true;
              }
              this.allowRotation = value;
              return this;
            },
            setDrag: function (x, y) {
              this.drag.set(x, y);
              return this;
            },
            setDamping: function (value) {
              this.useDamping = value;
              return this;
            },
            setDragX: function (value) {
              this.drag.x = value;
              return this;
            },
            setDragY: function (value) {
              this.drag.y = value;
              return this;
            },
            setGravity: function (x, y) {
              this.gravity.set(x, y);
              return this;
            },
            setGravityX: function (value) {
              this.gravity.x = value;
              return this;
            },
            setGravityY: function (value) {
              this.gravity.y = value;
              return this;
            },
            setFriction: function (x, y) {
              this.friction.set(x, y);
              return this;
            },
            setFrictionX: function (value) {
              this.friction.x = value;
              return this;
            },
            setFrictionY: function (value) {
              this.friction.y = value;
              return this;
            },
            setAngularVelocity: function (value) {
              this.angularVelocity = value;
              return this;
            },
            setAngularAcceleration: function (value) {
              this.angularAcceleration = value;
              return this;
            },
            setAngularDrag: function (value) {
              this.angularDrag = value;
              return this;
            },
            setMass: function (value) {
              this.mass = value;
              return this;
            },
            setImmovable: function (value) {
              if (value === void 0) {
                value = true;
              }
              this.immovable = value;
              return this;
            },
            setEnable: function (value) {
              if (value === void 0) {
                value = true;
              }
              this.enable = value;
              return this;
            },
            processX: function (x, vx, left, right) {
              this.x += x;
              this.updateCenter();
              if (vx !== null) {
                this.velocity.x = vx;
              }
              var blocked = this.blocked;
              if (left) {
                blocked.left = true;
              }
              if (right) {
                blocked.right = true;
              }
            },
            processY: function (y, vy, up, down) {
              this.y += y;
              this.updateCenter();
              if (vy !== null) {
                this.velocity.y = vy;
              }
              var blocked = this.blocked;
              if (up) {
                blocked.up = true;
              }
              if (down) {
                blocked.down = true;
              }
            },
            x: {
              get: function () {
                return this.position.x;
              },
              set: function (value) {
                this.position.x = value;
              }
            },
            y: {
              get: function () {
                return this.position.y;
              },
              set: function (value) {
                this.position.y = value;
              }
            },
            left: {
              get: function () {
                return this.position.x;
              }
            },
            right: {
              get: function () {
                return this.position.x + this.width;
              }
            },
            top: {
              get: function () {
                return this.position.y;
              }
            },
            bottom: {
              get: function () {
                return this.position.y + this.height;
              }
            }
          });
          module2.exports = Body;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Collider = new Class({
            initialize: function Collider2(world, overlapOnly, object1, object2, collideCallback, processCallback, callbackContext) {
              this.world = world;
              this.name = "";
              this.active = true;
              this.overlapOnly = overlapOnly;
              this.object1 = object1;
              this.object2 = object2;
              this.collideCallback = collideCallback;
              this.processCallback = processCallback;
              this.callbackContext = callbackContext;
            },
            setName: function (name) {
              this.name = name;
              return this;
            },
            update: function () {
              this.world.collideObjects(this.object1, this.object2, this.collideCallback, this.processCallback, this.callbackContext, this.overlapOnly);
            },
            destroy: function () {
              this.world.removeCollider(this);
              this.active = false;
              this.world = null;
              this.object1 = null;
              this.object2 = null;
              this.collideCallback = null;
              this.processCallback = null;
              this.callbackContext = null;
            }
          });
          module2.exports = Collider;
        }, function (module2, exports2, __webpack_require__) {
          var GetTilesWithin = __webpack_require__(26);
          var Vector2 = __webpack_require__(3);
          var pointStart = new Vector2();
          var pointEnd = new Vector2();
          var GetTilesWithinWorldXY = function (worldX, worldY, width, height, filteringOptions, camera, layer) {
            var worldToTileXY = layer.tilemapLayer.tilemap._convert.WorldToTileXY;
            worldToTileXY(worldX, worldY, true, pointStart, camera, layer);
            var xStart = pointStart.x;
            var yStart = pointStart.y;
            worldToTileXY(worldX + width, worldY + height, false, pointEnd, camera, layer);
            var xEnd = Math.ceil(pointEnd.x);
            var yEnd = Math.ceil(pointEnd.y);
            return GetTilesWithin(xStart, yStart, xEnd - xStart, yEnd - yStart, filteringOptions, layer);
          };
          module2.exports = GetTilesWithinWorldXY;
        }, function (module2, exports2) {
          var ProcessTileCallbacks = function (tile, sprite) {
            if (tile.collisionCallback) {
              return !tile.collisionCallback.call(tile.collisionCallbackContext, sprite, tile);
            } else if (tile.layer.callbacks[tile.index]) {
              return !tile.layer.callbacks[tile.index].callback.call(tile.layer.callbacks[tile.index].callbackContext, sprite, tile);
            }
            return true;
          };
          module2.exports = ProcessTileCallbacks;
        }, function (module2, exports2, __webpack_require__) {
          var quickselect = __webpack_require__(436);
          function rbush(maxEntries) {
            var format = [".left", ".top", ".right", ".bottom"];
            if (!(this instanceof rbush)) return new rbush(maxEntries, format);
            this._maxEntries = Math.max(4, maxEntries || 9);
            this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
            this.clear();
          }
          rbush.prototype = {
            all: function () {
              return this._all(this.data, []);
            },
            search: function (bbox) {
              var node = this.data, result = [], toBBox = this.toBBox;
              if (!intersects(bbox, node)) return result;
              var nodesToSearch = [], i, len, child, childBBox;
              while (node) {
                for ((i = 0, len = node.children.length); i < len; i++) {
                  child = node.children[i];
                  childBBox = node.leaf ? toBBox(child) : child;
                  if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child); else if (contains(bbox, childBBox)) this._all(child, result); else nodesToSearch.push(child);
                  }
                }
                node = nodesToSearch.pop();
              }
              return result;
            },
            collides: function (bbox) {
              var node = this.data, toBBox = this.toBBox;
              if (!intersects(bbox, node)) return false;
              var nodesToSearch = [], i, len, child, childBBox;
              while (node) {
                for ((i = 0, len = node.children.length); i < len; i++) {
                  child = node.children[i];
                  childBBox = node.leaf ? toBBox(child) : child;
                  if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                  }
                }
                node = nodesToSearch.pop();
              }
              return false;
            },
            load: function (data) {
              if (!(data && data.length)) return this;
              if (data.length < this._minEntries) {
                for (var i = 0, len = data.length; i < len; i++) {
                  this.insert(data[i]);
                }
                return this;
              }
              var node = this._build(data.slice(), 0, data.length - 1, 0);
              if (!this.data.children.length) {
                this.data = node;
              } else if (this.data.height === node.height) {
                this._splitRoot(this.data, node);
              } else {
                if (this.data.height < node.height) {
                  var tmpNode = this.data;
                  this.data = node;
                  node = tmpNode;
                }
                this._insert(node, this.data.height - node.height - 1, true);
              }
              return this;
            },
            insert: function (item) {
              if (item) this._insert(item, this.data.height - 1);
              return this;
            },
            clear: function () {
              this.data = createNode([]);
              return this;
            },
            remove: function (item, equalsFn) {
              if (!item) return this;
              var node = this.data, bbox = this.toBBox(item), path = [], indexes = [], i, parent, index, goingUp;
              while (node || path.length) {
                if (!node) {
                  node = path.pop();
                  parent = path[path.length - 1];
                  i = indexes.pop();
                  goingUp = true;
                }
                if (node.leaf) {
                  index = findItem(item, node.children, equalsFn);
                  if (index !== -1) {
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                  }
                }
                if (!goingUp && !node.leaf && contains(node, bbox)) {
                  path.push(node);
                  indexes.push(i);
                  i = 0;
                  parent = node;
                  node = node.children[0];
                } else if (parent) {
                  i++;
                  node = parent.children[i];
                  goingUp = false;
                } else node = null;
              }
              return this;
            },
            toBBox: function (item) {
              return item;
            },
            compareMinX: compareNodeMinX,
            compareMinY: compareNodeMinY,
            toJSON: function () {
              return this.data;
            },
            fromJSON: function (data) {
              this.data = data;
              return this;
            },
            _all: function (node, result) {
              var nodesToSearch = [];
              while (node) {
                if (node.leaf) result.push.apply(result, node.children); else nodesToSearch.push.apply(nodesToSearch, node.children);
                node = nodesToSearch.pop();
              }
              return result;
            },
            _build: function (items, left, right, height) {
              var N = right - left + 1, M = this._maxEntries, node;
              if (N <= M) {
                node = createNode(items.slice(left, right + 1));
                calcBBox(node, this.toBBox);
                return node;
              }
              if (!height) {
                height = Math.ceil(Math.log(N) / Math.log(M));
                M = Math.ceil(N / Math.pow(M, height - 1));
              }
              node = createNode([]);
              node.leaf = false;
              node.height = height;
              var N2 = Math.ceil(N / M), N1 = N2 * Math.ceil(Math.sqrt(M)), i, j, right2, right3;
              multiSelect(items, left, right, N1, this.compareMinX);
              for (i = left; i <= right; i += N1) {
                right2 = Math.min(i + N1 - 1, right);
                multiSelect(items, i, right2, N2, this.compareMinY);
                for (j = i; j <= right2; j += N2) {
                  right3 = Math.min(j + N2 - 1, right2);
                  node.children.push(this._build(items, j, right3, height - 1));
                }
              }
              calcBBox(node, this.toBBox);
              return node;
            },
            _chooseSubtree: function (bbox, node, level, path) {
              var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;
              while (true) {
                path.push(node);
                if (node.leaf || path.length - 1 === level) break;
                minArea = minEnlargement = Infinity;
                for ((i = 0, len = node.children.length); i < len; i++) {
                  child = node.children[i];
                  area = bboxArea(child);
                  enlargement = enlargedArea(bbox, child) - area;
                  if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;
                  } else if (enlargement === minEnlargement) {
                    if (area < minArea) {
                      minArea = area;
                      targetNode = child;
                    }
                  }
                }
                node = targetNode || node.children[0];
              }
              return node;
            },
            _insert: function (item, level, isNode) {
              var toBBox = this.toBBox, bbox = isNode ? item : toBBox(item), insertPath = [];
              var node = this._chooseSubtree(bbox, this.data, level, insertPath);
              node.children.push(item);
              extend(node, bbox);
              while (level >= 0) {
                if (insertPath[level].children.length > this._maxEntries) {
                  this._split(insertPath, level);
                  level--;
                } else break;
              }
              this._adjustParentBBoxes(bbox, insertPath, level);
            },
            _split: function (insertPath, level) {
              var node = insertPath[level], M = node.children.length, m = this._minEntries;
              this._chooseSplitAxis(node, m, M);
              var splitIndex = this._chooseSplitIndex(node, m, M);
              var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
              newNode.height = node.height;
              newNode.leaf = node.leaf;
              calcBBox(node, this.toBBox);
              calcBBox(newNode, this.toBBox);
              if (level) insertPath[level - 1].children.push(newNode); else this._splitRoot(node, newNode);
            },
            _splitRoot: function (node, newNode) {
              this.data = createNode([node, newNode]);
              this.data.height = node.height + 1;
              this.data.leaf = false;
              calcBBox(this.data, this.toBBox);
            },
            _chooseSplitIndex: function (node, m, M) {
              var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
              minOverlap = minArea = Infinity;
              for (i = m; i <= M - m; i++) {
                bbox1 = distBBox(node, 0, i, this.toBBox);
                bbox2 = distBBox(node, i, M, this.toBBox);
                overlap = intersectionArea(bbox1, bbox2);
                area = bboxArea(bbox1) + bboxArea(bbox2);
                if (overlap < minOverlap) {
                  minOverlap = overlap;
                  index = i;
                  minArea = area < minArea ? area : minArea;
                } else if (overlap === minOverlap) {
                  if (area < minArea) {
                    minArea = area;
                    index = i;
                  }
                }
              }
              return index;
            },
            _chooseSplitAxis: function (node, m, M) {
              var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m, M, compareMinX), yMargin = this._allDistMargin(node, m, M, compareMinY);
              if (xMargin < yMargin) node.children.sort(compareMinX);
            },
            _allDistMargin: function (node, m, M, compare) {
              node.children.sort(compare);
              var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m, toBBox), rightBBox = distBBox(node, M - m, M, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i, child;
              for (i = m; i < M - m; i++) {
                child = node.children[i];
                extend(leftBBox, node.leaf ? toBBox(child) : child);
                margin += bboxMargin(leftBBox);
              }
              for (i = M - m - 1; i >= m; i--) {
                child = node.children[i];
                extend(rightBBox, node.leaf ? toBBox(child) : child);
                margin += bboxMargin(rightBBox);
              }
              return margin;
            },
            _adjustParentBBoxes: function (bbox, path, level) {
              for (var i = level; i >= 0; i--) {
                extend(path[i], bbox);
              }
            },
            _condense: function (path) {
              for (var i = path.length - 1, siblings; i >= 0; i--) {
                if (path[i].children.length === 0) {
                  if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);
                  } else this.clear();
                } else calcBBox(path[i], this.toBBox);
              }
            },
            compareMinX: function (a, b) {
              return a.left - b.left;
            },
            compareMinY: function (a, b) {
              return a.top - b.top;
            },
            toBBox: function (a) {
              return {
                minX: a.left,
                minY: a.top,
                maxX: a.right,
                maxY: a.bottom
              };
            }
          };
          function findItem(item, items, equalsFn) {
            if (!equalsFn) return items.indexOf(item);
            for (var i = 0; i < items.length; i++) {
              if (equalsFn(item, items[i])) return i;
            }
            return -1;
          }
          function calcBBox(node, toBBox) {
            distBBox(node, 0, node.children.length, toBBox, node);
          }
          function distBBox(node, k, p3, toBBox, destNode) {
            if (!destNode) destNode = createNode(null);
            destNode.minX = Infinity;
            destNode.minY = Infinity;
            destNode.maxX = -Infinity;
            destNode.maxY = -Infinity;
            for (var i = k, child; i < p3; i++) {
              child = node.children[i];
              extend(destNode, node.leaf ? toBBox(child) : child);
            }
            return destNode;
          }
          function extend(a, b) {
            a.minX = Math.min(a.minX, b.minX);
            a.minY = Math.min(a.minY, b.minY);
            a.maxX = Math.max(a.maxX, b.maxX);
            a.maxY = Math.max(a.maxY, b.maxY);
            return a;
          }
          function compareNodeMinX(a, b) {
            return a.minX - b.minX;
          }
          function compareNodeMinY(a, b) {
            return a.minY - b.minY;
          }
          function bboxArea(a) {
            return (a.maxX - a.minX) * (a.maxY - a.minY);
          }
          function bboxMargin(a) {
            return a.maxX - a.minX + (a.maxY - a.minY);
          }
          function enlargedArea(a, b) {
            return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
          }
          function intersectionArea(a, b) {
            var minX = Math.max(a.minX, b.minX), minY = Math.max(a.minY, b.minY), maxX = Math.min(a.maxX, b.maxX), maxY = Math.min(a.maxY, b.maxY);
            return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
          }
          function contains(a, b) {
            return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
          }
          function intersects(a, b) {
            return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
          }
          function createNode(children) {
            return {
              children,
              height: 1,
              leaf: true,
              minX: Infinity,
              minY: Infinity,
              maxX: -Infinity,
              maxY: -Infinity
            };
          }
          function multiSelect(arr, left, right, n, compare) {
            var stack = [left, right], mid;
            while (stack.length) {
              right = stack.pop();
              left = stack.pop();
              if (right - left <= n) continue;
              mid = left + Math.ceil((right - left) / n / 2) * n;
              quickselect(arr, mid, left, right, compare);
              stack.push(left, mid, mid, right);
            }
          }
          module2.exports = rbush;
        }, function (module2, exports2, __webpack_require__) {
          var TileCheckX = __webpack_require__(533);
          var TileCheckY = __webpack_require__(535);
          var TileIntersectsBody = __webpack_require__(248);
          var SeparateTile = function (i, body, tile, tileWorldRect, tilemapLayer, tileBias, isLayer) {
            var tileLeft = tileWorldRect.left;
            var tileTop = tileWorldRect.top;
            var tileRight = tileWorldRect.right;
            var tileBottom = tileWorldRect.bottom;
            var faceHorizontal = tile.faceLeft || tile.faceRight;
            var faceVertical = tile.faceTop || tile.faceBottom;
            if (!isLayer) {
              faceHorizontal = true;
              faceVertical = true;
            }
            if (!faceHorizontal && !faceVertical) {
              return false;
            }
            var ox = 0;
            var oy = 0;
            var minX = 0;
            var minY = 1;
            if (body.deltaAbsX() > body.deltaAbsY()) {
              minX = -1;
            } else if (body.deltaAbsX() < body.deltaAbsY()) {
              minY = -1;
            }
            if (body.deltaX() !== 0 && body.deltaY() !== 0 && faceHorizontal && faceVertical) {
              minX = Math.min(Math.abs(body.position.x - tileRight), Math.abs(body.right - tileLeft));
              minY = Math.min(Math.abs(body.position.y - tileBottom), Math.abs(body.bottom - tileTop));
            }
            if (minX < minY) {
              if (faceHorizontal) {
                ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer);
                if (ox !== 0 && !TileIntersectsBody(tileWorldRect, body)) {
                  return true;
                }
              }
              if (faceVertical) {
                oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer);
              }
            } else {
              if (faceVertical) {
                oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer);
                if (oy !== 0 && !TileIntersectsBody(tileWorldRect, body)) {
                  return true;
                }
              }
              if (faceHorizontal) {
                ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer);
              }
            }
            return ox !== 0 || oy !== 0;
          };
          module2.exports = SeparateTile;
        }, function (module2, exports2, __webpack_require__) {
          var ProcessTileSeparationX = __webpack_require__(534);
          var TileCheckX = function (body, tile, tileLeft, tileRight, tileBias, isLayer) {
            var ox = 0;
            var faceLeft = tile.faceLeft;
            var faceRight = tile.faceRight;
            var collideLeft = tile.collideLeft;
            var collideRight = tile.collideRight;
            if (!isLayer) {
              faceLeft = true;
              faceRight = true;
              collideLeft = true;
              collideRight = true;
            }
            if (body.deltaX() < 0 && collideRight && body.checkCollision.left) {
              if (faceRight && body.x < tileRight) {
                ox = body.x - tileRight;
                if (ox < -tileBias) {
                  ox = 0;
                }
              }
            } else if (body.deltaX() > 0 && collideLeft && body.checkCollision.right) {
              if (faceLeft && body.right > tileLeft) {
                ox = body.right - tileLeft;
                if (ox > tileBias) {
                  ox = 0;
                }
              }
            }
            if (ox !== 0) {
              if (body.customSeparateX) {
                body.overlapX = ox;
              } else {
                ProcessTileSeparationX(body, ox);
              }
            }
            return ox;
          };
          module2.exports = TileCheckX;
        }, function (module2, exports2) {
          var ProcessTileSeparationX = function (body, x) {
            if (x < 0) {
              body.blocked.none = false;
              body.blocked.left = true;
            } else if (x > 0) {
              body.blocked.none = false;
              body.blocked.right = true;
            }
            body.position.x -= x;
            if (body.bounce.x === 0) {
              body.velocity.x = 0;
            } else {
              body.velocity.x = -body.velocity.x * body.bounce.x;
            }
          };
          module2.exports = ProcessTileSeparationX;
        }, function (module2, exports2, __webpack_require__) {
          var ProcessTileSeparationY = __webpack_require__(536);
          var TileCheckY = function (body, tile, tileTop, tileBottom, tileBias, isLayer) {
            var oy = 0;
            var faceTop = tile.faceTop;
            var faceBottom = tile.faceBottom;
            var collideUp = tile.collideUp;
            var collideDown = tile.collideDown;
            if (!isLayer) {
              faceTop = true;
              faceBottom = true;
              collideUp = true;
              collideDown = true;
            }
            if (body.deltaY() < 0 && collideDown && body.checkCollision.up) {
              if (faceBottom && body.y < tileBottom) {
                oy = body.y - tileBottom;
                if (oy < -tileBias) {
                  oy = 0;
                }
              }
            } else if (body.deltaY() > 0 && collideUp && body.checkCollision.down) {
              if (faceTop && body.bottom > tileTop) {
                oy = body.bottom - tileTop;
                if (oy > tileBias) {
                  oy = 0;
                }
              }
            }
            if (oy !== 0) {
              if (body.customSeparateY) {
                body.overlapY = oy;
              } else {
                ProcessTileSeparationY(body, oy);
              }
            }
            return oy;
          };
          module2.exports = TileCheckY;
        }, function (module2, exports2) {
          var ProcessTileSeparationY = function (body, y) {
            if (y < 0) {
              body.blocked.none = false;
              body.blocked.up = true;
            } else if (y > 0) {
              body.blocked.none = false;
              body.blocked.down = true;
            }
            body.position.y -= y;
            if (body.bounce.y === 0) {
              body.velocity.y = 0;
            } else {
              body.velocity.y = -body.velocity.y * body.bounce.y;
            }
          };
          module2.exports = ProcessTileSeparationY;
        }, function (module2, exports2, __webpack_require__) {
          var GetOverlapX = __webpack_require__(246);
          var ProcessX = __webpack_require__(1389);
          var SeparateX = function (body1, body2, overlapOnly, bias) {
            var overlap = GetOverlapX(body1, body2, overlapOnly, bias);
            var body1Immovable = body1.immovable;
            var body2Immovable = body2.immovable;
            if (overlapOnly || overlap === 0 || body1Immovable && body2Immovable || body1.customSeparateX || body2.customSeparateX) {
              return overlap !== 0 || body1.embedded && body2.embedded;
            }
            var blockedState = ProcessX.Set(body1, body2, overlap);
            if (!body1Immovable && !body2Immovable) {
              if (blockedState > 0) {
                return true;
              }
              return ProcessX.Check();
            } else if (body1Immovable) {
              ProcessX.RunImmovableBody1(blockedState);
            } else if (body2Immovable) {
              ProcessX.RunImmovableBody2(blockedState);
            }
            return true;
          };
          module2.exports = SeparateX;
        }, function (module2, exports2, __webpack_require__) {
          var GetOverlapY = __webpack_require__(247);
          var ProcessY = __webpack_require__(1390);
          var SeparateY = function (body1, body2, overlapOnly, bias) {
            var overlap = GetOverlapY(body1, body2, overlapOnly, bias);
            var body1Immovable = body1.immovable;
            var body2Immovable = body2.immovable;
            if (overlapOnly || overlap === 0 || body1Immovable && body2Immovable || body1.customSeparateY || body2.customSeparateY) {
              return overlap !== 0 || body1.embedded && body2.embedded;
            }
            var blockedState = ProcessY.Set(body1, body2, overlap);
            if (!body1Immovable && !body2Immovable) {
              if (blockedState > 0) {
                return true;
              }
              return ProcessY.Check();
            } else if (body1Immovable) {
              ProcessY.RunImmovableBody1(blockedState);
            } else if (body2Immovable) {
              ProcessY.RunImmovableBody2(blockedState);
            }
            return true;
          };
          module2.exports = SeparateY;
        }, function (module2, exports2, __webpack_require__) {
          var CircleContains = __webpack_require__(66);
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(62);
          var RectangleContains = __webpack_require__(57);
          var Vector2 = __webpack_require__(3);
          var StaticBody = new Class({
            initialize: function StaticBody2(world, gameObject) {
              var width = gameObject.displayWidth ? gameObject.displayWidth : 64;
              var height = gameObject.displayHeight ? gameObject.displayHeight : 64;
              this.world = world;
              this.gameObject = gameObject;
              this.debugShowBody = world.defaults.debugShowStaticBody;
              this.debugBodyColor = world.defaults.staticBodyDebugColor;
              this.enable = true;
              this.isCircle = false;
              this.radius = 0;
              this.offset = new Vector2();
              this.position = new Vector2(gameObject.x - width * gameObject.originX, gameObject.y - height * gameObject.originY);
              this.width = width;
              this.height = height;
              this.halfWidth = Math.abs(this.width / 2);
              this.halfHeight = Math.abs(this.height / 2);
              this.center = new Vector2(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
              this.velocity = Vector2.ZERO;
              this.allowGravity = false;
              this.gravity = Vector2.ZERO;
              this.bounce = Vector2.ZERO;
              this.onWorldBounds = false;
              this.onCollide = false;
              this.onOverlap = false;
              this.mass = 1;
              this.immovable = true;
              this.pushable = false;
              this.customSeparateX = false;
              this.customSeparateY = false;
              this.overlapX = 0;
              this.overlapY = 0;
              this.overlapR = 0;
              this.embedded = false;
              this.collideWorldBounds = false;
              this.checkCollision = {
                none: false,
                up: true,
                down: true,
                left: true,
                right: true
              };
              this.touching = {
                none: true,
                up: false,
                down: false,
                left: false,
                right: false
              };
              this.wasTouching = {
                none: true,
                up: false,
                down: false,
                left: false,
                right: false
              };
              this.blocked = {
                none: true,
                up: false,
                down: false,
                left: false,
                right: false
              };
              this.physicsType = CONST.STATIC_BODY;
              this._dx = 0;
              this._dy = 0;
            },
            setGameObject: function (gameObject, update) {
              if (gameObject && gameObject !== this.gameObject) {
                this.gameObject.body = null;
                gameObject.body = this;
                this.gameObject = gameObject;
              }
              if (update) {
                this.updateFromGameObject();
              }
              return this;
            },
            updateFromGameObject: function () {
              this.world.staticTree.remove(this);
              var gameObject = this.gameObject;
              gameObject.getTopLeft(this.position);
              this.width = gameObject.displayWidth;
              this.height = gameObject.displayHeight;
              this.halfWidth = Math.abs(this.width / 2);
              this.halfHeight = Math.abs(this.height / 2);
              this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
              this.world.staticTree.insert(this);
              return this;
            },
            setOffset: function (x, y) {
              if (y === void 0) {
                y = x;
              }
              this.world.staticTree.remove(this);
              this.position.x -= this.offset.x;
              this.position.y -= this.offset.y;
              this.offset.set(x, y);
              this.position.x += this.offset.x;
              this.position.y += this.offset.y;
              this.updateCenter();
              this.world.staticTree.insert(this);
              return this;
            },
            setSize: function (width, height, center) {
              if (center === void 0) {
                center = true;
              }
              var gameObject = this.gameObject;
              if (!width && gameObject.frame) {
                width = gameObject.frame.realWidth;
              }
              if (!height && gameObject.frame) {
                height = gameObject.frame.realHeight;
              }
              this.world.staticTree.remove(this);
              this.width = width;
              this.height = height;
              this.halfWidth = Math.floor(width / 2);
              this.halfHeight = Math.floor(height / 2);
              if (center && gameObject.getCenter) {
                var ox = gameObject.displayWidth / 2;
                var oy = gameObject.displayHeight / 2;
                this.position.x -= this.offset.x;
                this.position.y -= this.offset.y;
                this.offset.set(ox - this.halfWidth, oy - this.halfHeight);
                this.position.x += this.offset.x;
                this.position.y += this.offset.y;
              }
              this.updateCenter();
              this.isCircle = false;
              this.radius = 0;
              this.world.staticTree.insert(this);
              return this;
            },
            setCircle: function (radius, offsetX, offsetY) {
              if (offsetX === void 0) {
                offsetX = this.offset.x;
              }
              if (offsetY === void 0) {
                offsetY = this.offset.y;
              }
              if (radius > 0) {
                this.world.staticTree.remove(this);
                this.isCircle = true;
                this.radius = radius;
                this.width = radius * 2;
                this.height = radius * 2;
                this.halfWidth = Math.floor(this.width / 2);
                this.halfHeight = Math.floor(this.height / 2);
                this.offset.set(offsetX, offsetY);
                this.updateCenter();
                this.world.staticTree.insert(this);
              } else {
                this.isCircle = false;
              }
              return this;
            },
            updateCenter: function () {
              this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
            },
            reset: function (x, y) {
              var gameObject = this.gameObject;
              if (x === void 0) {
                x = gameObject.x;
              }
              if (y === void 0) {
                y = gameObject.y;
              }
              this.world.staticTree.remove(this);
              gameObject.setPosition(x, y);
              gameObject.getTopLeft(this.position);
              this.updateCenter();
              this.world.staticTree.insert(this);
            },
            stop: function () {
              return this;
            },
            getBounds: function (obj) {
              obj.x = this.x;
              obj.y = this.y;
              obj.right = this.right;
              obj.bottom = this.bottom;
              return obj;
            },
            hitTest: function (x, y) {
              return this.isCircle ? CircleContains(this, x, y) : RectangleContains(this, x, y);
            },
            postUpdate: function () {},
            deltaAbsX: function () {
              return 0;
            },
            deltaAbsY: function () {
              return 0;
            },
            deltaX: function () {
              return 0;
            },
            deltaY: function () {
              return 0;
            },
            deltaZ: function () {
              return 0;
            },
            destroy: function () {
              this.enable = false;
              this.world.pendingDestroy.set(this);
            },
            drawDebug: function (graphic) {
              var pos = this.position;
              var x = pos.x + this.halfWidth;
              var y = pos.y + this.halfHeight;
              if (this.debugShowBody) {
                graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor, 1);
                if (this.isCircle) {
                  graphic.strokeCircle(x, y, this.width / 2);
                } else {
                  graphic.strokeRect(pos.x, pos.y, this.width, this.height);
                }
              }
            },
            willDrawDebug: function () {
              return this.debugShowBody;
            },
            setMass: function (value) {
              if (value <= 0) {
                value = 0.1;
              }
              this.mass = value;
              return this;
            },
            x: {
              get: function () {
                return this.position.x;
              },
              set: function (value) {
                this.world.staticTree.remove(this);
                this.position.x = value;
                this.world.staticTree.insert(this);
              }
            },
            y: {
              get: function () {
                return this.position.y;
              },
              set: function (value) {
                this.world.staticTree.remove(this);
                this.position.y = value;
                this.world.staticTree.insert(this);
              }
            },
            left: {
              get: function () {
                return this.position.x;
              }
            },
            right: {
              get: function () {
                return this.position.x + this.width;
              }
            },
            top: {
              get: function () {
                return this.position.y;
              }
            },
            bottom: {
              get: function () {
                return this.position.y + this.height;
              }
            }
          });
          module2.exports = StaticBody;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var BasePlugin = new Class({
            initialize: function BasePlugin2(pluginManager) {
              this.pluginManager = pluginManager;
              this.game = pluginManager.game;
            },
            init: function () {},
            start: function () {},
            stop: function () {},
            destroy: function () {
              this.pluginManager = null;
              this.game = null;
              this.scene = null;
              this.systems = null;
            }
          });
          module2.exports = BasePlugin;
        }, function (module2, exports2, __webpack_require__) {
          var Vector2 = __webpack_require__(3);
          var point = new Vector2();
          var CheckIsoBounds = function (tileX, tileY, layer, camera) {
            var tilemapLayer = layer.tilemapLayer;
            var cullPaddingX = tilemapLayer.cullPaddingX;
            var cullPaddingY = tilemapLayer.cullPaddingY;
            var pos = tilemapLayer.tilemap.tileToWorldXY(tileX, tileY, point, camera, tilemapLayer);
            return pos.x > camera.worldView.x + tilemapLayer.scaleX * layer.tileWidth * (-cullPaddingX - 0.5) && pos.x < camera.worldView.right + tilemapLayer.scaleX * layer.tileWidth * (cullPaddingX - 0.5) && pos.y > camera.worldView.y + tilemapLayer.scaleY * layer.tileHeight * (-cullPaddingY - 1) && pos.y < camera.worldView.bottom + tilemapLayer.scaleY * layer.tileHeight * (cullPaddingY - 0.5);
          };
          module2.exports = CheckIsoBounds;
        }, function (module2, exports2, __webpack_require__) {
          var GetTilesWithin = __webpack_require__(26);
          var ReplaceByIndex = function (findIndex, newIndex, tileX, tileY, width, height, layer) {
            var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
            for (var i = 0; i < tiles.length; i++) {
              if (tiles[i] && tiles[i].index === findIndex) {
                tiles[i].index = newIndex;
              }
            }
          };
          module2.exports = ReplaceByIndex;
        }, function (module2, exports2, __webpack_require__) {
          var Rectangle = __webpack_require__(10);
          var SnapCeil = __webpack_require__(139);
          var SnapFloor = __webpack_require__(76);
          var bounds = new Rectangle();
          var CullBounds = function (layer, camera) {
            var tilemap = layer.tilemapLayer.tilemap;
            var tilemapLayer = layer.tilemapLayer;
            var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);
            var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);
            var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;
            var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;
            var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH, 0, true) - tilemapLayer.cullPaddingY;
            var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH, 0, true) + tilemapLayer.cullPaddingY;
            return bounds.setTo(boundsLeft, boundsTop, boundsRight - boundsLeft, boundsBottom - boundsTop);
          };
          module2.exports = CullBounds;
        }, function (module2, exports2, __webpack_require__) {
          var CullBounds = __webpack_require__(543);
          var RunCull = __webpack_require__(159);
          var CullTiles = function (layer, camera, outputArray, renderOrder) {
            if (outputArray === void 0) {
              outputArray = [];
            }
            if (renderOrder === void 0) {
              renderOrder = 0;
            }
            outputArray.length = 0;
            var tilemapLayer = layer.tilemapLayer;
            var bounds = CullBounds(layer, camera);
            if (tilemapLayer.skipCull || tilemapLayer.scrollFactorX !== 1 || tilemapLayer.scrollFactorY !== 1) {
              bounds.left = 0;
              bounds.right = layer.width;
              bounds.top = 0;
              bounds.bottom = layer.height;
            }
            RunCull(layer, bounds, renderOrder, outputArray);
            return outputArray;
          };
          module2.exports = CullTiles;
        }, function (module2, exports2, __webpack_require__) {
          var CullBounds = __webpack_require__(546);
          var RunCull = __webpack_require__(159);
          var HexagonalCullTiles = function (layer, camera, outputArray, renderOrder) {
            if (outputArray === void 0) {
              outputArray = [];
            }
            if (renderOrder === void 0) {
              renderOrder = 0;
            }
            outputArray.length = 0;
            var tilemapLayer = layer.tilemapLayer;
            if (!tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1) {
              var bounds = CullBounds(layer, camera);
              RunCull(layer, bounds, renderOrder, outputArray);
            }
            return outputArray;
          };
          module2.exports = HexagonalCullTiles;
        }, function (module2, exports2, __webpack_require__) {
          var SnapCeil = __webpack_require__(139);
          var SnapFloor = __webpack_require__(76);
          var HexagonalCullBounds = function (layer, camera) {
            var tilemap = layer.tilemapLayer.tilemap;
            var tilemapLayer = layer.tilemapLayer;
            var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);
            var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);
            var len = layer.hexSideLength;
            var rowH = (tileH - len) / 2 + len;
            var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;
            var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;
            var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, rowH, 0, true) - tilemapLayer.cullPaddingY;
            var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, rowH, 0, true) + tilemapLayer.cullPaddingY;
            return {
              left: boundsLeft,
              right: boundsRight,
              top: boundsTop,
              bottom: boundsBottom
            };
          };
          module2.exports = HexagonalCullBounds;
        }, function (module2, exports2, __webpack_require__) {
          var CheckIsoBounds = __webpack_require__(541);
          var IsometricCullTiles = function (layer, camera, outputArray, renderOrder) {
            if (outputArray === void 0) {
              outputArray = [];
            }
            if (renderOrder === void 0) {
              renderOrder = 0;
            }
            outputArray.length = 0;
            var tilemapLayer = layer.tilemapLayer;
            var mapData = layer.data;
            var mapWidth = layer.width;
            var mapHeight = layer.height;
            var drawLeft = 0;
            var drawRight = mapWidth;
            var drawTop = 0;
            var drawBottom = mapHeight;
            if (!tilemapLayer.skipCull) {
              var x;
              var y;
              var tile;
              if (renderOrder === 0) {
                for (y = drawTop; y < drawBottom; y++) {
                  for (x = drawLeft; mapData[y] && x < drawRight; x++) {
                    if (CheckIsoBounds(x, y, layer, camera)) {
                      tile = mapData[y][x];
                      if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                        continue;
                      }
                      outputArray.push(tile);
                    }
                  }
                }
              } else if (renderOrder === 1) {
                for (y = drawTop; y < drawBottom; y++) {
                  for (x = drawRight; mapData[y] && x >= drawLeft; x--) {
                    if (CheckIsoBounds(x, y, layer, camera)) {
                      tile = mapData[y][x];
                      if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                        continue;
                      }
                      outputArray.push(tile);
                    }
                  }
                }
              } else if (renderOrder === 2) {
                for (y = drawBottom; y >= drawTop; y--) {
                  for (x = drawLeft; mapData[y] && x < drawRight; x++) {
                    if (CheckIsoBounds(x, y, layer, camera)) {
                      tile = mapData[y][x];
                      if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                        continue;
                      }
                      outputArray.push(tile);
                    }
                  }
                }
              } else if (renderOrder === 3) {
                for (y = drawBottom; y >= drawTop; y--) {
                  for (x = drawRight; mapData[y] && x >= drawLeft; x--) {
                    if (CheckIsoBounds(x, y, layer, camera)) {
                      tile = mapData[y][x];
                      if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                        continue;
                      }
                      outputArray.push(tile);
                    }
                  }
                }
              }
            }
            tilemapLayer.tilesDrawn = outputArray.length;
            tilemapLayer.tilesTotal = mapWidth * mapHeight;
            return outputArray;
          };
          module2.exports = IsometricCullTiles;
        }, function (module2, exports2, __webpack_require__) {
          var CullBounds = __webpack_require__(549);
          var RunCull = __webpack_require__(159);
          var StaggeredCullTiles = function (layer, camera, outputArray, renderOrder) {
            if (outputArray === void 0) {
              outputArray = [];
            }
            if (renderOrder === void 0) {
              renderOrder = 0;
            }
            outputArray.length = 0;
            var tilemapLayer = layer.tilemapLayer;
            if (!tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1) {
              var bounds = CullBounds(layer, camera);
              RunCull(layer, bounds, renderOrder, outputArray);
            }
            return outputArray;
          };
          module2.exports = StaggeredCullTiles;
        }, function (module2, exports2, __webpack_require__) {
          var SnapCeil = __webpack_require__(139);
          var SnapFloor = __webpack_require__(76);
          var StaggeredCullBounds = function (layer, camera) {
            var tilemap = layer.tilemapLayer.tilemap;
            var tilemapLayer = layer.tilemapLayer;
            var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);
            var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);
            var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;
            var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;
            var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH / 2, 0, true) - tilemapLayer.cullPaddingY;
            var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH / 2, 0, true) + tilemapLayer.cullPaddingY;
            return {
              left: boundsLeft,
              right: boundsRight,
              top: boundsTop,
              bottom: boundsBottom
            };
          };
          module2.exports = StaggeredCullBounds;
        }, function (module2, exports2, __webpack_require__) {
          var Vector2 = __webpack_require__(3);
          var HexagonalTileToWorldXY = function (tileX, tileY, point, camera, layer) {
            if (!point) {
              point = new Vector2();
            }
            var tileWidth = layer.baseTileWidth;
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            var layerWorldX = 0;
            var layerWorldY = 0;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
              tileWidth *= tilemapLayer.scaleX;
              layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
              tileHeight *= tilemapLayer.scaleY;
            }
            var len = layer.hexSideLength;
            var rowHeight = (tileHeight - len) / 2 + len;
            var x = layerWorldX + tileX * tileWidth + tileY % 2 * (tileWidth / 2);
            var y = layerWorldY + tileY * rowHeight;
            return point.set(x, y);
          };
          module2.exports = HexagonalTileToWorldXY;
        }, function (module2, exports2, __webpack_require__) {
          var Vector2 = __webpack_require__(3);
          var IsometricTileToWorldXY = function (tileX, tileY, point, camera, layer) {
            if (!point) {
              point = new Vector2();
            }
            var tileWidth = layer.baseTileWidth;
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            var layerWorldX = 0;
            var layerWorldY = 0;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
              tileWidth *= tilemapLayer.scaleX;
              layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
              tileHeight *= tilemapLayer.scaleY;
            }
            var x = layerWorldX + (tileX - tileY) * (tileWidth / 2);
            var y = layerWorldY + (tileX + tileY) * (tileHeight / 2);
            return point.set(x, y);
          };
          module2.exports = IsometricTileToWorldXY;
        }, function (module2, exports2, __webpack_require__) {
          var Vector2 = __webpack_require__(3);
          var StaggeredTileToWorldXY = function (tileX, tileY, point, camera, layer) {
            if (!point) {
              point = new Vector2();
            }
            var tileWidth = layer.baseTileWidth;
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            var layerWorldX = 0;
            var layerWorldY = 0;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
              tileWidth *= tilemapLayer.scaleX;
              layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
              tileHeight *= tilemapLayer.scaleY;
            }
            var x = layerWorldX + tileX * tileWidth + tileY % 2 * (tileWidth / 2);
            var y = layerWorldY + tileY * (tileHeight / 2);
            return point.set(x, y);
          };
          module2.exports = StaggeredTileToWorldXY;
        }, function (module2, exports2, __webpack_require__) {
          var TileToWorldX = __webpack_require__(253);
          var TileToWorldY = __webpack_require__(254);
          var Vector2 = __webpack_require__(3);
          var TileToWorldXY = function (tileX, tileY, point, camera, layer) {
            if (!point) {
              point = new Vector2(0, 0);
            }
            point.x = TileToWorldX(tileX, camera, layer);
            point.y = TileToWorldY(tileY, camera, layer);
            return point;
          };
          module2.exports = TileToWorldXY;
        }, function (module2, exports2) {
          var HexagonalTileToWorldY = function (tileY, camera, layer) {
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            var layerWorldY = 0;
            if (tilemapLayer) {
              if (camera === void 0) {
                camera = tilemapLayer.scene.cameras.main;
              }
              layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
              tileHeight *= tilemapLayer.scaleY;
            }
            var len = tilemapLayer.tilemap.hexSideLength;
            var rowHeight = (tileHeight - len) / 2 + len;
            return layerWorldY + tileY * rowHeight;
          };
          module2.exports = HexagonalTileToWorldY;
        }, function (module2, exports2) {
          var StaggeredTileToWorldY = function (tileY, camera, layer) {
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            var layerWorldY = 0;
            if (tilemapLayer) {
              if (camera === void 0) {
                camera = tilemapLayer.scene.cameras.main;
              }
              layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
              tileHeight *= tilemapLayer.scaleY;
            }
            return layerWorldY + tileY * (tileHeight / 2);
          };
          module2.exports = StaggeredTileToWorldY;
        }, function (module2, exports2, __webpack_require__) {
          var Vector2 = __webpack_require__(3);
          var HexagonalWorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer) {
            if (!point) {
              point = new Vector2();
            }
            var tileWidth = layer.baseTileWidth;
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
              tileHeight *= tilemapLayer.scaleY;
              worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
              tileWidth *= tilemapLayer.scaleX;
            }
            var len = layer.hexSideLength;
            var rowHeight = (tileHeight - len) / 2 + len;
            var y = snapToFloor ? Math.floor(worldY / rowHeight) : worldY / rowHeight;
            var x = snapToFloor ? Math.floor((worldX - y % 2 * 0.5 * tileWidth) / tileWidth) : (worldX - y % 2 * 0.5 * tileWidth) / tileWidth;
            return point.set(x, y);
          };
          module2.exports = HexagonalWorldToTileXY;
        }, function (module2, exports2, __webpack_require__) {
          var Vector2 = __webpack_require__(3);
          var IsometricWorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer) {
            if (!point) {
              point = new Vector2();
            }
            var tileWidth = layer.baseTileWidth;
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
              tileHeight *= tilemapLayer.scaleY;
              worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
              tileWidth *= tilemapLayer.scaleX;
            }
            var x = snapToFloor ? Math.floor((worldX / (tileWidth / 2) + worldY / (tileHeight / 2)) / 2) : (worldX / (tileWidth / 2) + worldY / (tileHeight / 2)) / 2;
            var y = snapToFloor ? Math.floor((worldY / (tileHeight / 2) - worldX / (tileWidth / 2)) / 2) : (worldY / (tileHeight / 2) - worldX / (tileWidth / 2)) / 2;
            return point.set(x, y);
          };
          module2.exports = IsometricWorldToTileXY;
        }, function (module2, exports2, __webpack_require__) {
          var Vector2 = __webpack_require__(3);
          var StaggeredWorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer) {
            if (!point) {
              point = new Vector2();
            }
            var tileWidth = layer.baseTileWidth;
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
              tileHeight *= tilemapLayer.scaleY;
              worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
              tileWidth *= tilemapLayer.scaleX;
            }
            var y = snapToFloor ? Math.floor(worldY / (tileHeight / 2)) : worldY / (tileHeight / 2);
            var x = snapToFloor ? Math.floor((worldX + y % 2 * 0.5 * tileWidth) / tileWidth) : (worldX + y % 2 * 0.5 * tileWidth) / tileWidth;
            return point.set(x, y);
          };
          module2.exports = StaggeredWorldToTileXY;
        }, function (module2, exports2, __webpack_require__) {
          var WorldToTileX = __webpack_require__(255);
          var WorldToTileY = __webpack_require__(256);
          var Vector2 = __webpack_require__(3);
          var WorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer) {
            if (snapToFloor === void 0) {
              snapToFloor = true;
            }
            if (!point) {
              point = new Vector2(0, 0);
            }
            point.x = WorldToTileX(worldX, snapToFloor, camera, layer);
            point.y = WorldToTileY(worldY, snapToFloor, camera, layer);
            return point;
          };
          module2.exports = WorldToTileXY;
        }, function (module2, exports2) {
          var HexagonalWorldToTileY = function (worldY, snapToFloor, camera, layer) {
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
              tileHeight *= tilemapLayer.scaleY;
            }
            var len = layer.hexSideLength;
            var rowHeight = (tileHeight - len) / 2 + len;
            return snapToFloor ? Math.floor(worldY / rowHeight) : worldY / rowHeight;
          };
          module2.exports = HexagonalWorldToTileY;
        }, function (module2, exports2) {
          var StaggeredWorldToTileY = function (worldY, snapToFloor, camera, layer) {
            var tileHeight = layer.baseTileHeight;
            var tilemapLayer = layer.tilemapLayer;
            if (tilemapLayer) {
              if (!camera) {
                camera = tilemapLayer.scene.cameras.main;
              }
              worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
              tileHeight *= tilemapLayer.scaleY;
            }
            return snapToFloor ? Math.floor(worldY / (tileHeight / 2)) : worldY / (tileHeight / 2);
          };
          module2.exports = StaggeredWorldToTileY;
        }, function (module2, exports2, __webpack_require__) {
          var IsInLayerBounds = __webpack_require__(119);
          var HasTileAt = function (tileX, tileY, layer) {
            if (IsInLayerBounds(tileX, tileY, layer)) {
              var tile = layer.data[tileY][tileX];
              return tile !== null && tile.index > -1;
            } else {
              return false;
            }
          };
          module2.exports = HasTileAt;
        }, function (module2, exports2, __webpack_require__) {
          var Tile = __webpack_require__(85);
          var IsInLayerBounds = __webpack_require__(119);
          var CalculateFacesAt = __webpack_require__(252);
          var RemoveTileAt = function (tileX, tileY, replaceWithNull, recalculateFaces, layer) {
            if (replaceWithNull === void 0) {
              replaceWithNull = true;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            if (!IsInLayerBounds(tileX, tileY, layer)) {
              return null;
            }
            var tile = layer.data[tileY][tileX];
            if (!tile) {
              return null;
            } else {
              layer.data[tileY][tileX] = replaceWithNull ? null : new Tile(layer, -1, tileX, tileY, layer.tileWidth, layer.tileHeight);
            }
            if (recalculateFaces && tile && tile.collides) {
              CalculateFacesAt(tileX, tileY, layer);
            }
            return tile;
          };
          module2.exports = RemoveTileAt;
        }, function (module2, exports2, __webpack_require__) {
          var Formats = __webpack_require__(40);
          var Parse2DArray = __webpack_require__(259);
          var ParseCSV = __webpack_require__(565);
          var ParseJSONTiled = __webpack_require__(566);
          var ParseWeltmeister = __webpack_require__(577);
          var Parse = function (name, mapFormat, data, tileWidth, tileHeight, insertNull) {
            var newMap;
            switch (mapFormat) {
              case Formats.ARRAY_2D:
                newMap = Parse2DArray(name, data, tileWidth, tileHeight, insertNull);
                break;
              case Formats.CSV:
                newMap = ParseCSV(name, data, tileWidth, tileHeight, insertNull);
                break;
              case Formats.TILED_JSON:
                newMap = ParseJSONTiled(name, data, insertNull);
                break;
              case Formats.WELTMEISTER:
                newMap = ParseWeltmeister(name, data, insertNull);
                break;
              default:
                console.warn("Unrecognized tilemap data format: " + mapFormat);
                newMap = null;
            }
            return newMap;
          };
          module2.exports = Parse;
        }, function (module2, exports2, __webpack_require__) {
          var Formats = __webpack_require__(40);
          var Parse2DArray = __webpack_require__(259);
          var ParseCSV = function (name, data, tileWidth, tileHeight, insertNull) {
            var array2D = data.trim().split("\n").map(function (row) {
              return row.split(",");
            });
            var map = Parse2DArray(name, array2D, tileWidth, tileHeight, insertNull);
            map.format = Formats.CSV;
            return map;
          };
          module2.exports = ParseCSV;
        }, function (module2, exports2, __webpack_require__) {
          var AssignTileProperties = __webpack_require__(567);
          var BuildTilesetIndex = __webpack_require__(568);
          var CONST = __webpack_require__(29);
          var Formats = __webpack_require__(40);
          var FromOrientationString = __webpack_require__(258);
          var MapData = __webpack_require__(121);
          var ParseImageLayers = __webpack_require__(569);
          var ParseObjectLayers = __webpack_require__(570);
          var ParseTileLayers = __webpack_require__(573);
          var ParseTilesets = __webpack_require__(575);
          var ParseJSONTiled = function (name, json, insertNull) {
            var mapData = new MapData({
              width: json.width,
              height: json.height,
              name,
              tileWidth: json.tilewidth,
              tileHeight: json.tileheight,
              orientation: FromOrientationString(json.orientation),
              format: Formats.TILED_JSON,
              version: json.version,
              properties: json.properties,
              renderOrder: json.renderorder,
              infinite: json.infinite
            });
            if (mapData.orientation === CONST.HEXAGONAL) {
              mapData.hexSideLength = json.hexsidelength;
            }
            mapData.layers = ParseTileLayers(json, insertNull);
            mapData.images = ParseImageLayers(json);
            var sets = ParseTilesets(json);
            mapData.tilesets = sets.tilesets;
            mapData.imageCollections = sets.imageCollections;
            mapData.objects = ParseObjectLayers(json);
            mapData.tiles = BuildTilesetIndex(mapData);
            AssignTileProperties(mapData);
            return mapData;
          };
          module2.exports = ParseJSONTiled;
        }, function (module2, exports2, __webpack_require__) {
          var Extend = __webpack_require__(17);
          var AssignTileProperties = function (mapData) {
            var layerData;
            var tile;
            var sid;
            var set;
            var row;
            for (var i = 0; i < mapData.layers.length; i++) {
              layerData = mapData.layers[i];
              set = null;
              for (var j = 0; j < layerData.data.length; j++) {
                row = layerData.data[j];
                for (var k = 0; k < row.length; k++) {
                  tile = row[k];
                  if (tile === null || tile.index < 0) {
                    continue;
                  }
                  sid = mapData.tiles[tile.index][2];
                  set = mapData.tilesets[sid];
                  tile.width = set.tileWidth;
                  tile.height = set.tileHeight;
                  if (set.tileProperties && set.tileProperties[tile.index - set.firstgid]) {
                    tile.properties = Extend(tile.properties, set.tileProperties[tile.index - set.firstgid]);
                  }
                }
              }
            }
          };
          module2.exports = AssignTileProperties;
        }, function (module2, exports2, __webpack_require__) {
          var Tileset = __webpack_require__(122);
          var BuildTilesetIndex = function (mapData) {
            var i;
            var set;
            var tiles = [];
            for (i = 0; i < mapData.imageCollections.length; i++) {
              var collection = mapData.imageCollections[i];
              var images = collection.images;
              for (var j = 0; j < images.length; j++) {
                var image = images[j];
                set = new Tileset(image.image, image.gid, collection.imageWidth, collection.imageHeight, 0, 0);
                set.updateTileData(collection.imageWidth, collection.imageHeight);
                mapData.tilesets.push(set);
              }
            }
            for (i = 0; i < mapData.tilesets.length; i++) {
              set = mapData.tilesets[i];
              var x = set.tileMargin;
              var y = set.tileMargin;
              var count = 0;
              var countX = 0;
              var countY = 0;
              for (var t = set.firstgid; t < set.firstgid + set.total; t++) {
                tiles[t] = [x, y, i];
                x += set.tileWidth + set.tileSpacing;
                count++;
                if (count === set.total) {
                  break;
                }
                countX++;
                if (countX === set.columns) {
                  x = set.tileMargin;
                  y += set.tileHeight + set.tileSpacing;
                  countX = 0;
                  countY++;
                  if (countY === set.rows) {
                    break;
                  }
                }
              }
            }
            return tiles;
          };
          module2.exports = BuildTilesetIndex;
        }, function (module2, exports2, __webpack_require__) {
          var GetFastValue = __webpack_require__(2);
          var CreateGroupLayer = __webpack_require__(161);
          var ParseImageLayers = function (json) {
            var images = [];
            var groupStack = [];
            var curGroupState = CreateGroupLayer(json);
            while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0) {
              if (curGroupState.i >= curGroupState.layers.length) {
                if (groupStack.length < 1) {
                  console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
                  break;
                }
                curGroupState = groupStack.pop();
                continue;
              }
              var curi = curGroupState.layers[curGroupState.i];
              curGroupState.i++;
              if (curi.type !== "imagelayer") {
                if (curi.type === "group") {
                  var nextGroupState = CreateGroupLayer(json, curi, curGroupState);
                  groupStack.push(curGroupState);
                  curGroupState = nextGroupState;
                }
                continue;
              }
              var layerOffsetX = GetFastValue(curi, "offsetx", 0) + GetFastValue(curi, "startx", 0);
              var layerOffsetY = GetFastValue(curi, "offsety", 0) + GetFastValue(curi, "starty", 0);
              images.push({
                name: curGroupState.name + curi.name,
                image: curi.image,
                x: curGroupState.x + layerOffsetX + curi.x,
                y: curGroupState.y + layerOffsetY + curi.y,
                alpha: curGroupState.opacity * curi.opacity,
                visible: curGroupState.visible && curi.visible,
                properties: GetFastValue(curi, "properties", {})
              });
            }
            return images;
          };
          module2.exports = ParseImageLayers;
        }, function (module2, exports2, __webpack_require__) {
          var GetFastValue = __webpack_require__(2);
          var ParseObject = __webpack_require__(260);
          var ObjectLayer = __webpack_require__(572);
          var CreateGroupLayer = __webpack_require__(161);
          var ParseObjectLayers = function (json) {
            var objectLayers = [];
            var groupStack = [];
            var curGroupState = CreateGroupLayer(json);
            while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0) {
              if (curGroupState.i >= curGroupState.layers.length) {
                if (groupStack.length < 1) {
                  console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
                  break;
                }
                curGroupState = groupStack.pop();
                continue;
              }
              var curo = curGroupState.layers[curGroupState.i];
              curGroupState.i++;
              curo.opacity *= curGroupState.opacity;
              curo.visible = curGroupState.visible && curo.visible;
              if (curo.type !== "objectgroup") {
                if (curo.type === "group") {
                  var nextGroupState = CreateGroupLayer(json, curo, curGroupState);
                  groupStack.push(curGroupState);
                  curGroupState = nextGroupState;
                }
                continue;
              }
              curo.name = curGroupState.name + curo.name;
              var offsetX = curGroupState.x + GetFastValue(curo, "startx", 0) + GetFastValue(curo, "offsetx", 0);
              var offsetY = curGroupState.y + GetFastValue(curo, "starty", 0) + GetFastValue(curo, "offsety", 0);
              var objects = [];
              for (var j = 0; j < curo.objects.length; j++) {
                var parsedObject = ParseObject(curo.objects[j], offsetX, offsetY);
                objects.push(parsedObject);
              }
              var objectLayer = new ObjectLayer(curo);
              objectLayer.objects = objects;
              objectLayers.push(objectLayer);
            }
            return objectLayers;
          };
          module2.exports = ParseObjectLayers;
        }, function (module2, exports2, __webpack_require__) {
          var HasValue = __webpack_require__(126);
          var Pick = function (object, keys) {
            var obj = {};
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (HasValue(object, key)) {
                obj[key] = object[key];
              }
            }
            return obj;
          };
          module2.exports = Pick;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var ObjectLayer = new Class({
            initialize: function ObjectLayer2(config) {
              if (config === void 0) {
                config = {};
              }
              this.name = GetFastValue(config, "name", "object layer");
              this.opacity = GetFastValue(config, "opacity", 1);
              this.properties = GetFastValue(config, "properties", {});
              this.propertyTypes = GetFastValue(config, "propertytypes", {});
              this.type = GetFastValue(config, "type", "objectgroup");
              this.visible = GetFastValue(config, "visible", true);
              this.objects = GetFastValue(config, "objects", []);
            }
          });
          module2.exports = ObjectLayer;
        }, function (module2, exports2, __webpack_require__) {
          var Base64Decode = __webpack_require__(574);
          var CONST = __webpack_require__(29);
          var CreateGroupLayer = __webpack_require__(161);
          var FromOrientationString = __webpack_require__(258);
          var GetFastValue = __webpack_require__(2);
          var LayerData = __webpack_require__(120);
          var ParseGID = __webpack_require__(261);
          var Tile = __webpack_require__(85);
          var ParseTileLayers = function (json, insertNull) {
            var infiniteMap = GetFastValue(json, "infinite", false);
            var tileLayers = [];
            var groupStack = [];
            var curGroupState = CreateGroupLayer(json);
            while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0) {
              if (curGroupState.i >= curGroupState.layers.length) {
                if (groupStack.length < 1) {
                  console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
                  break;
                }
                curGroupState = groupStack.pop();
                continue;
              }
              var curl = curGroupState.layers[curGroupState.i];
              curGroupState.i++;
              if (curl.type !== "tilelayer") {
                if (curl.type === "group") {
                  var nextGroupState = CreateGroupLayer(json, curl, curGroupState);
                  groupStack.push(curGroupState);
                  curGroupState = nextGroupState;
                }
                continue;
              }
              if (curl.compression) {
                console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '" + curl.name + "'");
                continue;
              } else if (curl.encoding && curl.encoding === "base64") {
                if (curl.chunks) {
                  for (var i = 0; i < curl.chunks.length; i++) {
                    curl.chunks[i].data = Base64Decode(curl.chunks[i].data);
                  }
                }
                if (curl.data) {
                  curl.data = Base64Decode(curl.data);
                }
                delete curl.encoding;
              }
              var layerData;
              var gidInfo;
              var tile;
              var blankTile;
              var output = [];
              var x = 0;
              if (infiniteMap) {
                var layerOffsetX = GetFastValue(curl, "startx", 0) + curl.x;
                var layerOffsetY = GetFastValue(curl, "starty", 0) + curl.y;
                layerData = new LayerData({
                  name: curGroupState.name + curl.name,
                  x: curGroupState.x + GetFastValue(curl, "offsetx", 0) + layerOffsetX * json.tilewidth,
                  y: curGroupState.y + GetFastValue(curl, "offsety", 0) + layerOffsetY * json.tileheight,
                  width: curl.width,
                  height: curl.height,
                  tileWidth: json.tilewidth,
                  tileHeight: json.tileheight,
                  alpha: curGroupState.opacity * curl.opacity,
                  visible: curGroupState.visible && curl.visible,
                  properties: GetFastValue(curl, "properties", []),
                  orientation: FromOrientationString(json.orientation)
                });
                if (layerData.orientation === CONST.HEXAGONAL) {
                  layerData.hexSideLength = json.hexsidelength;
                }
                for (var c = 0; c < curl.height; c++) {
                  output.push([null]);
                  for (var j = 0; j < curl.width; j++) {
                    output[c][j] = null;
                  }
                }
                for ((c = 0, len = curl.chunks.length); c < len; c++) {
                  var chunk = curl.chunks[c];
                  var offsetX = chunk.x - layerOffsetX;
                  var offsetY = chunk.y - layerOffsetY;
                  var y = 0;
                  for (var t = 0, len2 = chunk.data.length; t < len2; t++) {
                    var newOffsetX = x + offsetX;
                    var newOffsetY = y + offsetY;
                    gidInfo = ParseGID(chunk.data[t]);
                    if (gidInfo.gid > 0) {
                      tile = new Tile(layerData, gidInfo.gid, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);
                      tile.rotation = gidInfo.rotation;
                      tile.flipX = gidInfo.flipped;
                      output[newOffsetY][newOffsetX] = tile;
                    } else {
                      blankTile = insertNull ? null : new Tile(layerData, -1, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);
                      output[newOffsetY][newOffsetX] = blankTile;
                    }
                    x++;
                    if (x === chunk.width) {
                      y++;
                      x = 0;
                    }
                  }
                }
              } else {
                layerData = new LayerData({
                  name: curGroupState.name + curl.name,
                  x: curGroupState.x + GetFastValue(curl, "offsetx", 0) + curl.x,
                  y: curGroupState.y + GetFastValue(curl, "offsety", 0) + curl.y,
                  width: curl.width,
                  height: curl.height,
                  tileWidth: json.tilewidth,
                  tileHeight: json.tileheight,
                  alpha: curGroupState.opacity * curl.opacity,
                  visible: curGroupState.visible && curl.visible,
                  properties: GetFastValue(curl, "properties", []),
                  orientation: FromOrientationString(json.orientation)
                });
                if (layerData.orientation === CONST.HEXAGONAL) {
                  layerData.hexSideLength = json.hexsidelength;
                }
                var row = [];
                for (var k = 0, len = curl.data.length; k < len; k++) {
                  gidInfo = ParseGID(curl.data[k]);
                  if (gidInfo.gid > 0) {
                    tile = new Tile(layerData, gidInfo.gid, x, output.length, json.tilewidth, json.tileheight);
                    tile.rotation = gidInfo.rotation;
                    tile.flipX = gidInfo.flipped;
                    row.push(tile);
                  } else {
                    blankTile = insertNull ? null : new Tile(layerData, -1, x, output.length, json.tilewidth, json.tileheight);
                    row.push(blankTile);
                  }
                  x++;
                  if (x === curl.width) {
                    output.push(row);
                    x = 0;
                    row = [];
                  }
                }
              }
              layerData.data = output;
              tileLayers.push(layerData);
            }
            return tileLayers;
          };
          module2.exports = ParseTileLayers;
        }, function (module2, exports2) {
          var Base64Decode = function (data) {
            var binaryString = window.atob(data);
            var len = binaryString.length;
            var bytes = new Array(len / 4);
            for (var i = 0; i < len; i += 4) {
              bytes[i / 4] = (binaryString.charCodeAt(i) | binaryString.charCodeAt(i + 1) << 8 | binaryString.charCodeAt(i + 2) << 16 | binaryString.charCodeAt(i + 3) << 24) >>> 0;
            }
            return bytes;
          };
          module2.exports = Base64Decode;
        }, function (module2, exports2, __webpack_require__) {
          var Tileset = __webpack_require__(122);
          var ImageCollection = __webpack_require__(576);
          var ParseObject = __webpack_require__(260);
          var ParseWangsets = __webpack_require__(1453);
          var ParseTilesets = function (json) {
            var tilesets = [];
            var imageCollections = [];
            var lastSet = null;
            var stringID;
            for (var i = 0; i < json.tilesets.length; i++) {
              var set = json.tilesets[i];
              if (set.source) {
                console.warn("External tilesets unsupported. Use Embed Tileset and re-export");
              } else if (set.image) {
                var newSet = new Tileset(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing);
                if (json.version > 1) {
                  var datas = void 0;
                  var props = void 0;
                  if (Array.isArray(set.tiles)) {
                    datas = datas || ({});
                    props = props || ({});
                    for (var t = 0; t < set.tiles.length; t++) {
                      var tile = set.tiles[t];
                      if (tile.properties) {
                        var newPropData = {};
                        tile.properties.forEach(function (propData) {
                          newPropData[propData["name"]] = propData["value"];
                        });
                        props[tile.id] = newPropData;
                      }
                      if (tile.objectgroup) {
                        (datas[tile.id] || (datas[tile.id] = {})).objectgroup = tile.objectgroup;
                        if (tile.objectgroup.objects) {
                          var parsedObjects2 = tile.objectgroup.objects.map(function (obj) {
                            return ParseObject(obj);
                          });
                          datas[tile.id].objectgroup.objects = parsedObjects2;
                        }
                      }
                      if (tile.animation) {
                        (datas[tile.id] || (datas[tile.id] = {})).animation = tile.animation;
                      }
                      if (tile.type) {
                        (datas[tile.id] || (datas[tile.id] = {})).type = tile.type;
                      }
                    }
                  }
                  if (Array.isArray(set.wangsets)) {
                    datas = datas || ({});
                    props = props || ({});
                    ParseWangsets(set.wangsets, datas);
                  }
                  if (datas) {
                    newSet.tileData = datas;
                    newSet.tileProperties = props;
                  }
                } else {
                  if (set.tileproperties) {
                    newSet.tileProperties = set.tileproperties;
                  }
                  if (set.tiles) {
                    newSet.tileData = set.tiles;
                    for (stringID in newSet.tileData) {
                      var objectGroup = newSet.tileData[stringID].objectgroup;
                      if (objectGroup && objectGroup.objects) {
                        var parsedObjects1 = objectGroup.objects.map(function (obj) {
                          return ParseObject(obj);
                        });
                        newSet.tileData[stringID].objectgroup.objects = parsedObjects1;
                      }
                    }
                  }
                }
                newSet.updateTileData(set.imagewidth, set.imageheight);
                tilesets.push(newSet);
              } else {
                var newCollection = new ImageCollection(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, set.properties);
                var maxId = 0;
                for (t = 0; t < set.tiles.length; t++) {
                  tile = set.tiles[t];
                  var image = tile.image;
                  var tileId = parseInt(tile.id, 10);
                  var gid = set.firstgid + tileId;
                  newCollection.addImage(gid, image);
                  maxId = Math.max(tileId, maxId);
                }
                newCollection.maxId = maxId;
                imageCollections.push(newCollection);
              }
              if (lastSet) {
                lastSet.lastgid = set.firstgid - 1;
              }
              lastSet = set;
            }
            return {
              tilesets,
              imageCollections
            };
          };
          module2.exports = ParseTilesets;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var ImageCollection = new Class({
            initialize: function ImageCollection2(name, firstgid, width, height, margin, spacing, properties) {
              if (width === void 0 || width <= 0) {
                width = 32;
              }
              if (height === void 0 || height <= 0) {
                height = 32;
              }
              if (margin === void 0) {
                margin = 0;
              }
              if (spacing === void 0) {
                spacing = 0;
              }
              this.name = name;
              this.firstgid = firstgid | 0;
              this.imageWidth = width | 0;
              this.imageHeight = height | 0;
              this.imageMargin = margin | 0;
              this.imageSpacing = spacing | 0;
              this.properties = properties || ({});
              this.images = [];
              this.total = 0;
            },
            containsImageIndex: function (imageIndex) {
              return imageIndex >= this.firstgid && imageIndex < this.firstgid + this.total;
            },
            addImage: function (gid, image) {
              this.images.push({
                gid,
                image
              });
              this.total++;
              return this;
            }
          });
          module2.exports = ImageCollection;
        }, function (module2, exports2, __webpack_require__) {
          var Formats = __webpack_require__(40);
          var MapData = __webpack_require__(121);
          var ParseTileLayers = __webpack_require__(578);
          var ParseTilesets = __webpack_require__(579);
          var ParseWeltmeister = function (name, json, insertNull) {
            if (json.layer.length === 0) {
              console.warn("No layers found in the Weltmeister map: " + name);
              return null;
            }
            var width = 0;
            var height = 0;
            for (var i = 0; i < json.layer.length; i++) {
              if (json.layer[i].width > width) {
                width = json.layer[i].width;
              }
              if (json.layer[i].height > height) {
                height = json.layer[i].height;
              }
            }
            var mapData = new MapData({
              width,
              height,
              name,
              tileWidth: json.layer[0].tilesize,
              tileHeight: json.layer[0].tilesize,
              format: Formats.WELTMEISTER
            });
            mapData.layers = ParseTileLayers(json, insertNull);
            mapData.tilesets = ParseTilesets(json);
            return mapData;
          };
          module2.exports = ParseWeltmeister;
        }, function (module2, exports2, __webpack_require__) {
          var LayerData = __webpack_require__(120);
          var Tile = __webpack_require__(85);
          var ParseTileLayers = function (json, insertNull) {
            var tileLayers = [];
            for (var i = 0; i < json.layer.length; i++) {
              var layer = json.layer[i];
              var layerData = new LayerData({
                name: layer.name,
                width: layer.width,
                height: layer.height,
                tileWidth: layer.tilesize,
                tileHeight: layer.tilesize,
                visible: layer.visible === 1
              });
              var row = [];
              var tileGrid = [];
              for (var y = 0; y < layer.data.length; y++) {
                for (var x = 0; x < layer.data[y].length; x++) {
                  var index = layer.data[y][x] - 1;
                  var tile;
                  if (index > -1) {
                    tile = new Tile(layerData, index, x, y, layer.tilesize, layer.tilesize);
                  } else {
                    tile = insertNull ? null : new Tile(layerData, -1, x, y, layer.tilesize, layer.tilesize);
                  }
                  row.push(tile);
                }
                tileGrid.push(row);
                row = [];
              }
              layerData.data = tileGrid;
              tileLayers.push(layerData);
            }
            return tileLayers;
          };
          module2.exports = ParseTileLayers;
        }, function (module2, exports2, __webpack_require__) {
          var Tileset = __webpack_require__(122);
          var ParseTilesets = function (json) {
            var tilesets = [];
            var tilesetsNames = [];
            for (var i = 0; i < json.layer.length; i++) {
              var layer = json.layer[i];
              var tilesetName = layer.tilesetName;
              if (tilesetName !== "" && tilesetsNames.indexOf(tilesetName) === -1) {
                tilesetsNames.push(tilesetName);
                tilesets.push(new Tileset(tilesetName, 0, layer.tilesize, layer.tilesize, 0, 0));
              }
            }
            return tilesets;
          };
          module2.exports = ParseTilesets;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var DegToRad = __webpack_require__(36);
          var Formats = __webpack_require__(40);
          var GetFastValue = __webpack_require__(2);
          var LayerData = __webpack_require__(120);
          var ORIENTATION = __webpack_require__(29);
          var Rotate = __webpack_require__(362);
          var SpliceOne = __webpack_require__(74);
          var Sprite = __webpack_require__(73);
          var Tile = __webpack_require__(85);
          var TilemapComponents = __webpack_require__(251);
          var TilemapLayer = __webpack_require__(581);
          var Tileset = __webpack_require__(122);
          var Tilemap = new Class({
            initialize: function Tilemap2(scene, mapData) {
              this.scene = scene;
              this.tileWidth = mapData.tileWidth;
              this.tileHeight = mapData.tileHeight;
              this.width = mapData.width;
              this.height = mapData.height;
              this.orientation = mapData.orientation;
              this.renderOrder = mapData.renderOrder;
              this.format = mapData.format;
              this.version = mapData.version;
              this.properties = mapData.properties;
              this.widthInPixels = mapData.widthInPixels;
              this.heightInPixels = mapData.heightInPixels;
              this.imageCollections = mapData.imageCollections;
              this.images = mapData.images;
              this.layers = mapData.layers;
              this.tilesets = mapData.tilesets;
              this.objects = mapData.objects;
              this.currentLayerIndex = 0;
              this.hexSideLength = mapData.hexSideLength;
              var orientation = this.orientation;
              this._convert = {
                WorldToTileXY: TilemapComponents.GetWorldToTileXYFunction(orientation),
                WorldToTileX: TilemapComponents.GetWorldToTileXFunction(orientation),
                WorldToTileY: TilemapComponents.GetWorldToTileYFunction(orientation),
                TileToWorldXY: TilemapComponents.GetTileToWorldXYFunction(orientation),
                TileToWorldX: TilemapComponents.GetTileToWorldXFunction(orientation),
                TileToWorldY: TilemapComponents.GetTileToWorldYFunction(orientation)
              };
            },
            createBlankDynamicLayer: function (name, tileset, x, y, width, height, tileWidth, tileHeight) {
              console.warn("createBlankDynamicLayer is deprecated. Use createBlankLayer");
              return this.createBlankLayer(name, tileset, x, y, width, height, tileWidth, tileHeight);
            },
            createDynamicLayer: function (layerID, tileset, x, y) {
              console.warn("createDynamicLayer is deprecated. Use createLayer");
              return this.createLayer(layerID, tileset, x, y);
            },
            createStaticLayer: function (layerID, tileset, x, y) {
              console.warn("createStaticLayer is deprecated. Use createLayer");
              return this.createLayer(layerID, tileset, x, y);
            },
            setRenderOrder: function (renderOrder) {
              var orders = ["right-down", "left-down", "right-up", "left-up"];
              if (typeof renderOrder === "number") {
                renderOrder = orders[renderOrder];
              }
              if (orders.indexOf(renderOrder) > -1) {
                this.renderOrder = renderOrder;
              }
              return this;
            },
            addTilesetImage: function (tilesetName, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid) {
              if (tilesetName === void 0) {
                return null;
              }
              if (key === void 0 || key === null) {
                key = tilesetName;
              }
              if (!this.scene.sys.textures.exists(key)) {
                console.warn("Invalid Tileset Image: " + key);
                return null;
              }
              var texture = this.scene.sys.textures.get(key);
              var index = this.getTilesetIndex(tilesetName);
              if (index === null && this.format === Formats.TILED_JSON) {
                console.warn("No data found for Tileset: " + tilesetName);
                return null;
              }
              var tileset = this.tilesets[index];
              if (tileset) {
                tileset.setTileSize(tileWidth, tileHeight);
                tileset.setSpacing(tileMargin, tileSpacing);
                tileset.setImage(texture);
                return tileset;
              }
              if (tileWidth === void 0) {
                tileWidth = this.tileWidth;
              }
              if (tileHeight === void 0) {
                tileHeight = this.tileHeight;
              }
              if (tileMargin === void 0) {
                tileMargin = 0;
              }
              if (tileSpacing === void 0) {
                tileSpacing = 0;
              }
              if (gid === void 0) {
                gid = 0;
              }
              tileset = new Tileset(tilesetName, gid, tileWidth, tileHeight, tileMargin, tileSpacing);
              tileset.setImage(texture);
              this.tilesets.push(tileset);
              return tileset;
            },
            copy: function (srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer) {
              layer = this.getLayer(layer);
              if (layer !== null) {
                TilemapComponents.Copy(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer);
                return this;
              } else {
                return null;
              }
            },
            createBlankLayer: function (name, tileset, x, y, width, height, tileWidth, tileHeight) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = this.width;
              }
              if (height === void 0) {
                height = this.height;
              }
              if (tileWidth === void 0) {
                tileWidth = this.tileWidth;
              }
              if (tileHeight === void 0) {
                tileHeight = this.tileHeight;
              }
              var index = this.getLayerIndex(name);
              if (index !== null) {
                console.warn("Invalid Tilemap Layer ID: " + name);
                return null;
              }
              var layerData = new LayerData({
                name,
                tileWidth,
                tileHeight,
                width,
                height,
                orientation: this.orientation
              });
              var row;
              for (var tileY = 0; tileY < height; tileY++) {
                row = [];
                for (var tileX = 0; tileX < width; tileX++) {
                  row.push(new Tile(layerData, -1, tileX, tileY, tileWidth, tileHeight, this.tileWidth, this.tileHeight));
                }
                layerData.data.push(row);
              }
              this.layers.push(layerData);
              this.currentLayerIndex = this.layers.length - 1;
              var layer = new TilemapLayer(this.scene, this, this.currentLayerIndex, tileset, x, y);
              layer.setRenderOrder(this.renderOrder);
              this.scene.sys.displayList.add(layer);
              return layer;
            },
            createLayer: function (layerID, tileset, x, y) {
              var index = this.getLayerIndex(layerID);
              if (index === null) {
                console.warn("Invalid Tilemap Layer ID: " + layerID);
                if (typeof layerID === "string") {
                  console.warn("Valid tilelayer names:\n	" + this.getTileLayerNames().join(",\n	"));
                }
                return null;
              }
              var layerData = this.layers[index];
              if (layerData.tilemapLayer) {
                console.warn("Tilemap Layer ID already exists:" + layerID);
                return null;
              }
              this.currentLayerIndex = index;
              if (x === void 0) {
                x = layerData.x;
              }
              if (y === void 0) {
                y = layerData.y;
              }
              var layer = new TilemapLayer(this.scene, this, index, tileset, x, y);
              layer.setRenderOrder(this.renderOrder);
              this.scene.sys.displayList.add(layer);
              return layer;
            },
            createFromObjects: function (objectLayerName, config) {
              var results = [];
              var objectLayer = this.getObjectLayer(objectLayerName);
              if (!objectLayer) {
                console.warn("createFromObjects: Invalid objectLayerName given: " + objectLayerName);
                return results;
              }
              if (!Array.isArray(config)) {
                config = [config];
              }
              var objects = objectLayer.objects;
              for (var c = 0; c < config.length; c++) {
                var singleConfig = config[c];
                var id = GetFastValue(singleConfig, "id", null);
                var gid = GetFastValue(singleConfig, "gid", null);
                var name = GetFastValue(singleConfig, "name", null);
                var obj;
                var toConvert = [];
                for (var s = 0; s < objects.length; s++) {
                  obj = objects[s];
                  if (id === null && gid === null && name === null || id !== null && obj.id === id || gid !== null && obj.gid === gid || name !== null && obj.name === name) {
                    toConvert.push(obj);
                  }
                }
                var classType = GetFastValue(singleConfig, "classType", Sprite);
                var scene = GetFastValue(singleConfig, "scene", this.scene);
                var container = GetFastValue(singleConfig, "container", null);
                var texture = GetFastValue(singleConfig, "key", null);
                var frame = GetFastValue(singleConfig, "frame", null);
                for (var i = 0; i < toConvert.length; i++) {
                  obj = toConvert[i];
                  var sprite = new classType(scene);
                  sprite.setName(obj.name);
                  sprite.setPosition(obj.x, obj.y);
                  sprite.setTexture(texture, frame);
                  if (obj.width) {
                    sprite.displayWidth = obj.width;
                  }
                  if (obj.height) {
                    sprite.displayHeight = obj.height;
                  }
                  var offset = {
                    x: sprite.originX * obj.width,
                    y: (sprite.originY - 1) * obj.height
                  };
                  if (obj.rotation) {
                    var angle = DegToRad(obj.rotation);
                    Rotate(offset, angle);
                    sprite.rotation = angle;
                  }
                  sprite.x += offset.x;
                  sprite.y += offset.y;
                  if (obj.flippedHorizontal !== void 0 || obj.flippedVertical !== void 0) {
                    sprite.setFlip(obj.flippedHorizontal, obj.flippedVertical);
                  }
                  if (!obj.visible) {
                    sprite.visible = false;
                  }
                  if (Array.isArray(obj.properties)) {
                    obj.properties.forEach(function (propData) {
                      var key2 = propData["name"];
                      if (sprite[key2] !== void 0) {
                        sprite[key2] = propData["value"];
                      } else {
                        sprite.setData(key2, propData["value"]);
                      }
                    });
                  } else {
                    for (var key in obj.properties) {
                      if (sprite[key] !== void 0) {
                        sprite[key] = obj.properties[key];
                      } else {
                        sprite.setData(key, obj.properties[key]);
                      }
                    }
                  }
                  if (container) {
                    container.add(sprite);
                  } else {
                    scene.add.existing(sprite);
                  }
                  results.push(sprite);
                }
              }
              return results;
            },
            createFromTiles: function (indexes, replacements, spriteConfig, scene, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, layer);
            },
            fill: function (index, tileX, tileY, width, height, recalculateFaces, layer) {
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, layer);
              return this;
            },
            filterObjects: function (objectLayer, callback, context) {
              if (typeof objectLayer === "string") {
                var name = objectLayer;
                objectLayer = this.getObjectLayer(objectLayer);
                if (!objectLayer) {
                  console.warn("No object layer found with the name: " + name);
                  return null;
                }
              }
              return objectLayer.objects.filter(callback, context);
            },
            filterTiles: function (callback, context, tileX, tileY, width, height, filteringOptions, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, layer);
            },
            findByIndex: function (findIndex, skip, reverse, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.FindByIndex(findIndex, skip, reverse, layer);
            },
            findObject: function (objectLayer, callback, context) {
              if (typeof objectLayer === "string") {
                var name = objectLayer;
                objectLayer = this.getObjectLayer(objectLayer);
                if (!objectLayer) {
                  console.warn("No object layer found with the name: " + name);
                  return null;
                }
              }
              return objectLayer.objects.find(callback, context) || null;
            },
            findTile: function (callback, context, tileX, tileY, width, height, filteringOptions, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);
            },
            forEachTile: function (callback, context, tileX, tileY, width, height, filteringOptions, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);
              return this;
            },
            getImageIndex: function (name) {
              return this.getIndex(this.images, name);
            },
            getImageLayerNames: function () {
              if (!this.images || !Array.isArray(this.images)) {
                return [];
              }
              return this.images.map(function (image) {
                return image.name;
              });
            },
            getIndex: function (location, name) {
              for (var i = 0; i < location.length; i++) {
                if (location[i].name === name) {
                  return i;
                }
              }
              return null;
            },
            getLayer: function (layer) {
              var index = this.getLayerIndex(layer);
              return index !== null ? this.layers[index] : null;
            },
            getObjectLayer: function (name) {
              var index = this.getIndex(this.objects, name);
              return index !== null ? this.objects[index] : null;
            },
            getObjectLayerNames: function () {
              if (!this.objects || !Array.isArray(this.objects)) {
                return [];
              }
              return this.objects.map(function (object) {
                return object.name;
              });
            },
            getLayerIndex: function (layer) {
              if (layer === void 0) {
                return this.currentLayerIndex;
              } else if (typeof layer === "string") {
                return this.getLayerIndexByName(layer);
              } else if (typeof layer === "number" && layer < this.layers.length) {
                return layer;
              } else if (layer instanceof TilemapLayer) {
                return layer.layerIndex;
              } else {
                return null;
              }
            },
            getLayerIndexByName: function (name) {
              return this.getIndex(this.layers, name);
            },
            getTileAt: function (tileX, tileY, nonNull, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.GetTileAt(tileX, tileY, nonNull, layer);
            },
            getTileAtWorldXY: function (worldX, worldY, nonNull, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, layer);
            },
            getTileLayerNames: function () {
              if (!this.layers || !Array.isArray(this.layers)) {
                return [];
              }
              return this.layers.map(function (layer) {
                return layer.name;
              });
            },
            getTilesWithin: function (tileX, tileY, width, height, filteringOptions, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
            },
            getTilesWithinShape: function (shape, filteringOptions, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, layer);
            },
            getTilesWithinWorldXY: function (worldX, worldY, width, height, filteringOptions, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, layer);
            },
            getTileset: function (name) {
              var index = this.getIndex(this.tilesets, name);
              return index !== null ? this.tilesets[index] : null;
            },
            getTilesetIndex: function (name) {
              return this.getIndex(this.tilesets, name);
            },
            hasTileAt: function (tileX, tileY, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.HasTileAt(tileX, tileY, layer);
            },
            hasTileAtWorldXY: function (worldX, worldY, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, layer);
            },
            layer: {
              get: function () {
                return this.layers[this.currentLayerIndex];
              },
              set: function (layer) {
                this.setLayer(layer);
              }
            },
            putTileAt: function (tile, tileX, tileY, recalculateFaces, layer) {
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, layer);
            },
            putTileAtWorldXY: function (tile, worldX, worldY, recalculateFaces, camera, layer) {
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, layer);
            },
            putTilesAt: function (tilesArray, tileX, tileY, recalculateFaces, layer) {
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, layer);
              return this;
            },
            randomize: function (tileX, tileY, width, height, indexes, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.Randomize(tileX, tileY, width, height, indexes, layer);
              return this;
            },
            calculateFacesAt: function (tileX, tileY, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.CalculateFacesAt(tileX, tileY, layer);
              return this;
            },
            calculateFacesWithin: function (tileX, tileY, width, height, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, layer);
              return this;
            },
            removeLayer: function (layer) {
              var index = this.getLayerIndex(layer);
              if (index !== null) {
                SpliceOne(this.layers, index);
                for (var i = index; i < this.layers.length; i++) {
                  if (this.layers[i].tilemapLayer) {
                    this.layers[i].tilemapLayer.layerIndex--;
                  }
                }
                if (this.currentLayerIndex === index) {
                  this.currentLayerIndex = 0;
                }
                return this;
              } else {
                return null;
              }
            },
            destroyLayer: function (layer) {
              var index = this.getLayerIndex(layer);
              if (index !== null) {
                layer = this.layers[index];
                layer.destroy();
                SpliceOne(this.layers, index);
                if (this.currentLayerIndex === index) {
                  this.currentLayerIndex = 0;
                }
                return this;
              } else {
                return null;
              }
            },
            removeAllLayers: function () {
              var layers = this.layers;
              for (var i = 0; i < layers.length; i++) {
                if (layers[i].tilemapLayer) {
                  layers[i].tilemapLayer.destroy(false);
                }
              }
              layers.length = 0;
              this.currentLayerIndex = 0;
              return this;
            },
            removeTile: function (tiles, replaceIndex, recalculateFaces) {
              if (replaceIndex === void 0) {
                replaceIndex = -1;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              var removed = [];
              if (!Array.isArray(tiles)) {
                tiles = [tiles];
              }
              for (var i = 0; i < tiles.length; i++) {
                var tile = tiles[i];
                removed.push(this.removeTileAt(tile.x, tile.y, true, recalculateFaces, tile.tilemapLayer));
                if (replaceIndex > -1) {
                  this.putTileAt(replaceIndex, tile.x, tile.y, recalculateFaces, tile.tilemapLayer);
                }
              }
              return removed;
            },
            removeTileAt: function (tileX, tileY, replaceWithNull, recalculateFaces, layer) {
              if (replaceWithNull === void 0) {
                replaceWithNull = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, layer);
            },
            removeTileAtWorldXY: function (worldX, worldY, replaceWithNull, recalculateFaces, camera, layer) {
              if (replaceWithNull === void 0) {
                replaceWithNull = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer);
            },
            renderDebug: function (graphics, styleConfig, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              if (this.orientation === ORIENTATION.ORTHOGONAL) {
                TilemapComponents.RenderDebug(graphics, styleConfig, layer);
              }
              return this;
            },
            renderDebugFull: function (graphics, styleConfig) {
              var layers = this.layers;
              for (var i = 0; i < layers.length; i++) {
                TilemapComponents.RenderDebug(graphics, styleConfig, layers[i]);
              }
              return this;
            },
            replaceByIndex: function (findIndex, newIndex, tileX, tileY, width, height, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, layer);
              return this;
            },
            setCollision: function (indexes, collides, recalculateFaces, layer, updateLayer) {
              if (collides === void 0) {
                collides = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              if (updateLayer === void 0) {
                updateLayer = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.SetCollision(indexes, collides, recalculateFaces, layer, updateLayer);
              return this;
            },
            setCollisionBetween: function (start, stop, collides, recalculateFaces, layer) {
              if (collides === void 0) {
                collides = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, layer);
              return this;
            },
            setCollisionByProperty: function (properties, collides, recalculateFaces, layer) {
              if (collides === void 0) {
                collides = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, layer);
              return this;
            },
            setCollisionByExclusion: function (indexes, collides, recalculateFaces, layer) {
              if (collides === void 0) {
                collides = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, layer);
              return this;
            },
            setCollisionFromCollisionGroup: function (collides, recalculateFaces, layer) {
              if (collides === void 0) {
                collides = true;
              }
              if (recalculateFaces === void 0) {
                recalculateFaces = true;
              }
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, layer);
              return this;
            },
            setTileIndexCallback: function (indexes, callback, callbackContext, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, layer);
              return this;
            },
            setTileLocationCallback: function (tileX, tileY, width, height, callback, callbackContext, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, layer);
              return this;
            },
            setLayer: function (layer) {
              var index = this.getLayerIndex(layer);
              if (index !== null) {
                this.currentLayerIndex = index;
              }
              return this;
            },
            setBaseTileSize: function (tileWidth, tileHeight) {
              this.tileWidth = tileWidth;
              this.tileHeight = tileHeight;
              this.widthInPixels = this.width * tileWidth;
              this.heightInPixels = this.height * tileHeight;
              for (var i = 0; i < this.layers.length; i++) {
                this.layers[i].baseTileWidth = tileWidth;
                this.layers[i].baseTileHeight = tileHeight;
                var mapData = this.layers[i].data;
                var mapWidth = this.layers[i].width;
                var mapHeight = this.layers[i].height;
                for (var row = 0; row < mapHeight; row++) {
                  for (var col = 0; col < mapWidth; col++) {
                    var tile = mapData[row][col];
                    if (tile !== null) {
                      tile.setSize(void 0, void 0, tileWidth, tileHeight);
                    }
                  }
                }
              }
              return this;
            },
            setLayerTileSize: function (tileWidth, tileHeight, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return this;
              }
              layer.tileWidth = tileWidth;
              layer.tileHeight = tileHeight;
              var mapData = layer.data;
              var mapWidth = layer.width;
              var mapHeight = layer.height;
              for (var row = 0; row < mapHeight; row++) {
                for (var col = 0; col < mapWidth; col++) {
                  var tile = mapData[row][col];
                  if (tile !== null) {
                    tile.setSize(tileWidth, tileHeight);
                  }
                }
              }
              return this;
            },
            shuffle: function (tileX, tileY, width, height, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.Shuffle(tileX, tileY, width, height, layer);
              return this;
            },
            swapByIndex: function (indexA, indexB, tileX, tileY, width, height, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, layer);
              return this;
            },
            tileToWorldX: function (tileX, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return this._convert.TileToWorldX(tileX, camera, layer);
            },
            tileToWorldY: function (tileX, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return this._convert.TileToWorldY(tileX, camera, layer);
            },
            tileToWorldXY: function (tileX, tileY, vec2, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return this._convert.TileToWorldXY(tileX, tileY, vec2, camera, layer);
            },
            weightedRandomize: function (weightedIndexes, tileX, tileY, width, height, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, layer);
              return this;
            },
            worldToTileX: function (worldX, snapToFloor, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return this._convert.WorldToTileX(worldX, snapToFloor, camera, layer);
            },
            worldToTileY: function (worldY, snapToFloor, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return this._convert.WorldToTileY(worldY, snapToFloor, camera, layer);
            },
            worldToTileXY: function (worldX, worldY, snapToFloor, vec2, camera, layer) {
              layer = this.getLayer(layer);
              if (layer === null) {
                return null;
              }
              return this._convert.WorldToTileXY(worldX, worldY, snapToFloor, vec2, camera, layer);
            },
            destroy: function () {
              this.removeAllLayers();
              this.tilesets.length = 0;
              this.objects.length = 0;
              this.scene = null;
            }
          });
          module2.exports = Tilemap;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(11);
          var GameObject = __webpack_require__(15);
          var TilemapComponents = __webpack_require__(251);
          var TilemapLayerRender = __webpack_require__(1456);
          var TilemapLayer = new Class({
            Extends: GameObject,
            Mixins: [Components.Alpha, Components.BlendMode, Components.ComputedSize, Components.Depth, Components.Flip, Components.GetBounds, Components.Origin, Components.Pipeline, Components.Transform, Components.Visible, Components.ScrollFactor, TilemapLayerRender],
            initialize: function TilemapLayer2(scene, tilemap, layerIndex, tileset, x, y) {
              GameObject.call(this, scene, "TilemapLayer");
              this.isTilemap = true;
              this.tilemap = tilemap;
              this.layerIndex = layerIndex;
              this.layer = tilemap.layers[layerIndex];
              this.layer.tilemapLayer = this;
              this.tileset = [];
              this.tilesDrawn = 0;
              this.tilesTotal = this.layer.width * this.layer.height;
              this.culledTiles = [];
              this.skipCull = false;
              this.cullPaddingX = 1;
              this.cullPaddingY = 1;
              this.cullCallback = TilemapComponents.GetCullTilesFunction(this.layer.orientation);
              this._renderOrder = 0;
              this.gidMap = [];
              this.setTilesets(tileset);
              this.setAlpha(this.layer.alpha);
              this.setPosition(x, y);
              this.setOrigin();
              this.setSize(tilemap.tileWidth * this.layer.width, tilemap.tileHeight * this.layer.height);
              this.initPipeline();
            },
            setTilesets: function (tilesets) {
              var gidMap = [];
              var setList = [];
              var map = this.tilemap;
              if (!Array.isArray(tilesets)) {
                tilesets = [tilesets];
              }
              for (var i = 0; i < tilesets.length; i++) {
                var tileset = tilesets[i];
                if (typeof tileset === "string") {
                  tileset = map.getTileset(tileset);
                }
                if (tileset) {
                  setList.push(tileset);
                  var s = tileset.firstgid;
                  for (var t = 0; t < tileset.total; t++) {
                    gidMap[s + t] = tileset;
                  }
                }
              }
              this.gidMap = gidMap;
              this.tileset = setList;
            },
            setRenderOrder: function (renderOrder) {
              var orders = ["right-down", "left-down", "right-up", "left-up"];
              if (typeof renderOrder === "string") {
                renderOrder = orders.indexOf(renderOrder);
              }
              if (renderOrder >= 0 && renderOrder < 4) {
                this._renderOrder = renderOrder;
              }
              return this;
            },
            calculateFacesAt: function (tileX, tileY) {
              TilemapComponents.CalculateFacesAt(tileX, tileY, this.layer);
              return this;
            },
            calculateFacesWithin: function (tileX, tileY, width, height) {
              TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, this.layer);
              return this;
            },
            createFromTiles: function (indexes, replacements, spriteConfig, scene, camera) {
              return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, this.layer);
            },
            cull: function (camera) {
              return this.cullCallback(this.layer, camera, this.culledTiles, this._renderOrder);
            },
            copy: function (srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces) {
              TilemapComponents.Copy(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, this.layer);
              return this;
            },
            fill: function (index, tileX, tileY, width, height, recalculateFaces) {
              TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, this.layer);
              return this;
            },
            filterTiles: function (callback, context, tileX, tileY, width, height, filteringOptions) {
              return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);
            },
            findByIndex: function (findIndex, skip, reverse) {
              return TilemapComponents.FindByIndex(findIndex, skip, reverse, this.layer);
            },
            findTile: function (callback, context, tileX, tileY, width, height, filteringOptions) {
              return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);
            },
            forEachTile: function (callback, context, tileX, tileY, width, height, filteringOptions) {
              TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);
              return this;
            },
            getTileAt: function (tileX, tileY, nonNull) {
              return TilemapComponents.GetTileAt(tileX, tileY, nonNull, this.layer);
            },
            getTileAtWorldXY: function (worldX, worldY, nonNull, camera) {
              return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, this.layer);
            },
            getTilesWithin: function (tileX, tileY, width, height, filteringOptions) {
              return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, this.layer);
            },
            getTilesWithinShape: function (shape, filteringOptions, camera) {
              return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, this.layer);
            },
            getTilesWithinWorldXY: function (worldX, worldY, width, height, filteringOptions, camera) {
              return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, this.layer);
            },
            hasTileAt: function (tileX, tileY) {
              return TilemapComponents.HasTileAt(tileX, tileY, this.layer);
            },
            hasTileAtWorldXY: function (worldX, worldY, camera) {
              return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, this.layer);
            },
            putTileAt: function (tile, tileX, tileY, recalculateFaces) {
              return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, this.layer);
            },
            putTileAtWorldXY: function (tile, worldX, worldY, recalculateFaces, camera) {
              return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, this.layer);
            },
            putTilesAt: function (tilesArray, tileX, tileY, recalculateFaces) {
              TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, this.layer);
              return this;
            },
            randomize: function (tileX, tileY, width, height, indexes) {
              TilemapComponents.Randomize(tileX, tileY, width, height, indexes, this.layer);
              return this;
            },
            removeTileAt: function (tileX, tileY, replaceWithNull, recalculateFaces) {
              return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, this.layer);
            },
            removeTileAtWorldXY: function (worldX, worldY, replaceWithNull, recalculateFaces, camera) {
              return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, this.layer);
            },
            renderDebug: function (graphics, styleConfig) {
              TilemapComponents.RenderDebug(graphics, styleConfig, this.layer);
              return this;
            },
            replaceByIndex: function (findIndex, newIndex, tileX, tileY, width, height) {
              TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, this.layer);
              return this;
            },
            setSkipCull: function (value) {
              if (value === void 0) {
                value = true;
              }
              this.skipCull = value;
              return this;
            },
            setCullPadding: function (paddingX, paddingY) {
              if (paddingX === void 0) {
                paddingX = 1;
              }
              if (paddingY === void 0) {
                paddingY = 1;
              }
              this.cullPaddingX = paddingX;
              this.cullPaddingY = paddingY;
              return this;
            },
            setCollision: function (indexes, collides, recalculateFaces, updateLayer) {
              TilemapComponents.SetCollision(indexes, collides, recalculateFaces, this.layer, updateLayer);
              return this;
            },
            setCollisionBetween: function (start, stop, collides, recalculateFaces) {
              TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, this.layer);
              return this;
            },
            setCollisionByProperty: function (properties, collides, recalculateFaces) {
              TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, this.layer);
              return this;
            },
            setCollisionByExclusion: function (indexes, collides, recalculateFaces) {
              TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, this.layer);
              return this;
            },
            setCollisionFromCollisionGroup: function (collides, recalculateFaces) {
              TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, this.layer);
              return this;
            },
            setTileIndexCallback: function (indexes, callback, callbackContext) {
              TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, this.layer);
              return this;
            },
            setTileLocationCallback: function (tileX, tileY, width, height, callback, callbackContext) {
              TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, this.layer);
              return this;
            },
            shuffle: function (tileX, tileY, width, height) {
              TilemapComponents.Shuffle(tileX, tileY, width, height, this.layer);
              return this;
            },
            swapByIndex: function (indexA, indexB, tileX, tileY, width, height) {
              TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, this.layer);
              return this;
            },
            tileToWorldX: function (tileX, camera) {
              return this.tilemap.tileToWorldX(tileX, camera, this);
            },
            tileToWorldY: function (tileY, camera) {
              return this.tilemap.tileToWorldY(tileY, camera, this);
            },
            tileToWorldXY: function (tileX, tileY, point, camera) {
              return this.tilemap.tileToWorldXY(tileX, tileY, point, camera, this);
            },
            weightedRandomize: function (weightedIndexes, tileX, tileY, width, height) {
              TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, this.layer);
              return this;
            },
            worldToTileX: function (worldX, snapToFloor, camera) {
              return this.tilemap.worldToTileX(worldX, snapToFloor, camera, this);
            },
            worldToTileY: function (worldY, snapToFloor, camera) {
              return this.tilemap.worldToTileY(worldY, snapToFloor, camera, this);
            },
            worldToTileXY: function (worldX, worldY, snapToFloor, point, camera) {
              return this.tilemap.worldToTileXY(worldX, worldY, snapToFloor, point, camera, this);
            },
            destroy: function (removeFromTilemap) {
              if (removeFromTilemap === void 0) {
                removeFromTilemap = true;
              }
              if (!this.tilemap) {
                return;
              }
              if (this.layer.tilemapLayer === this) {
                this.layer.tilemapLayer = void 0;
              }
              if (removeFromTilemap) {
                this.tilemap.removeLayer(this);
              }
              this.tilemap = void 0;
              this.layer = void 0;
              this.culledTiles.length = 0;
              this.cullCallback = null;
              this.gidMap = [];
              this.tileset = [];
              GameObject.prototype.destroy.call(this);
            }
          });
          module2.exports = TilemapLayer;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var TimerEvent = new Class({
            initialize: function TimerEvent2(config) {
              this.delay = 0;
              this.repeat = 0;
              this.repeatCount = 0;
              this.loop = false;
              this.callback;
              this.callbackScope;
              this.args;
              this.timeScale = 1;
              this.startAt = 0;
              this.elapsed = 0;
              this.paused = false;
              this.hasDispatched = false;
              this.reset(config);
            },
            reset: function (config) {
              this.delay = GetFastValue(config, "delay", 0);
              this.repeat = GetFastValue(config, "repeat", 0);
              this.loop = GetFastValue(config, "loop", false);
              this.callback = GetFastValue(config, "callback", void 0);
              this.callbackScope = GetFastValue(config, "callbackScope", this.callback);
              this.args = GetFastValue(config, "args", []);
              this.timeScale = GetFastValue(config, "timeScale", 1);
              this.startAt = GetFastValue(config, "startAt", 0);
              this.paused = GetFastValue(config, "paused", false);
              this.elapsed = this.startAt;
              this.hasDispatched = false;
              this.repeatCount = this.repeat === -1 || this.loop ? 999999999999 : this.repeat;
              return this;
            },
            getProgress: function () {
              return this.elapsed / this.delay;
            },
            getOverallProgress: function () {
              if (this.repeat > 0) {
                var totalDuration = this.delay + this.delay * this.repeat;
                var totalElapsed = this.elapsed + this.delay * (this.repeat - this.repeatCount);
                return totalElapsed / totalDuration;
              } else {
                return this.getProgress();
              }
            },
            getRepeatCount: function () {
              return this.repeatCount;
            },
            getElapsed: function () {
              return this.elapsed;
            },
            getElapsedSeconds: function () {
              return this.elapsed * 1e-3;
            },
            getRemaining: function () {
              return this.delay - this.elapsed;
            },
            getRemainingSeconds: function () {
              return this.getRemaining() * 1e-3;
            },
            getOverallRemaining: function () {
              return this.delay * (1 + this.repeatCount) - this.elapsed;
            },
            getOverallRemainingSeconds: function () {
              return this.getOverallRemaining() * 1e-3;
            },
            remove: function (dispatchCallback) {
              if (dispatchCallback === void 0) {
                dispatchCallback = false;
              }
              this.elapsed = this.delay;
              this.hasDispatched = !dispatchCallback;
              this.repeatCount = 0;
            },
            destroy: function () {
              this.callback = void 0;
              this.callbackScope = void 0;
              this.args = [];
            }
          });
          module2.exports = TimerEvent;
        }, function (module2, exports2, __webpack_require__) {
          var RESERVED = __webpack_require__(1465);
          var GetProps = function (config) {
            var key;
            var keys = [];
            if (config.hasOwnProperty("props")) {
              for (key in config.props) {
                if (key.substr(0, 1) !== "_") {
                  keys.push({
                    key,
                    value: config.props[key]
                  });
                }
              }
            } else {
              for (key in config) {
                if (RESERVED.indexOf(key) === -1 && key.substr(0, 1) !== "_") {
                  keys.push({
                    key,
                    value: config[key]
                  });
                }
              }
            }
            return keys;
          };
          module2.exports = GetProps;
        }, function (module2, exports2, __webpack_require__) {
          var GetValue = __webpack_require__(6);
          var GetTweens = function (config) {
            var tweens = GetValue(config, "tweens", null);
            if (tweens === null) {
              return [];
            } else if (typeof tweens === "function") {
              tweens = tweens.call();
            }
            if (!Array.isArray(tweens)) {
              tweens = [tweens];
            }
            return tweens;
          };
          module2.exports = GetTweens;
        }, function (module2, exports2, __webpack_require__) {
          var Defaults = __webpack_require__(265);
          var GetAdvancedValue = __webpack_require__(13);
          var GetBoolean = __webpack_require__(99);
          var GetEaseFunction = __webpack_require__(80);
          var GetNewValue = __webpack_require__(162);
          var GetValue = __webpack_require__(6);
          var GetValueOp = __webpack_require__(264);
          var Tween = __webpack_require__(266);
          var TweenData = __webpack_require__(268);
          var NumberTweenBuilder = function (parent, config, defaults) {
            if (defaults === void 0) {
              defaults = Defaults;
            }
            var from = GetValue(config, "from", 0);
            var to = GetValue(config, "to", 1);
            var targets = [{
              value: from
            }];
            var delay = GetNewValue(config, "delay", defaults.delay);
            var duration = GetNewValue(config, "duration", defaults.duration);
            var easeParams = GetValue(config, "easeParams", defaults.easeParams);
            var ease = GetEaseFunction(GetValue(config, "ease", defaults.ease), easeParams);
            var hold = GetNewValue(config, "hold", defaults.hold);
            var repeat = GetNewValue(config, "repeat", defaults.repeat);
            var repeatDelay = GetNewValue(config, "repeatDelay", defaults.repeatDelay);
            var yoyo = GetBoolean(config, "yoyo", defaults.yoyo);
            var data = [];
            var ops = GetValueOp("value", to);
            var tweenData = TweenData(targets[0], 0, "value", ops.getEnd, ops.getStart, ops.getActive, ease, delay, duration, yoyo, hold, repeat, repeatDelay, false, false);
            tweenData.start = from;
            tweenData.current = from;
            tweenData.to = to;
            data.push(tweenData);
            var tween = new Tween(parent, data, targets);
            tween.offset = GetAdvancedValue(config, "offset", null);
            tween.completeDelay = GetAdvancedValue(config, "completeDelay", 0);
            tween.loop = Math.round(GetAdvancedValue(config, "loop", 0));
            tween.loopDelay = Math.round(GetAdvancedValue(config, "loopDelay", 0));
            tween.paused = GetBoolean(config, "paused", false);
            tween.useFrames = GetBoolean(config, "useFrames", false);
            var scope = GetValue(config, "callbackScope", tween);
            var tweenArray = [tween, null];
            var callbacks = Tween.TYPES;
            for (var i = 0; i < callbacks.length; i++) {
              var type = callbacks[i];
              var callback = GetValue(config, type, false);
              if (callback) {
                var callbackScope = GetValue(config, type + "Scope", scope);
                var callbackParams = GetValue(config, type + "Params", []);
                tween.setCallback(type, callback, tweenArray.concat(callbackParams), callbackScope);
              }
            }
            return tween;
          };
          module2.exports = NumberTweenBuilder;
        }, function (module2, exports2, __webpack_require__) {
          var GetEaseFunction = __webpack_require__(80);
          var GetValue = __webpack_require__(6);
          var MATH_CONST = __webpack_require__(14);
          var StaggerBuilder = function (value, options) {
            if (options === void 0) {
              options = {};
            }
            var result;
            var start = GetValue(options, "start", 0);
            var ease = GetValue(options, "ease", null);
            var grid = GetValue(options, "grid", null);
            var from = GetValue(options, "from", 0);
            var fromFirst = from === "first";
            var fromCenter = from === "center";
            var fromLast = from === "last";
            var fromValue = typeof from === "number";
            var isRange = Array.isArray(value);
            var value1 = isRange ? parseFloat(value[0]) : parseFloat(value);
            var value2 = isRange ? parseFloat(value[1]) : 0;
            var maxValue = Math.max(value1, value2);
            if (isRange) {
              start += value1;
            }
            if (grid) {
              var gridWidth = grid[0];
              var gridHeight = grid[1];
              var fromX = 0;
              var fromY = 0;
              var distanceX = 0;
              var distanceY = 0;
              var gridValues = [];
              if (fromLast) {
                fromX = gridWidth - 1;
                fromY = gridHeight - 1;
              } else if (fromValue) {
                fromX = from % gridWidth;
                fromY = Math.floor(from / gridWidth);
              } else if (fromCenter) {
                fromX = (gridWidth - 1) / 2;
                fromY = (gridHeight - 1) / 2;
              }
              var gridMax = MATH_CONST.MIN_SAFE_INTEGER;
              for (var toY = 0; toY < gridHeight; toY++) {
                gridValues[toY] = [];
                for (var toX = 0; toX < gridWidth; toX++) {
                  distanceX = fromX - toX;
                  distanceY = fromY - toY;
                  var dist = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
                  if (dist > gridMax) {
                    gridMax = dist;
                  }
                  gridValues[toY][toX] = dist;
                }
              }
            }
            var easeFunction = ease ? GetEaseFunction(ease) : null;
            if (grid) {
              result = function (target, key, value3, index) {
                var gridSpace = 0;
                var toX2 = index % gridWidth;
                var toY2 = Math.floor(index / gridWidth);
                if (toX2 >= 0 && toX2 < gridWidth && toY2 >= 0 && toY2 < gridHeight) {
                  gridSpace = gridValues[toY2][toX2];
                }
                var output;
                if (isRange) {
                  var diff = value2 - value1;
                  if (easeFunction) {
                    output = gridSpace / gridMax * diff * easeFunction(gridSpace / gridMax);
                  } else {
                    output = gridSpace / gridMax * diff;
                  }
                } else if (easeFunction) {
                  output = gridSpace * value1 * easeFunction(gridSpace / gridMax);
                } else {
                  output = gridSpace * value1;
                }
                return output + start;
              };
            } else {
              result = function (target, key, value3, index, total) {
                total--;
                var fromIndex;
                if (fromFirst) {
                  fromIndex = index;
                } else if (fromCenter) {
                  fromIndex = Math.abs(total / 2 - index);
                } else if (fromLast) {
                  fromIndex = total - index;
                } else if (fromValue) {
                  fromIndex = Math.abs(from - index);
                }
                var output;
                if (isRange) {
                  var spacing;
                  if (fromCenter) {
                    spacing = (value2 - value1) / total * (fromIndex * 2);
                  } else {
                    spacing = (value2 - value1) / total * fromIndex;
                  }
                  if (easeFunction) {
                    output = spacing * easeFunction(fromIndex / total);
                  } else {
                    output = spacing;
                  }
                } else if (easeFunction) {
                  output = total * maxValue * easeFunction(fromIndex / total);
                } else {
                  output = fromIndex * value1;
                }
                return output + start;
              };
            }
            return result;
          };
          module2.exports = StaggerBuilder;
        }, function (module2, exports2, __webpack_require__) {
          var Clone = __webpack_require__(77);
          var Defaults = __webpack_require__(265);
          var GetAdvancedValue = __webpack_require__(13);
          var GetBoolean = __webpack_require__(99);
          var GetEaseFunction = __webpack_require__(80);
          var GetNewValue = __webpack_require__(162);
          var GetTargets = __webpack_require__(263);
          var GetTweens = __webpack_require__(584);
          var GetValue = __webpack_require__(6);
          var Timeline = __webpack_require__(588);
          var TweenBuilder = __webpack_require__(163);
          var TimelineBuilder = function (manager, config) {
            var timeline = new Timeline(manager);
            timeline.completeDelay = GetAdvancedValue(config, "completeDelay", 0);
            timeline.loop = Math.round(GetAdvancedValue(config, "loop", 0));
            timeline.loopDelay = Math.round(GetAdvancedValue(config, "loopDelay", 0));
            timeline.paused = GetBoolean(config, "paused", false);
            timeline.useFrames = GetBoolean(config, "useFrames", false);
            var scope = GetValue(config, "callbackScope", timeline);
            var timelineArray = [timeline];
            var onStart = GetValue(config, "onStart", false);
            if (onStart) {
              var onStartScope = GetValue(config, "onStartScope", scope);
              var onStartParams = GetValue(config, "onStartParams", []);
              timeline.setCallback("onStart", onStart, timelineArray.concat(onStartParams), onStartScope);
            }
            var onUpdate = GetValue(config, "onUpdate", false);
            if (onUpdate) {
              var onUpdateScope = GetValue(config, "onUpdateScope", scope);
              var onUpdateParams = GetValue(config, "onUpdateParams", []);
              timeline.setCallback("onUpdate", onUpdate, timelineArray.concat(onUpdateParams), onUpdateScope);
            }
            var onLoop = GetValue(config, "onLoop", false);
            if (onLoop) {
              var onLoopScope = GetValue(config, "onLoopScope", scope);
              var onLoopParams = GetValue(config, "onLoopParams", []);
              timeline.setCallback("onLoop", onLoop, timelineArray.concat(onLoopParams), onLoopScope);
            }
            var onYoyo = GetValue(config, "onYoyo", false);
            if (onYoyo) {
              var onYoyoScope = GetValue(config, "onYoyoScope", scope);
              var onYoyoParams = GetValue(config, "onYoyoParams", []);
              timeline.setCallback("onYoyo", onYoyo, timelineArray.concat(null, onYoyoParams), onYoyoScope);
            }
            var onComplete = GetValue(config, "onComplete", false);
            if (onComplete) {
              var onCompleteScope = GetValue(config, "onCompleteScope", scope);
              var onCompleteParams = GetValue(config, "onCompleteParams", []);
              timeline.setCallback("onComplete", onComplete, timelineArray.concat(onCompleteParams), onCompleteScope);
            }
            var tweens = GetTweens(config);
            if (tweens.length === 0) {
              timeline.paused = true;
              return timeline;
            }
            var defaults = Clone(Defaults);
            defaults.targets = GetTargets(config);
            var totalDuration = GetAdvancedValue(config, "totalDuration", 0);
            if (totalDuration > 0) {
              defaults.duration = Math.floor(totalDuration / tweens.length);
            } else {
              defaults.duration = GetNewValue(config, "duration", defaults.duration);
            }
            defaults.delay = GetNewValue(config, "delay", defaults.delay);
            defaults.easeParams = GetValue(config, "easeParams", defaults.easeParams);
            defaults.ease = GetEaseFunction(GetValue(config, "ease", defaults.ease), defaults.easeParams);
            defaults.hold = GetNewValue(config, "hold", defaults.hold);
            defaults.repeat = GetNewValue(config, "repeat", defaults.repeat);
            defaults.repeatDelay = GetNewValue(config, "repeatDelay", defaults.repeatDelay);
            defaults.yoyo = GetBoolean(config, "yoyo", defaults.yoyo);
            defaults.flipX = GetBoolean(config, "flipX", defaults.flipX);
            defaults.flipY = GetBoolean(config, "flipY", defaults.flipY);
            for (var i = 0; i < tweens.length; i++) {
              timeline.queue(TweenBuilder(timeline, tweens[i], defaults));
            }
            return timeline;
          };
          module2.exports = TimelineBuilder;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(267);
          var TweenBuilder = __webpack_require__(163);
          var TWEEN_CONST = __webpack_require__(100);
          var Timeline = new Class({
            Extends: EventEmitter,
            initialize: function Timeline2(manager) {
              EventEmitter.call(this);
              this.manager = manager;
              this.isTimeline = true;
              this.data = [];
              this.totalData = 0;
              this.useFrames = false;
              this.timeScale = 1;
              this.loop = 0;
              this.loopDelay = 0;
              this.loopCounter = 0;
              this.completeDelay = 0;
              this.countdown = 0;
              this.state = TWEEN_CONST.PENDING_ADD;
              this._pausedState = TWEEN_CONST.PENDING_ADD;
              this.paused = false;
              this.elapsed = 0;
              this.totalElapsed = 0;
              this.duration = 0;
              this.progress = 0;
              this.totalDuration = 0;
              this.totalProgress = 0;
              this.callbacks = {
                onComplete: null,
                onLoop: null,
                onStart: null,
                onUpdate: null,
                onYoyo: null
              };
              this.callbackScope;
            },
            dispatchTimelineEvent: function (event, callback) {
              this.emit(event, this);
              if (callback) {
                callback.func.apply(callback.scope, callback.params);
              }
            },
            setTimeScale: function (value) {
              this.timeScale = value;
              return this;
            },
            getTimeScale: function () {
              return this.timeScale;
            },
            isPlaying: function () {
              return this.state === TWEEN_CONST.ACTIVE;
            },
            add: function (config) {
              return this.queue(TweenBuilder(this, config));
            },
            queue: function (tween) {
              if (!this.isPlaying()) {
                tween.parent = this;
                tween.parentIsTimeline = true;
                this.data.push(tween);
                this.totalData = this.data.length;
              }
              return this;
            },
            hasOffset: function (tween) {
              return tween.offset !== null;
            },
            isOffsetAbsolute: function (value) {
              return typeof value === "number";
            },
            isOffsetRelative: function (value) {
              var t = typeof value;
              if (t === "string") {
                var op = value[0];
                if (op === "-" || op === "+") {
                  return true;
                }
              }
              return false;
            },
            getRelativeOffset: function (value, base) {
              var op = value[0];
              var num = parseFloat(value.substr(2));
              var result = base;
              switch (op) {
                case "+":
                  result += num;
                  break;
                case "-":
                  result -= num;
                  break;
              }
              return Math.max(0, result);
            },
            calcDuration: function () {
              var prevEnd = 0;
              var totalDuration = 0;
              var offsetDuration = 0;
              for (var i = 0; i < this.totalData; i++) {
                var tween = this.data[i];
                tween.init();
                if (this.hasOffset(tween)) {
                  if (this.isOffsetAbsolute(tween.offset)) {
                    tween.calculatedOffset = tween.offset;
                    if (tween.offset === 0) {
                      offsetDuration = 0;
                    }
                  } else if (this.isOffsetRelative(tween.offset)) {
                    tween.calculatedOffset = this.getRelativeOffset(tween.offset, prevEnd);
                  }
                } else {
                  tween.calculatedOffset = offsetDuration;
                }
                prevEnd = tween.totalDuration + tween.calculatedOffset;
                totalDuration += tween.totalDuration;
                offsetDuration += tween.totalDuration;
              }
              this.duration = totalDuration;
              this.loopCounter = this.loop === -1 ? 999999999999 : this.loop;
              if (this.loopCounter > 0) {
                this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter;
              } else {
                this.totalDuration = this.duration + this.completeDelay;
              }
            },
            init: function () {
              this.calcDuration();
              this.progress = 0;
              this.totalProgress = 0;
              if (this.paused) {
                this.state = TWEEN_CONST.PAUSED;
                return false;
              } else {
                return true;
              }
            },
            resetTweens: function (resetFromLoop) {
              for (var i = 0; i < this.totalData; i++) {
                var tween = this.data[i];
                tween.play(resetFromLoop);
              }
            },
            setCallback: function (type, callback, params, scope) {
              if (Timeline.TYPES.indexOf(type) !== -1) {
                this.callbacks[type] = {
                  func: callback,
                  scope,
                  params
                };
              }
              return this;
            },
            makeActive: function (tween) {
              return this.manager.makeActive(tween);
            },
            play: function () {
              if (this.state === TWEEN_CONST.ACTIVE) {
                return;
              }
              if (this.paused) {
                this.paused = false;
                this.manager.makeActive(this);
                return;
              } else {
                this.resetTweens(false);
                this.state = TWEEN_CONST.ACTIVE;
              }
              this.dispatchTimelineEvent(Events.TIMELINE_START, this.callbacks.onStart);
            },
            nextState: function () {
              if (this.loopCounter > 0) {
                this.elapsed = 0;
                this.progress = 0;
                this.loopCounter--;
                this.resetTweens(true);
                if (this.loopDelay > 0) {
                  this.countdown = this.loopDelay;
                  this.state = TWEEN_CONST.LOOP_DELAY;
                } else {
                  this.state = TWEEN_CONST.ACTIVE;
                  this.dispatchTimelineEvent(Events.TIMELINE_LOOP, this.callbacks.onLoop);
                }
              } else if (this.completeDelay > 0) {
                this.state = TWEEN_CONST.COMPLETE_DELAY;
                this.countdown = this.completeDelay;
              } else {
                this.state = TWEEN_CONST.PENDING_REMOVE;
                this.dispatchTimelineEvent(Events.TIMELINE_COMPLETE, this.callbacks.onComplete);
              }
            },
            update: function (timestamp, delta) {
              if (this.state === TWEEN_CONST.PAUSED) {
                return;
              }
              if (this.useFrames) {
                delta = 1 * this.manager.timeScale;
              }
              delta *= this.timeScale;
              this.elapsed += delta;
              this.progress = Math.min(this.elapsed / this.duration, 1);
              this.totalElapsed += delta;
              this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1);
              switch (this.state) {
                case TWEEN_CONST.ACTIVE:
                  var stillRunning = this.totalData;
                  for (var i = 0; i < this.totalData; i++) {
                    var tween = this.data[i];
                    if (tween.update(timestamp, delta)) {
                      stillRunning--;
                    }
                  }
                  this.dispatchTimelineEvent(Events.TIMELINE_UPDATE, this.callbacks.onUpdate);
                  if (stillRunning === 0) {
                    this.nextState();
                  }
                  break;
                case TWEEN_CONST.LOOP_DELAY:
                  this.countdown -= delta;
                  if (this.countdown <= 0) {
                    this.state = TWEEN_CONST.ACTIVE;
                    this.dispatchTimelineEvent(Events.TIMELINE_LOOP, this.callbacks.onLoop);
                  }
                  break;
                case TWEEN_CONST.COMPLETE_DELAY:
                  this.countdown -= delta;
                  if (this.countdown <= 0) {
                    this.state = TWEEN_CONST.PENDING_REMOVE;
                    this.dispatchTimelineEvent(Events.TIMELINE_COMPLETE, this.callbacks.onComplete);
                  }
                  break;
              }
              return this.state === TWEEN_CONST.PENDING_REMOVE;
            },
            stop: function () {
              this.state = TWEEN_CONST.PENDING_REMOVE;
            },
            pause: function () {
              if (this.state === TWEEN_CONST.PAUSED) {
                return;
              }
              this.paused = true;
              this._pausedState = this.state;
              this.state = TWEEN_CONST.PAUSED;
              this.emit(Events.TIMELINE_PAUSE, this);
              return this;
            },
            resume: function () {
              if (this.state === TWEEN_CONST.PAUSED) {
                this.paused = false;
                this.state = this._pausedState;
                this.emit(Events.TIMELINE_RESUME, this);
              }
              return this;
            },
            hasTarget: function (target) {
              for (var i = 0; i < this.data.length; i++) {
                if (this.data[i].hasTarget(target)) {
                  return true;
                }
              }
              return false;
            },
            destroy: function () {
              for (var i = 0; i < this.data.length; i++) {
                this.data[i].stop();
              }
            }
          });
          Timeline.TYPES = ["onStart", "onUpdate", "onLoop", "onComplete", "onYoyo"];
          module2.exports = Timeline;
        }, function (module2, exports2, __webpack_require__) {
          var Bodies = __webpack_require__(86);
          var Body = __webpack_require__(41);
          var Common = __webpack_require__(32);
          var GetFastValue = __webpack_require__(2);
          var Vertices = __webpack_require__(64);
          var PhysicsEditorParser = {
            parseBody: function (x, y, config, options) {
              if (options === void 0) {
                options = {};
              }
              var fixtureConfigs = GetFastValue(config, "fixtures", []);
              var fixtures = [];
              for (var fc = 0; fc < fixtureConfigs.length; fc++) {
                var fixtureParts = this.parseFixture(fixtureConfigs[fc]);
                for (var i = 0; i < fixtureParts.length; i++) {
                  fixtures.push(fixtureParts[i]);
                }
              }
              var matterConfig = Common.clone(config, true);
              Common.extend(matterConfig, options, true);
              delete matterConfig.fixtures;
              delete matterConfig.type;
              var body = Body.create(matterConfig);
              Body.setParts(body, fixtures);
              Body.setPosition(body, {
                x,
                y
              });
              return body;
            },
            parseFixture: function (fixtureConfig) {
              var matterConfig = Common.extend({}, false, fixtureConfig);
              delete matterConfig.circle;
              delete matterConfig.vertices;
              var fixtures;
              if (fixtureConfig.circle) {
                var x = GetFastValue(fixtureConfig.circle, "x");
                var y = GetFastValue(fixtureConfig.circle, "y");
                var r = GetFastValue(fixtureConfig.circle, "radius");
                fixtures = [Bodies.circle(x, y, r, matterConfig)];
              } else if (fixtureConfig.vertices) {
                fixtures = this.parseVertices(fixtureConfig.vertices, matterConfig);
              }
              return fixtures;
            },
            parseVertices: function (vertexSets, options) {
              if (options === void 0) {
                options = {};
              }
              var parts = [];
              for (var v = 0; v < vertexSets.length; v++) {
                Vertices.clockwiseSort(vertexSets[v]);
                parts.push(Body.create(Common.extend({
                  position: Vertices.centre(vertexSets[v]),
                  vertices: vertexSets[v]
                }, options)));
              }
              return Bodies.flagCoincidentParts(parts);
            }
          };
          module2.exports = PhysicsEditorParser;
        }, function (module2, exports2, __webpack_require__) {
          var Bodies = __webpack_require__(86);
          var Body = __webpack_require__(41);
          var PhysicsJSONParser = {
            parseBody: function (x, y, config, options) {
              if (options === void 0) {
                options = {};
              }
              var body;
              var vertexSets = config.vertices;
              if (vertexSets.length === 1) {
                options.vertices = vertexSets[0];
                body = Body.create(options);
                Bodies.flagCoincidentParts(body.parts);
              } else {
                var parts = [];
                for (var i = 0; i < vertexSets.length; i++) {
                  var part = Body.create({
                    vertices: vertexSets[i]
                  });
                  parts.push(part);
                }
                Bodies.flagCoincidentParts(parts);
                options.parts = parts;
                body = Body.create(options);
              }
              body.label = config.label;
              Body.setPosition(body, {
                x,
                y
              });
              return body;
            }
          };
          module2.exports = PhysicsJSONParser;
        }, function (module2, exports2, __webpack_require__) {
          var Composites = {};
          module2.exports = Composites;
          var Composite = __webpack_require__(118);
          var Constraint = __webpack_require__(128);
          var Common = __webpack_require__(32);
          var Body = __webpack_require__(41);
          var Bodies = __webpack_require__(86);
          (function () {
            Composites.stack = function (xx, yy, columns, rows, columnGap, rowGap, callback) {
              var stack = Composite.create({
                label: "Stack"
              }), x = xx, y = yy, lastBody, i = 0;
              for (var row = 0; row < rows; row++) {
                var maxHeight = 0;
                for (var column = 0; column < columns; column++) {
                  var body = callback(x, y, column, row, lastBody, i);
                  if (body) {
                    var bodyHeight = body.bounds.max.y - body.bounds.min.y, bodyWidth = body.bounds.max.x - body.bounds.min.x;
                    if (bodyHeight > maxHeight) maxHeight = bodyHeight;
                    Body.translate(body, {
                      x: bodyWidth * 0.5,
                      y: bodyHeight * 0.5
                    });
                    x = body.bounds.max.x + columnGap;
                    Composite.addBody(stack, body);
                    lastBody = body;
                    i += 1;
                  } else {
                    x += columnGap;
                  }
                }
                y += maxHeight + rowGap;
                x = xx;
              }
              return stack;
            };
            Composites.chain = function (composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {
              var bodies = composite.bodies;
              for (var i = 1; i < bodies.length; i++) {
                var bodyA = bodies[i - 1], bodyB = bodies[i], bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y, bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y, bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;
                var defaults = {
                  bodyA,
                  pointA: {
                    x: bodyAWidth * xOffsetA,
                    y: bodyAHeight * yOffsetA
                  },
                  bodyB,
                  pointB: {
                    x: bodyBWidth * xOffsetB,
                    y: bodyBHeight * yOffsetB
                  }
                };
                var constraint = Common.extend(defaults, options);
                Composite.addConstraint(composite, Constraint.create(constraint));
              }
              composite.label += " Chain";
              return composite;
            };
            Composites.mesh = function (composite, columns, rows, crossBrace, options) {
              var bodies = composite.bodies, row, col, bodyA, bodyB, bodyC;
              for (row = 0; row < rows; row++) {
                for (col = 1; col < columns; col++) {
                  bodyA = bodies[col - 1 + row * columns];
                  bodyB = bodies[col + row * columns];
                  Composite.addConstraint(composite, Constraint.create(Common.extend({
                    bodyA,
                    bodyB
                  }, options)));
                }
                if (row > 0) {
                  for (col = 0; col < columns; col++) {
                    bodyA = bodies[col + (row - 1) * columns];
                    bodyB = bodies[col + row * columns];
                    Composite.addConstraint(composite, Constraint.create(Common.extend({
                      bodyA,
                      bodyB
                    }, options)));
                    if (crossBrace && col > 0) {
                      bodyC = bodies[col - 1 + (row - 1) * columns];
                      Composite.addConstraint(composite, Constraint.create(Common.extend({
                        bodyA: bodyC,
                        bodyB
                      }, options)));
                    }
                    if (crossBrace && col < columns - 1) {
                      bodyC = bodies[col + 1 + (row - 1) * columns];
                      Composite.addConstraint(composite, Constraint.create(Common.extend({
                        bodyA: bodyC,
                        bodyB
                      }, options)));
                    }
                  }
                }
              }
              composite.label += " Mesh";
              return composite;
            };
            Composites.pyramid = function (xx, yy, columns, rows, columnGap, rowGap, callback) {
              return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function (x, y, column, row, lastBody, i) {
                var actualRows = Math.min(rows, Math.ceil(columns / 2)), lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;
                if (row > actualRows) return;
                row = actualRows - row;
                var start = row, end = columns - 1 - row;
                if (column < start || column > end) return;
                if (i === 1) {
                  Body.translate(lastBody, {
                    x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth,
                    y: 0
                  });
                }
                var xOffset = lastBody ? column * lastBodyWidth : 0;
                return callback(xx + xOffset + column * columnGap, y, column, row, lastBody, i);
              });
            };
            Composites.newtonsCradle = function (xx, yy, number, size, length) {
              var newtonsCradle = Composite.create({
                label: "Newtons Cradle"
              });
              for (var i = 0; i < number; i++) {
                var separation = 1.9, circle = Bodies.circle(xx + i * (size * separation), yy + length, size, {
                  inertia: Infinity,
                  restitution: 1,
                  friction: 0,
                  frictionAir: 1e-4,
                  slop: 1
                }), constraint = Constraint.create({
                  pointA: {
                    x: xx + i * (size * separation),
                    y: yy
                  },
                  bodyB: circle
                });
                Composite.addBody(newtonsCradle, circle);
                Composite.addConstraint(newtonsCradle, constraint);
              }
              return newtonsCradle;
            };
            Composites.car = function (xx, yy, width, height, wheelSize) {
              var group = Body.nextGroup(true), wheelBase = 20, wheelAOffset = -width * 0.5 + wheelBase, wheelBOffset = width * 0.5 - wheelBase, wheelYOffset = 0;
              var car = Composite.create({
                label: "Car"
              }), body = Bodies.rectangle(xx, yy, width, height, {
                collisionFilter: {
                  group
                },
                chamfer: {
                  radius: height * 0.5
                },
                density: 2e-4
              });
              var wheelA = Bodies.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, {
                collisionFilter: {
                  group
                },
                friction: 0.8
              });
              var wheelB = Bodies.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, {
                collisionFilter: {
                  group
                },
                friction: 0.8
              });
              var axelA = Constraint.create({
                bodyB: body,
                pointB: {
                  x: wheelAOffset,
                  y: wheelYOffset
                },
                bodyA: wheelA,
                stiffness: 1,
                length: 0
              });
              var axelB = Constraint.create({
                bodyB: body,
                pointB: {
                  x: wheelBOffset,
                  y: wheelYOffset
                },
                bodyA: wheelB,
                stiffness: 1,
                length: 0
              });
              Composite.addBody(car, body);
              Composite.addBody(car, wheelA);
              Composite.addBody(car, wheelB);
              Composite.addConstraint(car, axelA);
              Composite.addConstraint(car, axelB);
              return car;
            };
            Composites.softBody = function (xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {
              particleOptions = Common.extend({
                inertia: Infinity
              }, particleOptions);
              constraintOptions = Common.extend({
                stiffness: 0.2,
                render: {
                  type: "line",
                  anchors: false
                }
              }, constraintOptions);
              var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function (x, y) {
                return Bodies.circle(x, y, particleRadius, particleOptions);
              });
              Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);
              softBody.label = "Soft Body";
              return softBody;
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          var Svg = {};
          module2.exports = Svg;
          var Bounds = __webpack_require__(84);
          var Common = __webpack_require__(32);
          (function () {
            Svg.pathToVertices = function (path, sampleLength) {
              if (typeof window !== "undefined" && !(("SVGPathSeg" in window))) {
                Common.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
              }
              var i, il, total, point, segment, segments, segmentsQueue, lastSegment, lastPoint, segmentIndex, points = [], lx, ly, length = 0, x = 0, y = 0;
              sampleLength = sampleLength || 15;
              var addPoint = function (px, py, pathSegType) {
                var isRelative = pathSegType % 2 === 1 && pathSegType > 1;
                if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {
                  if (lastPoint && isRelative) {
                    lx = lastPoint.x;
                    ly = lastPoint.y;
                  } else {
                    lx = 0;
                    ly = 0;
                  }
                  var point2 = {
                    x: lx + px,
                    y: ly + py
                  };
                  if (isRelative || !lastPoint) {
                    lastPoint = point2;
                  }
                  points.push(point2);
                  x = lx + px;
                  y = ly + py;
                }
              };
              var addSegmentPoint = function (segment2) {
                var segType = segment2.pathSegTypeAsLetter.toUpperCase();
                if (segType === "Z") return;
                switch (segType) {
                  case "M":
                  case "L":
                  case "T":
                  case "C":
                  case "S":
                  case "Q":
                    x = segment2.x;
                    y = segment2.y;
                    break;
                  case "H":
                    x = segment2.x;
                    break;
                  case "V":
                    y = segment2.y;
                    break;
                }
                addPoint(x, y, segment2.pathSegType);
              };
              Svg._svgPathToAbsolute(path);
              total = path.getTotalLength();
              segments = [];
              for (i = 0; i < path.pathSegList.numberOfItems; i += 1) segments.push(path.pathSegList.getItem(i));
              segmentsQueue = segments.concat();
              while (length < total) {
                segmentIndex = path.getPathSegAtLength(length);
                segment = segments[segmentIndex];
                if (segment != lastSegment) {
                  while (segmentsQueue.length && segmentsQueue[0] != segment) addSegmentPoint(segmentsQueue.shift());
                  lastSegment = segment;
                }
                switch (segment.pathSegTypeAsLetter.toUpperCase()) {
                  case "C":
                  case "T":
                  case "S":
                  case "Q":
                  case "A":
                    point = path.getPointAtLength(length);
                    addPoint(point.x, point.y, 0);
                    break;
                }
                length += sampleLength;
              }
              for ((i = 0, il = segmentsQueue.length); i < il; ++i) addSegmentPoint(segmentsQueue[i]);
              return points;
            };
            Svg._svgPathToAbsolute = function (path) {
              var x0, y0, x1, y1, x2, y2, segs = path.pathSegList, x = 0, y = 0, len = segs.numberOfItems;
              for (var i = 0; i < len; ++i) {
                var seg = segs.getItem(i), segType = seg.pathSegTypeAsLetter;
                if ((/[MLHVCSQTA]/).test(segType)) {
                  if (("x" in seg)) x = seg.x;
                  if (("y" in seg)) y = seg.y;
                } else {
                  if (("x1" in seg)) x1 = x + seg.x1;
                  if (("x2" in seg)) x2 = x + seg.x2;
                  if (("y1" in seg)) y1 = y + seg.y1;
                  if (("y2" in seg)) y2 = y + seg.y2;
                  if (("x" in seg)) x += seg.x;
                  if (("y" in seg)) y += seg.y;
                  switch (segType) {
                    case "m":
                      segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);
                      break;
                    case "l":
                      segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);
                      break;
                    case "h":
                      segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);
                      break;
                    case "v":
                      segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);
                      break;
                    case "c":
                      segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);
                      break;
                    case "s":
                      segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);
                      break;
                    case "q":
                      segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);
                      break;
                    case "t":
                      segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);
                      break;
                    case "a":
                      segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);
                      break;
                    case "z":
                    case "Z":
                      x = x0;
                      y = y0;
                      break;
                  }
                }
                if (segType == "M" || segType == "m") {
                  x0 = x;
                  y0 = y;
                }
              }
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          var Bodies = __webpack_require__(86);
          var Body = __webpack_require__(41);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(249);
          var EventEmitter = __webpack_require__(9);
          var GetFastValue = __webpack_require__(2);
          var HasValue = __webpack_require__(126);
          var Vertices = __webpack_require__(64);
          var MatterTileBody = new Class({
            Extends: EventEmitter,
            Mixins: [Components.Bounce, Components.Collision, Components.Friction, Components.Gravity, Components.Mass, Components.Sensor, Components.Sleep, Components.Static],
            initialize: function MatterTileBody2(world, tile, options) {
              EventEmitter.call(this);
              this.tile = tile;
              this.world = world;
              if (tile.physics.matterBody) {
                tile.physics.matterBody.destroy();
              }
              tile.physics.matterBody = this;
              var body = GetFastValue(options, "body", null);
              var addToWorld = GetFastValue(options, "addToWorld", true);
              if (!body) {
                var collisionGroup = tile.getCollisionGroup();
                var collisionObjects = GetFastValue(collisionGroup, "objects", []);
                if (collisionObjects.length > 0) {
                  this.setFromTileCollision(options);
                } else {
                  this.setFromTileRectangle(options);
                }
              } else {
                this.setBody(body, addToWorld);
              }
            },
            setFromTileRectangle: function (options) {
              if (options === void 0) {
                options = {};
              }
              if (!HasValue(options, "isStatic")) {
                options.isStatic = true;
              }
              if (!HasValue(options, "addToWorld")) {
                options.addToWorld = true;
              }
              var bounds = this.tile.getBounds();
              var cx = bounds.x + bounds.width / 2;
              var cy = bounds.y + bounds.height / 2;
              var body = Bodies.rectangle(cx, cy, bounds.width, bounds.height, options);
              this.setBody(body, options.addToWorld);
              return this;
            },
            setFromTileCollision: function (options) {
              if (options === void 0) {
                options = {};
              }
              if (!HasValue(options, "isStatic")) {
                options.isStatic = true;
              }
              if (!HasValue(options, "addToWorld")) {
                options.addToWorld = true;
              }
              var sx = this.tile.tilemapLayer.scaleX;
              var sy = this.tile.tilemapLayer.scaleY;
              var tileX = this.tile.getLeft();
              var tileY = this.tile.getTop();
              var collisionGroup = this.tile.getCollisionGroup();
              var collisionObjects = GetFastValue(collisionGroup, "objects", []);
              var parts = [];
              for (var i = 0; i < collisionObjects.length; i++) {
                var object = collisionObjects[i];
                var ox = tileX + object.x * sx;
                var oy = tileY + object.y * sy;
                var ow = object.width * sx;
                var oh = object.height * sy;
                var body = null;
                if (object.rectangle) {
                  body = Bodies.rectangle(ox + ow / 2, oy + oh / 2, ow, oh, options);
                } else if (object.ellipse) {
                  body = Bodies.circle(ox + ow / 2, oy + oh / 2, ow / 2, options);
                } else if (object.polygon || object.polyline) {
                  var originalPoints = object.polygon ? object.polygon : object.polyline;
                  var points = originalPoints.map(function (p3) {
                    return {
                      x: p3.x * sx,
                      y: p3.y * sy
                    };
                  });
                  var vertices = Vertices.create(points);
                  var center = Vertices.centre(vertices);
                  ox += center.x;
                  oy += center.y;
                  body = Bodies.fromVertices(ox, oy, vertices, options);
                }
                if (body) {
                  parts.push(body);
                }
              }
              if (parts.length === 1) {
                this.setBody(parts[0], options.addToWorld);
              } else if (parts.length > 1) {
                options.parts = parts;
                this.setBody(Body.create(options), options.addToWorld);
              }
              return this;
            },
            setBody: function (body, addToWorld) {
              if (addToWorld === void 0) {
                addToWorld = true;
              }
              if (this.body) {
                this.removeBody();
              }
              this.body = body;
              this.body.gameObject = this;
              if (addToWorld) {
                this.world.add(this.body);
              }
              return this;
            },
            removeBody: function () {
              if (this.body) {
                this.world.remove(this.body);
                this.body.gameObject = void 0;
                this.body = void 0;
              }
              return this;
            },
            destroy: function () {
              this.removeBody();
              this.tile.physics.matterBody = void 0;
              this.removeAllListeners();
            }
          });
          module2.exports = MatterTileBody;
        }, function (module2, exports2, __webpack_require__) {
          var Matter = __webpack_require__(1399);
          Matter.Body = __webpack_require__(41);
          Matter.Composite = __webpack_require__(118);
          Matter.World = __webpack_require__(596);
          Matter.Detector = __webpack_require__(273);
          Matter.Grid = __webpack_require__(597);
          Matter.Pairs = __webpack_require__(598);
          Matter.Pair = __webpack_require__(250);
          Matter.Query = __webpack_require__(1400);
          Matter.Resolver = __webpack_require__(599);
          Matter.SAT = __webpack_require__(274);
          Matter.Constraint = __webpack_require__(128);
          Matter.Common = __webpack_require__(32);
          Matter.Engine = __webpack_require__(1401);
          Matter.Events = __webpack_require__(166);
          Matter.Sleeping = __webpack_require__(165);
          Matter.Plugin = __webpack_require__(595);
          Matter.Bodies = __webpack_require__(86);
          Matter.Composites = __webpack_require__(591);
          Matter.Axes = __webpack_require__(271);
          Matter.Bounds = __webpack_require__(84);
          Matter.Svg = __webpack_require__(592);
          Matter.Vector = __webpack_require__(83);
          Matter.Vertices = __webpack_require__(64);
          Matter.World.add = Matter.Composite.add;
          Matter.World.remove = Matter.Composite.remove;
          Matter.World.addComposite = Matter.Composite.addComposite;
          Matter.World.addBody = Matter.Composite.addBody;
          Matter.World.addConstraint = Matter.Composite.addConstraint;
          Matter.World.clear = Matter.Composite.clear;
          module2.exports = Matter;
        }, function (module2, exports2, __webpack_require__) {
          var Plugin = {};
          module2.exports = Plugin;
          var Common = __webpack_require__(32);
          (function () {
            Plugin._registry = {};
            Plugin.register = function (plugin) {
              if (!Plugin.isPlugin(plugin)) {
                Common.warn("Plugin.register:", Plugin.toString(plugin), "does not implement all required fields.");
              }
              if ((plugin.name in Plugin._registry)) {
                var registered = Plugin._registry[plugin.name], pluginVersion = Plugin.versionParse(plugin.version).number, registeredVersion = Plugin.versionParse(registered.version).number;
                if (pluginVersion > registeredVersion) {
                  Common.warn("Plugin.register:", Plugin.toString(registered), "was upgraded to", Plugin.toString(plugin));
                  Plugin._registry[plugin.name] = plugin;
                } else if (pluginVersion < registeredVersion) {
                  Common.warn("Plugin.register:", Plugin.toString(registered), "can not be downgraded to", Plugin.toString(plugin));
                } else if (plugin !== registered) {
                  Common.warn("Plugin.register:", Plugin.toString(plugin), "is already registered to different plugin object");
                }
              } else {
                Plugin._registry[plugin.name] = plugin;
              }
              return plugin;
            };
            Plugin.resolve = function (dependency) {
              return Plugin._registry[Plugin.dependencyParse(dependency).name];
            };
            Plugin.toString = function (plugin) {
              return typeof plugin === "string" ? plugin : (plugin.name || "anonymous") + "@" + (plugin.version || plugin.range || "0.0.0");
            };
            Plugin.isPlugin = function (obj) {
              return obj && obj.name && obj.version && obj.install;
            };
            Plugin.isUsed = function (module3, name) {
              return module3.used.indexOf(name) > -1;
            };
            Plugin.isFor = function (plugin, module3) {
              var parsed = plugin.for && Plugin.dependencyParse(plugin.for);
              return !plugin.for || module3.name === parsed.name && Plugin.versionSatisfies(module3.version, parsed.range);
            };
            Plugin.use = function (module3, plugins) {
              module3.uses = (module3.uses || []).concat(plugins || []);
              if (module3.uses.length === 0) {
                Common.warn("Plugin.use:", Plugin.toString(module3), "does not specify any dependencies to install.");
                return;
              }
              var dependencies = Plugin.dependencies(module3), sortedDependencies = Common.topologicalSort(dependencies), status = [];
              for (var i = 0; i < sortedDependencies.length; i += 1) {
                if (sortedDependencies[i] === module3.name) {
                  continue;
                }
                var plugin = Plugin.resolve(sortedDependencies[i]);
                if (!plugin) {
                  status.push("\u274C " + sortedDependencies[i]);
                  continue;
                }
                if (Plugin.isUsed(module3, plugin.name)) {
                  continue;
                }
                if (!Plugin.isFor(plugin, module3)) {
                  Common.warn("Plugin.use:", Plugin.toString(plugin), "is for", plugin.for, "but installed on", Plugin.toString(module3) + ".");
                  plugin._warned = true;
                }
                if (plugin.install) {
                  plugin.install(module3);
                } else {
                  Common.warn("Plugin.use:", Plugin.toString(plugin), "does not specify an install function.");
                  plugin._warned = true;
                }
                if (plugin._warned) {
                  status.push("\u{1F536} " + Plugin.toString(plugin));
                  delete plugin._warned;
                } else {
                  status.push("\u2705 " + Plugin.toString(plugin));
                }
                module3.used.push(plugin.name);
              }
              if (status.length > 0 && !plugin.silent) {
                Common.info(status.join("  "));
              }
            };
            Plugin.dependencies = function (module3, tracked) {
              var parsedBase = Plugin.dependencyParse(module3), name = parsedBase.name;
              tracked = tracked || ({});
              if ((name in tracked)) {
                return;
              }
              module3 = Plugin.resolve(module3) || module3;
              tracked[name] = Common.map(module3.uses || [], function (dependency) {
                if (Plugin.isPlugin(dependency)) {
                  Plugin.register(dependency);
                }
                var parsed = Plugin.dependencyParse(dependency), resolved = Plugin.resolve(dependency);
                if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {
                  Common.warn("Plugin.dependencies:", Plugin.toString(resolved), "does not satisfy", Plugin.toString(parsed), "used by", Plugin.toString(parsedBase) + ".");
                  resolved._warned = true;
                  module3._warned = true;
                } else if (!resolved) {
                  Common.warn("Plugin.dependencies:", Plugin.toString(dependency), "used by", Plugin.toString(parsedBase), "could not be resolved.");
                  module3._warned = true;
                }
                return parsed.name;
              });
              for (var i = 0; i < tracked[name].length; i += 1) {
                Plugin.dependencies(tracked[name][i], tracked);
              }
              return tracked;
            };
            Plugin.dependencyParse = function (dependency) {
              if (Common.isString(dependency)) {
                var pattern = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/;
                if (!pattern.test(dependency)) {
                  Common.warn("Plugin.dependencyParse:", dependency, "is not a valid dependency string.");
                }
                return {
                  name: dependency.split("@")[0],
                  range: dependency.split("@")[1] || "*"
                };
              }
              return {
                name: dependency.name,
                range: dependency.range || dependency.version
              };
            };
            Plugin.versionParse = function (range) {
              var pattern = /^\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?$/;
              if (!pattern.test(range)) {
                Common.warn("Plugin.versionParse:", range, "is not a valid version or range.");
              }
              var identifiers = range.split("-");
              range = identifiers[0];
              var isRange = isNaN(Number(range[0])), version = isRange ? range.substr(1) : range, parts = Common.map(version.split("."), function (part) {
                return Number(part);
              });
              return {
                isRange,
                version,
                range,
                operator: isRange ? range[0] : "",
                parts,
                prerelease: identifiers[1],
                number: parts[0] * 1e8 + parts[1] * 1e4 + parts[2]
              };
            };
            Plugin.versionSatisfies = function (version, range) {
              range = range || "*";
              var rangeParsed = Plugin.versionParse(range), rangeParts = rangeParsed.parts, versionParsed = Plugin.versionParse(version), versionParts = versionParsed.parts;
              if (rangeParsed.isRange) {
                if (rangeParsed.operator === "*" || version === "*") {
                  return true;
                }
                if (rangeParsed.operator === "~") {
                  return versionParts[0] === rangeParts[0] && versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];
                }
                if (rangeParsed.operator === "^") {
                  if (rangeParts[0] > 0) {
                    return versionParts[0] === rangeParts[0] && versionParsed.number >= rangeParsed.number;
                  }
                  if (rangeParts[1] > 0) {
                    return versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];
                  }
                  return versionParts[2] === rangeParts[2];
                }
              }
              return version === range || version === "*";
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          var World = {};
          module2.exports = World;
          var Composite = __webpack_require__(118);
          var Constraint = __webpack_require__(128);
          var Common = __webpack_require__(32);
          (function () {
            World.create = function (options) {
              var composite = Composite.create();
              var defaults = {
                label: "World",
                gravity: {
                  x: 0,
                  y: 1,
                  scale: 1e-3
                },
                bounds: {
                  min: {
                    x: -Infinity,
                    y: -Infinity
                  },
                  max: {
                    x: Infinity,
                    y: Infinity
                  }
                }
              };
              return Common.extend(composite, defaults, options);
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          var Grid = {};
          module2.exports = Grid;
          var Pair = __webpack_require__(250);
          var Detector = __webpack_require__(273);
          var Common = __webpack_require__(32);
          (function () {
            Grid.create = function (options) {
              var defaults = {
                controller: Grid,
                detector: Detector.collisions,
                buckets: {},
                pairs: {},
                pairsList: [],
                bucketWidth: 48,
                bucketHeight: 48
              };
              return Common.extend(defaults, options);
            };
            Grid.update = function (grid, bodies, engine, forceUpdate) {
              var i, col, row, world = engine.world, buckets = grid.buckets, bucket, bucketId, gridChanged = false;
              var metrics = engine.metrics;
              metrics.broadphaseTests = 0;
              for (i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                if (body.isSleeping && !forceUpdate) continue;
                if (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y) continue;
                var newRegion = Grid._getRegion(grid, body);
                if (!body.region || newRegion.id !== body.region.id || forceUpdate) {
                  metrics.broadphaseTests += 1;
                  if (!body.region || forceUpdate) body.region = newRegion;
                  var union = Grid._regionUnion(newRegion, body.region);
                  for (col = union.startCol; col <= union.endCol; col++) {
                    for (row = union.startRow; row <= union.endRow; row++) {
                      bucketId = Grid._getBucketId(col, row);
                      bucket = buckets[bucketId];
                      var isInsideNewRegion = col >= newRegion.startCol && col <= newRegion.endCol && row >= newRegion.startRow && row <= newRegion.endRow;
                      var isInsideOldRegion = col >= body.region.startCol && col <= body.region.endCol && row >= body.region.startRow && row <= body.region.endRow;
                      if (!isInsideNewRegion && isInsideOldRegion) {
                        if (isInsideOldRegion) {
                          if (bucket) Grid._bucketRemoveBody(grid, bucket, body);
                        }
                      }
                      if (body.region === newRegion || isInsideNewRegion && !isInsideOldRegion || forceUpdate) {
                        if (!bucket) bucket = Grid._createBucket(buckets, bucketId);
                        Grid._bucketAddBody(grid, bucket, body);
                      }
                    }
                  }
                  body.region = newRegion;
                  gridChanged = true;
                }
              }
              if (gridChanged) grid.pairsList = Grid._createActivePairsList(grid);
            };
            Grid.clear = function (grid) {
              grid.buckets = {};
              grid.pairs = {};
              grid.pairsList = [];
            };
            Grid._regionUnion = function (regionA, regionB) {
              var startCol = Math.min(regionA.startCol, regionB.startCol), endCol = Math.max(regionA.endCol, regionB.endCol), startRow = Math.min(regionA.startRow, regionB.startRow), endRow = Math.max(regionA.endRow, regionB.endRow);
              return Grid._createRegion(startCol, endCol, startRow, endRow);
            };
            Grid._getRegion = function (grid, body) {
              var bounds = body.bounds, startCol = Math.floor(bounds.min.x / grid.bucketWidth), endCol = Math.floor(bounds.max.x / grid.bucketWidth), startRow = Math.floor(bounds.min.y / grid.bucketHeight), endRow = Math.floor(bounds.max.y / grid.bucketHeight);
              return Grid._createRegion(startCol, endCol, startRow, endRow);
            };
            Grid._createRegion = function (startCol, endCol, startRow, endRow) {
              return {
                id: startCol + "," + endCol + "," + startRow + "," + endRow,
                startCol,
                endCol,
                startRow,
                endRow
              };
            };
            Grid._getBucketId = function (column, row) {
              return "C" + column + "R" + row;
            };
            Grid._createBucket = function (buckets, bucketId) {
              var bucket = buckets[bucketId] = [];
              return bucket;
            };
            Grid._bucketAddBody = function (grid, bucket, body) {
              for (var i = 0; i < bucket.length; i++) {
                var bodyB = bucket[i];
                if (body.id === bodyB.id || body.isStatic && bodyB.isStatic) continue;
                var pairId = Pair.id(body, bodyB), pair = grid.pairs[pairId];
                if (pair) {
                  pair[2] += 1;
                } else {
                  grid.pairs[pairId] = [body, bodyB, 1];
                }
              }
              bucket.push(body);
            };
            Grid._bucketRemoveBody = function (grid, bucket, body) {
              bucket.splice(bucket.indexOf(body), 1);
              for (var i = 0; i < bucket.length; i++) {
                var bodyB = bucket[i], pairId = Pair.id(body, bodyB), pair = grid.pairs[pairId];
                if (pair) pair[2] -= 1;
              }
            };
            Grid._createActivePairsList = function (grid) {
              var pairKeys, pair, pairs = [];
              pairKeys = Common.keys(grid.pairs);
              for (var k = 0; k < pairKeys.length; k++) {
                pair = grid.pairs[pairKeys[k]];
                if (pair[2] > 0) {
                  pairs.push(pair);
                } else {
                  delete grid.pairs[pairKeys[k]];
                }
              }
              return pairs;
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          var Pairs = {};
          module2.exports = Pairs;
          var Pair = __webpack_require__(250);
          var Common = __webpack_require__(32);
          (function () {
            Pairs._pairMaxIdleLife = 1e3;
            Pairs.create = function (options) {
              return Common.extend({
                table: {},
                list: [],
                collisionStart: [],
                collisionActive: [],
                collisionEnd: []
              }, options);
            };
            Pairs.update = function (pairs, collisions, timestamp) {
              var pairsList = pairs.list, pairsTable = pairs.table, collisionStart = pairs.collisionStart, collisionEnd = pairs.collisionEnd, collisionActive = pairs.collisionActive, collision, pairId, pair, i;
              collisionStart.length = 0;
              collisionEnd.length = 0;
              collisionActive.length = 0;
              for (i = 0; i < pairsList.length; i++) {
                pairsList[i].confirmedActive = false;
              }
              for (i = 0; i < collisions.length; i++) {
                collision = collisions[i];
                if (collision.collided) {
                  pairId = Pair.id(collision.bodyA, collision.bodyB);
                  pair = pairsTable[pairId];
                  if (pair) {
                    if (pair.isActive) {
                      collisionActive.push(pair);
                    } else {
                      collisionStart.push(pair);
                    }
                    Pair.update(pair, collision, timestamp);
                    pair.confirmedActive = true;
                  } else {
                    pair = Pair.create(collision, timestamp);
                    pairsTable[pairId] = pair;
                    collisionStart.push(pair);
                    pairsList.push(pair);
                  }
                }
              }
              for (i = 0; i < pairsList.length; i++) {
                pair = pairsList[i];
                if (pair.isActive && !pair.confirmedActive) {
                  Pair.setActive(pair, false, timestamp);
                  collisionEnd.push(pair);
                }
              }
            };
            Pairs.removeOld = function (pairs, timestamp) {
              var pairsList = pairs.list, pairsTable = pairs.table, indexesToRemove = [], pair, collision, pairIndex, i;
              for (i = 0; i < pairsList.length; i++) {
                pair = pairsList[i];
                collision = pair.collision;
                if (collision.bodyA.isSleeping || collision.bodyB.isSleeping) {
                  pair.timeUpdated = timestamp;
                  continue;
                }
                if (timestamp - pair.timeUpdated > Pairs._pairMaxIdleLife) {
                  indexesToRemove.push(i);
                }
              }
              for (i = 0; i < indexesToRemove.length; i++) {
                pairIndex = indexesToRemove[i] - i;
                pair = pairsList[pairIndex];
                delete pairsTable[pair.id];
                pairsList.splice(pairIndex, 1);
              }
            };
            Pairs.clear = function (pairs) {
              pairs.table = {};
              pairs.list.length = 0;
              pairs.collisionStart.length = 0;
              pairs.collisionActive.length = 0;
              pairs.collisionEnd.length = 0;
              return pairs;
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          var Resolver = {};
          module2.exports = Resolver;
          var Vertices = __webpack_require__(64);
          var Vector = __webpack_require__(83);
          var Common = __webpack_require__(32);
          var Bounds = __webpack_require__(84);
          (function () {
            Resolver._restingThresh = 4;
            Resolver._restingThreshTangent = 6;
            Resolver._positionDampen = 0.9;
            Resolver._positionWarming = 0.8;
            Resolver._frictionNormalMultiplier = 5;
            Resolver.preSolvePosition = function (pairs) {
              var i, pair, activeCount;
              for (i = 0; i < pairs.length; i++) {
                pair = pairs[i];
                if (!pair.isActive) continue;
                activeCount = pair.activeContacts.length;
                pair.collision.parentA.totalContacts += activeCount;
                pair.collision.parentB.totalContacts += activeCount;
              }
            };
            Resolver.solvePosition = function (pairs, bodies, timeScale) {
              var i, normalX, normalY, pair, collision, bodyA, bodyB, normal, separation, penetration, positionImpulseA, positionImpulseB, contactShare, bodyBtoAX, bodyBtoAY, positionImpulse, impulseCoefficient = timeScale * Resolver._positionDampen;
              for (i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                body.previousPositionImpulse.x = body.positionImpulse.x;
                body.previousPositionImpulse.y = body.positionImpulse.y;
              }
              for (i = 0; i < pairs.length; i++) {
                pair = pairs[i];
                if (!pair.isActive || pair.isSensor) continue;
                collision = pair.collision;
                bodyA = collision.parentA;
                bodyB = collision.parentB;
                normal = collision.normal;
                positionImpulseA = bodyA.previousPositionImpulse;
                positionImpulseB = bodyB.previousPositionImpulse;
                penetration = collision.penetration;
                bodyBtoAX = positionImpulseB.x - positionImpulseA.x + penetration.x;
                bodyBtoAY = positionImpulseB.y - positionImpulseA.y + penetration.y;
                normalX = normal.x;
                normalY = normal.y;
                separation = normalX * bodyBtoAX + normalY * bodyBtoAY;
                pair.separation = separation;
                positionImpulse = (separation - pair.slop) * impulseCoefficient;
                if (bodyA.isStatic || bodyB.isStatic) positionImpulse *= 2;
                if (!(bodyA.isStatic || bodyA.isSleeping)) {
                  contactShare = positionImpulse / bodyA.totalContacts;
                  bodyA.positionImpulse.x += normalX * contactShare;
                  bodyA.positionImpulse.y += normalY * contactShare;
                }
                if (!(bodyB.isStatic || bodyB.isSleeping)) {
                  contactShare = positionImpulse / bodyB.totalContacts;
                  bodyB.positionImpulse.x -= normalX * contactShare;
                  bodyB.positionImpulse.y -= normalY * contactShare;
                }
              }
            };
            Resolver.postSolvePosition = function (bodies) {
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                body.totalContacts = 0;
                if (body.positionImpulse.x !== 0 || body.positionImpulse.y !== 0) {
                  for (var j = 0; j < body.parts.length; j++) {
                    var part = body.parts[j];
                    Vertices.translate(part.vertices, body.positionImpulse);
                    Bounds.update(part.bounds, part.vertices, body.velocity);
                    part.position.x += body.positionImpulse.x;
                    part.position.y += body.positionImpulse.y;
                  }
                  body.positionPrev.x += body.positionImpulse.x;
                  body.positionPrev.y += body.positionImpulse.y;
                  if (Vector.dot(body.positionImpulse, body.velocity) < 0) {
                    body.positionImpulse.x = 0;
                    body.positionImpulse.y = 0;
                  } else {
                    body.positionImpulse.x *= Resolver._positionWarming;
                    body.positionImpulse.y *= Resolver._positionWarming;
                  }
                }
              }
            };
            Resolver.preSolveVelocity = function (pairs) {
              var i, j, pair, contacts, collision, bodyA, bodyB, normal, tangent, contact, contactVertex, normalImpulse, tangentImpulse, offset, impulse = Vector._temp[0], tempA = Vector._temp[1];
              for (i = 0; i < pairs.length; i++) {
                pair = pairs[i];
                if (!pair.isActive || pair.isSensor) continue;
                contacts = pair.activeContacts;
                collision = pair.collision;
                bodyA = collision.parentA;
                bodyB = collision.parentB;
                normal = collision.normal;
                tangent = collision.tangent;
                for (j = 0; j < contacts.length; j++) {
                  contact = contacts[j];
                  contactVertex = contact.vertex;
                  normalImpulse = contact.normalImpulse;
                  tangentImpulse = contact.tangentImpulse;
                  if (normalImpulse !== 0 || tangentImpulse !== 0) {
                    impulse.x = normal.x * normalImpulse + tangent.x * tangentImpulse;
                    impulse.y = normal.y * normalImpulse + tangent.y * tangentImpulse;
                    if (!(bodyA.isStatic || bodyA.isSleeping)) {
                      offset = Vector.sub(contactVertex, bodyA.position, tempA);
                      bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
                      bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
                      bodyA.anglePrev += Vector.cross(offset, impulse) * bodyA.inverseInertia;
                    }
                    if (!(bodyB.isStatic || bodyB.isSleeping)) {
                      offset = Vector.sub(contactVertex, bodyB.position, tempA);
                      bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
                      bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
                      bodyB.anglePrev -= Vector.cross(offset, impulse) * bodyB.inverseInertia;
                    }
                  }
                }
              }
            };
            Resolver.solveVelocity = function (pairs, timeScale) {
              var timeScaleSquared = timeScale * timeScale, impulse = Vector._temp[0], tempA = Vector._temp[1], tempB = Vector._temp[2], tempC = Vector._temp[3], tempD = Vector._temp[4], tempE = Vector._temp[5];
              for (var i = 0; i < pairs.length; i++) {
                var pair = pairs[i];
                if (!pair.isActive || pair.isSensor) continue;
                var collision = pair.collision, bodyA = collision.parentA, bodyB = collision.parentB, normal = collision.normal, tangent = collision.tangent, contacts = pair.activeContacts, contactShare = 1 / contacts.length;
                bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;
                bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;
                bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;
                bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;
                bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;
                bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;
                for (var j = 0; j < contacts.length; j++) {
                  var contact = contacts[j], contactVertex = contact.vertex, offsetA = Vector.sub(contactVertex, bodyA.position, tempA), offsetB = Vector.sub(contactVertex, bodyB.position, tempB), velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity), tempC), velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity), tempD), relativeVelocity = Vector.sub(velocityPointA, velocityPointB, tempE), normalVelocity = Vector.dot(normal, relativeVelocity);
                  var tangentVelocity = Vector.dot(tangent, relativeVelocity), tangentSpeed = Math.abs(tangentVelocity), tangentVelocityDirection = Common.sign(tangentVelocity);
                  var normalImpulse = (1 + pair.restitution) * normalVelocity, normalForce = Common.clamp(pair.separation + normalVelocity, 0, 1) * Resolver._frictionNormalMultiplier;
                  var tangentImpulse = tangentVelocity, maxFriction = Infinity;
                  if (tangentSpeed > pair.friction * pair.frictionStatic * normalForce * timeScaleSquared) {
                    maxFriction = tangentSpeed;
                    tangentImpulse = Common.clamp(pair.friction * tangentVelocityDirection * timeScaleSquared, -maxFriction, maxFriction);
                  }
                  var oAcN = Vector.cross(offsetA, normal), oBcN = Vector.cross(offsetB, normal), share = contactShare / (bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * oAcN * oAcN + bodyB.inverseInertia * oBcN * oBcN);
                  normalImpulse *= share;
                  tangentImpulse *= share;
                  if (normalVelocity < 0 && normalVelocity * normalVelocity > Resolver._restingThresh * timeScaleSquared) {
                    contact.normalImpulse = 0;
                  } else {
                    var contactNormalImpulse = contact.normalImpulse;
                    contact.normalImpulse = Math.min(contact.normalImpulse + normalImpulse, 0);
                    normalImpulse = contact.normalImpulse - contactNormalImpulse;
                  }
                  if (tangentVelocity * tangentVelocity > Resolver._restingThreshTangent * timeScaleSquared) {
                    contact.tangentImpulse = 0;
                  } else {
                    var contactTangentImpulse = contact.tangentImpulse;
                    contact.tangentImpulse = Common.clamp(contact.tangentImpulse + tangentImpulse, -maxFriction, maxFriction);
                    tangentImpulse = contact.tangentImpulse - contactTangentImpulse;
                  }
                  impulse.x = normal.x * normalImpulse + tangent.x * tangentImpulse;
                  impulse.y = normal.y * normalImpulse + tangent.y * tangentImpulse;
                  if (!(bodyA.isStatic || bodyA.isSleeping)) {
                    bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
                    bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
                    bodyA.anglePrev += Vector.cross(offsetA, impulse) * bodyA.inverseInertia;
                  }
                  if (!(bodyB.isStatic || bodyB.isSleeping)) {
                    bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
                    bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
                    bodyB.anglePrev -= Vector.cross(offsetB, impulse) * bodyB.inverseInertia;
                  }
                }
              }
            };
          })();
        }, function (module2, exports2) {
          var g;
          g = (function () {
            return this;
          })();
          try {
            g = g || new Function("return this")();
          } catch (e) {
            if (typeof window === "object") g = window;
          }
          module2.exports = g;
        }, function (module2, exports2, __webpack_require__) {
          var QuickSet = __webpack_require__(276);
          var AlignTo = function (items, position, offsetX, offsetY) {
            var target = items[0];
            for (var i = 1; i < items.length; i++) {
              var item = items[i];
              QuickSet(item, target, position, offsetX, offsetY);
              target = item;
            }
            return items;
          };
          module2.exports = AlignTo;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueInc = __webpack_require__(46);
          var Angle = function (items, value, step, index, direction) {
            return PropertyValueInc(items, "angle", value, step, index, direction);
          };
          module2.exports = Angle;
        }, function (module2, exports2) {
          var Call = function (items, callback, context) {
            for (var i = 0; i < items.length; i++) {
              var item = items[i];
              callback.call(context, item);
            }
            return items;
          };
          module2.exports = Call;
        }, function (module2, exports2) {
          var GetFirst = function (items, compare, index) {
            if (index === void 0) {
              index = 0;
            }
            for (var i = index; i < items.length; i++) {
              var item = items[i];
              var match = true;
              for (var property in compare) {
                if (item[property] !== compare[property]) {
                  match = false;
                }
              }
              if (match) {
                return item;
              }
            }
            return null;
          };
          module2.exports = GetFirst;
        }, function (module2, exports2) {
          var GetLast = function (items, compare, index) {
            if (index === void 0) {
              index = 0;
            }
            for (var i = index; i < items.length; i++) {
              var item = items[i];
              var match = true;
              for (var property in compare) {
                if (item[property] !== compare[property]) {
                  match = false;
                }
              }
              if (match) {
                return item;
              }
            }
            return null;
          };
          module2.exports = GetLast;
        }, function (module2, exports2, __webpack_require__) {
          var AlignIn = __webpack_require__(289);
          var CONST = __webpack_require__(123);
          var GetFastValue = __webpack_require__(2);
          var NOOP = __webpack_require__(1);
          var Zone = __webpack_require__(129);
          var tempZone = new Zone({
            sys: {
              queueDepthSort: NOOP,
              events: {
                once: NOOP
              }
            }
          }, 0, 0, 1, 1);
          var GridAlign = function (items, options) {
            if (options === void 0) {
              options = {};
            }
            var widthSet = options.hasOwnProperty("width");
            var heightSet = options.hasOwnProperty("height");
            var width = GetFastValue(options, "width", -1);
            var height = GetFastValue(options, "height", -1);
            var cellWidth = GetFastValue(options, "cellWidth", 1);
            var cellHeight = GetFastValue(options, "cellHeight", cellWidth);
            var position = GetFastValue(options, "position", CONST.TOP_LEFT);
            var x = GetFastValue(options, "x", 0);
            var y = GetFastValue(options, "y", 0);
            var cx = 0;
            var cy = 0;
            var w = width * cellWidth;
            var h = height * cellHeight;
            tempZone.setPosition(x, y);
            tempZone.setSize(cellWidth, cellHeight);
            for (var i = 0; i < items.length; i++) {
              AlignIn(items[i], tempZone, position);
              if (widthSet && width === -1) {
                tempZone.x += cellWidth;
              } else if (heightSet && height === -1) {
                tempZone.y += cellHeight;
              } else if (heightSet && !widthSet) {
                cy += cellHeight;
                tempZone.y += cellHeight;
                if (cy === h) {
                  cy = 0;
                  cx += cellWidth;
                  tempZone.y = y;
                  tempZone.x += cellWidth;
                  if (cx === w) {
                    break;
                  }
                }
              } else {
                cx += cellWidth;
                tempZone.x += cellWidth;
                if (cx === w) {
                  cx = 0;
                  cy += cellHeight;
                  tempZone.x = x;
                  tempZone.y += cellHeight;
                  if (cy === h) {
                    break;
                  }
                }
              }
            }
            return items;
          };
          module2.exports = GridAlign;
        }, function (module2, exports2, __webpack_require__) {
          var Clamp = __webpack_require__(18);
          var _FLAG = 2;
          var Alpha = {
            _alpha: 1,
            _alphaTL: 1,
            _alphaTR: 1,
            _alphaBL: 1,
            _alphaBR: 1,
            clearAlpha: function () {
              return this.setAlpha(1);
            },
            setAlpha: function (topLeft, topRight, bottomLeft, bottomRight) {
              if (topLeft === void 0) {
                topLeft = 1;
              }
              if (topRight === void 0) {
                this.alpha = topLeft;
              } else {
                this._alphaTL = Clamp(topLeft, 0, 1);
                this._alphaTR = Clamp(topRight, 0, 1);
                this._alphaBL = Clamp(bottomLeft, 0, 1);
                this._alphaBR = Clamp(bottomRight, 0, 1);
              }
              return this;
            },
            alpha: {
              get: function () {
                return this._alpha;
              },
              set: function (value) {
                var v = Clamp(value, 0, 1);
                this._alpha = v;
                this._alphaTL = v;
                this._alphaTR = v;
                this._alphaBL = v;
                this._alphaBR = v;
                if (v === 0) {
                  this.renderFlags &= ~_FLAG;
                } else {
                  this.renderFlags |= _FLAG;
                }
              }
            },
            alphaTopLeft: {
              get: function () {
                return this._alphaTL;
              },
              set: function (value) {
                var v = Clamp(value, 0, 1);
                this._alphaTL = v;
                if (v !== 0) {
                  this.renderFlags |= _FLAG;
                }
              }
            },
            alphaTopRight: {
              get: function () {
                return this._alphaTR;
              },
              set: function (value) {
                var v = Clamp(value, 0, 1);
                this._alphaTR = v;
                if (v !== 0) {
                  this.renderFlags |= _FLAG;
                }
              }
            },
            alphaBottomLeft: {
              get: function () {
                return this._alphaBL;
              },
              set: function (value) {
                var v = Clamp(value, 0, 1);
                this._alphaBL = v;
                if (v !== 0) {
                  this.renderFlags |= _FLAG;
                }
              }
            },
            alphaBottomRight: {
              get: function () {
                return this._alphaBR;
              },
              set: function (value) {
                var v = Clamp(value, 0, 1);
                this._alphaBR = v;
                if (v !== 0) {
                  this.renderFlags |= _FLAG;
                }
              }
            }
          };
          module2.exports = Alpha;
        }, function (module2, exports2) {
          var ComputedSize = {
            width: 0,
            height: 0,
            displayWidth: {
              get: function () {
                return this.scaleX * this.width;
              },
              set: function (value) {
                this.scaleX = value / this.width;
              }
            },
            displayHeight: {
              get: function () {
                return this.scaleY * this.height;
              },
              set: function (value) {
                this.scaleY = value / this.height;
              }
            },
            setSize: function (width, height) {
              this.width = width;
              this.height = height;
              return this;
            },
            setDisplaySize: function (width, height) {
              this.displayWidth = width;
              this.displayHeight = height;
              return this;
            }
          };
          module2.exports = ComputedSize;
        }, function (module2, exports2) {
          var Crop = {
            texture: null,
            frame: null,
            isCropped: false,
            setCrop: function (x, y, width, height) {
              if (x === void 0) {
                this.isCropped = false;
              } else if (this.frame) {
                if (typeof x === "number") {
                  this.frame.setCropUVs(this._crop, x, y, width, height, this.flipX, this.flipY);
                } else {
                  var rect = x;
                  this.frame.setCropUVs(this._crop, rect.x, rect.y, rect.width, rect.height, this.flipX, this.flipY);
                }
                this.isCropped = true;
              }
              return this;
            },
            resetCropObject: function () {
              return {
                u0: 0,
                v0: 0,
                u1: 0,
                v1: 0,
                width: 0,
                height: 0,
                x: 0,
                y: 0,
                flipX: false,
                flipY: false,
                cx: 0,
                cy: 0,
                cw: 0,
                ch: 0
              };
            }
          };
          module2.exports = Crop;
        }, function (module2, exports2) {
          var Flip = {
            flipX: false,
            flipY: false,
            toggleFlipX: function () {
              this.flipX = !this.flipX;
              return this;
            },
            toggleFlipY: function () {
              this.flipY = !this.flipY;
              return this;
            },
            setFlipX: function (value) {
              this.flipX = value;
              return this;
            },
            setFlipY: function (value) {
              this.flipY = value;
              return this;
            },
            setFlip: function (x, y) {
              this.flipX = x;
              this.flipY = y;
              return this;
            },
            resetFlip: function () {
              this.flipX = false;
              this.flipY = false;
              return this;
            }
          };
          module2.exports = Flip;
        }, function (module2, exports2, __webpack_require__) {
          var Rectangle = __webpack_require__(10);
          var RotateAround = __webpack_require__(308);
          var Vector2 = __webpack_require__(3);
          var GetBounds = {
            prepareBoundsOutput: function (output, includeParent) {
              if (includeParent === void 0) {
                includeParent = false;
              }
              if (this.rotation !== 0) {
                RotateAround(output, this.x, this.y, this.rotation);
              }
              if (includeParent && this.parentContainer) {
                var parentMatrix = this.parentContainer.getBoundsTransformMatrix();
                parentMatrix.transformPoint(output.x, output.y, output);
              }
              return output;
            },
            getCenter: function (output) {
              if (output === void 0) {
                output = new Vector2();
              }
              output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
              output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;
              return output;
            },
            getTopLeft: function (output, includeParent) {
              if (!output) {
                output = new Vector2();
              }
              output.x = this.x - this.displayWidth * this.originX;
              output.y = this.y - this.displayHeight * this.originY;
              return this.prepareBoundsOutput(output, includeParent);
            },
            getTopCenter: function (output, includeParent) {
              if (!output) {
                output = new Vector2();
              }
              output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
              output.y = this.y - this.displayHeight * this.originY;
              return this.prepareBoundsOutput(output, includeParent);
            },
            getTopRight: function (output, includeParent) {
              if (!output) {
                output = new Vector2();
              }
              output.x = this.x - this.displayWidth * this.originX + this.displayWidth;
              output.y = this.y - this.displayHeight * this.originY;
              return this.prepareBoundsOutput(output, includeParent);
            },
            getLeftCenter: function (output, includeParent) {
              if (!output) {
                output = new Vector2();
              }
              output.x = this.x - this.displayWidth * this.originX;
              output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;
              return this.prepareBoundsOutput(output, includeParent);
            },
            getRightCenter: function (output, includeParent) {
              if (!output) {
                output = new Vector2();
              }
              output.x = this.x - this.displayWidth * this.originX + this.displayWidth;
              output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;
              return this.prepareBoundsOutput(output, includeParent);
            },
            getBottomLeft: function (output, includeParent) {
              if (!output) {
                output = new Vector2();
              }
              output.x = this.x - this.displayWidth * this.originX;
              output.y = this.y - this.displayHeight * this.originY + this.displayHeight;
              return this.prepareBoundsOutput(output, includeParent);
            },
            getBottomCenter: function (output, includeParent) {
              if (!output) {
                output = new Vector2();
              }
              output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
              output.y = this.y - this.displayHeight * this.originY + this.displayHeight;
              return this.prepareBoundsOutput(output, includeParent);
            },
            getBottomRight: function (output, includeParent) {
              if (!output) {
                output = new Vector2();
              }
              output.x = this.x - this.displayWidth * this.originX + this.displayWidth;
              output.y = this.y - this.displayHeight * this.originY + this.displayHeight;
              return this.prepareBoundsOutput(output, includeParent);
            },
            getBounds: function (output) {
              if (output === void 0) {
                output = new Rectangle();
              }
              var TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy;
              if (this.parentContainer) {
                var parentMatrix = this.parentContainer.getBoundsTransformMatrix();
                this.getTopLeft(output);
                parentMatrix.transformPoint(output.x, output.y, output);
                TLx = output.x;
                TLy = output.y;
                this.getTopRight(output);
                parentMatrix.transformPoint(output.x, output.y, output);
                TRx = output.x;
                TRy = output.y;
                this.getBottomLeft(output);
                parentMatrix.transformPoint(output.x, output.y, output);
                BLx = output.x;
                BLy = output.y;
                this.getBottomRight(output);
                parentMatrix.transformPoint(output.x, output.y, output);
                BRx = output.x;
                BRy = output.y;
              } else {
                this.getTopLeft(output);
                TLx = output.x;
                TLy = output.y;
                this.getTopRight(output);
                TRx = output.x;
                TRy = output.y;
                this.getBottomLeft(output);
                BLx = output.x;
                BLy = output.y;
                this.getBottomRight(output);
                BRx = output.x;
                BRy = output.y;
              }
              output.x = Math.min(TLx, TRx, BLx, BRx);
              output.y = Math.min(TLy, TRy, BLy, BRy);
              output.width = Math.max(TLx, TRx, BLx, BRx) - output.x;
              output.height = Math.max(TLy, TRy, BLy, BRy) - output.y;
              return output;
            }
          };
          module2.exports = GetBounds;
        }, function (module2, exports2) {
          module2.exports = "blur";
        }, function (module2, exports2) {
          module2.exports = "boot";
        }, function (module2, exports2) {
          module2.exports = "contextlost";
        }, function (module2, exports2) {
          module2.exports = "contextrestored";
        }, function (module2, exports2) {
          module2.exports = "destroy";
        }, function (module2, exports2) {
          module2.exports = "focus";
        }, function (module2, exports2) {
          module2.exports = "hidden";
        }, function (module2, exports2) {
          module2.exports = "pause";
        }, function (module2, exports2) {
          module2.exports = "postrender";
        }, function (module2, exports2) {
          module2.exports = "poststep";
        }, function (module2, exports2) {
          module2.exports = "prerender";
        }, function (module2, exports2) {
          module2.exports = "prestep";
        }, function (module2, exports2) {
          module2.exports = "ready";
        }, function (module2, exports2) {
          module2.exports = "resume";
        }, function (module2, exports2) {
          module2.exports = "step";
        }, function (module2, exports2) {
          module2.exports = "visible";
        }, function (module2, exports2) {
          module2.exports = "postrender";
        }, function (module2, exports2) {
          module2.exports = "prerender";
        }, function (module2, exports2) {
          module2.exports = "render";
        }, function (module2, exports2) {
          module2.exports = "resize";
        }, function (module2, exports2) {
          var Origin = {
            _originComponent: true,
            originX: 0.5,
            originY: 0.5,
            _displayOriginX: 0,
            _displayOriginY: 0,
            displayOriginX: {
              get: function () {
                return this._displayOriginX;
              },
              set: function (value) {
                this._displayOriginX = value;
                this.originX = value / this.width;
              }
            },
            displayOriginY: {
              get: function () {
                return this._displayOriginY;
              },
              set: function (value) {
                this._displayOriginY = value;
                this.originY = value / this.height;
              }
            },
            setOrigin: function (x, y) {
              if (x === void 0) {
                x = 0.5;
              }
              if (y === void 0) {
                y = x;
              }
              this.originX = x;
              this.originY = y;
              return this.updateDisplayOrigin();
            },
            setOriginFromFrame: function () {
              if (!this.frame || !this.frame.customPivot) {
                return this.setOrigin();
              } else {
                this.originX = this.frame.pivotX;
                this.originY = this.frame.pivotY;
              }
              return this.updateDisplayOrigin();
            },
            setDisplayOrigin: function (x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = x;
              }
              this.displayOriginX = x;
              this.displayOriginY = y;
              return this;
            },
            updateDisplayOrigin: function () {
              this._displayOriginX = this.originX * this.width;
              this._displayOriginY = this.originY * this.height;
              return this;
            }
          };
          module2.exports = Origin;
        }, function (module2, exports2, __webpack_require__) {
          var DegToRad = __webpack_require__(36);
          var GetBoolean = __webpack_require__(99);
          var GetValue = __webpack_require__(6);
          var TWEEN_CONST = __webpack_require__(100);
          var Vector2 = __webpack_require__(3);
          var PathFollower = {
            path: null,
            rotateToPath: false,
            pathRotationOffset: 0,
            pathOffset: null,
            pathVector: null,
            pathDelta: null,
            pathTween: null,
            pathConfig: null,
            _prevDirection: TWEEN_CONST.PLAYING_FORWARD,
            setPath: function (path, config) {
              if (config === void 0) {
                config = this.pathConfig;
              }
              var tween = this.pathTween;
              if (tween && tween.isPlaying()) {
                tween.stop();
              }
              this.path = path;
              if (config) {
                this.startFollow(config);
              }
              return this;
            },
            setRotateToPath: function (value, offset) {
              if (offset === void 0) {
                offset = 0;
              }
              this.rotateToPath = value;
              this.pathRotationOffset = offset;
              return this;
            },
            isFollowing: function () {
              var tween = this.pathTween;
              return tween && tween.isPlaying();
            },
            startFollow: function (config, startAt) {
              if (config === void 0) {
                config = {};
              }
              if (startAt === void 0) {
                startAt = 0;
              }
              var tween = this.pathTween;
              if (tween && tween.isPlaying()) {
                tween.stop();
              }
              if (typeof config === "number") {
                config = {
                  duration: config
                };
              }
              config.from = GetValue(config, "from", 0);
              config.to = GetValue(config, "to", 1);
              var positionOnPath = GetBoolean(config, "positionOnPath", false);
              this.rotateToPath = GetBoolean(config, "rotateToPath", false);
              this.pathRotationOffset = GetValue(config, "rotationOffset", 0);
              var seek = GetValue(config, "startAt", startAt);
              if (seek) {
                config.onStart = function (tween2) {
                  var tweenData = tween2.data[0];
                  tweenData.progress = seek;
                  tweenData.elapsed = tweenData.duration * seek;
                  var v = tweenData.ease(tweenData.progress);
                  tweenData.current = tweenData.start + (tweenData.end - tweenData.start) * v;
                  tweenData.target[tweenData.key] = tweenData.current;
                };
              }
              if (!this.pathOffset) {
                this.pathOffset = new Vector2(this.x, this.y);
              }
              if (!this.pathVector) {
                this.pathVector = new Vector2();
              }
              if (!this.pathDelta) {
                this.pathDelta = new Vector2();
              }
              this.pathDelta.reset();
              this.pathTween = this.scene.sys.tweens.addCounter(config);
              this.path.getStartPoint(this.pathOffset);
              if (positionOnPath) {
                this.x = this.pathOffset.x;
                this.y = this.pathOffset.y;
              }
              this.pathOffset.x = this.x - this.pathOffset.x;
              this.pathOffset.y = this.y - this.pathOffset.y;
              this._prevDirection = TWEEN_CONST.PLAYING_FORWARD;
              if (this.rotateToPath) {
                var nextPoint = this.path.getPoint(0.1);
                this.rotation = Math.atan2(nextPoint.y - this.y, nextPoint.x - this.x) + DegToRad(this.pathRotationOffset);
              }
              this.pathConfig = config;
              return this;
            },
            pauseFollow: function () {
              var tween = this.pathTween;
              if (tween && tween.isPlaying()) {
                tween.pause();
              }
              return this;
            },
            resumeFollow: function () {
              var tween = this.pathTween;
              if (tween && tween.isPaused()) {
                tween.resume();
              }
              return this;
            },
            stopFollow: function () {
              var tween = this.pathTween;
              if (tween && tween.isPlaying()) {
                tween.stop();
              }
              return this;
            },
            pathUpdate: function () {
              var tween = this.pathTween;
              if (tween) {
                var tweenData = tween.data[0];
                var pathDelta = this.pathDelta;
                var pathVector = this.pathVector;
                pathDelta.copy(pathVector).negate();
                if (tweenData.state === TWEEN_CONST.COMPLETE) {
                  this.path.getPoint(1, pathVector);
                  pathDelta.add(pathVector);
                  pathVector.add(this.pathOffset);
                  this.setPosition(pathVector.x, pathVector.y);
                  return;
                } else if (tweenData.state !== TWEEN_CONST.PLAYING_FORWARD && tweenData.state !== TWEEN_CONST.PLAYING_BACKWARD) {
                  return;
                }
                this.path.getPoint(tween.getValue(), pathVector);
                pathDelta.add(pathVector);
                pathVector.add(this.pathOffset);
                var oldX = this.x;
                var oldY = this.y;
                this.setPosition(pathVector.x, pathVector.y);
                var speedX = this.x - oldX;
                var speedY = this.y - oldY;
                if (speedX === 0 && speedY === 0) {
                  return;
                }
                if (tweenData.state !== this._prevDirection) {
                  this._prevDirection = tweenData.state;
                  return;
                }
                if (this.rotateToPath) {
                  this.rotation = Math.atan2(speedY, speedX) + DegToRad(this.pathRotationOffset);
                }
              }
            }
          };
          module2.exports = PathFollower;
        }, function (module2, exports2) {
          var Size = {
            _sizeComponent: true,
            width: 0,
            height: 0,
            displayWidth: {
              get: function () {
                return Math.abs(this.scaleX * this.frame.realWidth);
              },
              set: function (value) {
                this.scaleX = value / this.frame.realWidth;
              }
            },
            displayHeight: {
              get: function () {
                return Math.abs(this.scaleY * this.frame.realHeight);
              },
              set: function (value) {
                this.scaleY = value / this.frame.realHeight;
              }
            },
            setSizeToFrame: function (frame) {
              if (frame === void 0) {
                frame = this.frame;
              }
              this.width = frame.realWidth;
              this.height = frame.realHeight;
              return this;
            },
            setSize: function (width, height) {
              this.width = width;
              this.height = height;
              return this;
            },
            setDisplaySize: function (width, height) {
              this.displayWidth = width;
              this.displayHeight = height;
              return this;
            }
          };
          module2.exports = Size;
        }, function (module2, exports2) {
          var _FLAG = 8;
          var Texture = {
            texture: null,
            frame: null,
            isCropped: false,
            setTexture: function (key, frame) {
              this.texture = this.scene.sys.textures.get(key);
              return this.setFrame(frame);
            },
            setFrame: function (frame, updateSize, updateOrigin) {
              if (updateSize === void 0) {
                updateSize = true;
              }
              if (updateOrigin === void 0) {
                updateOrigin = true;
              }
              this.frame = this.texture.get(frame);
              if (!this.frame.cutWidth || !this.frame.cutHeight) {
                this.renderFlags &= ~_FLAG;
              } else {
                this.renderFlags |= _FLAG;
              }
              if (this._sizeComponent && updateSize) {
                this.setSizeToFrame();
              }
              if (this._originComponent && updateOrigin) {
                if (this.frame.customPivot) {
                  this.setOrigin(this.frame.pivotX, this.frame.pivotY);
                } else {
                  this.updateDisplayOrigin();
                }
              }
              return this;
            }
          };
          module2.exports = Texture;
        }, function (module2, exports2) {
          var _FLAG = 8;
          var TextureCrop = {
            texture: null,
            frame: null,
            isCropped: false,
            setCrop: function (x, y, width, height) {
              if (x === void 0) {
                this.isCropped = false;
              } else if (this.frame) {
                if (typeof x === "number") {
                  this.frame.setCropUVs(this._crop, x, y, width, height, this.flipX, this.flipY);
                } else {
                  var rect = x;
                  this.frame.setCropUVs(this._crop, rect.x, rect.y, rect.width, rect.height, this.flipX, this.flipY);
                }
                this.isCropped = true;
              }
              return this;
            },
            setTexture: function (key, frame) {
              this.texture = this.scene.sys.textures.get(key);
              return this.setFrame(frame);
            },
            setFrame: function (frame, updateSize, updateOrigin) {
              if (updateSize === void 0) {
                updateSize = true;
              }
              if (updateOrigin === void 0) {
                updateOrigin = true;
              }
              this.frame = this.texture.get(frame);
              if (!this.frame.cutWidth || !this.frame.cutHeight) {
                this.renderFlags &= ~_FLAG;
              } else {
                this.renderFlags |= _FLAG;
              }
              if (this._sizeComponent && updateSize) {
                this.setSizeToFrame();
              }
              if (this._originComponent && updateOrigin) {
                if (this.frame.customPivot) {
                  this.setOrigin(this.frame.pivotX, this.frame.pivotY);
                } else {
                  this.updateDisplayOrigin();
                }
              }
              if (this.isCropped) {
                this.frame.updateCropUVs(this._crop, this.flipX, this.flipY);
              }
              return this;
            },
            resetCropObject: function () {
              return {
                u0: 0,
                v0: 0,
                u1: 0,
                v1: 0,
                width: 0,
                height: 0,
                x: 0,
                y: 0,
                flipX: false,
                flipY: false,
                cx: 0,
                cy: 0,
                cw: 0,
                ch: 0
              };
            }
          };
          module2.exports = TextureCrop;
        }, function (module2, exports2) {
          var Tint = {
            tintTopLeft: 16777215,
            tintTopRight: 16777215,
            tintBottomLeft: 16777215,
            tintBottomRight: 16777215,
            tintFill: false,
            clearTint: function () {
              this.setTint(16777215);
              return this;
            },
            setTint: function (topLeft, topRight, bottomLeft, bottomRight) {
              if (topLeft === void 0) {
                topLeft = 16777215;
              }
              if (topRight === void 0) {
                topRight = topLeft;
                bottomLeft = topLeft;
                bottomRight = topLeft;
              }
              this.tintTopLeft = topLeft;
              this.tintTopRight = topRight;
              this.tintBottomLeft = bottomLeft;
              this.tintBottomRight = bottomRight;
              this.tintFill = false;
              return this;
            },
            setTintFill: function (topLeft, topRight, bottomLeft, bottomRight) {
              this.setTint(topLeft, topRight, bottomLeft, bottomRight);
              this.tintFill = true;
              return this;
            },
            tint: {
              set: function (value) {
                this.setTint(value, value, value, value);
              }
            },
            isTinted: {
              get: function () {
                var white = 16777215;
                return this.tintFill || this.tintTopLeft !== white || this.tintTopRight !== white || this.tintBottomLeft !== white || this.tintBottomRight !== white;
              }
            }
          };
          module2.exports = Tint;
        }, function (module2, exports2) {
          module2.exports = "changedata";
        }, function (module2, exports2) {
          module2.exports = "changedata-";
        }, function (module2, exports2) {
          module2.exports = "destroy";
        }, function (module2, exports2) {
          module2.exports = "removedata";
        }, function (module2, exports2) {
          module2.exports = "setdata";
        }, function (module2, exports2) {
          module2.exports = "addedtoscene";
        }, function (module2, exports2) {
          module2.exports = "destroy";
        }, function (module2, exports2) {
          module2.exports = "removedfromscene";
        }, function (module2, exports2) {
          module2.exports = "complete";
        }, function (module2, exports2) {
          module2.exports = "created";
        }, function (module2, exports2) {
          module2.exports = "error";
        }, function (module2, exports2) {
          module2.exports = "loop";
        }, function (module2, exports2) {
          module2.exports = "play";
        }, function (module2, exports2) {
          module2.exports = "seeked";
        }, function (module2, exports2) {
          module2.exports = "seeking";
        }, function (module2, exports2) {
          module2.exports = "stop";
        }, function (module2, exports2) {
          module2.exports = "timeout";
        }, function (module2, exports2) {
          module2.exports = "unlocked";
        }, function (module2, exports2) {
          module2.exports = "addedtoscene";
        }, function (module2, exports2) {
          module2.exports = "boot";
        }, function (module2, exports2) {
          module2.exports = "create";
        }, function (module2, exports2) {
          module2.exports = "destroy";
        }, function (module2, exports2) {
          module2.exports = "pause";
        }, function (module2, exports2) {
          module2.exports = "postupdate";
        }, function (module2, exports2) {
          module2.exports = "prerender";
        }, function (module2, exports2) {
          module2.exports = "preupdate";
        }, function (module2, exports2) {
          module2.exports = "ready";
        }, function (module2, exports2) {
          module2.exports = "removedfromscene";
        }, function (module2, exports2) {
          module2.exports = "render";
        }, function (module2, exports2) {
          module2.exports = "resume";
        }, function (module2, exports2) {
          module2.exports = "shutdown";
        }, function (module2, exports2) {
          module2.exports = "sleep";
        }, function (module2, exports2) {
          module2.exports = "start";
        }, function (module2, exports2) {
          module2.exports = "transitioncomplete";
        }, function (module2, exports2) {
          module2.exports = "transitioninit";
        }, function (module2, exports2) {
          module2.exports = "transitionout";
        }, function (module2, exports2) {
          module2.exports = "transitionstart";
        }, function (module2, exports2) {
          module2.exports = "transitionwake";
        }, function (module2, exports2) {
          module2.exports = "update";
        }, function (module2, exports2) {
          module2.exports = "wake";
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueInc = __webpack_require__(46);
          var IncAlpha = function (items, value, step, index, direction) {
            return PropertyValueInc(items, "alpha", value, step, index, direction);
          };
          module2.exports = IncAlpha;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueInc = __webpack_require__(46);
          var IncX = function (items, value, step, index, direction) {
            return PropertyValueInc(items, "x", value, step, index, direction);
          };
          module2.exports = IncX;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueInc = __webpack_require__(46);
          var IncXY = function (items, x, y, stepX, stepY, index, direction) {
            if (y === void 0 || y === null) {
              y = x;
            }
            PropertyValueInc(items, "x", x, stepX, index, direction);
            return PropertyValueInc(items, "y", y, stepY, index, direction);
          };
          module2.exports = IncXY;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueInc = __webpack_require__(46);
          var IncY = function (items, value, step, index, direction) {
            return PropertyValueInc(items, "y", value, step, index, direction);
          };
          module2.exports = IncY;
        }, function (module2, exports2) {
          var PlaceOnCircle = function (items, circle, startAngle, endAngle) {
            if (startAngle === void 0) {
              startAngle = 0;
            }
            if (endAngle === void 0) {
              endAngle = 6.28;
            }
            var angle = startAngle;
            var angleStep = (endAngle - startAngle) / items.length;
            for (var i = 0; i < items.length; i++) {
              items[i].x = circle.x + circle.radius * Math.cos(angle);
              items[i].y = circle.y + circle.radius * Math.sin(angle);
              angle += angleStep;
            }
            return items;
          };
          module2.exports = PlaceOnCircle;
        }, function (module2, exports2) {
          var PlaceOnEllipse = function (items, ellipse, startAngle, endAngle) {
            if (startAngle === void 0) {
              startAngle = 0;
            }
            if (endAngle === void 0) {
              endAngle = 6.28;
            }
            var angle = startAngle;
            var angleStep = (endAngle - startAngle) / items.length;
            var a = ellipse.width / 2;
            var b = ellipse.height / 2;
            for (var i = 0; i < items.length; i++) {
              items[i].x = ellipse.x + a * Math.cos(angle);
              items[i].y = ellipse.y + b * Math.sin(angle);
              angle += angleStep;
            }
            return items;
          };
          module2.exports = PlaceOnEllipse;
        }, function (module2, exports2, __webpack_require__) {
          var GetPoints = __webpack_require__(172);
          var PlaceOnLine = function (items, line) {
            var points = GetPoints(line, items.length);
            for (var i = 0; i < items.length; i++) {
              var item = items[i];
              var point = points[i];
              item.x = point.x;
              item.y = point.y;
            }
            return items;
          };
          module2.exports = PlaceOnLine;
        }, function (module2, exports2, __webpack_require__) {
          var MarchingAnts = __webpack_require__(316);
          var RotateLeft = __webpack_require__(178);
          var RotateRight = __webpack_require__(179);
          var PlaceOnRectangle = function (items, rect, shift) {
            if (shift === void 0) {
              shift = 0;
            }
            var points = MarchingAnts(rect, false, items.length);
            if (shift > 0) {
              RotateLeft(points, shift);
            } else if (shift < 0) {
              RotateRight(points, Math.abs(shift));
            }
            for (var i = 0; i < items.length; i++) {
              items[i].x = points[i].x;
              items[i].y = points[i].y;
            }
            return items;
          };
          module2.exports = PlaceOnRectangle;
        }, function (module2, exports2, __webpack_require__) {
          var BresenhamPoints = __webpack_require__(317);
          var PlaceOnTriangle = function (items, triangle, stepRate) {
            var p1 = BresenhamPoints({
              x1: triangle.x1,
              y1: triangle.y1,
              x2: triangle.x2,
              y2: triangle.y2
            }, stepRate);
            var p22 = BresenhamPoints({
              x1: triangle.x2,
              y1: triangle.y2,
              x2: triangle.x3,
              y2: triangle.y3
            }, stepRate);
            var p3 = BresenhamPoints({
              x1: triangle.x3,
              y1: triangle.y3,
              x2: triangle.x1,
              y2: triangle.y1
            }, stepRate);
            p1.pop();
            p22.pop();
            p3.pop();
            p1 = p1.concat(p22, p3);
            var step = p1.length / items.length;
            var p4 = 0;
            for (var i = 0; i < items.length; i++) {
              var item = items[i];
              var point = p1[Math.floor(p4)];
              item.x = point.x;
              item.y = point.y;
              p4 += step;
            }
            return items;
          };
          module2.exports = PlaceOnTriangle;
        }, function (module2, exports2) {
          var PlayAnimation = function (items, key, ignoreIfPlaying) {
            for (var i = 0; i < items.length; i++) {
              var gameObject = items[i];
              if (gameObject.anims) {
                gameObject.anims.play(key, ignoreIfPlaying);
              }
            }
            return items;
          };
          module2.exports = PlayAnimation;
        }, function (module2, exports2, __webpack_require__) {
          var Random = __webpack_require__(170);
          var RandomCircle = function (items, circle) {
            for (var i = 0; i < items.length; i++) {
              Random(circle, items[i]);
            }
            return items;
          };
          module2.exports = RandomCircle;
        }, function (module2, exports2, __webpack_require__) {
          var Random = __webpack_require__(180);
          var RandomEllipse = function (items, ellipse) {
            for (var i = 0; i < items.length; i++) {
              Random(ellipse, items[i]);
            }
            return items;
          };
          module2.exports = RandomEllipse;
        }, function (module2, exports2, __webpack_require__) {
          var Random = __webpack_require__(173);
          var RandomLine = function (items, line) {
            for (var i = 0; i < items.length; i++) {
              Random(line, items[i]);
            }
            return items;
          };
          module2.exports = RandomLine;
        }, function (module2, exports2, __webpack_require__) {
          var Random = __webpack_require__(174);
          var RandomRectangle = function (items, rect) {
            for (var i = 0; i < items.length; i++) {
              Random(rect, items[i]);
            }
            return items;
          };
          module2.exports = RandomRectangle;
        }, function (module2, exports2, __webpack_require__) {
          var Random = __webpack_require__(181);
          var RandomTriangle = function (items, triangle) {
            for (var i = 0; i < items.length; i++) {
              Random(triangle, items[i]);
            }
            return items;
          };
          module2.exports = RandomTriangle;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueInc = __webpack_require__(46);
          var Rotate = function (items, value, step, index, direction) {
            return PropertyValueInc(items, "rotation", value, step, index, direction);
          };
          module2.exports = Rotate;
        }, function (module2, exports2, __webpack_require__) {
          var RotateAroundDistance = __webpack_require__(182);
          var DistanceBetween = __webpack_require__(50);
          var RotateAround = function (items, point, angle) {
            var x = point.x;
            var y = point.y;
            for (var i = 0; i < items.length; i++) {
              var item = items[i];
              RotateAroundDistance(item, x, y, angle, Math.max(1, DistanceBetween(item.x, item.y, x, y)));
            }
            return items;
          };
          module2.exports = RotateAround;
        }, function (module2, exports2, __webpack_require__) {
          var MathRotateAroundDistance = __webpack_require__(182);
          var RotateAroundDistance = function (items, point, angle, distance) {
            var x = point.x;
            var y = point.y;
            if (distance === 0) {
              return items;
            }
            for (var i = 0; i < items.length; i++) {
              MathRotateAroundDistance(items[i], x, y, angle, distance);
            }
            return items;
          };
          module2.exports = RotateAroundDistance;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueInc = __webpack_require__(46);
          var ScaleX = function (items, value, step, index, direction) {
            return PropertyValueInc(items, "scaleX", value, step, index, direction);
          };
          module2.exports = ScaleX;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueInc = __webpack_require__(46);
          var ScaleXY = function (items, scaleX, scaleY, stepX, stepY, index, direction) {
            if (scaleY === void 0 || scaleY === null) {
              scaleY = scaleX;
            }
            PropertyValueInc(items, "scaleX", scaleX, stepX, index, direction);
            return PropertyValueInc(items, "scaleY", scaleY, stepY, index, direction);
          };
          module2.exports = ScaleXY;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueInc = __webpack_require__(46);
          var ScaleY = function (items, value, step, index, direction) {
            return PropertyValueInc(items, "scaleY", value, step, index, direction);
          };
          module2.exports = ScaleY;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueSet = __webpack_require__(27);
          var SetAlpha = function (items, value, step, index, direction) {
            return PropertyValueSet(items, "alpha", value, step, index, direction);
          };
          module2.exports = SetAlpha;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueSet = __webpack_require__(27);
          var SetBlendMode = function (items, value, index, direction) {
            return PropertyValueSet(items, "blendMode", value, 0, index, direction);
          };
          module2.exports = SetBlendMode;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueSet = __webpack_require__(27);
          var SetDepth = function (items, value, step, index, direction) {
            return PropertyValueSet(items, "depth", value, step, index, direction);
          };
          module2.exports = SetDepth;
        }, function (module2, exports2) {
          var SetHitArea = function (items, hitArea, hitAreaCallback) {
            for (var i = 0; i < items.length; i++) {
              items[i].setInteractive(hitArea, hitAreaCallback);
            }
            return items;
          };
          module2.exports = SetHitArea;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueSet = __webpack_require__(27);
          var SetOrigin = function (items, originX, originY, stepX, stepY, index, direction) {
            if (originY === void 0 || originY === null) {
              originY = originX;
            }
            PropertyValueSet(items, "originX", originX, stepX, index, direction);
            PropertyValueSet(items, "originY", originY, stepY, index, direction);
            items.forEach(function (item) {
              item.updateDisplayOrigin();
            });
            return items;
          };
          module2.exports = SetOrigin;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueSet = __webpack_require__(27);
          var SetRotation = function (items, value, step, index, direction) {
            return PropertyValueSet(items, "rotation", value, step, index, direction);
          };
          module2.exports = SetRotation;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueSet = __webpack_require__(27);
          var SetScale = function (items, scaleX, scaleY, stepX, stepY, index, direction) {
            if (scaleY === void 0 || scaleY === null) {
              scaleY = scaleX;
            }
            PropertyValueSet(items, "scaleX", scaleX, stepX, index, direction);
            return PropertyValueSet(items, "scaleY", scaleY, stepY, index, direction);
          };
          module2.exports = SetScale;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueSet = __webpack_require__(27);
          var SetScaleX = function (items, value, step, index, direction) {
            return PropertyValueSet(items, "scaleX", value, step, index, direction);
          };
          module2.exports = SetScaleX;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueSet = __webpack_require__(27);
          var SetScaleY = function (items, value, step, index, direction) {
            return PropertyValueSet(items, "scaleY", value, step, index, direction);
          };
          module2.exports = SetScaleY;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueSet = __webpack_require__(27);
          var SetScrollFactor = function (items, scrollFactorX, scrollFactorY, stepX, stepY, index, direction) {
            if (scrollFactorY === void 0 || scrollFactorY === null) {
              scrollFactorY = scrollFactorX;
            }
            PropertyValueSet(items, "scrollFactorX", scrollFactorX, stepX, index, direction);
            return PropertyValueSet(items, "scrollFactorY", scrollFactorY, stepY, index, direction);
          };
          module2.exports = SetScrollFactor;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueSet = __webpack_require__(27);
          var SetScrollFactorX = function (items, value, step, index, direction) {
            return PropertyValueSet(items, "scrollFactorX", value, step, index, direction);
          };
          module2.exports = SetScrollFactorX;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueSet = __webpack_require__(27);
          var SetScrollFactorY = function (items, value, step, index, direction) {
            return PropertyValueSet(items, "scrollFactorY", value, step, index, direction);
          };
          module2.exports = SetScrollFactorY;
        }, function (module2, exports2) {
          var SetTint = function (items, topLeft, topRight, bottomLeft, bottomRight) {
            for (var i = 0; i < items.length; i++) {
              items[i].setTint(topLeft, topRight, bottomLeft, bottomRight);
            }
            return items;
          };
          module2.exports = SetTint;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueSet = __webpack_require__(27);
          var SetVisible = function (items, value, index, direction) {
            return PropertyValueSet(items, "visible", value, 0, index, direction);
          };
          module2.exports = SetVisible;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueSet = __webpack_require__(27);
          var SetX = function (items, value, step, index, direction) {
            return PropertyValueSet(items, "x", value, step, index, direction);
          };
          module2.exports = SetX;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueSet = __webpack_require__(27);
          var SetXY = function (items, x, y, stepX, stepY, index, direction) {
            if (y === void 0 || y === null) {
              y = x;
            }
            PropertyValueSet(items, "x", x, stepX, index, direction);
            return PropertyValueSet(items, "y", y, stepY, index, direction);
          };
          module2.exports = SetXY;
        }, function (module2, exports2, __webpack_require__) {
          var PropertyValueSet = __webpack_require__(27);
          var SetY = function (items, value, step, index, direction) {
            return PropertyValueSet(items, "y", value, step, index, direction);
          };
          module2.exports = SetY;
        }, function (module2, exports2, __webpack_require__) {
          var Vector2 = __webpack_require__(3);
          var ShiftPosition = function (items, x, y, direction, output) {
            if (direction === void 0) {
              direction = 0;
            }
            if (output === void 0) {
              output = new Vector2();
            }
            var px;
            var py;
            if (items.length > 1) {
              var i;
              var cx;
              var cy;
              var cur;
              if (direction === 0) {
                var len = items.length - 1;
                px = items[len].x;
                py = items[len].y;
                for (i = len - 1; i >= 0; i--) {
                  cur = items[i];
                  cx = cur.x;
                  cy = cur.y;
                  cur.x = px;
                  cur.y = py;
                  px = cx;
                  py = cy;
                }
                items[len].x = x;
                items[len].y = y;
              } else {
                px = items[0].x;
                py = items[0].y;
                for (i = 1; i < items.length; i++) {
                  cur = items[i];
                  cx = cur.x;
                  cy = cur.y;
                  cur.x = px;
                  cur.y = py;
                  px = cx;
                  py = cy;
                }
                items[0].x = x;
                items[0].y = y;
              }
            } else {
              px = items[0].x;
              py = items[0].y;
              items[0].x = x;
              items[0].y = y;
            }
            output.x = px;
            output.y = py;
            return output;
          };
          module2.exports = ShiftPosition;
        }, function (module2, exports2, __webpack_require__) {
          var ArrayShuffle = __webpack_require__(131);
          var Shuffle = function (items) {
            return ArrayShuffle(items);
          };
          module2.exports = Shuffle;
        }, function (module2, exports2, __webpack_require__) {
          var MathSmootherStep = __webpack_require__(183);
          var SmootherStep = function (items, property, min, max, inc) {
            if (inc === void 0) {
              inc = false;
            }
            var step = Math.abs(max - min) / items.length;
            var i;
            if (inc) {
              for (i = 0; i < items.length; i++) {
                items[i][property] += MathSmootherStep(i * step, min, max);
              }
            } else {
              for (i = 0; i < items.length; i++) {
                items[i][property] = MathSmootherStep(i * step, min, max);
              }
            }
            return items;
          };
          module2.exports = SmootherStep;
        }, function (module2, exports2, __webpack_require__) {
          var MathSmoothStep = __webpack_require__(184);
          var SmoothStep = function (items, property, min, max, inc) {
            if (inc === void 0) {
              inc = false;
            }
            var step = Math.abs(max - min) / items.length;
            var i;
            if (inc) {
              for (i = 0; i < items.length; i++) {
                items[i][property] += MathSmoothStep(i * step, min, max);
              }
            } else {
              for (i = 0; i < items.length; i++) {
                items[i][property] = MathSmoothStep(i * step, min, max);
              }
            }
            return items;
          };
          module2.exports = SmoothStep;
        }, function (module2, exports2) {
          var Spread = function (items, property, min, max, inc) {
            if (inc === void 0) {
              inc = false;
            }
            var step = Math.abs(max - min) / items.length;
            var i;
            if (inc) {
              for (i = 0; i < items.length; i++) {
                items[i][property] += i * step + min;
              }
            } else {
              for (i = 0; i < items.length; i++) {
                items[i][property] = i * step + min;
              }
            }
            return items;
          };
          module2.exports = Spread;
        }, function (module2, exports2) {
          var ToggleVisible = function (items) {
            for (var i = 0; i < items.length; i++) {
              items[i].visible = !items[i].visible;
            }
            return items;
          };
          module2.exports = ToggleVisible;
        }, function (module2, exports2, __webpack_require__) {
          var Wrap = __webpack_require__(68);
          var WrapInRectangle = function (items, rect, padding) {
            if (padding === void 0) {
              padding = 0;
            }
            for (var i = 0; i < items.length; i++) {
              var item = items[i];
              item.x = Wrap(item.x, rect.left - padding, rect.right + padding);
              item.y = Wrap(item.y, rect.top - padding, rect.bottom + padding);
            }
            return items;
          };
          module2.exports = WrapInRectangle;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Animation: __webpack_require__(185),
            AnimationFrame: __webpack_require__(319),
            AnimationManager: __webpack_require__(321),
            AnimationState: __webpack_require__(164),
            Events: __webpack_require__(132)
          };
        }, function (module2, exports2) {
          module2.exports = "add";
        }, function (module2, exports2) {
          module2.exports = "animationcomplete";
        }, function (module2, exports2) {
          module2.exports = "animationcomplete-";
        }, function (module2, exports2) {
          module2.exports = "animationrepeat";
        }, function (module2, exports2) {
          module2.exports = "animationrestart";
        }, function (module2, exports2) {
          module2.exports = "animationstart";
        }, function (module2, exports2) {
          module2.exports = "animationstop";
        }, function (module2, exports2) {
          module2.exports = "animationupdate";
        }, function (module2, exports2) {
          module2.exports = "pauseall";
        }, function (module2, exports2) {
          module2.exports = "remove";
        }, function (module2, exports2) {
          module2.exports = "resumeall";
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            BaseCache: __webpack_require__(323),
            CacheManager: __webpack_require__(325),
            Events: __webpack_require__(324)
          };
        }, function (module2, exports2) {
          module2.exports = "add";
        }, function (module2, exports2) {
          module2.exports = "remove";
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Controls: __webpack_require__(739),
            Scene2D: __webpack_require__(742)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            FixedKeyControl: __webpack_require__(740),
            SmoothedKeyControl: __webpack_require__(741)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GetValue = __webpack_require__(6);
          var FixedKeyControl = new Class({
            initialize: function FixedKeyControl2(config) {
              this.camera = GetValue(config, "camera", null);
              this.left = GetValue(config, "left", null);
              this.right = GetValue(config, "right", null);
              this.up = GetValue(config, "up", null);
              this.down = GetValue(config, "down", null);
              this.zoomIn = GetValue(config, "zoomIn", null);
              this.zoomOut = GetValue(config, "zoomOut", null);
              this.zoomSpeed = GetValue(config, "zoomSpeed", 0.01);
              this.minZoom = GetValue(config, "minZoom", 1e-3);
              this.maxZoom = GetValue(config, "maxZoom", 1e3);
              this.speedX = 0;
              this.speedY = 0;
              var speed = GetValue(config, "speed", null);
              if (typeof speed === "number") {
                this.speedX = speed;
                this.speedY = speed;
              } else {
                this.speedX = GetValue(config, "speed.x", 0);
                this.speedY = GetValue(config, "speed.y", 0);
              }
              this._zoom = 0;
              this.active = this.camera !== null;
            },
            start: function () {
              this.active = this.camera !== null;
              return this;
            },
            stop: function () {
              this.active = false;
              return this;
            },
            setCamera: function (camera) {
              this.camera = camera;
              return this;
            },
            update: function (delta) {
              if (!this.active) {
                return;
              }
              if (delta === void 0) {
                delta = 1;
              }
              var cam = this.camera;
              if (this.up && this.up.isDown) {
                cam.scrollY -= this.speedY * delta | 0;
              } else if (this.down && this.down.isDown) {
                cam.scrollY += this.speedY * delta | 0;
              }
              if (this.left && this.left.isDown) {
                cam.scrollX -= this.speedX * delta | 0;
              } else if (this.right && this.right.isDown) {
                cam.scrollX += this.speedX * delta | 0;
              }
              if (this.zoomIn && this.zoomIn.isDown) {
                cam.zoom -= this.zoomSpeed;
                if (cam.zoom < this.minZoom) {
                  cam.zoom = this.minZoom;
                }
              } else if (this.zoomOut && this.zoomOut.isDown) {
                cam.zoom += this.zoomSpeed;
                if (cam.zoom > this.maxZoom) {
                  cam.zoom = this.maxZoom;
                }
              }
            },
            destroy: function () {
              this.camera = null;
              this.left = null;
              this.right = null;
              this.up = null;
              this.down = null;
              this.zoomIn = null;
              this.zoomOut = null;
            }
          });
          module2.exports = FixedKeyControl;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var GetValue = __webpack_require__(6);
          var SmoothedKeyControl = new Class({
            initialize: function SmoothedKeyControl2(config) {
              this.camera = GetValue(config, "camera", null);
              this.left = GetValue(config, "left", null);
              this.right = GetValue(config, "right", null);
              this.up = GetValue(config, "up", null);
              this.down = GetValue(config, "down", null);
              this.zoomIn = GetValue(config, "zoomIn", null);
              this.zoomOut = GetValue(config, "zoomOut", null);
              this.zoomSpeed = GetValue(config, "zoomSpeed", 0.01);
              this.minZoom = GetValue(config, "minZoom", 1e-3);
              this.maxZoom = GetValue(config, "maxZoom", 1e3);
              this.accelX = 0;
              this.accelY = 0;
              var accel = GetValue(config, "acceleration", null);
              if (typeof accel === "number") {
                this.accelX = accel;
                this.accelY = accel;
              } else {
                this.accelX = GetValue(config, "acceleration.x", 0);
                this.accelY = GetValue(config, "acceleration.y", 0);
              }
              this.dragX = 0;
              this.dragY = 0;
              var drag = GetValue(config, "drag", null);
              if (typeof drag === "number") {
                this.dragX = drag;
                this.dragY = drag;
              } else {
                this.dragX = GetValue(config, "drag.x", 0);
                this.dragY = GetValue(config, "drag.y", 0);
              }
              this.maxSpeedX = 0;
              this.maxSpeedY = 0;
              var maxSpeed = GetValue(config, "maxSpeed", null);
              if (typeof maxSpeed === "number") {
                this.maxSpeedX = maxSpeed;
                this.maxSpeedY = maxSpeed;
              } else {
                this.maxSpeedX = GetValue(config, "maxSpeed.x", 0);
                this.maxSpeedY = GetValue(config, "maxSpeed.y", 0);
              }
              this._speedX = 0;
              this._speedY = 0;
              this._zoom = 0;
              this.active = this.camera !== null;
            },
            start: function () {
              this.active = this.camera !== null;
              return this;
            },
            stop: function () {
              this.active = false;
              return this;
            },
            setCamera: function (camera) {
              this.camera = camera;
              return this;
            },
            update: function (delta) {
              if (!this.active) {
                return;
              }
              if (delta === void 0) {
                delta = 1;
              }
              var cam = this.camera;
              if (this._speedX > 0) {
                this._speedX -= this.dragX * delta;
                if (this._speedX < 0) {
                  this._speedX = 0;
                }
              } else if (this._speedX < 0) {
                this._speedX += this.dragX * delta;
                if (this._speedX > 0) {
                  this._speedX = 0;
                }
              }
              if (this._speedY > 0) {
                this._speedY -= this.dragY * delta;
                if (this._speedY < 0) {
                  this._speedY = 0;
                }
              } else if (this._speedY < 0) {
                this._speedY += this.dragY * delta;
                if (this._speedY > 0) {
                  this._speedY = 0;
                }
              }
              if (this.up && this.up.isDown) {
                this._speedY += this.accelY;
                if (this._speedY > this.maxSpeedY) {
                  this._speedY = this.maxSpeedY;
                }
              } else if (this.down && this.down.isDown) {
                this._speedY -= this.accelY;
                if (this._speedY < -this.maxSpeedY) {
                  this._speedY = -this.maxSpeedY;
                }
              }
              if (this.left && this.left.isDown) {
                this._speedX += this.accelX;
                if (this._speedX > this.maxSpeedX) {
                  this._speedX = this.maxSpeedX;
                }
              } else if (this.right && this.right.isDown) {
                this._speedX -= this.accelX;
                if (this._speedX < -this.maxSpeedX) {
                  this._speedX = -this.maxSpeedX;
                }
              }
              if (this.zoomIn && this.zoomIn.isDown) {
                this._zoom = -this.zoomSpeed;
              } else if (this.zoomOut && this.zoomOut.isDown) {
                this._zoom = this.zoomSpeed;
              } else {
                this._zoom = 0;
              }
              if (this._speedX !== 0) {
                cam.scrollX -= this._speedX * delta | 0;
              }
              if (this._speedY !== 0) {
                cam.scrollY -= this._speedY * delta | 0;
              }
              if (this._zoom !== 0) {
                cam.zoom += this._zoom;
                if (cam.zoom < this.minZoom) {
                  cam.zoom = this.minZoom;
                } else if (cam.zoom > this.maxZoom) {
                  cam.zoom = this.maxZoom;
                }
              }
            },
            destroy: function () {
              this.camera = null;
              this.left = null;
              this.right = null;
              this.up = null;
              this.down = null;
              this.zoomIn = null;
              this.zoomOut = null;
            }
          });
          module2.exports = SmoothedKeyControl;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Camera: __webpack_require__(326),
            BaseCamera: __webpack_require__(133),
            CameraManager: __webpack_require__(799),
            Effects: __webpack_require__(333),
            Events: __webpack_require__(37)
          };
        }, function (module2, exports2) {
          module2.exports = "cameradestroy";
        }, function (module2, exports2) {
          module2.exports = "camerafadeincomplete";
        }, function (module2, exports2) {
          module2.exports = "camerafadeinstart";
        }, function (module2, exports2) {
          module2.exports = "camerafadeoutcomplete";
        }, function (module2, exports2) {
          module2.exports = "camerafadeoutstart";
        }, function (module2, exports2) {
          module2.exports = "cameraflashcomplete";
        }, function (module2, exports2) {
          module2.exports = "cameraflashstart";
        }, function (module2, exports2) {
          module2.exports = "followupdate";
        }, function (module2, exports2) {
          module2.exports = "camerapancomplete";
        }, function (module2, exports2) {
          module2.exports = "camerapanstart";
        }, function (module2, exports2) {
          module2.exports = "postrender";
        }, function (module2, exports2) {
          module2.exports = "prerender";
        }, function (module2, exports2) {
          module2.exports = "camerarotatecomplete";
        }, function (module2, exports2) {
          module2.exports = "camerarotatestart";
        }, function (module2, exports2) {
          module2.exports = "camerashakecomplete";
        }, function (module2, exports2) {
          module2.exports = "camerashakestart";
        }, function (module2, exports2) {
          module2.exports = "camerazoomcomplete";
        }, function (module2, exports2) {
          module2.exports = "camerazoomstart";
        }, function (module2, exports2, __webpack_require__) {
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(37);
          var Fade = new Class({
            initialize: function Fade2(camera) {
              this.camera = camera;
              this.isRunning = false;
              this.isComplete = false;
              this.direction = true;
              this.duration = 0;
              this.red = 0;
              this.green = 0;
              this.blue = 0;
              this.alpha = 0;
              this.progress = 0;
              this._elapsed = 0;
              this._onUpdate;
              this._onUpdateScope;
            },
            start: function (direction, duration, red, green, blue, force, callback, context) {
              if (direction === void 0) {
                direction = true;
              }
              if (duration === void 0) {
                duration = 1e3;
              }
              if (red === void 0) {
                red = 0;
              }
              if (green === void 0) {
                green = 0;
              }
              if (blue === void 0) {
                blue = 0;
              }
              if (force === void 0) {
                force = false;
              }
              if (callback === void 0) {
                callback = null;
              }
              if (context === void 0) {
                context = this.camera.scene;
              }
              if (!force && this.isRunning) {
                return this.camera;
              }
              this.isRunning = true;
              this.isComplete = false;
              this.duration = duration;
              this.direction = direction;
              this.progress = 0;
              this.red = red;
              this.green = green;
              this.blue = blue;
              this.alpha = direction ? Number.MIN_VALUE : 1;
              this._elapsed = 0;
              this._onUpdate = callback;
              this._onUpdateScope = context;
              var eventName = direction ? Events.FADE_OUT_START : Events.FADE_IN_START;
              this.camera.emit(eventName, this.camera, this, duration, red, green, blue);
              return this.camera;
            },
            update: function (time, delta) {
              if (!this.isRunning) {
                return;
              }
              this._elapsed += delta;
              this.progress = Clamp(this._elapsed / this.duration, 0, 1);
              if (this._onUpdate) {
                this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
              }
              if (this._elapsed < this.duration) {
                this.alpha = this.direction ? this.progress : 1 - this.progress;
              } else {
                this.alpha = this.direction ? 1 : 0;
                this.effectComplete();
              }
            },
            postRenderCanvas: function (ctx) {
              if (!this.isRunning && !this.isComplete) {
                return false;
              }
              var camera = this.camera;
              ctx.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")";
              ctx.fillRect(camera.x, camera.y, camera.width, camera.height);
              return true;
            },
            postRenderWebGL: function (pipeline, getTintFunction) {
              if (!this.isRunning && !this.isComplete) {
                return false;
              }
              var camera = this.camera;
              var red = this.red / 255;
              var green = this.green / 255;
              var blue = this.blue / 255;
              pipeline.drawFillRect(camera.x, camera.y, camera.width, camera.height, getTintFunction(blue, green, red, 1), this.alpha);
              return true;
            },
            effectComplete: function () {
              this._onUpdate = null;
              this._onUpdateScope = null;
              this.isRunning = false;
              this.isComplete = true;
              var eventName = this.direction ? Events.FADE_OUT_COMPLETE : Events.FADE_IN_COMPLETE;
              this.camera.emit(eventName, this.camera, this);
            },
            reset: function () {
              this.isRunning = false;
              this.isComplete = false;
              this._onUpdate = null;
              this._onUpdateScope = null;
            },
            destroy: function () {
              this.reset();
              this.camera = null;
            }
          });
          module2.exports = Fade;
        }, function (module2, exports2, __webpack_require__) {
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(37);
          var Flash = new Class({
            initialize: function Flash2(camera) {
              this.camera = camera;
              this.isRunning = false;
              this.duration = 0;
              this.red = 0;
              this.green = 0;
              this.blue = 0;
              this.alpha = 0;
              this.progress = 0;
              this._elapsed = 0;
              this._onUpdate;
              this._onUpdateScope;
            },
            start: function (duration, red, green, blue, force, callback, context) {
              if (duration === void 0) {
                duration = 250;
              }
              if (red === void 0) {
                red = 255;
              }
              if (green === void 0) {
                green = 255;
              }
              if (blue === void 0) {
                blue = 255;
              }
              if (force === void 0) {
                force = false;
              }
              if (callback === void 0) {
                callback = null;
              }
              if (context === void 0) {
                context = this.camera.scene;
              }
              if (!force && this.isRunning) {
                return this.camera;
              }
              this.isRunning = true;
              this.duration = duration;
              this.progress = 0;
              this.red = red;
              this.green = green;
              this.blue = blue;
              this.alpha = 1;
              this._elapsed = 0;
              this._onUpdate = callback;
              this._onUpdateScope = context;
              this.camera.emit(Events.FLASH_START, this.camera, this, duration, red, green, blue);
              return this.camera;
            },
            update: function (time, delta) {
              if (!this.isRunning) {
                return;
              }
              this._elapsed += delta;
              this.progress = Clamp(this._elapsed / this.duration, 0, 1);
              if (this._onUpdate) {
                this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
              }
              if (this._elapsed < this.duration) {
                this.alpha = 1 - this.progress;
              } else {
                this.effectComplete();
              }
            },
            postRenderCanvas: function (ctx) {
              if (!this.isRunning) {
                return false;
              }
              var camera = this.camera;
              ctx.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")";
              ctx.fillRect(camera.x, camera.y, camera.width, camera.height);
              return true;
            },
            postRenderWebGL: function (pipeline, getTintFunction) {
              if (!this.isRunning) {
                return false;
              }
              var camera = this.camera;
              var red = this.red / 255;
              var green = this.green / 255;
              var blue = this.blue / 255;
              pipeline.drawFillRect(camera.x, camera.y, camera.width, camera.height, getTintFunction(blue, green, red, 1), this.alpha);
              return true;
            },
            effectComplete: function () {
              this._onUpdate = null;
              this._onUpdateScope = null;
              this.isRunning = false;
              this.camera.emit(Events.FLASH_COMPLETE, this.camera, this);
            },
            reset: function () {
              this.isRunning = false;
              this._onUpdate = null;
              this._onUpdateScope = null;
            },
            destroy: function () {
              this.reset();
              this.camera = null;
            }
          });
          module2.exports = Flash;
        }, function (module2, exports2, __webpack_require__) {
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var EaseMap = __webpack_require__(134);
          var Events = __webpack_require__(37);
          var Vector2 = __webpack_require__(3);
          var Pan = new Class({
            initialize: function Pan2(camera) {
              this.camera = camera;
              this.isRunning = false;
              this.duration = 0;
              this.source = new Vector2();
              this.current = new Vector2();
              this.destination = new Vector2();
              this.ease;
              this.progress = 0;
              this._elapsed = 0;
              this._onUpdate;
              this._onUpdateScope;
            },
            start: function (x, y, duration, ease, force, callback, context) {
              if (duration === void 0) {
                duration = 1e3;
              }
              if (ease === void 0) {
                ease = EaseMap.Linear;
              }
              if (force === void 0) {
                force = false;
              }
              if (callback === void 0) {
                callback = null;
              }
              if (context === void 0) {
                context = this.camera.scene;
              }
              var cam = this.camera;
              if (!force && this.isRunning) {
                return cam;
              }
              this.isRunning = true;
              this.duration = duration;
              this.progress = 0;
              this.source.set(cam.scrollX, cam.scrollY);
              this.destination.set(x, y);
              cam.getScroll(x, y, this.current);
              if (typeof ease === "string" && EaseMap.hasOwnProperty(ease)) {
                this.ease = EaseMap[ease];
              } else if (typeof ease === "function") {
                this.ease = ease;
              }
              this._elapsed = 0;
              this._onUpdate = callback;
              this._onUpdateScope = context;
              this.camera.emit(Events.PAN_START, this.camera, this, duration, x, y);
              return cam;
            },
            update: function (time, delta) {
              if (!this.isRunning) {
                return;
              }
              this._elapsed += delta;
              var progress = Clamp(this._elapsed / this.duration, 0, 1);
              this.progress = progress;
              var cam = this.camera;
              if (this._elapsed < this.duration) {
                var v = this.ease(progress);
                cam.getScroll(this.destination.x, this.destination.y, this.current);
                var x = this.source.x + (this.current.x - this.source.x) * v;
                var y = this.source.y + (this.current.y - this.source.y) * v;
                cam.setScroll(x, y);
                if (this._onUpdate) {
                  this._onUpdate.call(this._onUpdateScope, cam, progress, x, y);
                }
              } else {
                cam.centerOn(this.destination.x, this.destination.y);
                if (this._onUpdate) {
                  this._onUpdate.call(this._onUpdateScope, cam, progress, cam.scrollX, cam.scrollY);
                }
                this.effectComplete();
              }
            },
            effectComplete: function () {
              this._onUpdate = null;
              this._onUpdateScope = null;
              this.isRunning = false;
              this.camera.emit(Events.PAN_COMPLETE, this.camera, this);
            },
            reset: function () {
              this.isRunning = false;
              this._onUpdate = null;
              this._onUpdateScope = null;
            },
            destroy: function () {
              this.reset();
              this.camera = null;
              this.source = null;
              this.destination = null;
            }
          });
          module2.exports = Pan;
        }, function (module2, exports2) {
          var In = function (v, overshoot) {
            if (overshoot === void 0) {
              overshoot = 1.70158;
            }
            return v * v * ((overshoot + 1) * v - overshoot);
          };
          module2.exports = In;
        }, function (module2, exports2) {
          var Out = function (v, overshoot) {
            if (overshoot === void 0) {
              overshoot = 1.70158;
            }
            return --v * v * ((overshoot + 1) * v + overshoot) + 1;
          };
          module2.exports = Out;
        }, function (module2, exports2) {
          var InOut = function (v, overshoot) {
            if (overshoot === void 0) {
              overshoot = 1.70158;
            }
            var s = overshoot * 1.525;
            if ((v *= 2) < 1) {
              return 0.5 * (v * v * ((s + 1) * v - s));
            } else {
              return 0.5 * ((v -= 2) * v * ((s + 1) * v + s) + 2);
            }
          };
          module2.exports = InOut;
        }, function (module2, exports2) {
          var In = function (v) {
            v = 1 - v;
            if (v < 1 / 2.75) {
              return 1 - 7.5625 * v * v;
            } else if (v < 2 / 2.75) {
              return 1 - (7.5625 * (v -= 1.5 / 2.75) * v + 0.75);
            } else if (v < 2.5 / 2.75) {
              return 1 - (7.5625 * (v -= 2.25 / 2.75) * v + 0.9375);
            } else {
              return 1 - (7.5625 * (v -= 2.625 / 2.75) * v + 0.984375);
            }
          };
          module2.exports = In;
        }, function (module2, exports2) {
          var Out = function (v) {
            if (v < 1 / 2.75) {
              return 7.5625 * v * v;
            } else if (v < 2 / 2.75) {
              return 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
            } else if (v < 2.5 / 2.75) {
              return 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
            } else {
              return 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
            }
          };
          module2.exports = Out;
        }, function (module2, exports2) {
          var InOut = function (v) {
            var reverse = false;
            if (v < 0.5) {
              v = 1 - v * 2;
              reverse = true;
            } else {
              v = v * 2 - 1;
            }
            if (v < 1 / 2.75) {
              v = 7.5625 * v * v;
            } else if (v < 2 / 2.75) {
              v = 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
            } else if (v < 2.5 / 2.75) {
              v = 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
            } else {
              v = 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
            }
            if (reverse) {
              return (1 - v) * 0.5;
            } else {
              return v * 0.5 + 0.5;
            }
          };
          module2.exports = InOut;
        }, function (module2, exports2) {
          var In = function (v) {
            return 1 - Math.sqrt(1 - v * v);
          };
          module2.exports = In;
        }, function (module2, exports2) {
          var Out = function (v) {
            return Math.sqrt(1 - --v * v);
          };
          module2.exports = Out;
        }, function (module2, exports2) {
          var InOut = function (v) {
            if ((v *= 2) < 1) {
              return -0.5 * (Math.sqrt(1 - v * v) - 1);
            } else {
              return 0.5 * (Math.sqrt(1 - (v -= 2) * v) + 1);
            }
          };
          module2.exports = InOut;
        }, function (module2, exports2) {
          var In = function (v) {
            return v * v * v;
          };
          module2.exports = In;
        }, function (module2, exports2) {
          var Out = function (v) {
            return --v * v * v + 1;
          };
          module2.exports = Out;
        }, function (module2, exports2) {
          var InOut = function (v) {
            if ((v *= 2) < 1) {
              return 0.5 * v * v * v;
            } else {
              return 0.5 * ((v -= 2) * v * v + 2);
            }
          };
          module2.exports = InOut;
        }, function (module2, exports2) {
          var In = function (v, amplitude, period) {
            if (amplitude === void 0) {
              amplitude = 0.1;
            }
            if (period === void 0) {
              period = 0.1;
            }
            if (v === 0) {
              return 0;
            } else if (v === 1) {
              return 1;
            } else {
              var s = period / 4;
              if (amplitude < 1) {
                amplitude = 1;
              } else {
                s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
              }
              return -(amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
            }
          };
          module2.exports = In;
        }, function (module2, exports2) {
          var Out = function (v, amplitude, period) {
            if (amplitude === void 0) {
              amplitude = 0.1;
            }
            if (period === void 0) {
              period = 0.1;
            }
            if (v === 0) {
              return 0;
            } else if (v === 1) {
              return 1;
            } else {
              var s = period / 4;
              if (amplitude < 1) {
                amplitude = 1;
              } else {
                s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
              }
              return amplitude * Math.pow(2, -10 * v) * Math.sin((v - s) * (2 * Math.PI) / period) + 1;
            }
          };
          module2.exports = Out;
        }, function (module2, exports2) {
          var InOut = function (v, amplitude, period) {
            if (amplitude === void 0) {
              amplitude = 0.1;
            }
            if (period === void 0) {
              period = 0.1;
            }
            if (v === 0) {
              return 0;
            } else if (v === 1) {
              return 1;
            } else {
              var s = period / 4;
              if (amplitude < 1) {
                amplitude = 1;
              } else {
                s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
              }
              if ((v *= 2) < 1) {
                return -0.5 * (amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
              } else {
                return amplitude * Math.pow(2, -10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period) * 0.5 + 1;
              }
            }
          };
          module2.exports = InOut;
        }, function (module2, exports2) {
          var In = function (v) {
            return Math.pow(2, 10 * (v - 1)) - 1e-3;
          };
          module2.exports = In;
        }, function (module2, exports2) {
          var Out = function (v) {
            return 1 - Math.pow(2, -10 * v);
          };
          module2.exports = Out;
        }, function (module2, exports2) {
          var InOut = function (v) {
            if ((v *= 2) < 1) {
              return 0.5 * Math.pow(2, 10 * (v - 1));
            } else {
              return 0.5 * (2 - Math.pow(2, -10 * (v - 1)));
            }
          };
          module2.exports = InOut;
        }, function (module2, exports2) {
          var Linear = function (v) {
            return v;
          };
          module2.exports = Linear;
        }, function (module2, exports2) {
          var In = function (v) {
            return v * v;
          };
          module2.exports = In;
        }, function (module2, exports2) {
          var Out = function (v) {
            return v * (2 - v);
          };
          module2.exports = Out;
        }, function (module2, exports2) {
          var InOut = function (v) {
            if ((v *= 2) < 1) {
              return 0.5 * v * v;
            } else {
              return -0.5 * (--v * (v - 2) - 1);
            }
          };
          module2.exports = InOut;
        }, function (module2, exports2) {
          var In = function (v) {
            return v * v * v * v;
          };
          module2.exports = In;
        }, function (module2, exports2) {
          var Out = function (v) {
            return 1 - --v * v * v * v;
          };
          module2.exports = Out;
        }, function (module2, exports2) {
          var InOut = function (v) {
            if ((v *= 2) < 1) {
              return 0.5 * v * v * v * v;
            } else {
              return -0.5 * ((v -= 2) * v * v * v - 2);
            }
          };
          module2.exports = InOut;
        }, function (module2, exports2) {
          var In = function (v) {
            return v * v * v * v * v;
          };
          module2.exports = In;
        }, function (module2, exports2) {
          var Out = function (v) {
            return --v * v * v * v * v + 1;
          };
          module2.exports = Out;
        }, function (module2, exports2) {
          var InOut = function (v) {
            if ((v *= 2) < 1) {
              return 0.5 * v * v * v * v * v;
            } else {
              return 0.5 * ((v -= 2) * v * v * v * v + 2);
            }
          };
          module2.exports = InOut;
        }, function (module2, exports2) {
          var In = function (v) {
            if (v === 0) {
              return 0;
            } else if (v === 1) {
              return 1;
            } else {
              return 1 - Math.cos(v * Math.PI / 2);
            }
          };
          module2.exports = In;
        }, function (module2, exports2) {
          var Out = function (v) {
            if (v === 0) {
              return 0;
            } else if (v === 1) {
              return 1;
            } else {
              return Math.sin(v * Math.PI / 2);
            }
          };
          module2.exports = Out;
        }, function (module2, exports2) {
          var InOut = function (v) {
            if (v === 0) {
              return 0;
            } else if (v === 1) {
              return 1;
            } else {
              return 0.5 * (1 - Math.cos(Math.PI * v));
            }
          };
          module2.exports = InOut;
        }, function (module2, exports2) {
          var Stepped = function (v, steps) {
            if (steps === void 0) {
              steps = 1;
            }
            if (v <= 0) {
              return 0;
            } else if (v >= 1) {
              return 1;
            } else {
              return ((steps * v | 0) + 1) * (1 / steps);
            }
          };
          module2.exports = Stepped;
        }, function (module2, exports2, __webpack_require__) {
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(37);
          var Vector2 = __webpack_require__(3);
          var Shake = new Class({
            initialize: function Shake2(camera) {
              this.camera = camera;
              this.isRunning = false;
              this.duration = 0;
              this.intensity = new Vector2();
              this.progress = 0;
              this._elapsed = 0;
              this._offsetX = 0;
              this._offsetY = 0;
              this._onUpdate;
              this._onUpdateScope;
            },
            start: function (duration, intensity, force, callback, context) {
              if (duration === void 0) {
                duration = 100;
              }
              if (intensity === void 0) {
                intensity = 0.05;
              }
              if (force === void 0) {
                force = false;
              }
              if (callback === void 0) {
                callback = null;
              }
              if (context === void 0) {
                context = this.camera.scene;
              }
              if (!force && this.isRunning) {
                return this.camera;
              }
              this.isRunning = true;
              this.duration = duration;
              this.progress = 0;
              if (typeof intensity === "number") {
                this.intensity.set(intensity);
              } else {
                this.intensity.set(intensity.x, intensity.y);
              }
              this._elapsed = 0;
              this._offsetX = 0;
              this._offsetY = 0;
              this._onUpdate = callback;
              this._onUpdateScope = context;
              this.camera.emit(Events.SHAKE_START, this.camera, this, duration, intensity);
              return this.camera;
            },
            preRender: function () {
              if (this.isRunning) {
                this.camera.matrix.translate(this._offsetX, this._offsetY);
              }
            },
            update: function (time, delta) {
              if (!this.isRunning) {
                return;
              }
              this._elapsed += delta;
              this.progress = Clamp(this._elapsed / this.duration, 0, 1);
              if (this._onUpdate) {
                this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
              }
              if (this._elapsed < this.duration) {
                var intensity = this.intensity;
                var width = this.camera.width;
                var height = this.camera.height;
                var zoom = this.camera.zoom;
                this._offsetX = (Math.random() * intensity.x * width * 2 - intensity.x * width) * zoom;
                this._offsetY = (Math.random() * intensity.y * height * 2 - intensity.y * height) * zoom;
                if (this.camera.roundPixels) {
                  this._offsetX = Math.round(this._offsetX);
                  this._offsetY = Math.round(this._offsetY);
                }
              } else {
                this.effectComplete();
              }
            },
            effectComplete: function () {
              this._offsetX = 0;
              this._offsetY = 0;
              this._onUpdate = null;
              this._onUpdateScope = null;
              this.isRunning = false;
              this.camera.emit(Events.SHAKE_COMPLETE, this.camera, this);
            },
            reset: function () {
              this.isRunning = false;
              this._offsetX = 0;
              this._offsetY = 0;
              this._onUpdate = null;
              this._onUpdateScope = null;
            },
            destroy: function () {
              this.reset();
              this.camera = null;
              this.intensity = null;
            }
          });
          module2.exports = Shake;
        }, function (module2, exports2, __webpack_require__) {
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(37);
          var EaseMap = __webpack_require__(134);
          var RotateTo = new Class({
            initialize: function RotateTo2(camera) {
              this.camera = camera;
              this.isRunning = false;
              this.duration = 0;
              this.source = 0;
              this.current = 0;
              this.destination = 0;
              this.ease;
              this.progress = 0;
              this._elapsed = 0;
              this._onUpdate;
              this._onUpdateScope;
              this.clockwise = true;
              this.shortestPath = false;
            },
            start: function (radians, shortestPath, duration, ease, force, callback, context) {
              if (duration === void 0) {
                duration = 1e3;
              }
              if (ease === void 0) {
                ease = EaseMap.Linear;
              }
              if (force === void 0) {
                force = false;
              }
              if (callback === void 0) {
                callback = null;
              }
              if (context === void 0) {
                context = this.camera.scene;
              }
              if (shortestPath === void 0) {
                shortestPath = false;
              }
              this.shortestPath = shortestPath;
              var tmpDestination = radians;
              if (radians < 0) {
                tmpDestination = -1 * radians;
                this.clockwise = false;
              } else {
                this.clockwise = true;
              }
              var maxRad = 360 * Math.PI / 180;
              tmpDestination = tmpDestination - Math.floor(tmpDestination / maxRad) * maxRad;
              var cam = this.camera;
              if (!force && this.isRunning) {
                return cam;
              }
              this.isRunning = true;
              this.duration = duration;
              this.progress = 0;
              this.source = cam.rotation;
              this.destination = tmpDestination;
              if (typeof ease === "string" && EaseMap.hasOwnProperty(ease)) {
                this.ease = EaseMap[ease];
              } else if (typeof ease === "function") {
                this.ease = ease;
              }
              this._elapsed = 0;
              this._onUpdate = callback;
              this._onUpdateScope = context;
              if (this.shortestPath) {
                var cwDist = 0;
                var acwDist = 0;
                if (this.destination > this.source) {
                  cwDist = Math.abs(this.destination - this.source);
                } else {
                  cwDist = Math.abs(this.destination + maxRad) - this.source;
                }
                if (this.source > this.destination) {
                  acwDist = Math.abs(this.source - this.destination);
                } else {
                  acwDist = Math.abs(this.source + maxRad) - this.destination;
                }
                if (cwDist < acwDist) {
                  this.clockwise = true;
                } else if (cwDist > acwDist) {
                  this.clockwise = false;
                }
              }
              this.camera.emit(Events.ROTATE_START, this.camera, this, duration, tmpDestination);
              return cam;
            },
            update: function (time, delta) {
              if (!this.isRunning) {
                return;
              }
              this._elapsed += delta;
              var progress = Clamp(this._elapsed / this.duration, 0, 1);
              this.progress = progress;
              var cam = this.camera;
              if (this._elapsed < this.duration) {
                var v = this.ease(progress);
                this.current = cam.rotation;
                var distance = 0;
                var maxRad = 360 * Math.PI / 180;
                var target = this.destination;
                var current = this.current;
                if (this.clockwise === false) {
                  target = this.current;
                  current = this.destination;
                }
                if (target >= current) {
                  distance = Math.abs(target - current);
                } else {
                  distance = Math.abs(target + maxRad) - current;
                }
                var r = 0;
                if (this.clockwise) {
                  r = cam.rotation + distance * v;
                } else {
                  r = cam.rotation - distance * v;
                }
                cam.rotation = r;
                if (this._onUpdate) {
                  this._onUpdate.call(this._onUpdateScope, cam, progress, r);
                }
              } else {
                cam.rotation = this.destination;
                if (this._onUpdate) {
                  this._onUpdate.call(this._onUpdateScope, cam, progress, this.destination);
                }
                this.effectComplete();
              }
            },
            effectComplete: function () {
              this._onUpdate = null;
              this._onUpdateScope = null;
              this.isRunning = false;
              this.camera.emit(Events.ROTATE_COMPLETE, this.camera, this);
            },
            reset: function () {
              this.isRunning = false;
              this._onUpdate = null;
              this._onUpdateScope = null;
            },
            destroy: function () {
              this.reset();
              this.camera = null;
              this.source = null;
              this.destination = null;
            }
          });
          module2.exports = RotateTo;
        }, function (module2, exports2, __webpack_require__) {
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var EaseMap = __webpack_require__(134);
          var Events = __webpack_require__(37);
          var Zoom = new Class({
            initialize: function Zoom2(camera) {
              this.camera = camera;
              this.isRunning = false;
              this.duration = 0;
              this.source = 1;
              this.destination = 1;
              this.ease;
              this.progress = 0;
              this._elapsed = 0;
              this._onUpdate;
              this._onUpdateScope;
            },
            start: function (zoom, duration, ease, force, callback, context) {
              if (duration === void 0) {
                duration = 1e3;
              }
              if (ease === void 0) {
                ease = EaseMap.Linear;
              }
              if (force === void 0) {
                force = false;
              }
              if (callback === void 0) {
                callback = null;
              }
              if (context === void 0) {
                context = this.camera.scene;
              }
              var cam = this.camera;
              if (!force && this.isRunning) {
                return cam;
              }
              this.isRunning = true;
              this.duration = duration;
              this.progress = 0;
              this.source = cam.zoom;
              this.destination = zoom;
              if (typeof ease === "string" && EaseMap.hasOwnProperty(ease)) {
                this.ease = EaseMap[ease];
              } else if (typeof ease === "function") {
                this.ease = ease;
              }
              this._elapsed = 0;
              this._onUpdate = callback;
              this._onUpdateScope = context;
              this.camera.emit(Events.ZOOM_START, this.camera, this, duration, zoom);
              return cam;
            },
            update: function (time, delta) {
              if (!this.isRunning) {
                return;
              }
              this._elapsed += delta;
              this.progress = Clamp(this._elapsed / this.duration, 0, 1);
              if (this._elapsed < this.duration) {
                this.camera.zoom = this.source + (this.destination - this.source) * this.ease(this.progress);
                if (this._onUpdate) {
                  this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.camera.zoom);
                }
              } else {
                this.camera.zoom = this.destination;
                if (this._onUpdate) {
                  this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.destination);
                }
                this.effectComplete();
              }
            },
            effectComplete: function () {
              this._onUpdate = null;
              this._onUpdateScope = null;
              this.isRunning = false;
              this.camera.emit(Events.ZOOM_COMPLETE, this.camera, this);
            },
            reset: function () {
              this.isRunning = false;
              this._onUpdate = null;
              this._onUpdateScope = null;
            },
            destroy: function () {
              this.reset();
              this.camera = null;
            }
          });
          module2.exports = Zoom;
        }, function (module2, exports2, __webpack_require__) {
          var Camera = __webpack_require__(326);
          var Class = __webpack_require__(0);
          var GetFastValue = __webpack_require__(2);
          var PluginCache = __webpack_require__(24);
          var RectangleContains = __webpack_require__(57);
          var ScaleEvents = __webpack_require__(104);
          var SceneEvents = __webpack_require__(20);
          var CameraManager = new Class({
            initialize: function CameraManager2(scene) {
              this.scene = scene;
              this.systems = scene.sys;
              this.roundPixels = scene.sys.game.config.roundPixels;
              this.cameras = [];
              this.main;
              this.default;
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              scene.sys.events.on(SceneEvents.START, this.start, this);
            },
            boot: function () {
              var sys = this.systems;
              if (sys.settings.cameras) {
                this.fromJSON(sys.settings.cameras);
              } else {
                this.add();
              }
              this.main = this.cameras[0];
              this.default = new Camera(0, 0, sys.scale.width, sys.scale.height).setScene(this.scene);
              sys.game.scale.on(ScaleEvents.RESIZE, this.onResize, this);
              this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            start: function () {
              if (!this.main) {
                var sys = this.systems;
                if (sys.settings.cameras) {
                  this.fromJSON(sys.settings.cameras);
                } else {
                  this.add();
                }
                this.main = this.cameras[0];
              }
              var eventEmitter = this.systems.events;
              eventEmitter.on(SceneEvents.UPDATE, this.update, this);
              eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            add: function (x, y, width, height, makeMain, name) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = this.scene.sys.scale.width;
              }
              if (height === void 0) {
                height = this.scene.sys.scale.height;
              }
              if (makeMain === void 0) {
                makeMain = false;
              }
              if (name === void 0) {
                name = "";
              }
              var camera = new Camera(x, y, width, height);
              camera.setName(name);
              camera.setScene(this.scene);
              camera.setRoundPixels(this.roundPixels);
              camera.id = this.getNextID();
              this.cameras.push(camera);
              if (makeMain) {
                this.main = camera;
              }
              return camera;
            },
            addExisting: function (camera, makeMain) {
              if (makeMain === void 0) {
                makeMain = false;
              }
              var index = this.cameras.indexOf(camera);
              if (index === -1) {
                camera.id = this.getNextID();
                camera.setRoundPixels(this.roundPixels);
                this.cameras.push(camera);
                if (makeMain) {
                  this.main = camera;
                }
                return camera;
              }
              return null;
            },
            getNextID: function () {
              var cameras = this.cameras;
              var testID = 1;
              for (var t = 0; t < 32; t++) {
                var found = false;
                for (var i = 0; i < cameras.length; i++) {
                  var camera = cameras[i];
                  if (camera && camera.id === testID) {
                    found = true;
                    continue;
                  }
                }
                if (found) {
                  testID = testID << 1;
                } else {
                  return testID;
                }
              }
              return 0;
            },
            getTotal: function (isVisible) {
              if (isVisible === void 0) {
                isVisible = false;
              }
              var total = 0;
              var cameras = this.cameras;
              for (var i = 0; i < cameras.length; i++) {
                var camera = cameras[i];
                if (!isVisible || isVisible && camera.visible) {
                  total++;
                }
              }
              return total;
            },
            fromJSON: function (config) {
              if (!Array.isArray(config)) {
                config = [config];
              }
              var gameWidth = this.scene.sys.scale.width;
              var gameHeight = this.scene.sys.scale.height;
              for (var i = 0; i < config.length; i++) {
                var cameraConfig = config[i];
                var x = GetFastValue(cameraConfig, "x", 0);
                var y = GetFastValue(cameraConfig, "y", 0);
                var width = GetFastValue(cameraConfig, "width", gameWidth);
                var height = GetFastValue(cameraConfig, "height", gameHeight);
                var camera = this.add(x, y, width, height);
                camera.name = GetFastValue(cameraConfig, "name", "");
                camera.zoom = GetFastValue(cameraConfig, "zoom", 1);
                camera.rotation = GetFastValue(cameraConfig, "rotation", 0);
                camera.scrollX = GetFastValue(cameraConfig, "scrollX", 0);
                camera.scrollY = GetFastValue(cameraConfig, "scrollY", 0);
                camera.roundPixels = GetFastValue(cameraConfig, "roundPixels", false);
                camera.visible = GetFastValue(cameraConfig, "visible", true);
                var backgroundColor = GetFastValue(cameraConfig, "backgroundColor", false);
                if (backgroundColor) {
                  camera.setBackgroundColor(backgroundColor);
                }
                var boundsConfig = GetFastValue(cameraConfig, "bounds", null);
                if (boundsConfig) {
                  var bx = GetFastValue(boundsConfig, "x", 0);
                  var by = GetFastValue(boundsConfig, "y", 0);
                  var bwidth = GetFastValue(boundsConfig, "width", gameWidth);
                  var bheight = GetFastValue(boundsConfig, "height", gameHeight);
                  camera.setBounds(bx, by, bwidth, bheight);
                }
              }
              return this;
            },
            getCamera: function (name) {
              var cameras = this.cameras;
              for (var i = 0; i < cameras.length; i++) {
                if (cameras[i].name === name) {
                  return cameras[i];
                }
              }
              return null;
            },
            getCamerasBelowPointer: function (pointer) {
              var cameras = this.cameras;
              var x = pointer.x;
              var y = pointer.y;
              var output = [];
              for (var i = 0; i < cameras.length; i++) {
                var camera = cameras[i];
                if (camera.visible && camera.inputEnabled && RectangleContains(camera, x, y)) {
                  output.unshift(camera);
                }
              }
              return output;
            },
            remove: function (camera, runDestroy) {
              if (runDestroy === void 0) {
                runDestroy = true;
              }
              if (!Array.isArray(camera)) {
                camera = [camera];
              }
              var total = 0;
              var cameras = this.cameras;
              for (var i = 0; i < camera.length; i++) {
                var index = cameras.indexOf(camera[i]);
                if (index !== -1) {
                  if (runDestroy) {
                    cameras[index].destroy();
                  } else {
                    cameras[index].renderList = [];
                  }
                  cameras.splice(index, 1);
                  total++;
                }
              }
              if (!this.main && cameras[0]) {
                this.main = cameras[0];
              }
              return total;
            },
            render: function (renderer, displayList) {
              var scene = this.scene;
              var cameras = this.cameras;
              for (var i = 0; i < this.cameras.length; i++) {
                var camera = cameras[i];
                if (camera.visible && camera.alpha > 0) {
                  camera.preRender();
                  var visibleChildren = this.getVisibleChildren(displayList.getChildren(), camera);
                  renderer.render(scene, visibleChildren, camera);
                }
              }
            },
            getVisibleChildren: function (children, camera) {
              var visible = [];
              for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (child.willRender(camera)) {
                  visible.push(child);
                }
              }
              return visible;
            },
            resetAll: function () {
              for (var i = 0; i < this.cameras.length; i++) {
                this.cameras[i].destroy();
              }
              this.cameras = [];
              this.main = this.add();
              return this.main;
            },
            update: function (time, delta) {
              for (var i = 0; i < this.cameras.length; i++) {
                this.cameras[i].update(time, delta);
              }
            },
            onResize: function (gameSize, baseSize, displaySize, previousWidth, previousHeight) {
              for (var i = 0; i < this.cameras.length; i++) {
                var cam = this.cameras[i];
                if (cam._x === 0 && cam._y === 0 && cam._width === previousWidth && cam._height === previousHeight) {
                  cam.setSize(baseSize.width, baseSize.height);
                }
              }
            },
            resize: function (width, height) {
              for (var i = 0; i < this.cameras.length; i++) {
                this.cameras[i].setSize(width, height);
              }
            },
            shutdown: function () {
              this.main = void 0;
              for (var i = 0; i < this.cameras.length; i++) {
                this.cameras[i].destroy();
              }
              this.cameras = [];
              var eventEmitter = this.systems.events;
              eventEmitter.off(SceneEvents.UPDATE, this.update, this);
              eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function () {
              this.shutdown();
              this.default.destroy();
              this.scene.sys.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
            }
          });
          PluginCache.register("CameraManager", CameraManager, "cameras");
          module2.exports = CameraManager;
        }, function (module2, exports2) {
          module2.exports = "enterfullscreen";
        }, function (module2, exports2) {
          module2.exports = "fullscreenfailed";
        }, function (module2, exports2) {
          module2.exports = "fullscreenunsupported";
        }, function (module2, exports2) {
          module2.exports = "leavefullscreen";
        }, function (module2, exports2) {
          module2.exports = "orientationchange";
        }, function (module2, exports2) {
          module2.exports = "resize";
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Config: __webpack_require__(346),
            CreateRenderer: __webpack_require__(366),
            DebugHeader: __webpack_require__(384),
            Events: __webpack_require__(22),
            TimeStep: __webpack_require__(385),
            VisibilityHandler: __webpack_require__(387)
          };
        }, function (module2, exports2) {
          var process2 = module2.exports = {};
          var cachedSetTimeout;
          var cachedClearTimeout;
          function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
          }
          function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
          }
          (function () {
            try {
              if (typeof setTimeout === "function") {
                cachedSetTimeout = setTimeout;
              } else {
                cachedSetTimeout = defaultSetTimout;
              }
            } catch (e) {
              cachedSetTimeout = defaultSetTimout;
            }
            try {
              if (typeof clearTimeout === "function") {
                cachedClearTimeout = clearTimeout;
              } else {
                cachedClearTimeout = defaultClearTimeout;
              }
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout;
            }
          })();
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              return setTimeout(fun, 0);
            }
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
              cachedSetTimeout = setTimeout;
              return setTimeout(fun, 0);
            }
            try {
              return cachedSetTimeout(fun, 0);
            } catch (e) {
              try {
                return cachedSetTimeout.call(null, fun, 0);
              } catch (e2) {
                return cachedSetTimeout.call(this, fun, 0);
              }
            }
          }
          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              return clearTimeout(marker);
            }
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
              cachedClearTimeout = clearTimeout;
              return clearTimeout(marker);
            }
            try {
              return cachedClearTimeout(marker);
            } catch (e) {
              try {
                return cachedClearTimeout.call(null, marker);
              } catch (e2) {
                return cachedClearTimeout.call(this, marker);
              }
            }
          }
          var queue = [];
          var draining = false;
          var currentQueue;
          var queueIndex = -1;
          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return;
            }
            draining = false;
            if (currentQueue.length) {
              queue = currentQueue.concat(queue);
            } else {
              queueIndex = -1;
            }
            if (queue.length) {
              drainQueue();
            }
          }
          function drainQueue() {
            if (draining) {
              return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
              currentQueue = queue;
              queue = [];
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run();
                }
              }
              queueIndex = -1;
              len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
          }
          process2.nextTick = function (fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
              for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
              }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
              runTimeout(drainQueue);
            }
          };
          function Item(fun, array) {
            this.fun = fun;
            this.array = array;
          }
          Item.prototype.run = function () {
            this.fun.apply(null, this.array);
          };
          process2.title = "browser";
          process2.browser = true;
          process2.env = {};
          process2.argv = [];
          process2.version = "";
          process2.versions = {};
          function noop() {}
          process2.on = noop;
          process2.addListener = noop;
          process2.once = noop;
          process2.off = noop;
          process2.removeListener = noop;
          process2.removeAllListeners = noop;
          process2.emit = noop;
          process2.prependListener = noop;
          process2.prependOnceListener = noop;
          process2.listeners = function (name) {
            return [];
          };
          process2.binding = function (name) {
            throw new Error("process.binding is not supported");
          };
          process2.cwd = function () {
            return "/";
          };
          process2.chdir = function (dir) {
            throw new Error("process.chdir is not supported");
          };
          process2.umask = function () {
            return 0;
          };
        }, function (module2, exports2, __webpack_require__) {
          var Browser = __webpack_require__(136);
          var Input = {
            gamepads: false,
            mspointer: false,
            touch: false,
            wheelEvent: null
          };
          function init() {
            if (typeof importScripts === "function") {
              return Input;
            }
            if (("ontouchstart" in document.documentElement) || navigator.maxTouchPoints && navigator.maxTouchPoints >= 1) {
              Input.touch = true;
            }
            if (navigator.msPointerEnabled || navigator.pointerEnabled) {
              Input.mspointer = true;
            }
            if (navigator.getGamepads) {
              Input.gamepads = true;
            }
            if (("onwheel" in window) || Browser.ie && ("WheelEvent" in window)) {
              Input.wheelEvent = "wheel";
            } else if (("onmousewheel" in window)) {
              Input.wheelEvent = "mousewheel";
            } else if (Browser.firefox && ("MouseScrollEvent" in window)) {
              Input.wheelEvent = "DOMMouseScroll";
            }
            return Input;
          }
          module2.exports = init();
        }, function (module2, exports2, __webpack_require__) {
          var Browser = __webpack_require__(136);
          var Audio2 = {
            audioData: false,
            dolby: false,
            m4a: false,
            mp3: false,
            ogg: false,
            opus: false,
            wav: false,
            webAudio: false,
            webm: false
          };
          function init() {
            if (typeof importScripts === "function") {
              return Audio2;
            }
            Audio2.audioData = !!window["Audio"];
            Audio2.webAudio = !!(window["AudioContext"] || window["webkitAudioContext"]);
            var audioElement = document.createElement("audio");
            var result = !!audioElement.canPlayType;
            try {
              if (result) {
                if (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "")) {
                  Audio2.ogg = true;
                }
                if (audioElement.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || audioElement.canPlayType("audio/opus;").replace(/^no$/, "")) {
                  Audio2.opus = true;
                }
                if (audioElement.canPlayType("audio/mpeg;").replace(/^no$/, "")) {
                  Audio2.mp3 = true;
                }
                if (audioElement.canPlayType("audio/wav").replace(/^no$/, "")) {
                  Audio2.wav = true;
                }
                if (audioElement.canPlayType("audio/x-m4a;") || audioElement.canPlayType("audio/aac;").replace(/^no$/, "")) {
                  Audio2.m4a = true;
                }
                if (audioElement.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")) {
                  Audio2.webm = true;
                }
                if (audioElement.canPlayType('audio/mp4;codecs="ec-3"') !== "") {
                  if (Browser.edge) {
                    Audio2.dolby = true;
                  } else if (Browser.safari && Browser.safariVersion >= 9) {
                    if ((/Mac OS X (\d+)_(\d+)/).test(navigator.userAgent)) {
                      var major = parseInt(RegExp.$1, 10);
                      var minor = parseInt(RegExp.$2, 10);
                      if (major === 10 && minor >= 11 || major > 10) {
                        Audio2.dolby = true;
                      }
                    }
                  }
                }
              }
            } catch (e) {}
            return Audio2;
          }
          module2.exports = init();
        }, function (module2, exports2) {
          var Video = {
            h264: false,
            hls: false,
            mp4: false,
            ogg: false,
            vp9: false,
            webm: false
          };
          function init() {
            if (typeof importScripts === "function") {
              return Video;
            }
            var videoElement = document.createElement("video");
            var result = !!videoElement.canPlayType;
            try {
              if (result) {
                if (videoElement.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "")) {
                  Video.ogg = true;
                }
                if (videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "")) {
                  Video.h264 = true;
                  Video.mp4 = true;
                }
                if (videoElement.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "")) {
                  Video.webm = true;
                }
                if (videoElement.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "")) {
                  Video.vp9 = true;
                }
                if (videoElement.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "")) {
                  Video.hls = true;
                }
              }
            } catch (e) {}
            return Video;
          }
          module2.exports = init();
        }, function (module2, exports2) {
          var Fullscreen = {
            available: false,
            cancel: "",
            keyboard: false,
            request: ""
          };
          function init() {
            if (typeof importScripts === "function") {
              return Fullscreen;
            }
            var i;
            var suffix1 = "Fullscreen";
            var suffix2 = "FullScreen";
            var fs = ["request" + suffix1, "request" + suffix2, "webkitRequest" + suffix1, "webkitRequest" + suffix2, "msRequest" + suffix1, "msRequest" + suffix2, "mozRequest" + suffix2, "mozRequest" + suffix1];
            for (i = 0; i < fs.length; i++) {
              if (document.documentElement[fs[i]]) {
                Fullscreen.available = true;
                Fullscreen.request = fs[i];
                break;
              }
            }
            var cfs = ["cancel" + suffix2, "exit" + suffix1, "webkitCancel" + suffix2, "webkitExit" + suffix1, "msCancel" + suffix2, "msExit" + suffix1, "mozCancel" + suffix2, "mozExit" + suffix1];
            if (Fullscreen.available) {
              for (i = 0; i < cfs.length; i++) {
                if (document[cfs[i]]) {
                  Fullscreen.cancel = cfs[i];
                  break;
                }
              }
            }
            if (window["Element"] && Element["ALLOW_KEYBOARD_INPUT"] && !(/ Version\/5\.1(?:\.\d+)? Safari\//).test(navigator.userAgent)) {
              Fullscreen.keyboard = true;
            }
            Object.defineProperty(Fullscreen, "active", {
              get: function () {
                return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
              }
            });
            return Fullscreen;
          }
          module2.exports = init();
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Between: __webpack_require__(349),
            BetweenPoints: __webpack_require__(350),
            BetweenPointsY: __webpack_require__(813),
            BetweenY: __webpack_require__(814),
            CounterClockwise: __webpack_require__(815),
            Normalize: __webpack_require__(351),
            Random: __webpack_require__(816),
            RandomDegrees: __webpack_require__(817),
            Reverse: __webpack_require__(818),
            RotateTo: __webpack_require__(819),
            ShortestBetween: __webpack_require__(820),
            Wrap: __webpack_require__(269),
            WrapDegrees: __webpack_require__(270)
          };
        }, function (module2, exports2) {
          var BetweenPointsY = function (point1, point2) {
            return Math.atan2(point2.x - point1.x, point2.y - point1.y);
          };
          module2.exports = BetweenPointsY;
        }, function (module2, exports2) {
          var BetweenY = function (x1, y1, x2, y2) {
            return Math.atan2(x2 - x1, y2 - y1);
          };
          module2.exports = BetweenY;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(14);
          var CounterClockwise = function (angle) {
            if (angle > Math.PI) {
              angle -= CONST.PI2;
            }
            return Math.abs(((angle + CONST.TAU) % CONST.PI2 - CONST.PI2) % CONST.PI2);
          };
          module2.exports = CounterClockwise;
        }, function (module2, exports2, __webpack_require__) {
          var FloatBetween = __webpack_require__(137);
          var Random = function () {
            return FloatBetween(-Math.PI, Math.PI);
          };
          module2.exports = Random;
        }, function (module2, exports2, __webpack_require__) {
          var FloatBetween = __webpack_require__(137);
          var RandomDegrees = function () {
            return FloatBetween(-180, 180);
          };
          module2.exports = RandomDegrees;
        }, function (module2, exports2, __webpack_require__) {
          var Normalize = __webpack_require__(351);
          var Reverse = function (angle) {
            return Normalize(angle + Math.PI);
          };
          module2.exports = Reverse;
        }, function (module2, exports2, __webpack_require__) {
          var MATH_CONST = __webpack_require__(14);
          var RotateTo = function (currentAngle, targetAngle, lerp) {
            if (lerp === void 0) {
              lerp = 0.05;
            }
            if (currentAngle === targetAngle) {
              return currentAngle;
            }
            if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= MATH_CONST.PI2 - lerp) {
              currentAngle = targetAngle;
            } else {
              if (Math.abs(targetAngle - currentAngle) > Math.PI) {
                if (targetAngle < currentAngle) {
                  targetAngle += MATH_CONST.PI2;
                } else {
                  targetAngle -= MATH_CONST.PI2;
                }
              }
              if (targetAngle > currentAngle) {
                currentAngle += lerp;
              } else if (targetAngle < currentAngle) {
                currentAngle -= lerp;
              }
            }
            return currentAngle;
          };
          module2.exports = RotateTo;
        }, function (module2, exports2) {
          var ShortestBetween = function (angle1, angle2) {
            var difference = angle2 - angle1;
            if (difference === 0) {
              return 0;
            }
            var times = Math.floor((difference - -180) / 360);
            return difference - times * 360;
          };
          module2.exports = ShortestBetween;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Between: __webpack_require__(50),
            BetweenPoints: __webpack_require__(352),
            BetweenPointsSquared: __webpack_require__(822),
            Chebyshev: __webpack_require__(823),
            Power: __webpack_require__(824),
            Snake: __webpack_require__(825),
            Squared: __webpack_require__(353)
          };
        }, function (module2, exports2) {
          var DistanceBetweenPointsSquared = function (a, b) {
            var dx = a.x - b.x;
            var dy = a.y - b.y;
            return dx * dx + dy * dy;
          };
          module2.exports = DistanceBetweenPointsSquared;
        }, function (module2, exports2) {
          var ChebyshevDistance = function (x1, y1, x2, y2) {
            return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));
          };
          module2.exports = ChebyshevDistance;
        }, function (module2, exports2) {
          var DistancePower = function (x1, y1, x2, y2, pow) {
            if (pow === void 0) {
              pow = 2;
            }
            return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));
          };
          module2.exports = DistancePower;
        }, function (module2, exports2) {
          var SnakeDistance = function (x1, y1, x2, y2) {
            return Math.abs(x1 - x2) + Math.abs(y1 - y2);
          };
          module2.exports = SnakeDistance;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Back: __webpack_require__(334),
            Bounce: __webpack_require__(335),
            Circular: __webpack_require__(336),
            Cubic: __webpack_require__(337),
            Elastic: __webpack_require__(338),
            Expo: __webpack_require__(339),
            Linear: __webpack_require__(340),
            Quadratic: __webpack_require__(341),
            Quartic: __webpack_require__(342),
            Quintic: __webpack_require__(343),
            Sine: __webpack_require__(344),
            Stepped: __webpack_require__(345)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Ceil: __webpack_require__(828),
            Equal: __webpack_require__(124),
            Floor: __webpack_require__(829),
            GreaterThan: __webpack_require__(354),
            LessThan: __webpack_require__(355)
          };
        }, function (module2, exports2) {
          var Ceil = function (value, epsilon) {
            if (epsilon === void 0) {
              epsilon = 1e-4;
            }
            return Math.ceil(value - epsilon);
          };
          module2.exports = Ceil;
        }, function (module2, exports2) {
          var Floor = function (value, epsilon) {
            if (epsilon === void 0) {
              epsilon = 1e-4;
            }
            return Math.floor(value + epsilon);
          };
          module2.exports = Floor;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Bezier: __webpack_require__(831),
            CatmullRom: __webpack_require__(832),
            CubicBezier: __webpack_require__(358),
            Linear: __webpack_require__(833),
            QuadraticBezier: __webpack_require__(359),
            SmoothStep: __webpack_require__(360),
            SmootherStep: __webpack_require__(834)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Bernstein = __webpack_require__(356);
          var BezierInterpolation = function (v, k) {
            var b = 0;
            var n = v.length - 1;
            for (var i = 0; i <= n; i++) {
              b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Bernstein(n, i);
            }
            return b;
          };
          module2.exports = BezierInterpolation;
        }, function (module2, exports2, __webpack_require__) {
          var CatmullRom = __webpack_require__(194);
          var CatmullRomInterpolation = function (v, k) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor(f);
            if (v[0] === v[m]) {
              if (k < 0) {
                i = Math.floor(f = m * (1 + k));
              }
              return CatmullRom(f - i, v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m]);
            } else {
              if (k < 0) {
                return v[0] - (CatmullRom(-f, v[0], v[0], v[1], v[1]) - v[0]);
              }
              if (k > 1) {
                return v[m] - (CatmullRom(f - m, v[m], v[m], v[m - 1], v[m - 1]) - v[m]);
              }
              return CatmullRom(f - i, v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2]);
            }
          };
          module2.exports = CatmullRomInterpolation;
        }, function (module2, exports2, __webpack_require__) {
          var Linear = __webpack_require__(135);
          var LinearInterpolation = function (v, k) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor(f);
            if (k < 0) {
              return Linear(v[0], v[1], f);
            } else if (k > 1) {
              return Linear(v[m], v[m - 1], m - f);
            } else {
              return Linear(v[i], v[i + 1 > m ? m : i + 1], f - i);
            }
          };
          module2.exports = LinearInterpolation;
        }, function (module2, exports2, __webpack_require__) {
          var SmootherStep = __webpack_require__(183);
          var SmootherStepInterpolation = function (t, min, max) {
            return min + (max - min) * SmootherStep(t, 0, 1);
          };
          module2.exports = SmootherStepInterpolation;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            GetNext: __webpack_require__(361),
            IsSize: __webpack_require__(138),
            IsValue: __webpack_require__(836)
          };
        }, function (module2, exports2) {
          var IsValuePowerOfTwo = function (value) {
            return value > 0 && (value & value - 1) === 0;
          };
          module2.exports = IsValuePowerOfTwo;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Ceil: __webpack_require__(139),
            Floor: __webpack_require__(76),
            To: __webpack_require__(838)
          };
        }, function (module2, exports2) {
          var SnapTo = function (value, gap, start, divide) {
            if (start === void 0) {
              start = 0;
            }
            if (gap === 0) {
              return value;
            }
            value -= start;
            value = gap * Math.round(value / gap);
            return divide ? (start + value) / gap : start + value;
          };
          module2.exports = SnapTo;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var RandomDataGenerator = new Class({
            initialize: function RandomDataGenerator2(seeds) {
              if (seeds === void 0) {
                seeds = [(Date.now() * Math.random()).toString()];
              }
              this.c = 1;
              this.s0 = 0;
              this.s1 = 0;
              this.s2 = 0;
              this.n = 0;
              this.signs = [-1, 1];
              if (seeds) {
                this.init(seeds);
              }
            },
            rnd: function () {
              var t = 2091639 * this.s0 + this.c * 23283064365386963e-26;
              this.c = t | 0;
              this.s0 = this.s1;
              this.s1 = this.s2;
              this.s2 = t - this.c;
              return this.s2;
            },
            hash: function (data) {
              var h;
              var n = this.n;
              data = data.toString();
              for (var i = 0; i < data.length; i++) {
                n += data.charCodeAt(i);
                h = 0.02519603282416938 * n;
                n = h >>> 0;
                h -= n;
                h *= n;
                n = h >>> 0;
                h -= n;
                n += h * 4294967296;
              }
              this.n = n;
              return (n >>> 0) * 23283064365386963e-26;
            },
            init: function (seeds) {
              if (typeof seeds === "string") {
                this.state(seeds);
              } else {
                this.sow(seeds);
              }
            },
            sow: function (seeds) {
              this.n = 4022871197;
              this.s0 = this.hash(" ");
              this.s1 = this.hash(" ");
              this.s2 = this.hash(" ");
              this.c = 1;
              if (!seeds) {
                return;
              }
              for (var i = 0; i < seeds.length && seeds[i] != null; i++) {
                var seed = seeds[i];
                this.s0 -= this.hash(seed);
                this.s0 += ~~(this.s0 < 0);
                this.s1 -= this.hash(seed);
                this.s1 += ~~(this.s1 < 0);
                this.s2 -= this.hash(seed);
                this.s2 += ~~(this.s2 < 0);
              }
            },
            integer: function () {
              return this.rnd() * 4294967296;
            },
            frac: function () {
              return this.rnd() + (this.rnd() * 2097152 | 0) * 11102230246251565e-32;
            },
            real: function () {
              return this.integer() + this.frac();
            },
            integerInRange: function (min, max) {
              return Math.floor(this.realInRange(0, max - min + 1) + min);
            },
            between: function (min, max) {
              return Math.floor(this.realInRange(0, max - min + 1) + min);
            },
            realInRange: function (min, max) {
              return this.frac() * (max - min) + min;
            },
            normal: function () {
              return 1 - 2 * this.frac();
            },
            uuid: function () {
              var a = "";
              var b = "";
              for (b = a = ""; a++ < 36; b += ~a % 5 | a * 3 & 4 ? (a ^ 15 ? 8 ^ this.frac() * (a ^ 20 ? 16 : 4) : 4).toString(16) : "-") {}
              return b;
            },
            pick: function (array) {
              return array[this.integerInRange(0, array.length - 1)];
            },
            sign: function () {
              return this.pick(this.signs);
            },
            weightedPick: function (array) {
              return array[~~(Math.pow(this.frac(), 2) * (array.length - 1) + 0.5)];
            },
            timestamp: function (min, max) {
              return this.realInRange(min || 9466848e5, max || 1577862e6);
            },
            angle: function () {
              return this.integerInRange(-180, 180);
            },
            rotation: function () {
              return this.realInRange(-3.1415926, 3.1415926);
            },
            state: function (state) {
              if (typeof state === "string" && state.match(/^!rnd/)) {
                state = state.split(",");
                this.c = parseFloat(state[1]);
                this.s0 = parseFloat(state[2]);
                this.s1 = parseFloat(state[3]);
                this.s2 = parseFloat(state[4]);
              }
              return ["!rnd", this.c, this.s0, this.s1, this.s2].join(",");
            },
            shuffle: function (array) {
              var len = array.length - 1;
              for (var i = len; i > 0; i--) {
                var randomIndex = Math.floor(this.frac() * (i + 1));
                var itemAtIndex = array[randomIndex];
                array[randomIndex] = array[i];
                array[i] = itemAtIndex;
              }
              return array;
            }
          });
          module2.exports = RandomDataGenerator;
        }, function (module2, exports2) {
          var Average = function (values) {
            var sum = 0;
            for (var i = 0; i < values.length; i++) {
              sum += +values[i];
            }
            return sum / values.length;
          };
          module2.exports = Average;
        }, function (module2, exports2) {
          var CeilTo = function (value, place, base) {
            if (place === void 0) {
              place = 0;
            }
            if (base === void 0) {
              base = 10;
            }
            var p3 = Math.pow(base, -place);
            return Math.ceil(value * p3) / p3;
          };
          module2.exports = CeilTo;
        }, function (module2, exports2) {
          var Difference = function (a, b) {
            return Math.abs(a - b);
          };
          module2.exports = Difference;
        }, function (module2, exports2, __webpack_require__) {
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var Matrix4 = __webpack_require__(69);
          var NOOP = __webpack_require__(1);
          var tempMatrix = new Matrix4();
          var Euler = new Class({
            initialize: function Euler2(x, y, z, order) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (z === void 0) {
                z = 0;
              }
              if (order === void 0) {
                order = Euler2.DefaultOrder;
              }
              this._x = x;
              this._y = y;
              this._z = z;
              this._order = order;
              this.onChangeCallback = NOOP;
            },
            x: {
              get: function () {
                return this._x;
              },
              set: function (value) {
                this._x = value;
                this.onChangeCallback(this);
              }
            },
            y: {
              get: function () {
                return this._y;
              },
              set: function (value) {
                this._y = value;
                this.onChangeCallback(this);
              }
            },
            z: {
              get: function () {
                return this._z;
              },
              set: function (value) {
                this._z = value;
                this.onChangeCallback(this);
              }
            },
            order: {
              get: function () {
                return this._order;
              },
              set: function (value) {
                this._order = value;
                this.onChangeCallback(this);
              }
            },
            set: function (x, y, z, order) {
              if (order === void 0) {
                order = this._order;
              }
              this._x = x;
              this._y = y;
              this._z = z;
              this._order = order;
              this.onChangeCallback(this);
              return this;
            },
            copy: function (euler) {
              return this.set(euler.x, euler.y, euler.z, euler.order);
            },
            setFromQuaternion: function (quaternion, order, update) {
              if (order === void 0) {
                order = this._order;
              }
              if (update === void 0) {
                update = false;
              }
              tempMatrix.fromQuat(quaternion);
              return this.setFromRotationMatrix(tempMatrix, order, update);
            },
            setFromRotationMatrix: function (matrix, order, update) {
              if (order === void 0) {
                order = this._order;
              }
              if (update === void 0) {
                update = false;
              }
              var elements = matrix.val;
              var m11 = elements[0];
              var m12 = elements[4];
              var m13 = elements[8];
              var m21 = elements[1];
              var m22 = elements[5];
              var m23 = elements[9];
              var m31 = elements[2];
              var m32 = elements[6];
              var m33 = elements[10];
              var x = 0;
              var y = 0;
              var z = 0;
              var epsilon = 0.99999;
              switch (order) {
                case "XYZ":
                  {
                    y = Math.asin(Clamp(m13, -1, 1));
                    if (Math.abs(m13) < epsilon) {
                      x = Math.atan2(-m23, m33);
                      z = Math.atan2(-m12, m11);
                    } else {
                      x = Math.atan2(m32, m22);
                    }
                    break;
                  }
                case "YXZ":
                  {
                    x = Math.asin(-Clamp(m23, -1, 1));
                    if (Math.abs(m23) < epsilon) {
                      y = Math.atan2(m13, m33);
                      z = Math.atan2(m21, m22);
                    } else {
                      y = Math.atan2(-m31, m11);
                    }
                    break;
                  }
                case "ZXY":
                  {
                    x = Math.asin(Clamp(m32, -1, 1));
                    if (Math.abs(m32) < epsilon) {
                      y = Math.atan2(-m31, m33);
                      z = Math.atan2(-m12, m22);
                    } else {
                      z = Math.atan2(m21, m11);
                    }
                    break;
                  }
                case "ZYX":
                  {
                    y = Math.asin(-Clamp(m31, -1, 1));
                    if (Math.abs(m31) < epsilon) {
                      x = Math.atan2(m32, m33);
                      z = Math.atan2(m21, m11);
                    } else {
                      z = Math.atan2(-m12, m22);
                    }
                    break;
                  }
                case "YZX":
                  {
                    z = Math.asin(Clamp(m21, -1, 1));
                    if (Math.abs(m21) < epsilon) {
                      x = Math.atan2(-m23, m22);
                      y = Math.atan2(-m31, m11);
                    } else {
                      y = Math.atan2(m13, m33);
                    }
                    break;
                  }
                case "XZY":
                  {
                    z = Math.asin(-Clamp(m12, -1, 1));
                    if (Math.abs(m12) < epsilon) {
                      x = Math.atan2(m32, m22);
                      y = Math.atan2(m13, m11);
                    } else {
                      x = Math.atan2(-m23, m33);
                    }
                    break;
                  }
              }
              this._x = x;
              this._y = y;
              this._z = z;
              this._order = order;
              if (update) {
                this.onChangeCallback(this);
              }
              return this;
            }
          });
          Euler.RotationOrders = ["XYZ", "YXZ", "ZXY", "ZYX", "YZX", "XZY"];
          Euler.DefaultOrder = "XYZ";
          module2.exports = Euler;
        }, function (module2, exports2) {
          var FloorTo = function (value, place, base) {
            if (place === void 0) {
              place = 0;
            }
            if (base === void 0) {
              base = 10;
            }
            var p3 = Math.pow(base, -place);
            return Math.floor(value * p3) / p3;
          };
          module2.exports = FloorTo;
        }, function (module2, exports2) {
          var GetSpeed = function (distance, time) {
            return distance / time / 1e3;
          };
          module2.exports = GetSpeed;
        }, function (module2, exports2) {
          var IsEven = function (value) {
            return value == parseFloat(value) ? !(value % 2) : void 0;
          };
          module2.exports = IsEven;
        }, function (module2, exports2) {
          var IsEvenStrict = function (value) {
            return value === parseFloat(value) ? !(value % 2) : void 0;
          };
          module2.exports = IsEvenStrict;
        }, function (module2, exports2) {
          var MaxAdd = function (value, amount, max) {
            return Math.min(value + amount, max);
          };
          module2.exports = MaxAdd;
        }, function (module2, exports2) {
          var Median = function (values) {
            var valuesNum = values.length;
            if (valuesNum === 0) {
              return 0;
            }
            values.sort(function (a, b) {
              return a - b;
            });
            var halfIndex = Math.floor(valuesNum / 2);
            return valuesNum % 2 === 0 ? (values[halfIndex] + values[halfIndex - 1]) / 2 : values[halfIndex];
          };
          module2.exports = Median;
        }, function (module2, exports2) {
          var MinSub = function (value, amount, min) {
            return Math.max(value - amount, min);
          };
          module2.exports = MinSub;
        }, function (module2, exports2) {
          var Percent = function (value, min, max, upperMax) {
            if (max === void 0) {
              max = min + 1;
            }
            var percentage = (value - min) / (max - min);
            if (percentage > 1) {
              if (upperMax !== void 0) {
                percentage = (upperMax - value) / (upperMax - max);
                if (percentage < 0) {
                  percentage = 0;
                }
              } else {
                percentage = 1;
              }
            } else if (percentage < 0) {
              percentage = 0;
            }
            return percentage;
          };
          module2.exports = Percent;
        }, function (module2, exports2) {
          var RandomXY = function (vector, scale) {
            if (scale === void 0) {
              scale = 1;
            }
            var r = Math.random() * 2 * Math.PI;
            vector.x = Math.cos(r) * scale;
            vector.y = Math.sin(r) * scale;
            return vector;
          };
          module2.exports = RandomXY;
        }, function (module2, exports2) {
          var RandomXYZ = function (vec3, radius) {
            if (radius === void 0) {
              radius = 1;
            }
            var r = Math.random() * 2 * Math.PI;
            var z = Math.random() * 2 - 1;
            var zScale = Math.sqrt(1 - z * z) * radius;
            vec3.x = Math.cos(r) * zScale;
            vec3.y = Math.sin(r) * zScale;
            vec3.z = z * radius;
            return vec3;
          };
          module2.exports = RandomXYZ;
        }, function (module2, exports2) {
          var RandomXYZW = function (vec4, scale) {
            if (scale === void 0) {
              scale = 1;
            }
            vec4.x = (Math.random() * 2 - 1) * scale;
            vec4.y = (Math.random() * 2 - 1) * scale;
            vec4.z = (Math.random() * 2 - 1) * scale;
            vec4.w = (Math.random() * 2 - 1) * scale;
            return vec4;
          };
          module2.exports = RandomXYZW;
        }, function (module2, exports2) {
          var RotateTo = function (point, x, y, angle, distance) {
            point.x = x + distance * Math.cos(angle);
            point.y = y + distance * Math.sin(angle);
            return point;
          };
          module2.exports = RotateTo;
        }, function (module2, exports2) {
          var RoundTo = function (value, place, base) {
            if (place === void 0) {
              place = 0;
            }
            if (base === void 0) {
              base = 10;
            }
            var p3 = Math.pow(base, -place);
            return Math.round(value * p3) / p3;
          };
          module2.exports = RoundTo;
        }, function (module2, exports2) {
          var SinCosTableGenerator = function (length, sinAmp, cosAmp, frequency) {
            if (sinAmp === void 0) {
              sinAmp = 1;
            }
            if (cosAmp === void 0) {
              cosAmp = 1;
            }
            if (frequency === void 0) {
              frequency = 1;
            }
            frequency *= Math.PI / length;
            var cos = [];
            var sin = [];
            for (var c = 0; c < length; c++) {
              cosAmp -= sinAmp * frequency;
              sinAmp += cosAmp * frequency;
              cos[c] = cosAmp;
              sin[c] = sinAmp;
            }
            return {
              sin,
              cos,
              length
            };
          };
          module2.exports = SinCosTableGenerator;
        }, function (module2, exports2, __webpack_require__) {
          var Vector2 = __webpack_require__(3);
          var ToXY = function (index, width, height, out) {
            if (out === void 0) {
              out = new Vector2();
            }
            var x = 0;
            var y = 0;
            var total = width * height;
            if (index > 0 && index <= total) {
              if (index > width - 1) {
                y = Math.floor(index / width);
                x = index - y * width;
              } else {
                x = index;
              }
            }
            return out.set(x, y);
          };
          module2.exports = ToXY;
        }, function (module2, exports2) {
          var Within = function (a, b, tolerance) {
            return Math.abs(a - b) <= tolerance;
          };
          module2.exports = Within;
        }, function (module2, exports2, __webpack_require__) {
          var Vector3 = __webpack_require__(39);
          var Matrix4 = __webpack_require__(69);
          var Quaternion = __webpack_require__(365);
          var tmpMat4 = new Matrix4();
          var tmpQuat = new Quaternion();
          var tmpVec3 = new Vector3();
          var RotateVec3 = function (vec, axis, radians) {
            tmpQuat.setAxisAngle(axis, radians);
            tmpMat4.fromRotationTranslation(tmpQuat, tmpVec3.set(0, 0, 0));
            return vec.transformMat4(tmpMat4);
          };
          module2.exports = RotateVec3;
        }, function (module2, exports2) {
          module2.exports = "addtexture";
        }, function (module2, exports2) {
          module2.exports = "onerror";
        }, function (module2, exports2) {
          module2.exports = "onload";
        }, function (module2, exports2) {
          module2.exports = "ready";
        }, function (module2, exports2) {
          module2.exports = "removetexture";
        }, function (module2, exports2) {
          module2.exports = ["#define SHADER_NAME PHASER_BITMAP_MASK_FS", "", "precision mediump float;", "", "uniform vec2 uResolution;", "uniform sampler2D uMainSampler;", "uniform sampler2D uMaskSampler;", "uniform bool uInvertMaskAlpha;", "", "void main ()", "{", "    vec2 uv = gl_FragCoord.xy / uResolution;", "    vec4 mainColor = texture2D(uMainSampler, uv);", "    vec4 maskColor = texture2D(uMaskSampler, uv);", "    float alpha = mainColor.a;", "", "    if (!uInvertMaskAlpha)", "    {", "        alpha *= (maskColor.a);", "    }", "    else", "    {", "        alpha *= (1.0 - maskColor.a);", "    }", "", "    gl_FragColor = vec4(mainColor.rgb * alpha, alpha);", "}", ""].join("\n");
        }, function (module2, exports2) {
          module2.exports = ["#define SHADER_NAME PHASER_BITMAP_MASK_VS", "", "precision mediump float;", "", "attribute vec2 inPosition;", "", "void main ()", "{", "    gl_Position = vec4(inPosition, 0.0, 1.0);", "}", ""].join("\n");
        }, function (module2, exports2) {
          module2.exports = "pipelineafterflush";
        }, function (module2, exports2) {
          module2.exports = "pipelinebeforeflush";
        }, function (module2, exports2) {
          module2.exports = "pipelinebind";
        }, function (module2, exports2) {
          module2.exports = "pipelineboot";
        }, function (module2, exports2) {
          module2.exports = "pipelinedestroy";
        }, function (module2, exports2) {
          module2.exports = "pipelinerebind";
        }, function (module2, exports2) {
          module2.exports = "pipelineresize";
        }, function (module2, exports2) {
          module2.exports = ["#define SHADER_NAME PHASER_GRAPHICS_FS", "", "precision mediump float;", "", "varying vec4 outColor;", "", "void main ()", "{", "    gl_FragColor = vec4(outColor.bgr * outColor.a, outColor.a);", "}", ""].join("\n");
        }, function (module2, exports2) {
          module2.exports = ["#define SHADER_NAME PHASER_GRAPHICS_VS", "", "precision mediump float;", "", "uniform mat4 uProjectionMatrix;", "", "attribute vec2 inPosition;", "attribute vec4 inColor;", "", "varying vec4 outColor;", "", "void main ()", "{", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);", "", "    outColor = inColor;", "}", ""].join("\n");
        }, function (module2, exports2) {
          module2.exports = ["#define SHADER_NAME PHASER_LIGHT_FS", "", "precision mediump float;", "", "struct Light", "{", "    vec2 position;", "    vec3 color;", "    float intensity;", "    float radius;", "};", "", "const int kMaxLights = %LIGHT_COUNT%;", "", "uniform vec4 uCamera; /* x, y, rotation, zoom */", "uniform vec2 uResolution;", "uniform sampler2D uMainSampler;", "uniform sampler2D uNormSampler;", "uniform vec3 uAmbientLightColor;", "uniform Light uLights[kMaxLights];", "uniform mat3 uInverseRotationMatrix;", "", "varying vec2 outTexCoord;", "varying vec4 outTint;", "", "void main()", "{", "    vec3 finalColor = vec3(0.0, 0.0, 0.0);", "    vec4 color = texture2D(uMainSampler, outTexCoord) * vec4(outTint.bgr * outTint.a, outTint.a);", "    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;", "    vec3 normal = normalize(uInverseRotationMatrix * vec3(normalMap * 2.0 - 1.0));", "    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;", "", "    for (int index = 0; index < kMaxLights; ++index)", "    {", "        Light light = uLights[index];", "        vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);", "        vec3 lightNormal = normalize(lightDir);", "        float distToSurf = length(lightDir) * uCamera.w;", "        float diffuseFactor = max(dot(normal, lightNormal), 0.0);", "        float radius = (light.radius / res.x * uCamera.w) * uCamera.w;", "        float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);", "        vec3 diffuse = light.color * diffuseFactor;", "        finalColor += (attenuation * diffuse) * light.intensity;", "    }", "", "    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);", "", "    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);", "}", ""].join("\n");
        }, function (module2, exports2) {
          module2.exports = ["#define SHADER_NAME PHASER_MULTI_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler[%count%];", "", "varying vec2 outTexCoord;", "varying float outTexId;", "varying float outTintEffect;", "varying vec4 outTint;", "", "void main ()", "{", "    vec4 texture;", "", "    %forloop%", "", "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);", "", "    //  Multiply texture tint", "    vec4 color = texture * texel;", "", "    if (outTintEffect == 1.0)", "    {", "        //  Solid color + texture alpha", "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);", "    }", "    else if (outTintEffect == 2.0)", "    {", "        //  Solid color, no texture", "        color = texel;", "    }", "", "    gl_FragColor = color;", "}", ""].join("\n");
        }, function (module2, exports2) {
          module2.exports = ["#define SHADER_NAME PHASER_MULTI_VS", "", "precision mediump float;", "", "uniform mat4 uProjectionMatrix;", "", "attribute vec2 inPosition;", "attribute vec2 inTexCoord;", "attribute float inTexId;", "attribute float inTintEffect;", "attribute vec4 inTint;", "", "varying vec2 outTexCoord;", "varying float outTexId;", "varying float outTintEffect;", "varying vec4 outTint;", "", "void main ()", "{", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);", "", "    outTexCoord = inTexCoord;", "    outTexId = inTexId;", "    outTint = inTint;", "    outTintEffect = inTintEffect;", "}", ""].join("\n");
        }, function (module2, exports2) {
          module2.exports = ["#define SHADER_NAME PHASER_POINTLIGHT_FS", "", "precision mediump float;", "", "uniform vec2 uResolution;", "uniform float uCameraZoom;", "", "varying vec4 lightPosition;", "varying vec4 lightColor;", "varying float lightRadius;", "varying float lightAttenuation;", "", "void main ()", "{", "    vec2 center = (lightPosition.xy + 1.0) * (uResolution.xy * 0.5);", "", "    float distToSurf = length(center - gl_FragCoord.xy);", "", "    float radius = 1.0 - distToSurf / (lightRadius * uCameraZoom);", "", "    float intensity = smoothstep(0.0, 1.0, radius * lightAttenuation);", "", "    vec4 color = vec4(intensity, intensity, intensity, 0.0) * lightColor;", "", "    gl_FragColor = vec4(color.rgb * lightColor.a, color.a);", "}", ""].join("\n");
        }, function (module2, exports2) {
          module2.exports = ["#define SHADER_NAME PHASER_POINTLIGHT_VS", "", "precision mediump float;", "", "uniform mat4 uProjectionMatrix;", "", "attribute vec2 inPosition;", "attribute vec2 inLightPosition;", "attribute vec4 inLightColor;", "attribute float inLightRadius;", "attribute float inLightAttenuation;", "", "varying vec4 lightPosition;", "varying vec4 lightColor;", "varying float lightRadius;", "varying float lightAttenuation;", "", "void main ()", "{", "    lightColor = inLightColor;", "    lightRadius = inLightRadius;", "    lightAttenuation = inLightAttenuation;", "    lightPosition = uProjectionMatrix * vec4(inLightPosition, 1.0, 1.0);", "", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);", "}", ""].join("\n");
        }, function (module2, exports2) {
          module2.exports = ["#define SHADER_NAME PHASER_SINGLE_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler;", "", "varying vec2 outTexCoord;", "varying float outTintEffect;", "varying vec4 outTint;", "", "void main ()", "{", "    vec4 texture = texture2D(uMainSampler, outTexCoord);", "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);", "", "    //  Multiply texture tint", "    vec4 color = texture * texel;", "", "    if (outTintEffect == 1.0)", "    {", "        //  Solid color + texture alpha", "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);", "    }", "    else if (outTintEffect == 2.0)", "    {", "        //  Solid color, no texture", "        color = texel;", "    }", "", "    gl_FragColor = color;", "}", ""].join("\n");
        }, function (module2, exports2) {
          module2.exports = ["#define SHADER_NAME PHASER_SINGLE_VS", "", "precision mediump float;", "", "uniform mat4 uProjectionMatrix;", "", "attribute vec2 inPosition;", "attribute vec2 inTexCoord;", "attribute float inTexId;", "attribute float inTintEffect;", "attribute vec4 inTint;", "", "varying vec2 outTexCoord;", "varying float outTintEffect;", "varying vec4 outTint;", "", "void main ()", "{", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);", "", "    outTexCoord = inTexCoord;", "    outTint = inTint;", "    outTintEffect = inTintEffect;", "}", ""].join("\n");
        }, function (module2, exports2) {
          module2.exports = ["#define SHADER_NAME PHASER_ADD_BLEND_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler1;", "uniform sampler2D uMainSampler2;", "uniform float uStrength;", "", "varying vec2 outTexCoord;", "", "void main ()", "{", "    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);", "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);", "", "    gl_FragColor = frame1 + frame2 * uStrength;", "}", ""].join("\n");
        }, function (module2, exports2) {
          module2.exports = ["#define SHADER_NAME PHASER_COLORMATRIX_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler;", "uniform float uColorMatrix[20];", "uniform float uAlpha;", "", "varying vec2 outTexCoord;", "", "void main ()", "{", "    vec4 c = texture2D(uMainSampler, outTexCoord);", "", "    if (uAlpha == 0.0)", "    {", "        gl_FragColor = c;", "", "        return;", "    }", "", "    if (c.a > 0.0)", "    {", "        c.rgb /= c.a;", "    }", "", "    vec4 result;", "", "    result.r = (uColorMatrix[0] * c.r) + (uColorMatrix[1] * c.g) + (uColorMatrix[2] * c.b) + (uColorMatrix[3] * c.a) + uColorMatrix[4];", "    result.g = (uColorMatrix[5] * c.r) + (uColorMatrix[6] * c.g) + (uColorMatrix[7] * c.b) + (uColorMatrix[8] * c.a) + uColorMatrix[9];", "    result.b = (uColorMatrix[10] * c.r) + (uColorMatrix[11] * c.g) + (uColorMatrix[12] * c.b) + (uColorMatrix[13] * c.a) + uColorMatrix[14];", "    result.a = (uColorMatrix[15] * c.r) + (uColorMatrix[16] * c.g) + (uColorMatrix[17] * c.b) + (uColorMatrix[18] * c.a) + uColorMatrix[19];", "", "    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);", "", "    rgb *= result.a;", "", "    gl_FragColor = vec4(rgb, result.a);", "}", ""].join("\n");
        }, function (module2, exports2) {
          module2.exports = ["#define SHADER_NAME PHASER_COPY_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler;", "uniform float uBrightness;", "", "varying vec2 outTexCoord;", "", "void main ()", "{", "    gl_FragColor = texture2D(uMainSampler, outTexCoord) * uBrightness;", "}", ""].join("\n");
        }, function (module2, exports2) {
          module2.exports = ["#define SHADER_NAME PHASER_LINEAR_BLEND_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler1;", "uniform sampler2D uMainSampler2;", "uniform float uStrength;", "", "varying vec2 outTexCoord;", "", "void main ()", "{", "    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);", "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);", "", "    gl_FragColor = mix(frame1, frame2 * uStrength, 0.5);", "}", ""].join("\n");
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            GenerateTexture: __webpack_require__(388),
            Palettes: __webpack_require__(889)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            ARNE16: __webpack_require__(389),
            C64: __webpack_require__(890),
            CGA: __webpack_require__(891),
            JMP: __webpack_require__(892),
            MSX: __webpack_require__(893)
          };
        }, function (module2, exports2) {
          module2.exports = {
            0: "#000",
            1: "#fff",
            2: "#8b4131",
            3: "#7bbdc5",
            4: "#8b41ac",
            5: "#6aac41",
            6: "#3931a4",
            7: "#d5de73",
            8: "#945a20",
            9: "#5a4100",
            A: "#bd736a",
            B: "#525252",
            C: "#838383",
            D: "#acee8b",
            E: "#7b73de",
            F: "#acacac"
          };
        }, function (module2, exports2) {
          module2.exports = {
            0: "#000",
            1: "#2234d1",
            2: "#0c7e45",
            3: "#44aacc",
            4: "#8a3622",
            5: "#5c2e78",
            6: "#aa5c3d",
            7: "#b5b5b5",
            8: "#5e606e",
            9: "#4c81fb",
            A: "#6cd947",
            B: "#7be2f9",
            C: "#eb8a60",
            D: "#e23d69",
            E: "#ffd93f",
            F: "#fff"
          };
        }, function (module2, exports2) {
          module2.exports = {
            0: "#000",
            1: "#191028",
            2: "#46af45",
            3: "#a1d685",
            4: "#453e78",
            5: "#7664fe",
            6: "#833129",
            7: "#9ec2e8",
            8: "#dc534b",
            9: "#e18d79",
            A: "#d6b97b",
            B: "#e9d8a1",
            C: "#216c4b",
            D: "#d365c8",
            E: "#afaab9",
            F: "#f5f4eb"
          };
        }, function (module2, exports2) {
          module2.exports = {
            0: "#000",
            1: "#191028",
            2: "#46af45",
            3: "#a1d685",
            4: "#453e78",
            5: "#7664fe",
            6: "#833129",
            7: "#9ec2e8",
            8: "#dc534b",
            9: "#e18d79",
            A: "#d6b97b",
            B: "#e9d8a1",
            C: "#216c4b",
            D: "#d365c8",
            E: "#afaab9",
            F: "#fff"
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Path: __webpack_require__(895),
            MoveTo: __webpack_require__(393),
            CubicBezier: __webpack_require__(390),
            Curve: __webpack_require__(94),
            Ellipse: __webpack_require__(391),
            Line: __webpack_require__(392),
            QuadraticBezier: __webpack_require__(394),
            Spline: __webpack_require__(395)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CubicBezierCurve = __webpack_require__(390);
          var EllipseCurve = __webpack_require__(391);
          var GameObjectFactory = __webpack_require__(5);
          var LineCurve = __webpack_require__(392);
          var MovePathTo = __webpack_require__(393);
          var QuadraticBezierCurve = __webpack_require__(394);
          var Rectangle = __webpack_require__(10);
          var SplineCurve = __webpack_require__(395);
          var Vector2 = __webpack_require__(3);
          var MATH_CONST = __webpack_require__(14);
          var Path = new Class({
            initialize: function Path2(x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              this.name = "";
              this.curves = [];
              this.cacheLengths = [];
              this.autoClose = false;
              this.startPoint = new Vector2();
              this._tmpVec2A = new Vector2();
              this._tmpVec2B = new Vector2();
              if (typeof x === "object") {
                this.fromJSON(x);
              } else {
                this.startPoint.set(x, y);
              }
            },
            add: function (curve) {
              this.curves.push(curve);
              return this;
            },
            circleTo: function (radius, clockwise, rotation) {
              if (clockwise === void 0) {
                clockwise = false;
              }
              return this.ellipseTo(radius, radius, 0, 360, clockwise, rotation);
            },
            closePath: function () {
              var startPoint = this.curves[0].getPoint(0);
              var endPoint = this.curves[this.curves.length - 1].getPoint(1);
              if (!startPoint.equals(endPoint)) {
                this.curves.push(new LineCurve(endPoint, startPoint));
              }
              return this;
            },
            cubicBezierTo: function (x, y, control1X, control1Y, control2X, control2Y) {
              var p0 = this.getEndPoint();
              var p1;
              var p22;
              var p3;
              if (x instanceof Vector2) {
                p1 = x;
                p22 = y;
                p3 = control1X;
              } else {
                p1 = new Vector2(control1X, control1Y);
                p22 = new Vector2(control2X, control2Y);
                p3 = new Vector2(x, y);
              }
              return this.add(new CubicBezierCurve(p0, p1, p22, p3));
            },
            quadraticBezierTo: function (x, y, controlX, controlY) {
              var p0 = this.getEndPoint();
              var p1;
              var p22;
              if (x instanceof Vector2) {
                p1 = x;
                p22 = y;
              } else {
                p1 = new Vector2(controlX, controlY);
                p22 = new Vector2(x, y);
              }
              return this.add(new QuadraticBezierCurve(p0, p1, p22));
            },
            draw: function (graphics, pointsTotal) {
              for (var i = 0; i < this.curves.length; i++) {
                var curve = this.curves[i];
                if (!curve.active) {
                  continue;
                }
                curve.draw(graphics, pointsTotal);
              }
              return graphics;
            },
            ellipseTo: function (xRadius, yRadius, startAngle, endAngle, clockwise, rotation) {
              var ellipse = new EllipseCurve(0, 0, xRadius, yRadius, startAngle, endAngle, clockwise, rotation);
              var end = this.getEndPoint(this._tmpVec2A);
              var start = ellipse.getStartPoint(this._tmpVec2B);
              end.subtract(start);
              ellipse.x = end.x;
              ellipse.y = end.y;
              return this.add(ellipse);
            },
            fromJSON: function (data) {
              this.curves = [];
              this.cacheLengths = [];
              this.startPoint.set(data.x, data.y);
              this.autoClose = data.autoClose;
              for (var i = 0; i < data.curves.length; i++) {
                var curve = data.curves[i];
                switch (curve.type) {
                  case "LineCurve":
                    this.add(LineCurve.fromJSON(curve));
                    break;
                  case "EllipseCurve":
                    this.add(EllipseCurve.fromJSON(curve));
                    break;
                  case "SplineCurve":
                    this.add(SplineCurve.fromJSON(curve));
                    break;
                  case "CubicBezierCurve":
                    this.add(CubicBezierCurve.fromJSON(curve));
                    break;
                  case "QuadraticBezierCurve":
                    this.add(QuadraticBezierCurve.fromJSON(curve));
                    break;
                }
              }
              return this;
            },
            getBounds: function (out, accuracy) {
              if (out === void 0) {
                out = new Rectangle();
              }
              if (accuracy === void 0) {
                accuracy = 16;
              }
              out.x = Number.MAX_VALUE;
              out.y = Number.MAX_VALUE;
              var bounds = new Rectangle();
              var maxRight = MATH_CONST.MIN_SAFE_INTEGER;
              var maxBottom = MATH_CONST.MIN_SAFE_INTEGER;
              for (var i = 0; i < this.curves.length; i++) {
                var curve = this.curves[i];
                if (!curve.active) {
                  continue;
                }
                curve.getBounds(bounds, accuracy);
                out.x = Math.min(out.x, bounds.x);
                out.y = Math.min(out.y, bounds.y);
                maxRight = Math.max(maxRight, bounds.right);
                maxBottom = Math.max(maxBottom, bounds.bottom);
              }
              out.right = maxRight;
              out.bottom = maxBottom;
              return out;
            },
            getCurveLengths: function () {
              if (this.cacheLengths.length === this.curves.length) {
                return this.cacheLengths;
              }
              var lengths = [];
              var sums = 0;
              for (var i = 0; i < this.curves.length; i++) {
                sums += this.curves[i].getLength();
                lengths.push(sums);
              }
              this.cacheLengths = lengths;
              return lengths;
            },
            getEndPoint: function (out) {
              if (out === void 0) {
                out = new Vector2();
              }
              if (this.curves.length > 0) {
                this.curves[this.curves.length - 1].getPoint(1, out);
              } else {
                out.copy(this.startPoint);
              }
              return out;
            },
            getLength: function () {
              var lens = this.getCurveLengths();
              return lens[lens.length - 1];
            },
            getPoint: function (t, out) {
              if (out === void 0) {
                out = new Vector2();
              }
              var d = t * this.getLength();
              var curveLengths = this.getCurveLengths();
              var i = 0;
              while (i < curveLengths.length) {
                if (curveLengths[i] >= d) {
                  var diff = curveLengths[i] - d;
                  var curve = this.curves[i];
                  var segmentLength = curve.getLength();
                  var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                  return curve.getPointAt(u, out);
                }
                i++;
              }
              return null;
            },
            getPoints: function (divisions) {
              if (divisions === void 0) {
                divisions = 12;
              }
              var points = [];
              var last;
              for (var i = 0; i < this.curves.length; i++) {
                var curve = this.curves[i];
                if (!curve.active) {
                  continue;
                }
                var resolution = curve.getResolution(divisions);
                var pts = curve.getPoints(resolution);
                for (var j = 0; j < pts.length; j++) {
                  var point = pts[j];
                  if (last && last.equals(point)) {
                    continue;
                  }
                  points.push(point);
                  last = point;
                }
              }
              if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
                points.push(points[0]);
              }
              return points;
            },
            getRandomPoint: function (out) {
              if (out === void 0) {
                out = new Vector2();
              }
              return this.getPoint(Math.random(), out);
            },
            getSpacedPoints: function (divisions) {
              if (divisions === void 0) {
                divisions = 40;
              }
              var points = [];
              for (var i = 0; i <= divisions; i++) {
                points.push(this.getPoint(i / divisions));
              }
              if (this.autoClose) {
                points.push(points[0]);
              }
              return points;
            },
            getStartPoint: function (out) {
              if (out === void 0) {
                out = new Vector2();
              }
              return out.copy(this.startPoint);
            },
            getTangent: function (t, out) {
              if (out === void 0) {
                out = new Vector2();
              }
              var d = t * this.getLength();
              var curveLengths = this.getCurveLengths();
              var i = 0;
              while (i < curveLengths.length) {
                if (curveLengths[i] >= d) {
                  var diff = curveLengths[i] - d;
                  var curve = this.curves[i];
                  var segmentLength = curve.getLength();
                  var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                  return curve.getTangentAt(u, out);
                }
                i++;
              }
              return null;
            },
            lineTo: function (x, y) {
              if (x instanceof Vector2) {
                this._tmpVec2B.copy(x);
              } else {
                this._tmpVec2B.set(x, y);
              }
              var end = this.getEndPoint(this._tmpVec2A);
              return this.add(new LineCurve([end.x, end.y, this._tmpVec2B.x, this._tmpVec2B.y]));
            },
            splineTo: function (points) {
              points.unshift(this.getEndPoint());
              return this.add(new SplineCurve(points));
            },
            moveTo: function (x, y) {
              if (x instanceof Vector2) {
                return this.add(new MovePathTo(x.x, x.y));
              } else {
                return this.add(new MovePathTo(x, y));
              }
            },
            toJSON: function () {
              var out = [];
              for (var i = 0; i < this.curves.length; i++) {
                out.push(this.curves[i].toJSON());
              }
              return {
                type: "Path",
                x: this.startPoint.x,
                y: this.startPoint.y,
                autoClose: this.autoClose,
                curves: out
              };
            },
            updateArcLengths: function () {
              this.cacheLengths = [];
              this.getCurveLengths();
            },
            destroy: function () {
              this.curves.length = 0;
              this.cacheLengths.length = 0;
              this.startPoint = void 0;
            }
          });
          GameObjectFactory.register("path", function (x, y) {
            return new Path(x, y);
          });
          module2.exports = Path;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            DataManager: __webpack_require__(101),
            DataManagerPlugin: __webpack_require__(897),
            Events: __webpack_require__(315)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var DataManager = __webpack_require__(101);
          var PluginCache = __webpack_require__(24);
          var SceneEvents = __webpack_require__(20);
          var DataManagerPlugin = new Class({
            Extends: DataManager,
            initialize: function DataManagerPlugin2(scene) {
              DataManager.call(this, scene, scene.sys.events);
              this.scene = scene;
              this.systems = scene.sys;
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              scene.sys.events.on(SceneEvents.START, this.start, this);
            },
            boot: function () {
              this.events = this.systems.events;
              this.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            start: function () {
              this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            shutdown: function () {
              this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function () {
              DataManager.prototype.destroy.call(this);
              this.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
            }
          });
          PluginCache.register("DataManagerPlugin", DataManagerPlugin, "data");
          module2.exports = DataManagerPlugin;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Align: __webpack_require__(899),
            BaseShader: __webpack_require__(396),
            Bounds: __webpack_require__(902),
            Canvas: __webpack_require__(906),
            Color: __webpack_require__(397),
            ColorMatrix: __webpack_require__(198),
            Masks: __webpack_require__(916),
            RGB: __webpack_require__(200)
          };
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(123);
          var Extend = __webpack_require__(17);
          var Align = {
            In: __webpack_require__(900),
            To: __webpack_require__(901)
          };
          Align = Extend(false, Align, CONST);
          module2.exports = Align;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            BottomCenter: __webpack_require__(290),
            BottomLeft: __webpack_require__(291),
            BottomRight: __webpack_require__(292),
            Center: __webpack_require__(293),
            LeftCenter: __webpack_require__(295),
            QuickSet: __webpack_require__(289),
            RightCenter: __webpack_require__(296),
            TopCenter: __webpack_require__(297),
            TopLeft: __webpack_require__(298),
            TopRight: __webpack_require__(299)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            BottomCenter: __webpack_require__(277),
            BottomLeft: __webpack_require__(278),
            BottomRight: __webpack_require__(279),
            LeftBottom: __webpack_require__(280),
            LeftCenter: __webpack_require__(281),
            LeftTop: __webpack_require__(282),
            QuickSet: __webpack_require__(276),
            RightBottom: __webpack_require__(283),
            RightCenter: __webpack_require__(284),
            RightTop: __webpack_require__(285),
            TopCenter: __webpack_require__(286),
            TopLeft: __webpack_require__(287),
            TopRight: __webpack_require__(288)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            CenterOn: __webpack_require__(294),
            GetBottom: __webpack_require__(42),
            GetBounds: __webpack_require__(903),
            GetCenterX: __webpack_require__(87),
            GetCenterY: __webpack_require__(89),
            GetLeft: __webpack_require__(43),
            GetOffsetX: __webpack_require__(904),
            GetOffsetY: __webpack_require__(905),
            GetRight: __webpack_require__(44),
            GetTop: __webpack_require__(45),
            SetBottom: __webpack_require__(55),
            SetCenterX: __webpack_require__(88),
            SetCenterY: __webpack_require__(90),
            SetLeft: __webpack_require__(53),
            SetRight: __webpack_require__(54),
            SetTop: __webpack_require__(52)
          };
        }, function (module2, exports2, __webpack_require__) {
          var GetBottom = __webpack_require__(42);
          var GetLeft = __webpack_require__(43);
          var GetRight = __webpack_require__(44);
          var GetTop = __webpack_require__(45);
          var GetBounds = function (gameObject, output) {
            if (output === void 0) {
              output = {};
            }
            var left = GetLeft(gameObject);
            var top = GetTop(gameObject);
            output.x = left;
            output.y = top;
            output.width = GetRight(gameObject) - left;
            output.height = GetBottom(gameObject) - top;
            return output;
          };
          module2.exports = GetBounds;
        }, function (module2, exports2) {
          var GetOffsetX = function (gameObject) {
            return gameObject.width * gameObject.originX;
          };
          module2.exports = GetOffsetX;
        }, function (module2, exports2) {
          var GetOffsetY = function (gameObject) {
            return gameObject.height * gameObject.originY;
          };
          module2.exports = GetOffsetY;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            CanvasInterpolation: __webpack_require__(367),
            CanvasPool: __webpack_require__(31),
            Smoothing: __webpack_require__(192),
            TouchAction: __webpack_require__(907),
            UserSelect: __webpack_require__(908)
          };
        }, function (module2, exports2) {
          var TouchAction = function (canvas, value) {
            if (value === void 0) {
              value = "none";
            }
            canvas.style["msTouchAction"] = value;
            canvas.style["ms-touch-action"] = value;
            canvas.style["touch-action"] = value;
            return canvas;
          };
          module2.exports = TouchAction;
        }, function (module2, exports2) {
          var UserSelect = function (canvas, value) {
            if (value === void 0) {
              value = "none";
            }
            var vendors = ["-webkit-", "-khtml-", "-moz-", "-ms-", ""];
            vendors.forEach(function (vendor) {
              canvas.style[vendor + "user-select"] = value;
            });
            canvas.style["-webkit-touch-callout"] = value;
            canvas.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)";
            return canvas;
          };
          module2.exports = UserSelect;
        }, function (module2, exports2, __webpack_require__) {
          var GetColor = __webpack_require__(103);
          var ColorSpectrum = function (limit) {
            if (limit === void 0) {
              limit = 1024;
            }
            var colors = [];
            var range = 255;
            var i;
            var r = 255;
            var g = 0;
            var b = 0;
            for (i = 0; i <= range; i++) {
              colors.push({
                r,
                g: i,
                b,
                color: GetColor(r, i, b)
              });
            }
            g = 255;
            for (i = range; i >= 0; i--) {
              colors.push({
                r: i,
                g,
                b,
                color: GetColor(i, g, b)
              });
            }
            r = 0;
            for (i = 0; i <= range; (i++, g--)) {
              colors.push({
                r,
                g,
                b: i,
                color: GetColor(r, g, i)
              });
            }
            g = 0;
            b = 255;
            for (i = 0; i <= range; (i++, b--, r++)) {
              colors.push({
                r,
                g,
                b,
                color: GetColor(r, g, b)
              });
            }
            if (limit === 1024) {
              return colors;
            } else {
              var out = [];
              var t = 0;
              var inc = 1024 / limit;
              for (i = 0; i < limit; i++) {
                out.push(colors[Math.floor(t)]);
                t += inc;
              }
              return out;
            }
          };
          module2.exports = ColorSpectrum;
        }, function (module2, exports2) {
          var ColorToRGBA = function (color) {
            var output = {
              r: color >> 16 & 255,
              g: color >> 8 & 255,
              b: color & 255,
              a: 255
            };
            if (color > 16777215) {
              output.a = color >>> 24;
            }
            return output;
          };
          module2.exports = ColorToRGBA;
        }, function (module2, exports2, __webpack_require__) {
          var Color = __webpack_require__(38);
          var HueToComponent = __webpack_require__(399);
          var HSLToColor = function (h, s, l) {
            var r = l;
            var g = l;
            var b = l;
            if (s !== 0) {
              var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
              var p3 = 2 * l - q;
              r = HueToComponent(p3, q, h + 1 / 3);
              g = HueToComponent(p3, q, h);
              b = HueToComponent(p3, q, h - 1 / 3);
            }
            var color = new Color();
            return color.setGLTo(r, g, b, 1);
          };
          module2.exports = HSLToColor;
        }, function (module2, exports2, __webpack_require__) {
          var HSVToRGB = __webpack_require__(188);
          var HSVColorWheel = function (s, v) {
            if (s === void 0) {
              s = 1;
            }
            if (v === void 0) {
              v = 1;
            }
            var colors = [];
            for (var c = 0; c <= 359; c++) {
              colors.push(HSVToRGB(c / 359, s, v));
            }
            return colors;
          };
          module2.exports = HSVColorWheel;
        }, function (module2, exports2, __webpack_require__) {
          var Linear = __webpack_require__(135);
          var RGBWithRGB = function (r1, g1, b1, r2, g2, b2, length, index) {
            if (length === void 0) {
              length = 100;
            }
            if (index === void 0) {
              index = 0;
            }
            var t = index / length;
            return {
              r: Linear(r1, r2, t),
              g: Linear(g1, g2, t),
              b: Linear(b1, b2, t)
            };
          };
          var ColorWithColor = function (color1, color2, length, index) {
            if (length === void 0) {
              length = 100;
            }
            if (index === void 0) {
              index = 0;
            }
            return RGBWithRGB(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b, length, index);
          };
          var ColorWithRGB = function (color, r, g, b, length, index) {
            if (length === void 0) {
              length = 100;
            }
            if (index === void 0) {
              index = 0;
            }
            return RGBWithRGB(color.r, color.g, color.b, r, g, b, length, index);
          };
          module2.exports = {
            RGBWithRGB,
            ColorWithRGB,
            ColorWithColor
          };
        }, function (module2, exports2, __webpack_require__) {
          var Between = __webpack_require__(195);
          var Color = __webpack_require__(38);
          var RandomRGB = function (min, max) {
            if (min === void 0) {
              min = 0;
            }
            if (max === void 0) {
              max = 255;
            }
            return new Color(Between(min, max), Between(min, max), Between(min, max));
          };
          module2.exports = RandomRGB;
        }, function (module2, exports2, __webpack_require__) {
          var ComponentToHex = __webpack_require__(398);
          var RGBToString = function (r, g, b, a, prefix) {
            if (a === void 0) {
              a = 255;
            }
            if (prefix === void 0) {
              prefix = "#";
            }
            if (prefix === "#") {
              return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1, 7);
            } else {
              return "0x" + ComponentToHex(a) + ComponentToHex(r) + ComponentToHex(g) + ComponentToHex(b);
            }
          };
          module2.exports = RGBToString;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            BitmapMask: __webpack_require__(310),
            GeometryMask: __webpack_require__(311)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Dom = {
            AddToDOM: __webpack_require__(142),
            DOMContentLoaded: __webpack_require__(400),
            GetInnerHeight: __webpack_require__(401),
            GetScreenOrientation: __webpack_require__(402),
            GetTarget: __webpack_require__(407),
            ParseXML: __webpack_require__(408),
            RemoveFromDOM: __webpack_require__(202),
            RequestAnimationFrame: __webpack_require__(386)
          };
          module2.exports = Dom;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            EventEmitter: __webpack_require__(919)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var EE = __webpack_require__(9);
          var PluginCache = __webpack_require__(24);
          var EventEmitter = new Class({
            Extends: EE,
            initialize: function EventEmitter2() {
              EE.call(this);
            },
            shutdown: function () {
              this.removeAllListeners();
            },
            destroy: function () {
              this.removeAllListeners();
            }
          });
          PluginCache.register("EventEmitter", EventEmitter, "events");
          module2.exports = EventEmitter;
        }, function (module2, exports2, __webpack_require__) {
          var AddToDOM = __webpack_require__(142);
          var AnimationManager = __webpack_require__(321);
          var CacheManager = __webpack_require__(325);
          var CanvasPool = __webpack_require__(31);
          var Class = __webpack_require__(0);
          var Config = __webpack_require__(346);
          var CreateDOMContainer = __webpack_require__(921);
          var CreateRenderer = __webpack_require__(366);
          var DataManager = __webpack_require__(101);
          var DebugHeader = __webpack_require__(384);
          var Device = __webpack_require__(347);
          var DOMContentLoaded = __webpack_require__(400);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(22);
          var InputManager = __webpack_require__(409);
          var PluginCache = __webpack_require__(24);
          var PluginManager = __webpack_require__(414);
          var ScaleManager = __webpack_require__(415);
          var SceneManager = __webpack_require__(417);
          var TextureEvents = __webpack_require__(106);
          var TextureManager = __webpack_require__(422);
          var TimeStep = __webpack_require__(385);
          var VisibilityHandler = __webpack_require__(387);
          if (true) {
            var SoundManagerCreator = __webpack_require__(426);
          }
          if (false) {
            var FacebookInstantGamesPlugin;
          }
          var Game = new Class({
            initialize: function Game2(config) {
              this.config = new Config(config);
              this.renderer = null;
              this.domContainer = null;
              this.canvas = null;
              this.context = null;
              this.isBooted = false;
              this.isRunning = false;
              this.events = new EventEmitter();
              this.anims = new AnimationManager(this);
              this.textures = new TextureManager(this);
              this.cache = new CacheManager(this);
              this.registry = new DataManager(this);
              this.input = new InputManager(this, this.config);
              this.scene = new SceneManager(this, this.config.sceneConfig);
              this.device = Device;
              this.scale = new ScaleManager(this, this.config);
              this.sound = null;
              if (true) {
                this.sound = SoundManagerCreator.create(this);
              }
              this.loop = new TimeStep(this, this.config.fps);
              this.plugins = new PluginManager(this, this.config);
              if (false) {}
              this.pendingDestroy = false;
              this.removeCanvas = false;
              this.noReturn = false;
              this.hasFocus = false;
              DOMContentLoaded(this.boot.bind(this));
            },
            boot: function () {
              if (!PluginCache.hasCore("EventEmitter")) {
                console.warn("Aborting. Core Plugins missing.");
                return;
              }
              this.isBooted = true;
              this.config.preBoot(this);
              this.scale.preBoot();
              CreateRenderer(this);
              CreateDOMContainer(this);
              DebugHeader(this);
              AddToDOM(this.canvas, this.config.parent);
              this.textures.once(TextureEvents.READY, this.texturesReady, this);
              this.events.emit(Events.BOOT);
            },
            texturesReady: function () {
              this.events.emit(Events.READY);
              this.start();
            },
            start: function () {
              this.isRunning = true;
              this.config.postBoot(this);
              if (this.renderer) {
                this.loop.start(this.step.bind(this));
              } else {
                this.loop.start(this.headlessStep.bind(this));
              }
              VisibilityHandler(this);
              var eventEmitter = this.events;
              eventEmitter.on(Events.HIDDEN, this.onHidden, this);
              eventEmitter.on(Events.VISIBLE, this.onVisible, this);
              eventEmitter.on(Events.BLUR, this.onBlur, this);
              eventEmitter.on(Events.FOCUS, this.onFocus, this);
            },
            step: function (time, delta) {
              if (this.pendingDestroy) {
                return this.runDestroy();
              }
              var eventEmitter = this.events;
              eventEmitter.emit(Events.PRE_STEP, time, delta);
              eventEmitter.emit(Events.STEP, time, delta);
              this.scene.update(time, delta);
              eventEmitter.emit(Events.POST_STEP, time, delta);
              var renderer = this.renderer;
              renderer.preRender();
              eventEmitter.emit(Events.PRE_RENDER, renderer, time, delta);
              this.scene.render(renderer);
              renderer.postRender();
              eventEmitter.emit(Events.POST_RENDER, renderer, time, delta);
            },
            headlessStep: function (time, delta) {
              if (this.pendingDestroy) {
                return this.runDestroy();
              }
              var eventEmitter = this.events;
              eventEmitter.emit(Events.PRE_STEP, time, delta);
              eventEmitter.emit(Events.STEP, time, delta);
              this.scene.update(time, delta);
              eventEmitter.emit(Events.POST_STEP, time, delta);
              eventEmitter.emit(Events.PRE_RENDER);
              eventEmitter.emit(Events.POST_RENDER);
            },
            onHidden: function () {
              this.loop.pause();
              this.events.emit(Events.PAUSE);
            },
            onVisible: function () {
              this.loop.resume();
              this.events.emit(Events.RESUME);
            },
            onBlur: function () {
              this.hasFocus = false;
              this.loop.blur();
            },
            onFocus: function () {
              this.hasFocus = true;
              this.loop.focus();
            },
            getFrame: function () {
              return this.loop.frame;
            },
            getTime: function () {
              return this.loop.now;
            },
            destroy: function (removeCanvas, noReturn) {
              if (noReturn === void 0) {
                noReturn = false;
              }
              this.pendingDestroy = true;
              this.removeCanvas = removeCanvas;
              this.noReturn = noReturn;
            },
            runDestroy: function () {
              this.scene.destroy();
              this.events.emit(Events.DESTROY);
              this.events.removeAllListeners();
              if (this.renderer) {
                this.renderer.destroy();
              }
              if (this.removeCanvas && this.canvas) {
                CanvasPool.remove(this.canvas);
                if (this.canvas.parentNode) {
                  this.canvas.parentNode.removeChild(this.canvas);
                }
              }
              if (this.domContainer) {
                this.domContainer.parentNode.removeChild(this.domContainer);
              }
              this.loop.destroy();
              this.pendingDestroy = false;
            }
          });
          module2.exports = Game;
        }, function (module2, exports2, __webpack_require__) {
          var AddToDOM = __webpack_require__(142);
          var CreateDOMContainer = function (game) {
            var config = game.config;
            if (!config.parent || !config.domCreateContainer) {
              return;
            }
            var div = document.createElement("div");
            div.style.cssText = ["display: block;", "width: " + game.scale.width + "px;", "height: " + game.scale.height + "px;", "padding: 0; margin: 0;", "position: absolute;", "overflow: hidden;", "pointer-events: " + config.domPointerEvents + ";", "transform: scale(1);", "transform-origin: left top;"].join(" ");
            game.domContainer = div;
            AddToDOM(div, config.parent);
          };
          module2.exports = CreateDOMContainer;
        }, function (module2, exports2) {
          module2.exports = "boot";
        }, function (module2, exports2) {
          module2.exports = "destroy";
        }, function (module2, exports2) {
          module2.exports = "dragend";
        }, function (module2, exports2) {
          module2.exports = "dragenter";
        }, function (module2, exports2) {
          module2.exports = "drag";
        }, function (module2, exports2) {
          module2.exports = "dragleave";
        }, function (module2, exports2) {
          module2.exports = "dragover";
        }, function (module2, exports2) {
          module2.exports = "dragstart";
        }, function (module2, exports2) {
          module2.exports = "drop";
        }, function (module2, exports2) {
          module2.exports = "gameout";
        }, function (module2, exports2) {
          module2.exports = "gameover";
        }, function (module2, exports2) {
          module2.exports = "gameobjectdown";
        }, function (module2, exports2) {
          module2.exports = "dragend";
        }, function (module2, exports2) {
          module2.exports = "dragenter";
        }, function (module2, exports2) {
          module2.exports = "drag";
        }, function (module2, exports2) {
          module2.exports = "dragleave";
        }, function (module2, exports2) {
          module2.exports = "dragover";
        }, function (module2, exports2) {
          module2.exports = "dragstart";
        }, function (module2, exports2) {
          module2.exports = "drop";
        }, function (module2, exports2) {
          module2.exports = "gameobjectmove";
        }, function (module2, exports2) {
          module2.exports = "gameobjectout";
        }, function (module2, exports2) {
          module2.exports = "gameobjectover";
        }, function (module2, exports2) {
          module2.exports = "pointerdown";
        }, function (module2, exports2) {
          module2.exports = "pointermove";
        }, function (module2, exports2) {
          module2.exports = "pointerout";
        }, function (module2, exports2) {
          module2.exports = "pointerover";
        }, function (module2, exports2) {
          module2.exports = "pointerup";
        }, function (module2, exports2) {
          module2.exports = "wheel";
        }, function (module2, exports2) {
          module2.exports = "gameobjectup";
        }, function (module2, exports2) {
          module2.exports = "gameobjectwheel";
        }, function (module2, exports2) {
          module2.exports = "boot";
        }, function (module2, exports2) {
          module2.exports = "process";
        }, function (module2, exports2) {
          module2.exports = "update";
        }, function (module2, exports2) {
          module2.exports = "pointerdown";
        }, function (module2, exports2) {
          module2.exports = "pointerdownoutside";
        }, function (module2, exports2) {
          module2.exports = "pointermove";
        }, function (module2, exports2) {
          module2.exports = "pointerout";
        }, function (module2, exports2) {
          module2.exports = "pointerover";
        }, function (module2, exports2) {
          module2.exports = "pointerup";
        }, function (module2, exports2) {
          module2.exports = "pointerupoutside";
        }, function (module2, exports2) {
          module2.exports = "wheel";
        }, function (module2, exports2) {
          module2.exports = "pointerlockchange";
        }, function (module2, exports2) {
          module2.exports = "preupdate";
        }, function (module2, exports2) {
          module2.exports = "shutdown";
        }, function (module2, exports2) {
          module2.exports = "start";
        }, function (module2, exports2) {
          module2.exports = "update";
        }, function (module2, exports2) {
          module2.exports = "addfile";
        }, function (module2, exports2) {
          module2.exports = "complete";
        }, function (module2, exports2) {
          module2.exports = "filecomplete";
        }, function (module2, exports2) {
          module2.exports = "filecomplete-";
        }, function (module2, exports2) {
          module2.exports = "loaderror";
        }, function (module2, exports2) {
          module2.exports = "load";
        }, function (module2, exports2) {
          module2.exports = "fileprogress";
        }, function (module2, exports2) {
          module2.exports = "postprocess";
        }, function (module2, exports2) {
          module2.exports = "progress";
        }, function (module2, exports2) {
          module2.exports = "start";
        }, function (module2, exports2, __webpack_require__) {
          var InjectionMap = {
            game: "game",
            renderer: "renderer",
            anims: "anims",
            cache: "cache",
            plugins: "plugins",
            registry: "registry",
            scale: "scale",
            sound: "sound",
            textures: "textures",
            events: "events",
            cameras: "cameras",
            add: "add",
            make: "make",
            scenePlugin: "scene",
            displayList: "children",
            lights: "lights",
            data: "data",
            input: "input",
            load: "load",
            time: "time",
            tweens: "tweens",
            arcadePhysics: "physics",
            impactPhysics: "impact",
            matterPhysics: "matter"
          };
          if (false) {}
          if (false) {}
          module2.exports = InjectionMap;
        }, function (module2, exports2) {
          var AtlasXML = function (texture, sourceIndex, xml) {
            if (!xml.getElementsByTagName("TextureAtlas")) {
              console.warn("Invalid Texture Atlas XML given");
              return;
            }
            var source = texture.source[sourceIndex];
            texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
            var frames = xml.getElementsByTagName("SubTexture");
            var newFrame;
            for (var i = 0; i < frames.length; i++) {
              var frame = frames[i].attributes;
              var name = frame.name.value;
              var x = parseInt(frame.x.value, 10);
              var y = parseInt(frame.y.value, 10);
              var width = parseInt(frame.width.value, 10);
              var height = parseInt(frame.height.value, 10);
              newFrame = texture.add(name, sourceIndex, x, y, width, height);
              if (frame.frameX) {
                var frameX = Math.abs(parseInt(frame.frameX.value, 10));
                var frameY = Math.abs(parseInt(frame.frameY.value, 10));
                var frameWidth = parseInt(frame.frameWidth.value, 10);
                var frameHeight = parseInt(frame.frameHeight.value, 10);
                newFrame.setTrim(width, height, frameX, frameY, frameWidth, frameHeight);
              }
            }
            return texture;
          };
          module2.exports = AtlasXML;
        }, function (module2, exports2) {
          var Canvas = function (texture, sourceIndex) {
            var source = texture.source[sourceIndex];
            texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
            return texture;
          };
          module2.exports = Canvas;
        }, function (module2, exports2) {
          var Image2 = function (texture, sourceIndex) {
            var source = texture.source[sourceIndex];
            texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
            return texture;
          };
          module2.exports = Image2;
        }, function (module2, exports2, __webpack_require__) {
          var Clone = __webpack_require__(77);
          var JSONArray = function (texture, sourceIndex, json) {
            if (!json["frames"] && !json["textures"]) {
              console.warn("Invalid Texture Atlas JSON Array");
              return;
            }
            var source = texture.source[sourceIndex];
            texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
            var frames = Array.isArray(json.textures) ? json.textures[sourceIndex].frames : json.frames;
            var newFrame;
            for (var i = 0; i < frames.length; i++) {
              var src = frames[i];
              newFrame = texture.add(src.filename, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);
              if (src.trimmed) {
                newFrame.setTrim(src.sourceSize.w, src.sourceSize.h, src.spriteSourceSize.x, src.spriteSourceSize.y, src.spriteSourceSize.w, src.spriteSourceSize.h);
              }
              if (src.rotated) {
                newFrame.rotated = true;
                newFrame.updateUVsInverted();
              }
              var pivot = src.anchor || src.pivot;
              if (pivot) {
                newFrame.customPivot = true;
                newFrame.pivotX = pivot.x;
                newFrame.pivotY = pivot.y;
              }
              newFrame.customData = Clone(src);
            }
            for (var dataKey in json) {
              if (dataKey === "frames") {
                continue;
              }
              if (Array.isArray(json[dataKey])) {
                texture.customData[dataKey] = json[dataKey].slice(0);
              } else {
                texture.customData[dataKey] = json[dataKey];
              }
            }
            return texture;
          };
          module2.exports = JSONArray;
        }, function (module2, exports2, __webpack_require__) {
          var Clone = __webpack_require__(77);
          var JSONHash = function (texture, sourceIndex, json) {
            if (!json["frames"]) {
              console.warn("Invalid Texture Atlas JSON Hash given, missing 'frames' Object");
              return;
            }
            var source = texture.source[sourceIndex];
            texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
            var frames = json.frames;
            var newFrame;
            for (var key in frames) {
              if (!frames.hasOwnProperty(key)) {
                continue;
              }
              var src = frames[key];
              newFrame = texture.add(key, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);
              if (src.trimmed) {
                newFrame.setTrim(src.sourceSize.w, src.sourceSize.h, src.spriteSourceSize.x, src.spriteSourceSize.y, src.spriteSourceSize.w, src.spriteSourceSize.h);
              }
              if (src.rotated) {
                newFrame.rotated = true;
                newFrame.updateUVsInverted();
              }
              var pivot = src.anchor || src.pivot;
              if (pivot) {
                newFrame.customPivot = true;
                newFrame.pivotX = pivot.x;
                newFrame.pivotY = pivot.y;
              }
              newFrame.customData = Clone(src);
            }
            for (var dataKey in json) {
              if (dataKey === "frames") {
                continue;
              }
              if (Array.isArray(json[dataKey])) {
                texture.customData[dataKey] = json[dataKey].slice(0);
              } else {
                texture.customData[dataKey] = json[dataKey];
              }
            }
            return texture;
          };
          module2.exports = JSONHash;
        }, function (module2, exports2, __webpack_require__) {
          var GetFastValue = __webpack_require__(2);
          var SpriteSheet = function (texture, sourceIndex, x, y, width, height, config) {
            var frameWidth = GetFastValue(config, "frameWidth", null);
            var frameHeight = GetFastValue(config, "frameHeight", frameWidth);
            if (frameWidth === null) {
              throw new Error("TextureManager.SpriteSheet: Invalid frameWidth given.");
            }
            var source = texture.source[sourceIndex];
            texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
            var startFrame = GetFastValue(config, "startFrame", 0);
            var endFrame = GetFastValue(config, "endFrame", -1);
            var margin = GetFastValue(config, "margin", 0);
            var spacing = GetFastValue(config, "spacing", 0);
            var row = Math.floor((width - margin + spacing) / (frameWidth + spacing));
            var column = Math.floor((height - margin + spacing) / (frameHeight + spacing));
            var total = row * column;
            if (total === 0) {
              console.warn("SpriteSheet frame dimensions will result in zero frames for texture:", texture.key);
            }
            if (startFrame > total || startFrame < -total) {
              startFrame = 0;
            }
            if (startFrame < 0) {
              startFrame = total + startFrame;
            }
            if (endFrame !== -1) {
              total = startFrame + (endFrame + 1);
            }
            var fx = margin;
            var fy = margin;
            var ax = 0;
            var ay = 0;
            for (var i = 0; i < total; i++) {
              ax = 0;
              ay = 0;
              var w = fx + frameWidth;
              var h = fy + frameHeight;
              if (w > width) {
                ax = w - width;
              }
              if (h > height) {
                ay = h - height;
              }
              texture.add(i, sourceIndex, x + fx, y + fy, frameWidth - ax, frameHeight - ay);
              fx += frameWidth + spacing;
              if (fx + frameWidth > width) {
                fx = margin;
                fy += frameHeight + spacing;
              }
            }
            return texture;
          };
          module2.exports = SpriteSheet;
        }, function (module2, exports2, __webpack_require__) {
          var GetFastValue = __webpack_require__(2);
          var SpriteSheetFromAtlas = function (texture, frame, config) {
            var frameWidth = GetFastValue(config, "frameWidth", null);
            var frameHeight = GetFastValue(config, "frameHeight", frameWidth);
            if (!frameWidth) {
              throw new Error("TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.");
            }
            var source = texture.source[0];
            texture.add("__BASE", 0, 0, 0, source.width, source.height);
            var startFrame = GetFastValue(config, "startFrame", 0);
            var endFrame = GetFastValue(config, "endFrame", -1);
            var margin = GetFastValue(config, "margin", 0);
            var spacing = GetFastValue(config, "spacing", 0);
            var x = frame.cutX;
            var y = frame.cutY;
            var cutWidth = frame.cutWidth;
            var cutHeight = frame.cutHeight;
            var sheetWidth = frame.realWidth;
            var sheetHeight = frame.realHeight;
            var row = Math.floor((sheetWidth - margin + spacing) / (frameWidth + spacing));
            var column = Math.floor((sheetHeight - margin + spacing) / (frameHeight + spacing));
            var total = row * column;
            var leftPad = frame.x;
            var leftWidth = frameWidth - leftPad;
            var rightWidth = frameWidth - (sheetWidth - cutWidth - leftPad);
            var topPad = frame.y;
            var topHeight = frameHeight - topPad;
            var bottomHeight = frameHeight - (sheetHeight - cutHeight - topPad);
            if (startFrame > total || startFrame < -total) {
              startFrame = 0;
            }
            if (startFrame < 0) {
              startFrame = total + startFrame;
            }
            if (endFrame !== -1) {
              total = startFrame + (endFrame + 1);
            }
            var sheetFrame;
            var frameX = margin;
            var frameY = margin;
            var frameIndex = 0;
            var sourceIndex = frame.sourceIndex;
            for (var sheetY = 0; sheetY < column; sheetY++) {
              var topRow = sheetY === 0;
              var bottomRow = sheetY === column - 1;
              for (var sheetX = 0; sheetX < row; sheetX++) {
                var leftRow = sheetX === 0;
                var rightRow = sheetX === row - 1;
                sheetFrame = texture.add(frameIndex, sourceIndex, x + frameX, y + frameY, frameWidth, frameHeight);
                if (leftRow || topRow || rightRow || bottomRow) {
                  var destX = leftRow ? leftPad : 0;
                  var destY = topRow ? topPad : 0;
                  var trimWidth = 0;
                  var trimHeight = 0;
                  if (leftRow) {
                    trimWidth += frameWidth - leftWidth;
                  }
                  if (rightRow) {
                    trimWidth += frameWidth - rightWidth;
                  }
                  if (topRow) {
                    trimHeight += frameHeight - topHeight;
                  }
                  if (bottomRow) {
                    trimHeight += frameHeight - bottomHeight;
                  }
                  var destWidth = frameWidth - trimWidth;
                  var destHeight = frameHeight - trimHeight;
                  sheetFrame.cutWidth = destWidth;
                  sheetFrame.cutHeight = destHeight;
                  sheetFrame.setTrim(frameWidth, frameHeight, destX, destY, destWidth, destHeight);
                }
                frameX += spacing;
                if (leftRow) {
                  frameX += leftWidth;
                } else if (rightRow) {
                  frameX += rightWidth;
                } else {
                  frameX += frameWidth;
                }
                frameIndex++;
              }
              frameX = margin;
              frameY += spacing;
              if (topRow) {
                frameY += topHeight;
              } else if (bottomRow) {
                frameY += bottomHeight;
              } else {
                frameY += frameHeight;
              }
            }
            return texture;
          };
          module2.exports = SpriteSheetFromAtlas;
        }, function (module2, exports2) {
          var imageHeight = 0;
          var addFrame = function (texture, sourceIndex, name, frame) {
            var y = imageHeight - frame.y - frame.height;
            texture.add(name, sourceIndex, frame.x, y, frame.width, frame.height);
          };
          var UnityYAML = function (texture, sourceIndex, yaml) {
            var source = texture.source[sourceIndex];
            texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
            imageHeight = source.height;
            var data = yaml.split("\n");
            var lineRegExp = /^[ ]*(- )*(\w+)+[: ]+(.*)/;
            var prevSprite = "";
            var currentSprite = "";
            var rect = {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            };
            for (var i = 0; i < data.length; i++) {
              var results = data[i].match(lineRegExp);
              if (!results) {
                continue;
              }
              var isList = results[1] === "- ";
              var key = results[2];
              var value = results[3];
              if (isList) {
                if (currentSprite !== prevSprite) {
                  addFrame(texture, sourceIndex, currentSprite, rect);
                  prevSprite = currentSprite;
                }
                rect = {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                };
              }
              if (key === "name") {
                currentSprite = value;
                continue;
              }
              switch (key) {
                case "x":
                case "y":
                case "width":
                case "height":
                  rect[key] = parseInt(value, 10);
                  break;
              }
            }
            if (currentSprite !== prevSprite) {
              addFrame(texture, sourceIndex, currentSprite, rect);
            }
            return texture;
          };
          module2.exports = UnityYAML;
        }, function (module2, exports2) {
          module2.exports = "complete";
        }, function (module2, exports2) {
          module2.exports = "decoded";
        }, function (module2, exports2) {
          module2.exports = "decodedall";
        }, function (module2, exports2) {
          module2.exports = "destroy";
        }, function (module2, exports2) {
          module2.exports = "detune";
        }, function (module2, exports2) {
          module2.exports = "detune";
        }, function (module2, exports2) {
          module2.exports = "mute";
        }, function (module2, exports2) {
          module2.exports = "rate";
        }, function (module2, exports2) {
          module2.exports = "volume";
        }, function (module2, exports2) {
          module2.exports = "loop";
        }, function (module2, exports2) {
          module2.exports = "looped";
        }, function (module2, exports2) {
          module2.exports = "mute";
        }, function (module2, exports2) {
          module2.exports = "pan";
        }, function (module2, exports2) {
          module2.exports = "pauseall";
        }, function (module2, exports2) {
          module2.exports = "pause";
        }, function (module2, exports2) {
          module2.exports = "play";
        }, function (module2, exports2) {
          module2.exports = "rate";
        }, function (module2, exports2) {
          module2.exports = "resumeall";
        }, function (module2, exports2) {
          module2.exports = "resume";
        }, function (module2, exports2) {
          module2.exports = "seek";
        }, function (module2, exports2) {
          module2.exports = "stopall";
        }, function (module2, exports2) {
          module2.exports = "stop";
        }, function (module2, exports2) {
          module2.exports = "unlocked";
        }, function (module2, exports2) {
          module2.exports = "volume";
        }, function (module2, exports2, __webpack_require__) {
          var GameObjects = {
            Events: __webpack_require__(75),
            DisplayList: __webpack_require__(1012),
            GameObjectCreator: __webpack_require__(16),
            GameObjectFactory: __webpack_require__(5),
            UpdateList: __webpack_require__(1040),
            Components: __webpack_require__(11),
            GetCalcMatrix: __webpack_require__(19),
            BuildGameObject: __webpack_require__(28),
            BuildGameObjectAnimation: __webpack_require__(439),
            GameObject: __webpack_require__(15),
            BitmapText: __webpack_require__(148),
            Blitter: __webpack_require__(213),
            Bob: __webpack_require__(440),
            Container: __webpack_require__(214),
            DOMElement: __webpack_require__(442),
            DynamicBitmapText: __webpack_require__(215),
            Extern: __webpack_require__(444),
            Graphics: __webpack_require__(216),
            Group: __webpack_require__(113),
            Image: __webpack_require__(125),
            Layer: __webpack_require__(219),
            Particles: __webpack_require__(1074),
            PathFollower: __webpack_require__(457),
            RenderTexture: __webpack_require__(221),
            RetroFont: __webpack_require__(1082),
            Rope: __webpack_require__(223),
            Sprite: __webpack_require__(73),
            Text: __webpack_require__(224),
            GetTextSize: __webpack_require__(458),
            MeasureText: __webpack_require__(460),
            TextStyle: __webpack_require__(459),
            TileSprite: __webpack_require__(225),
            Zone: __webpack_require__(129),
            Video: __webpack_require__(226),
            Shape: __webpack_require__(34),
            Arc: __webpack_require__(461),
            Curve: __webpack_require__(462),
            Ellipse: __webpack_require__(463),
            Grid: __webpack_require__(464),
            IsoBox: __webpack_require__(465),
            IsoTriangle: __webpack_require__(466),
            Line: __webpack_require__(467),
            Polygon: __webpack_require__(468),
            Rectangle: __webpack_require__(473),
            Star: __webpack_require__(474),
            Triangle: __webpack_require__(475),
            Factories: {
              Blitter: __webpack_require__(1130),
              Container: __webpack_require__(1131),
              DOMElement: __webpack_require__(1132),
              DynamicBitmapText: __webpack_require__(1133),
              Extern: __webpack_require__(1134),
              Graphics: __webpack_require__(1135),
              Group: __webpack_require__(1136),
              Image: __webpack_require__(1137),
              Layer: __webpack_require__(1138),
              Particles: __webpack_require__(1139),
              PathFollower: __webpack_require__(1140),
              RenderTexture: __webpack_require__(1141),
              Rope: __webpack_require__(1142),
              Sprite: __webpack_require__(1143),
              StaticBitmapText: __webpack_require__(1144),
              Text: __webpack_require__(1145),
              TileSprite: __webpack_require__(1146),
              Zone: __webpack_require__(1147),
              Video: __webpack_require__(1148),
              Arc: __webpack_require__(1149),
              Curve: __webpack_require__(1150),
              Ellipse: __webpack_require__(1151),
              Grid: __webpack_require__(1152),
              IsoBox: __webpack_require__(1153),
              IsoTriangle: __webpack_require__(1154),
              Line: __webpack_require__(1155),
              Polygon: __webpack_require__(1156),
              Rectangle: __webpack_require__(1157),
              Star: __webpack_require__(1158),
              Triangle: __webpack_require__(1159)
            },
            Creators: {
              Blitter: __webpack_require__(1160),
              Container: __webpack_require__(1161),
              DynamicBitmapText: __webpack_require__(1162),
              Graphics: __webpack_require__(1163),
              Group: __webpack_require__(1164),
              Image: __webpack_require__(1165),
              Layer: __webpack_require__(1166),
              Particles: __webpack_require__(1167),
              RenderTexture: __webpack_require__(1168),
              Rope: __webpack_require__(1169),
              Sprite: __webpack_require__(1170),
              StaticBitmapText: __webpack_require__(1171),
              Text: __webpack_require__(1172),
              TileSprite: __webpack_require__(1173),
              Zone: __webpack_require__(1174),
              Video: __webpack_require__(1175)
            }
          };
          if (true) {
            GameObjects.Shader = __webpack_require__(229);
            GameObjects.Mesh = __webpack_require__(230);
            GameObjects.PointLight = __webpack_require__(150);
            GameObjects.Factories.Shader = __webpack_require__(1184);
            GameObjects.Factories.Mesh = __webpack_require__(1185);
            GameObjects.Factories.PointLight = __webpack_require__(1186);
            GameObjects.Creators.Shader = __webpack_require__(1187);
            GameObjects.Creators.Mesh = __webpack_require__(1188);
            GameObjects.Creators.PointLight = __webpack_require__(1189);
            GameObjects.Light = __webpack_require__(481);
            GameObjects.LightsManager = __webpack_require__(482);
            GameObjects.LightsPlugin = __webpack_require__(1190);
          }
          module2.exports = GameObjects;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var List = __webpack_require__(110);
          var PluginCache = __webpack_require__(24);
          var GameObjectEvents = __webpack_require__(75);
          var SceneEvents = __webpack_require__(20);
          var StableSort = __webpack_require__(79);
          var DisplayList = new Class({
            Extends: List,
            initialize: function DisplayList2(scene) {
              List.call(this, scene);
              this.sortChildrenFlag = false;
              this.scene = scene;
              this.systems = scene.sys;
              this.events = scene.sys.events;
              this.addCallback = this.addChildCallback;
              this.removeCallback = this.removeChildCallback;
              this.events.once(SceneEvents.BOOT, this.boot, this);
              this.events.on(SceneEvents.START, this.start, this);
            },
            boot: function () {
              this.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            addChildCallback: function (gameObject) {
              if (gameObject.displayList && gameObject.displayList !== this) {
                gameObject.removeFromDisplayList();
              }
              if (!gameObject.displayList) {
                this.queueDepthSort();
                gameObject.displayList = this;
                gameObject.emit(GameObjectEvents.ADDED_TO_SCENE, gameObject, this.scene);
                this.events.emit(SceneEvents.ADDED_TO_SCENE, gameObject, this.scene);
              }
            },
            removeChildCallback: function (gameObject) {
              this.queueDepthSort();
              gameObject.displayList = null;
              gameObject.emit(GameObjectEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
              this.events.emit(SceneEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
            },
            start: function () {
              this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            queueDepthSort: function () {
              this.sortChildrenFlag = true;
            },
            depthSort: function () {
              if (this.sortChildrenFlag) {
                StableSort(this.list, this.sortByDepth);
                this.sortChildrenFlag = false;
              }
            },
            sortByDepth: function (childA, childB) {
              return childA._depth - childB._depth;
            },
            getChildren: function () {
              return this.list;
            },
            shutdown: function () {
              var list = this.list;
              var i = list.length;
              while (i--) {
                list[i].destroy(true);
              }
              list.length = 0;
              this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function () {
              this.shutdown();
              this.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
              this.events = null;
            }
          });
          PluginCache.register("DisplayList", DisplayList, "displayList");
          module2.exports = DisplayList;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            CheckMatrix: __webpack_require__(209),
            MatrixToString: __webpack_require__(1014),
            ReverseColumns: __webpack_require__(1015),
            ReverseRows: __webpack_require__(1016),
            Rotate180: __webpack_require__(1017),
            RotateLeft: __webpack_require__(1018),
            RotateMatrix: __webpack_require__(147),
            RotateRight: __webpack_require__(1019),
            Translate: __webpack_require__(1020),
            TransposeMatrix: __webpack_require__(435)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Pad = __webpack_require__(186);
          var CheckMatrix = __webpack_require__(209);
          var MatrixToString = function (matrix) {
            var str = "";
            if (!CheckMatrix(matrix)) {
              return str;
            }
            for (var r = 0; r < matrix.length; r++) {
              for (var c = 0; c < matrix[r].length; c++) {
                var cell = matrix[r][c].toString();
                if (cell !== "undefined") {
                  str += Pad(cell, 2);
                } else {
                  str += "?";
                }
                if (c < matrix[r].length - 1) {
                  str += " |";
                }
              }
              if (r < matrix.length - 1) {
                str += "\n";
                for (var i = 0; i < matrix[r].length; i++) {
                  str += "---";
                  if (i < matrix[r].length - 1) {
                    str += "+";
                  }
                }
                str += "\n";
              }
            }
            return str;
          };
          module2.exports = MatrixToString;
        }, function (module2, exports2) {
          var ReverseColumns = function (matrix) {
            return matrix.reverse();
          };
          module2.exports = ReverseColumns;
        }, function (module2, exports2) {
          var ReverseRows = function (matrix) {
            for (var i = 0; i < matrix.length; i++) {
              matrix[i].reverse();
            }
            return matrix;
          };
          module2.exports = ReverseRows;
        }, function (module2, exports2, __webpack_require__) {
          var RotateMatrix = __webpack_require__(147);
          var Rotate180 = function (matrix) {
            return RotateMatrix(matrix, 180);
          };
          module2.exports = Rotate180;
        }, function (module2, exports2, __webpack_require__) {
          var RotateMatrix = __webpack_require__(147);
          var RotateLeft = function (matrix) {
            return RotateMatrix(matrix, 90);
          };
          module2.exports = RotateLeft;
        }, function (module2, exports2, __webpack_require__) {
          var RotateMatrix = __webpack_require__(147);
          var RotateRight = function (matrix) {
            return RotateMatrix(matrix, -90);
          };
          module2.exports = RotateRight;
        }, function (module2, exports2, __webpack_require__) {
          var RotateLeft = __webpack_require__(178);
          var RotateRight = __webpack_require__(179);
          var TranslateMatrix = function (matrix, x, y) {
            if (x === void 0) {
              x = 0;
            }
            if (y === void 0) {
              y = 0;
            }
            if (y !== 0) {
              if (y < 0) {
                RotateLeft(matrix, Math.abs(y));
              } else {
                RotateRight(matrix, y);
              }
            }
            if (x !== 0) {
              for (var i = 0; i < matrix.length; i++) {
                var row = matrix[i];
                if (x < 0) {
                  RotateLeft(row, Math.abs(x));
                } else {
                  RotateRight(row, x);
                }
              }
            }
            return matrix;
          };
          module2.exports = TranslateMatrix;
        }, function (module2, exports2) {
          var Add = function (array, item, limit, callback, context) {
            if (context === void 0) {
              context = array;
            }
            if (limit > 0) {
              var remaining = limit - array.length;
              if (remaining <= 0) {
                return null;
              }
            }
            if (!Array.isArray(item)) {
              if (array.indexOf(item) === -1) {
                array.push(item);
                if (callback) {
                  callback.call(context, item);
                }
                return item;
              } else {
                return null;
              }
            }
            var itemLength = item.length - 1;
            while (itemLength >= 0) {
              if (array.indexOf(item[itemLength]) !== -1) {
                item.splice(itemLength, 1);
              }
              itemLength--;
            }
            itemLength = item.length;
            if (itemLength === 0) {
              return null;
            }
            if (limit > 0 && itemLength > remaining) {
              item.splice(remaining);
              itemLength = remaining;
            }
            for (var i = 0; i < itemLength; i++) {
              var entry = item[i];
              array.push(entry);
              if (callback) {
                callback.call(context, entry);
              }
            }
            return item;
          };
          module2.exports = Add;
        }, function (module2, exports2) {
          var AddAt = function (array, item, index, limit, callback, context) {
            if (index === void 0) {
              index = 0;
            }
            if (context === void 0) {
              context = array;
            }
            if (limit > 0) {
              var remaining = limit - array.length;
              if (remaining <= 0) {
                return null;
              }
            }
            if (!Array.isArray(item)) {
              if (array.indexOf(item) === -1) {
                array.splice(index, 0, item);
                if (callback) {
                  callback.call(context, item);
                }
                return item;
              } else {
                return null;
              }
            }
            var itemLength = item.length - 1;
            while (itemLength >= 0) {
              if (array.indexOf(item[itemLength]) !== -1) {
                item.pop();
              }
              itemLength--;
            }
            itemLength = item.length;
            if (itemLength === 0) {
              return null;
            }
            if (limit > 0 && itemLength > remaining) {
              item.splice(remaining);
              itemLength = remaining;
            }
            for (var i = itemLength - 1; i >= 0; i--) {
              var entry = item[i];
              array.splice(index, 0, entry);
              if (callback) {
                callback.call(context, entry);
              }
            }
            return item;
          };
          module2.exports = AddAt;
        }, function (module2, exports2) {
          var BringToTop = function (array, item) {
            var currentIndex = array.indexOf(item);
            if (currentIndex !== -1 && currentIndex < array.length) {
              array.splice(currentIndex, 1);
              array.push(item);
            }
            return item;
          };
          module2.exports = BringToTop;
        }, function (module2, exports2, __webpack_require__) {
          var SafeRange = __webpack_require__(78);
          var CountAllMatching = function (array, property, value, startIndex, endIndex) {
            if (startIndex === void 0) {
              startIndex = 0;
            }
            if (endIndex === void 0) {
              endIndex = array.length;
            }
            var total = 0;
            if (SafeRange(array, startIndex, endIndex)) {
              for (var i = startIndex; i < endIndex; i++) {
                var child = array[i];
                if (child[property] === value) {
                  total++;
                }
              }
            }
            return total;
          };
          module2.exports = CountAllMatching;
        }, function (module2, exports2) {
          var Each = function (array, callback, context) {
            var i;
            var args = [null];
            for (i = 3; i < arguments.length; i++) {
              args.push(arguments[i]);
            }
            for (i = 0; i < array.length; i++) {
              args[0] = array[i];
              callback.apply(context, args);
            }
            return array;
          };
          module2.exports = Each;
        }, function (module2, exports2, __webpack_require__) {
          var SafeRange = __webpack_require__(78);
          var EachInRange = function (array, callback, context, startIndex, endIndex) {
            if (startIndex === void 0) {
              startIndex = 0;
            }
            if (endIndex === void 0) {
              endIndex = array.length;
            }
            if (SafeRange(array, startIndex, endIndex)) {
              var i;
              var args = [null];
              for (i = 5; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              for (i = startIndex; i < endIndex; i++) {
                args[0] = array[i];
                callback.apply(context, args);
              }
            }
            return array;
          };
          module2.exports = EachInRange;
        }, function (module2, exports2) {
          var MoveDown = function (array, item) {
            var currentIndex = array.indexOf(item);
            if (currentIndex > 0) {
              var item2 = array[currentIndex - 1];
              var index2 = array.indexOf(item2);
              array[currentIndex] = item2;
              array[index2] = item;
            }
            return array;
          };
          module2.exports = MoveDown;
        }, function (module2, exports2) {
          var MoveTo = function (array, item, index) {
            var currentIndex = array.indexOf(item);
            if (currentIndex === -1 || index < 0 || index >= array.length) {
              throw new Error("Supplied index out of bounds");
            }
            if (currentIndex !== index) {
              array.splice(currentIndex, 1);
              array.splice(index, 0, item);
            }
            return item;
          };
          module2.exports = MoveTo;
        }, function (module2, exports2) {
          var MoveUp = function (array, item) {
            var currentIndex = array.indexOf(item);
            if (currentIndex !== -1 && currentIndex < array.length - 1) {
              var item2 = array[currentIndex + 1];
              var index2 = array.indexOf(item2);
              array[currentIndex] = item2;
              array[index2] = item;
            }
            return array;
          };
          module2.exports = MoveUp;
        }, function (module2, exports2) {
          var MoveAbove = function (array, item1, item2) {
            if (item1 === item2) {
              return array;
            }
            var currentIndex = array.indexOf(item1);
            var baseIndex = array.indexOf(item2);
            if (currentIndex < 0 || baseIndex < 0) {
              throw new Error("Supplied items must be elements of the same array");
            }
            if (currentIndex > baseIndex) {
              return array;
            }
            array.splice(currentIndex, 1);
            if (baseIndex === array.length - 1) {
              array.push(item1);
            } else {
              array.splice(baseIndex, 0, item1);
            }
            return array;
          };
          module2.exports = MoveAbove;
        }, function (module2, exports2) {
          var MoveBelow = function (array, item1, item2) {
            if (item1 === item2) {
              return array;
            }
            var currentIndex = array.indexOf(item1);
            var baseIndex = array.indexOf(item2);
            if (currentIndex < 0 || baseIndex < 0) {
              throw new Error("Supplied items must be elements of the same array");
            }
            if (currentIndex < baseIndex) {
              return array;
            }
            array.splice(currentIndex, 1);
            if (baseIndex === 0) {
              array.unshift(item1);
            } else {
              array.splice(baseIndex, 0, item1);
            }
            return array;
          };
          module2.exports = MoveBelow;
        }, function (module2, exports2, __webpack_require__) {
          var RoundAwayFromZero = __webpack_require__(363);
          var NumberArrayStep = function (start, end, step) {
            if (start === void 0) {
              start = 0;
            }
            if (end === void 0) {
              end = null;
            }
            if (step === void 0) {
              step = 1;
            }
            if (end === null) {
              end = start;
              start = 0;
            }
            var result = [];
            var total = Math.max(RoundAwayFromZero((end - start) / (step || 1)), 0);
            for (var i = 0; i < total; i++) {
              result.push(start);
              start += step;
            }
            return result;
          };
          module2.exports = NumberArrayStep;
        }, function (module2, exports2, __webpack_require__) {
          var SpliceOne = __webpack_require__(74);
          var RemoveAt = function (array, index, callback, context) {
            if (context === void 0) {
              context = array;
            }
            if (index < 0 || index > array.length - 1) {
              throw new Error("Index out of bounds");
            }
            var item = SpliceOne(array, index);
            if (callback) {
              callback.call(context, item);
            }
            return item;
          };
          module2.exports = RemoveAt;
        }, function (module2, exports2, __webpack_require__) {
          var SafeRange = __webpack_require__(78);
          var RemoveBetween = function (array, startIndex, endIndex, callback, context) {
            if (startIndex === void 0) {
              startIndex = 0;
            }
            if (endIndex === void 0) {
              endIndex = array.length;
            }
            if (context === void 0) {
              context = array;
            }
            if (SafeRange(array, startIndex, endIndex)) {
              var size = endIndex - startIndex;
              var removed = array.splice(startIndex, size);
              if (callback) {
                for (var i = 0; i < removed.length; i++) {
                  var entry = removed[i];
                  callback.call(context, entry);
                }
              }
              return removed;
            } else {
              return [];
            }
          };
          module2.exports = RemoveBetween;
        }, function (module2, exports2, __webpack_require__) {
          var SpliceOne = __webpack_require__(74);
          var RemoveRandomElement = function (array, start, length) {
            if (start === void 0) {
              start = 0;
            }
            if (length === void 0) {
              length = array.length;
            }
            var randomIndex = start + Math.floor(Math.random() * length);
            return SpliceOne(array, randomIndex);
          };
          module2.exports = RemoveRandomElement;
        }, function (module2, exports2) {
          var Replace = function (array, oldChild, newChild) {
            var index1 = array.indexOf(oldChild);
            var index2 = array.indexOf(newChild);
            if (index1 !== -1 && index2 === -1) {
              array[index1] = newChild;
              return true;
            } else {
              return false;
            }
          };
          module2.exports = Replace;
        }, function (module2, exports2) {
          var SendToBack = function (array, item) {
            var currentIndex = array.indexOf(item);
            if (currentIndex !== -1 && currentIndex > 0) {
              array.splice(currentIndex, 1);
              array.unshift(item);
            }
            return item;
          };
          module2.exports = SendToBack;
        }, function (module2, exports2, __webpack_require__) {
          var SafeRange = __webpack_require__(78);
          var SetAll = function (array, property, value, startIndex, endIndex) {
            if (startIndex === void 0) {
              startIndex = 0;
            }
            if (endIndex === void 0) {
              endIndex = array.length;
            }
            if (SafeRange(array, startIndex, endIndex)) {
              for (var i = startIndex; i < endIndex; i++) {
                var entry = array[i];
                if (entry.hasOwnProperty(property)) {
                  entry[property] = value;
                }
              }
            }
            return array;
          };
          module2.exports = SetAll;
        }, function (module2, exports2) {
          var Swap = function (array, item1, item2) {
            if (item1 === item2) {
              return array;
            }
            var index1 = array.indexOf(item1);
            var index2 = array.indexOf(item2);
            if (index1 < 0 || index2 < 0) {
              throw new Error("Supplied items must be elements of the same array");
            }
            array[index1] = item2;
            array[index2] = item1;
            return array;
          };
          module2.exports = Swap;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var ProcessQueue = __webpack_require__(211);
          var PluginCache = __webpack_require__(24);
          var SceneEvents = __webpack_require__(20);
          var UpdateList = new Class({
            Extends: ProcessQueue,
            initialize: function UpdateList2(scene) {
              ProcessQueue.call(this);
              this.checkQueue = true;
              this.scene = scene;
              this.systems = scene.sys;
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              scene.sys.events.on(SceneEvents.START, this.start, this);
            },
            boot: function () {
              this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            start: function () {
              var eventEmitter = this.systems.events;
              eventEmitter.on(SceneEvents.PRE_UPDATE, this.update, this);
              eventEmitter.on(SceneEvents.UPDATE, this.sceneUpdate, this);
              eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            sceneUpdate: function (time, delta) {
              var list = this._active;
              var length = list.length;
              for (var i = 0; i < length; i++) {
                var gameObject = list[i];
                if (gameObject.active) {
                  gameObject.preUpdate.call(gameObject, time, delta);
                }
              }
            },
            shutdown: function () {
              var i = this._active.length;
              while (i--) {
                this._active[i].destroy(true);
              }
              i = this._pending.length;
              while (i--) {
                this._pending[i].destroy(true);
              }
              i = this._destroy.length;
              while (i--) {
                this._destroy[i].destroy(true);
              }
              this._toProcess = 0;
              this._pending = [];
              this._active = [];
              this._destroy = [];
              this.removeAllListeners();
              var eventEmitter = this.systems.events;
              eventEmitter.off(SceneEvents.PRE_UPDATE, this.update, this);
              eventEmitter.off(SceneEvents.UPDATE, this.sceneUpdate, this);
              eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function () {
              this.shutdown();
              this.systems.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
            }
          });
          PluginCache.register("UpdateList", UpdateList, "updateList");
          module2.exports = UpdateList;
        }, function (module2, exports2) {
          module2.exports = "add";
        }, function (module2, exports2) {
          module2.exports = "remove";
        }, function (module2, exports2) {
          var GetBitmapTextSize = function (src, round, updateOrigin, out) {
            if (updateOrigin === void 0) {
              updateOrigin = false;
            }
            if (out === void 0) {
              out = {
                local: {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                },
                global: {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                },
                lines: {
                  shortest: 0,
                  longest: 0,
                  lengths: null,
                  height: 0
                },
                wrappedText: "",
                words: [],
                characters: [],
                scaleX: 0,
                scaleY: 0
              };
              return out;
            }
            var text = src.text;
            var textLength = text.length;
            var maxWidth = src.maxWidth;
            var wordWrapCharCode = src.wordWrapCharCode;
            var bx = Number.MAX_VALUE;
            var by = Number.MAX_VALUE;
            var bw = 0;
            var bh = 0;
            var chars = src.fontData.chars;
            var lineHeight = src.fontData.lineHeight;
            var letterSpacing = src.letterSpacing;
            var xAdvance = 0;
            var yAdvance = 0;
            var charCode = 0;
            var glyph = null;
            var align = src._align;
            var x = 0;
            var y = 0;
            var scale = src.fontSize / src.fontData.size;
            var sx = scale * src.scaleX;
            var sy = scale * src.scaleY;
            var lastGlyph = null;
            var lastCharCode = 0;
            var lineWidths = [];
            var shortestLine = Number.MAX_VALUE;
            var longestLine = 0;
            var currentLine = 0;
            var currentLineWidth = 0;
            var i;
            var words = [];
            var characters = [];
            var current = null;
            if (maxWidth > 0) {
              for (i = 0; i < textLength; i++) {
                charCode = text.charCodeAt(i);
                if (charCode === 10) {
                  if (current !== null) {
                    words.push({
                      word: current.word,
                      i: current.i,
                      x: current.x * sx,
                      y: current.y * sy,
                      w: current.w * sx,
                      h: current.h * sy,
                      cr: true
                    });
                    current = null;
                  }
                  xAdvance = 0;
                  yAdvance += lineHeight;
                  lastGlyph = null;
                  continue;
                }
                glyph = chars[charCode];
                if (!glyph) {
                  continue;
                }
                if (lastGlyph !== null) {
                  var glyphKerningOffset = glyph.kerning[lastCharCode];
                }
                if (charCode === wordWrapCharCode) {
                  if (current !== null) {
                    words.push({
                      word: current.word,
                      i: current.i,
                      x: current.x * sx,
                      y: current.y * sy,
                      w: current.w * sx,
                      h: current.h * sy,
                      cr: false
                    });
                    current = null;
                  }
                } else {
                  if (current === null) {
                    current = {
                      word: "",
                      i,
                      x: xAdvance,
                      y: yAdvance,
                      w: 0,
                      h: lineHeight,
                      cr: false
                    };
                  }
                  current.word = current.word.concat(text[i]);
                  current.w += glyph.xOffset + glyph.xAdvance + (glyphKerningOffset !== void 0 ? glyphKerningOffset : 0);
                }
                xAdvance += glyph.xAdvance + letterSpacing;
                lastGlyph = glyph;
                lastCharCode = charCode;
              }
              if (current !== null) {
                words.push({
                  word: current.word,
                  i: current.i,
                  x: current.x * sx,
                  y: current.y * sy,
                  w: current.w * sx,
                  h: current.h * sy,
                  cr: false
                });
              }
              xAdvance = 0;
              yAdvance = 0;
              lastGlyph = null;
              lastCharCode = 0;
              var prev;
              var offset = 0;
              var crs = [];
              for (i = 0; i < words.length; i++) {
                var entry = words[i];
                var left = entry.x;
                var right = entry.x + entry.w;
                if (prev) {
                  var diff = left - (prev.x + prev.w);
                  offset = left - (diff + prev.w);
                  prev = null;
                }
                var checkLeft = left - offset;
                var checkRight = right - offset;
                if (checkLeft > maxWidth || checkRight > maxWidth) {
                  crs.push(entry.i - 1);
                  if (entry.cr) {
                    crs.push(entry.i + entry.word.length);
                    offset = 0;
                    prev = null;
                  } else {
                    prev = entry;
                  }
                } else if (entry.cr) {
                  crs.push(entry.i + entry.word.length);
                  offset = 0;
                  prev = null;
                }
              }
              var stringInsert = function (str, index, value) {
                return str.substr(0, index) + value + str.substr(index + 1);
              };
              for (i = crs.length - 1; i >= 0; i--) {
                text = stringInsert(text, crs[i], "\n");
              }
              out.wrappedText = text;
              textLength = text.length;
              words = [];
              current = null;
            }
            var charIndex = 0;
            for (i = 0; i < textLength; i++) {
              charCode = text.charCodeAt(i);
              if (charCode === 10) {
                if (current !== null) {
                  words.push({
                    word: current.word,
                    i: current.i,
                    x: current.x * sx,
                    y: current.y * sy,
                    w: current.w * sx,
                    h: current.h * sy
                  });
                  current = null;
                }
                xAdvance = 0;
                yAdvance += lineHeight;
                lastGlyph = null;
                lineWidths[currentLine] = currentLineWidth;
                if (currentLineWidth > longestLine) {
                  longestLine = currentLineWidth;
                }
                if (currentLineWidth < shortestLine) {
                  shortestLine = currentLineWidth;
                }
                currentLine++;
                currentLineWidth = 0;
                continue;
              }
              glyph = chars[charCode];
              if (!glyph) {
                continue;
              }
              x = xAdvance;
              y = yAdvance;
              if (lastGlyph !== null) {
                var kerningOffset = glyph.kerning[lastCharCode];
                x += kerningOffset !== void 0 ? kerningOffset : 0;
              }
              if (bx > x) {
                bx = x;
              }
              if (by > y) {
                by = y;
              }
              var gw = x + glyph.xAdvance;
              var gh = y + lineHeight;
              if (bw < gw) {
                bw = gw;
              }
              if (bh < gh) {
                bh = gh;
              }
              var charWidth = glyph.xOffset + glyph.xAdvance + (kerningOffset !== void 0 ? kerningOffset : 0);
              if (charCode === wordWrapCharCode) {
                if (current !== null) {
                  words.push({
                    word: current.word,
                    i: current.i,
                    x: current.x * sx,
                    y: current.y * sy,
                    w: current.w * sx,
                    h: current.h * sy
                  });
                  current = null;
                }
              } else {
                if (current === null) {
                  current = {
                    word: "",
                    i: charIndex,
                    x: xAdvance,
                    y: yAdvance,
                    w: 0,
                    h: lineHeight
                  };
                }
                current.word = current.word.concat(text[i]);
                current.w += charWidth;
              }
              characters.push({
                i: charIndex,
                char: text[i],
                code: charCode,
                x: (glyph.xOffset + xAdvance) * scale,
                y: (glyph.yOffset + yAdvance) * scale,
                w: glyph.width * scale,
                h: glyph.height * scale,
                t: yAdvance * scale,
                r: gw * scale,
                b: lineHeight * scale,
                line: currentLine,
                glyph
              });
              xAdvance += glyph.xAdvance + letterSpacing;
              lastGlyph = glyph;
              lastCharCode = charCode;
              currentLineWidth = gw * scale;
              charIndex++;
            }
            if (current !== null) {
              words.push({
                word: current.word,
                i: current.i,
                x: current.x * sx,
                y: current.y * sy,
                w: current.w * sx,
                h: current.h * sy
              });
            }
            lineWidths[currentLine] = currentLineWidth;
            if (currentLineWidth > longestLine) {
              longestLine = currentLineWidth;
            }
            if (currentLineWidth < shortestLine) {
              shortestLine = currentLineWidth;
            }
            if (align > 0) {
              for (var c = 0; c < characters.length; c++) {
                var currentChar = characters[c];
                if (align === 1) {
                  var ax1 = (longestLine - lineWidths[currentChar.line]) / 2;
                  currentChar.x += ax1;
                  currentChar.r += ax1;
                } else if (align === 2) {
                  var ax2 = longestLine - lineWidths[currentChar.line];
                  currentChar.x += ax2;
                  currentChar.r += ax2;
                }
              }
            }
            var local = out.local;
            var global = out.global;
            var lines = out.lines;
            local.x = bx * scale;
            local.y = by * scale;
            local.width = bw * scale;
            local.height = bh * scale;
            global.x = src.x - src._displayOriginX + bx * sx;
            global.y = src.y - src._displayOriginY + by * sy;
            global.width = bw * sx;
            global.height = bh * sy;
            lines.shortest = shortestLine;
            lines.longest = longestLine;
            lines.lengths = lineWidths;
            if (round) {
              local.x = Math.ceil(local.x);
              local.y = Math.ceil(local.y);
              local.width = Math.ceil(local.width);
              local.height = Math.ceil(local.height);
              global.x = Math.ceil(global.x);
              global.y = Math.ceil(global.y);
              global.width = Math.ceil(global.width);
              global.height = Math.ceil(global.height);
              lines.shortest = Math.ceil(shortestLine);
              lines.longest = Math.ceil(longestLine);
            }
            if (updateOrigin) {
              src._displayOriginX = src.originX * local.width;
              src._displayOriginY = src.originY * local.height;
              global.x = src.x - src._displayOriginX * src.scaleX;
              global.y = src.y - src._displayOriginY * src.scaleY;
              if (round) {
                global.x = Math.ceil(global.x);
                global.y = Math.ceil(global.y);
              }
            }
            out.words = words;
            out.characters = characters;
            out.lines.height = lineHeight;
            out.scale = scale;
            out.scaleX = src.scaleX;
            out.scaleY = src.scaleY;
            return out;
          };
          module2.exports = GetBitmapTextSize;
        }, function (module2, exports2, __webpack_require__) {
          var ParseXMLBitmapFont = __webpack_require__(212);
          var ParseFromAtlas = function (scene, fontName, textureKey, frameKey, xmlKey, xSpacing, ySpacing) {
            var texture = scene.sys.textures.get(textureKey);
            var frame = texture.get(frameKey);
            var xml = scene.sys.cache.xml.get(xmlKey);
            if (frame && xml) {
              var data = ParseXMLBitmapFont(xml, frame, xSpacing, ySpacing, texture);
              scene.sys.cache.bitmapFont.add(fontName, {
                data,
                texture: textureKey,
                frame: frameKey,
                fromAtlas: true
              });
              return true;
            } else {
              return false;
            }
          };
          module2.exports = ParseFromAtlas;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1046);
          }
          if (true) {
            renderCanvas = __webpack_require__(1048);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var BatchChar = __webpack_require__(1047);
          var GetCalcMatrix = __webpack_require__(19);
          var Utils = __webpack_require__(12);
          var BitmapTextWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            var text = src._text;
            var textLength = text.length;
            if (textLength === 0) {
              return;
            }
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline, src);
            var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
            var roundPixels = camera.roundPixels;
            var cameraAlpha = camera.alpha;
            var charColors = src.charColors;
            var tintEffect = src.tintFill;
            var getTint = Utils.getTintAppendFloatAlpha;
            var tintTL = getTint(src.tintTopLeft, cameraAlpha * src._alphaTL);
            var tintTR = getTint(src.tintTopRight, cameraAlpha * src._alphaTR);
            var tintBL = getTint(src.tintBottomLeft, cameraAlpha * src._alphaBL);
            var tintBR = getTint(src.tintBottomRight, cameraAlpha * src._alphaBR);
            var texture = src.frame.glTexture;
            var textureUnit = pipeline.setGameObject(src);
            var bounds = src.getTextBounds(false);
            var i;
            var char2;
            var glyph;
            var characters = bounds.characters;
            var dropShadowX = src.dropShadowX;
            var dropShadowY = src.dropShadowY;
            var dropShadow = dropShadowX !== 0 || dropShadowY !== 0;
            renderer.pipelines.preBatch(src);
            if (dropShadow) {
              var srcShadowColor = src.dropShadowColor;
              var srcShadowAlpha = src.dropShadowAlpha;
              var shadowTL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTL);
              var shadowTR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTR);
              var shadowBL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBL);
              var shadowBR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBR);
              for (i = 0; i < characters.length; i++) {
                char2 = characters[i];
                glyph = char2.glyph;
                if (char2.code === 32 || glyph.width === 0 || glyph.height === 0) {
                  continue;
                }
                BatchChar(pipeline, src, char2, glyph, dropShadowX, dropShadowY, calcMatrix, roundPixels, shadowTL, shadowTR, shadowBL, shadowBR, 1, texture, textureUnit);
              }
            }
            for (i = 0; i < characters.length; i++) {
              char2 = characters[i];
              glyph = char2.glyph;
              if (char2.code === 32 || glyph.width === 0 || glyph.height === 0) {
                continue;
              }
              if (charColors[char2.i]) {
                var color = charColors[char2.i];
                var charTintEffect = color.tintEffect;
                var charTintTL = getTint(color.tintTL, cameraAlpha * src._alphaTL);
                var charTintTR = getTint(color.tintTR, cameraAlpha * src._alphaTR);
                var charTintBL = getTint(color.tintBL, cameraAlpha * src._alphaBL);
                var charTintBR = getTint(color.tintBR, cameraAlpha * src._alphaBR);
                BatchChar(pipeline, src, char2, glyph, 0, 0, calcMatrix, roundPixels, charTintTL, charTintTR, charTintBL, charTintBR, charTintEffect, texture, textureUnit);
              } else {
                BatchChar(pipeline, src, char2, glyph, 0, 0, calcMatrix, roundPixels, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
              }
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = BitmapTextWebGLRenderer;
        }, function (module2, exports2) {
          var BatchChar = function (pipeline, src, char2, glyph, offsetX, offsetY, calcMatrix, roundPixels, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit) {
            var x = char2.x - src.displayOriginX + offsetX;
            var y = char2.y - src.displayOriginY + offsetY;
            var xw = x + char2.w;
            var yh = y + char2.h;
            var tx0 = calcMatrix.getXRound(x, y, roundPixels);
            var ty0 = calcMatrix.getYRound(x, y, roundPixels);
            var tx1 = calcMatrix.getXRound(x, yh, roundPixels);
            var ty1 = calcMatrix.getYRound(x, yh, roundPixels);
            var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);
            var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);
            var tx3 = calcMatrix.getXRound(xw, y, roundPixels);
            var ty3 = calcMatrix.getYRound(xw, y, roundPixels);
            pipeline.batchQuad(src, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, glyph.u0, glyph.v0, glyph.u1, glyph.v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
          };
          module2.exports = BatchChar;
        }, function (module2, exports2, __webpack_require__) {
          var SetTransform = __webpack_require__(30);
          var BitmapTextCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            var text = src._text;
            var textLength = text.length;
            var ctx = renderer.currentContext;
            if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              return;
            }
            camera.addToRenderList(src);
            var textureFrame = src.fromAtlas ? src.frame : src.texture.frames["__BASE"];
            var chars = src.fontData.chars;
            var lineHeight = src.fontData.lineHeight;
            var letterSpacing = src._letterSpacing;
            var xAdvance = 0;
            var yAdvance = 0;
            var charCode = 0;
            var glyph = null;
            var glyphX = 0;
            var glyphY = 0;
            var glyphW = 0;
            var glyphH = 0;
            var x = 0;
            var y = 0;
            var lastGlyph = null;
            var lastCharCode = 0;
            var image = textureFrame.source.image;
            var textureX = textureFrame.cutX;
            var textureY = textureFrame.cutY;
            var scale = src._fontSize / src.fontData.size;
            var align = src._align;
            var currentLine = 0;
            var lineOffsetX = 0;
            var bounds = src.getTextBounds(false);
            if (src.maxWidth > 0) {
              text = bounds.wrappedText;
              textLength = text.length;
            }
            var lineData = src._bounds.lines;
            if (align === 1) {
              lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;
            } else if (align === 2) {
              lineOffsetX = lineData.longest - lineData.lengths[0];
            }
            ctx.translate(-src.displayOriginX, -src.displayOriginY);
            var roundPixels = camera.roundPixels;
            for (var i = 0; i < textLength; i++) {
              charCode = text.charCodeAt(i);
              if (charCode === 10) {
                currentLine++;
                if (align === 1) {
                  lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;
                } else if (align === 2) {
                  lineOffsetX = lineData.longest - lineData.lengths[currentLine];
                }
                xAdvance = 0;
                yAdvance += lineHeight;
                lastGlyph = null;
                continue;
              }
              glyph = chars[charCode];
              if (!glyph) {
                continue;
              }
              glyphX = textureX + glyph.x;
              glyphY = textureY + glyph.y;
              glyphW = glyph.width;
              glyphH = glyph.height;
              x = glyph.xOffset + xAdvance;
              y = glyph.yOffset + yAdvance;
              if (lastGlyph !== null) {
                var kerningOffset = glyph.kerning[lastCharCode];
                x += kerningOffset !== void 0 ? kerningOffset : 0;
              }
              x *= scale;
              y *= scale;
              x += lineOffsetX;
              xAdvance += glyph.xAdvance + letterSpacing;
              lastGlyph = glyph;
              lastCharCode = charCode;
              if (glyphW === 0 || glyphH === 0 || charCode === 32) {
                continue;
              }
              if (roundPixels) {
                x = Math.round(x);
                y = Math.round(y);
              }
              ctx.save();
              ctx.translate(x, y);
              ctx.scale(scale, scale);
              ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);
              ctx.restore();
            }
            ctx.restore();
          };
          module2.exports = BitmapTextCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1050);
          }
          if (true) {
            renderCanvas = __webpack_require__(1051);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var TransformMatrix = __webpack_require__(25);
          var Utils = __webpack_require__(12);
          var tempMatrix = new TransformMatrix();
          var BlitterWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            var list = src.getRenderList();
            if (list.length === 0) {
              return;
            }
            var alpha = camera.alpha * src.alpha;
            if (alpha === 0) {
              return;
            }
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(this.pipeline, src);
            var cameraScrollX = camera.scrollX * src.scrollFactorX;
            var cameraScrollY = camera.scrollY * src.scrollFactorY;
            var calcMatrix = tempMatrix.copyFrom(camera.matrix);
            if (parentMatrix) {
              calcMatrix.multiplyWithOffset(parentMatrix, -cameraScrollX, -cameraScrollY);
              cameraScrollX = 0;
              cameraScrollY = 0;
            }
            var blitterX = src.x - cameraScrollX;
            var blitterY = src.y - cameraScrollY;
            var prevTextureSourceIndex = -1;
            var tintEffect = false;
            var roundPixels = camera.roundPixels;
            renderer.pipelines.preBatch(src);
            for (var index = 0; index < list.length; index++) {
              var bob = list[index];
              var frame = bob.frame;
              var bobAlpha = bob.alpha * alpha;
              if (bobAlpha === 0) {
                continue;
              }
              var width = frame.width;
              var height = frame.height;
              var x = blitterX + bob.x + frame.x;
              var y = blitterY + bob.y + frame.y;
              if (bob.flipX) {
                width *= -1;
                x += frame.width;
              }
              if (bob.flipY) {
                height *= -1;
                y += frame.height;
              }
              var xw = x + width;
              var yh = y + height;
              var tx0 = calcMatrix.getX(x, y);
              var ty0 = calcMatrix.getY(x, y);
              var tx1 = calcMatrix.getX(xw, yh);
              var ty1 = calcMatrix.getY(xw, yh);
              var tint = Utils.getTintAppendFloatAlpha(bob.tint, bobAlpha);
              if (frame.sourceIndex !== prevTextureSourceIndex) {
                var textureUnit = pipeline.setGameObject(src, frame);
                prevTextureSourceIndex = frame.sourceIndex;
              }
              if (roundPixels) {
                tx0 = Math.round(tx0);
                ty0 = Math.round(ty0);
                tx1 = Math.round(tx1);
                ty1 = Math.round(ty1);
              }
              if (pipeline.batchQuad(src, tx0, ty0, tx0, ty1, tx1, ty1, tx1, ty0, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, tintEffect, frame.glTexture, textureUnit)) {
                prevTextureSourceIndex = -1;
              }
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = BlitterWebGLRenderer;
        }, function (module2, exports2) {
          var BlitterCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            var list = src.getRenderList();
            if (list.length === 0) {
              return;
            }
            var ctx = renderer.currentContext;
            var alpha = camera.alpha * src.alpha;
            if (alpha === 0) {
              return;
            }
            camera.addToRenderList(src);
            ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
            ctx.imageSmoothingEnabled = !(!renderer.antialias || src.frame.source.scaleMode);
            var cameraScrollX = src.x - camera.scrollX * src.scrollFactorX;
            var cameraScrollY = src.y - camera.scrollY * src.scrollFactorY;
            ctx.save();
            if (parentMatrix) {
              parentMatrix.copyToContext(ctx);
            }
            var roundPixels = camera.roundPixels;
            for (var i = 0; i < list.length; i++) {
              var bob = list[i];
              var flip = bob.flipX || bob.flipY;
              var frame = bob.frame;
              var cd = frame.canvasData;
              var dx = frame.x;
              var dy = frame.y;
              var fx = 1;
              var fy = 1;
              var bobAlpha = bob.alpha * alpha;
              if (bobAlpha === 0) {
                continue;
              }
              ctx.globalAlpha = bobAlpha;
              if (!flip) {
                if (roundPixels) {
                  dx = Math.round(dx);
                  dy = Math.round(dy);
                }
                ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, dx + bob.x + cameraScrollX, dy + bob.y + cameraScrollY, cd.width, cd.height);
              } else {
                if (bob.flipX) {
                  fx = -1;
                  dx -= cd.width;
                }
                if (bob.flipY) {
                  fy = -1;
                  dy -= cd.height;
                }
                ctx.save();
                ctx.translate(bob.x + cameraScrollX, bob.y + cameraScrollY);
                ctx.scale(fx, fy);
                ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, dx, dy, cd.width, cd.height);
                ctx.restore();
              }
            }
            ctx.restore();
          };
          module2.exports = BlitterCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1053);
          }
          if (true) {
            renderCanvas = __webpack_require__(1054);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2) {
          var ContainerWebGLRenderer = function (renderer, container, camera, parentMatrix) {
            camera.addToRenderList(container);
            var children = container.list;
            var childCount = children.length;
            if (childCount === 0) {
              return;
            }
            var transformMatrix = container.localTransform;
            if (parentMatrix) {
              transformMatrix.loadIdentity();
              transformMatrix.multiply(parentMatrix);
              transformMatrix.translate(container.x, container.y);
              transformMatrix.rotate(container.rotation);
              transformMatrix.scale(container.scaleX, container.scaleY);
            } else {
              transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY);
            }
            renderer.pipelines.preBatch(container);
            var containerHasBlendMode = container.blendMode !== -1;
            if (!containerHasBlendMode) {
              renderer.setBlendMode(0);
            }
            var alpha = container.alpha;
            var scrollFactorX = container.scrollFactorX;
            var scrollFactorY = container.scrollFactorY;
            for (var i = 0; i < childCount; i++) {
              var child = children[i];
              if (!child.willRender(camera)) {
                continue;
              }
              var childAlphaTopLeft;
              var childAlphaTopRight;
              var childAlphaBottomLeft;
              var childAlphaBottomRight;
              if (child.alphaTopLeft !== void 0) {
                childAlphaTopLeft = child.alphaTopLeft;
                childAlphaTopRight = child.alphaTopRight;
                childAlphaBottomLeft = child.alphaBottomLeft;
                childAlphaBottomRight = child.alphaBottomRight;
              } else {
                var childAlpha = child.alpha;
                childAlphaTopLeft = childAlpha;
                childAlphaTopRight = childAlpha;
                childAlphaBottomLeft = childAlpha;
                childAlphaBottomRight = childAlpha;
              }
              var childScrollFactorX = child.scrollFactorX;
              var childScrollFactorY = child.scrollFactorY;
              if (!containerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
                renderer.setBlendMode(child.blendMode);
              }
              var mask = child.mask;
              if (mask) {
                mask.preRenderWebGL(renderer, child, camera);
              }
              var type = child.type;
              if (type !== renderer.currentType) {
                renderer.newType = true;
                renderer.currentType = type;
              }
              renderer.nextTypeMatch = i < childCount - 1 ? children[i + 1].type === renderer.currentType : false;
              child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY);
              child.setAlpha(childAlphaTopLeft * alpha, childAlphaTopRight * alpha, childAlphaBottomLeft * alpha, childAlphaBottomRight * alpha);
              child.renderWebGL(renderer, child, camera, transformMatrix);
              child.setAlpha(childAlphaTopLeft, childAlphaTopRight, childAlphaBottomLeft, childAlphaBottomRight);
              child.setScrollFactor(childScrollFactorX, childScrollFactorY);
              if (mask) {
                mask.postRenderWebGL(renderer, camera);
              }
              renderer.newType = false;
            }
            renderer.pipelines.postBatch(container);
          };
          module2.exports = ContainerWebGLRenderer;
        }, function (module2, exports2) {
          var ContainerCanvasRenderer = function (renderer, container, camera, parentMatrix) {
            camera.addToRenderList(container);
            var children = container.list;
            if (children.length === 0) {
              return;
            }
            var transformMatrix = container.localTransform;
            if (parentMatrix) {
              transformMatrix.loadIdentity();
              transformMatrix.multiply(parentMatrix);
              transformMatrix.translate(container.x, container.y);
              transformMatrix.rotate(container.rotation);
              transformMatrix.scale(container.scaleX, container.scaleY);
            } else {
              transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY);
            }
            var containerHasBlendMode = container.blendMode !== -1;
            if (!containerHasBlendMode) {
              renderer.setBlendMode(0);
            }
            var alpha = container._alpha;
            var scrollFactorX = container.scrollFactorX;
            var scrollFactorY = container.scrollFactorY;
            if (container.mask) {
              container.mask.preRenderCanvas(renderer, null, camera);
            }
            for (var i = 0; i < children.length; i++) {
              var child = children[i];
              if (!child.willRender(camera)) {
                continue;
              }
              var childAlpha = child.alpha;
              var childScrollFactorX = child.scrollFactorX;
              var childScrollFactorY = child.scrollFactorY;
              if (!containerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
                renderer.setBlendMode(child.blendMode);
              }
              child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY);
              child.setAlpha(childAlpha * alpha);
              child.renderCanvas(renderer, child, camera, transformMatrix);
              child.setAlpha(childAlpha);
              child.setScrollFactor(childScrollFactorX, childScrollFactorY);
            }
            if (container.mask) {
              container.mask.postRenderCanvas(renderer);
            }
          };
          module2.exports = ContainerCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(443);
          }
          if (true) {
            renderCanvas = __webpack_require__(443);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2) {
          module2.exports = ["normal", "multiply", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1058);
          }
          if (true) {
            renderCanvas = __webpack_require__(1059);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var GetCalcMatrix = __webpack_require__(19);
          var TransformMatrix = __webpack_require__(25);
          var Utils = __webpack_require__(12);
          var tempMatrix = new TransformMatrix();
          var DynamicBitmapTextWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            var text = src.text;
            var textLength = text.length;
            if (textLength === 0) {
              return;
            }
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline, src);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            var spriteMatrix = result.sprite;
            var calcMatrix = result.calc;
            var fontMatrix = tempMatrix;
            var crop = src.cropWidth > 0 || src.cropHeight > 0;
            if (crop) {
              pipeline.flush();
              renderer.pushScissor(calcMatrix.tx, calcMatrix.ty, src.cropWidth * calcMatrix.scaleX, src.cropHeight * calcMatrix.scaleY);
            }
            var frame = src.frame;
            var texture = frame.glTexture;
            var tintEffect = src.tintFill;
            var tintTL = Utils.getTintAppendFloatAlpha(src.tintTopLeft, camera.alpha * src._alphaTL);
            var tintTR = Utils.getTintAppendFloatAlpha(src.tintTopRight, camera.alpha * src._alphaTR);
            var tintBL = Utils.getTintAppendFloatAlpha(src.tintBottomLeft, camera.alpha * src._alphaBL);
            var tintBR = Utils.getTintAppendFloatAlpha(src.tintBottomRight, camera.alpha * src._alphaBR);
            var textureUnit = pipeline.setGameObject(src);
            var xAdvance = 0;
            var yAdvance = 0;
            var charCode = 0;
            var lastCharCode = 0;
            var letterSpacing = src.letterSpacing;
            var glyph;
            var glyphW = 0;
            var glyphH = 0;
            var lastGlyph;
            var scrollX = src.scrollX;
            var scrollY = src.scrollY;
            var fontData = src.fontData;
            var chars = fontData.chars;
            var lineHeight = fontData.lineHeight;
            var scale = src.fontSize / fontData.size;
            var rotation = 0;
            var align = src._align;
            var currentLine = 0;
            var lineOffsetX = 0;
            var bounds = src.getTextBounds(false);
            if (src.maxWidth > 0) {
              text = bounds.wrappedText;
              textLength = text.length;
            }
            var lineData = src._bounds.lines;
            if (align === 1) {
              lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;
            } else if (align === 2) {
              lineOffsetX = lineData.longest - lineData.lengths[0];
            }
            var roundPixels = camera.roundPixels;
            var displayCallback = src.displayCallback;
            var callbackData = src.callbackData;
            renderer.pipelines.preBatch(src);
            for (var i = 0; i < textLength; i++) {
              charCode = text.charCodeAt(i);
              if (charCode === 10) {
                currentLine++;
                if (align === 1) {
                  lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;
                } else if (align === 2) {
                  lineOffsetX = lineData.longest - lineData.lengths[currentLine];
                }
                xAdvance = 0;
                yAdvance += lineHeight;
                lastGlyph = null;
                continue;
              }
              glyph = chars[charCode];
              if (!glyph) {
                continue;
              }
              glyphW = glyph.width;
              glyphH = glyph.height;
              var x = glyph.xOffset + xAdvance - scrollX;
              var y = glyph.yOffset + yAdvance - scrollY;
              if (lastGlyph !== null) {
                var kerningOffset = glyph.kerning[lastCharCode];
                x += kerningOffset !== void 0 ? kerningOffset : 0;
              }
              xAdvance += glyph.xAdvance + letterSpacing;
              lastGlyph = glyph;
              lastCharCode = charCode;
              if (glyphW === 0 || glyphH === 0 || charCode === 32) {
                continue;
              }
              scale = src.fontSize / src.fontData.size;
              rotation = 0;
              if (displayCallback) {
                callbackData.color = 0;
                callbackData.tint.topLeft = tintTL;
                callbackData.tint.topRight = tintTR;
                callbackData.tint.bottomLeft = tintBL;
                callbackData.tint.bottomRight = tintBR;
                callbackData.index = i;
                callbackData.charCode = charCode;
                callbackData.x = x;
                callbackData.y = y;
                callbackData.scale = scale;
                callbackData.rotation = rotation;
                callbackData.data = glyph.data;
                var output = displayCallback(callbackData);
                x = output.x;
                y = output.y;
                scale = output.scale;
                rotation = output.rotation;
                if (output.color) {
                  tintTL = output.color;
                  tintTR = output.color;
                  tintBL = output.color;
                  tintBR = output.color;
                } else {
                  tintTL = output.tint.topLeft;
                  tintTR = output.tint.topRight;
                  tintBL = output.tint.bottomLeft;
                  tintBR = output.tint.bottomRight;
                }
                tintTL = Utils.getTintAppendFloatAlpha(tintTL, camera.alpha * src._alphaTL);
                tintTR = Utils.getTintAppendFloatAlpha(tintTR, camera.alpha * src._alphaTR);
                tintBL = Utils.getTintAppendFloatAlpha(tintBL, camera.alpha * src._alphaBL);
                tintBR = Utils.getTintAppendFloatAlpha(tintBR, camera.alpha * src._alphaBR);
              }
              x *= scale;
              y *= scale;
              x -= src.displayOriginX;
              y -= src.displayOriginY;
              x += lineOffsetX;
              fontMatrix.applyITRS(x, y, rotation, scale, scale);
              calcMatrix.multiply(fontMatrix, spriteMatrix);
              var u0 = glyph.u0;
              var v0 = glyph.v0;
              var u1 = glyph.u1;
              var v1 = glyph.v1;
              var xw = glyphW;
              var yh = glyphH;
              var tx0 = spriteMatrix.e;
              var ty0 = spriteMatrix.f;
              var tx1 = yh * spriteMatrix.c + spriteMatrix.e;
              var ty1 = yh * spriteMatrix.d + spriteMatrix.f;
              var tx2 = xw * spriteMatrix.a + yh * spriteMatrix.c + spriteMatrix.e;
              var ty2 = xw * spriteMatrix.b + yh * spriteMatrix.d + spriteMatrix.f;
              var tx3 = xw * spriteMatrix.a + spriteMatrix.e;
              var ty3 = xw * spriteMatrix.b + spriteMatrix.f;
              if (roundPixels) {
                tx0 = Math.round(tx0);
                ty0 = Math.round(ty0);
                tx1 = Math.round(tx1);
                ty1 = Math.round(ty1);
                tx2 = Math.round(tx2);
                ty2 = Math.round(ty2);
                tx3 = Math.round(tx3);
                ty3 = Math.round(ty3);
              }
              pipeline.batchQuad(src, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
            }
            if (crop) {
              pipeline.flush();
              renderer.popScissor();
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = DynamicBitmapTextWebGLRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var SetTransform = __webpack_require__(30);
          var DynamicBitmapTextCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            var text = src._text;
            var textLength = text.length;
            var ctx = renderer.currentContext;
            if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              return;
            }
            camera.addToRenderList(src);
            var textureFrame = src.fromAtlas ? src.frame : src.texture.frames["__BASE"];
            var displayCallback = src.displayCallback;
            var callbackData = src.callbackData;
            var chars = src.fontData.chars;
            var lineHeight = src.fontData.lineHeight;
            var letterSpacing = src._letterSpacing;
            var xAdvance = 0;
            var yAdvance = 0;
            var charCode = 0;
            var glyph = null;
            var glyphX = 0;
            var glyphY = 0;
            var glyphW = 0;
            var glyphH = 0;
            var x = 0;
            var y = 0;
            var lastGlyph = null;
            var lastCharCode = 0;
            var image = src.frame.source.image;
            var textureX = textureFrame.cutX;
            var textureY = textureFrame.cutY;
            var rotation = 0;
            var scale = 0;
            var baseScale = src._fontSize / src.fontData.size;
            var align = src._align;
            var currentLine = 0;
            var lineOffsetX = 0;
            src.getTextBounds(false);
            var lineData = src._bounds.lines;
            if (align === 1) {
              lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;
            } else if (align === 2) {
              lineOffsetX = lineData.longest - lineData.lengths[0];
            }
            ctx.translate(-src.displayOriginX, -src.displayOriginY);
            var roundPixels = camera.roundPixels;
            if (src.cropWidth > 0 && src.cropHeight > 0) {
              ctx.beginPath();
              ctx.rect(0, 0, src.cropWidth, src.cropHeight);
              ctx.clip();
            }
            for (var i = 0; i < textLength; i++) {
              scale = baseScale;
              rotation = 0;
              charCode = text.charCodeAt(i);
              if (charCode === 10) {
                currentLine++;
                if (align === 1) {
                  lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;
                } else if (align === 2) {
                  lineOffsetX = lineData.longest - lineData.lengths[currentLine];
                }
                xAdvance = 0;
                yAdvance += lineHeight;
                lastGlyph = null;
                continue;
              }
              glyph = chars[charCode];
              if (!glyph) {
                continue;
              }
              glyphX = textureX + glyph.x;
              glyphY = textureY + glyph.y;
              glyphW = glyph.width;
              glyphH = glyph.height;
              x = glyph.xOffset + xAdvance - src.scrollX;
              y = glyph.yOffset + yAdvance - src.scrollY;
              if (lastGlyph !== null) {
                var kerningOffset = glyph.kerning[lastCharCode];
                x += kerningOffset !== void 0 ? kerningOffset : 0;
              }
              if (displayCallback) {
                callbackData.index = i;
                callbackData.charCode = charCode;
                callbackData.x = x;
                callbackData.y = y;
                callbackData.scale = scale;
                callbackData.rotation = rotation;
                callbackData.data = glyph.data;
                var output = displayCallback(callbackData);
                x = output.x;
                y = output.y;
                scale = output.scale;
                rotation = output.rotation;
              }
              x *= scale;
              y *= scale;
              x += lineOffsetX;
              xAdvance += glyph.xAdvance + letterSpacing;
              lastGlyph = glyph;
              lastCharCode = charCode;
              if (glyphW === 0 || glyphH === 0 || charCode === 32) {
                continue;
              }
              if (roundPixels) {
                x = Math.round(x);
                y = Math.round(y);
              }
              ctx.save();
              ctx.translate(x, y);
              ctx.rotate(rotation);
              ctx.scale(scale, scale);
              ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);
              ctx.restore();
            }
            ctx.restore();
          };
          module2.exports = DynamicBitmapTextCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1061);
          }
          if (true) {
            renderCanvas = __webpack_require__(1062);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var GetCalcMatrix = __webpack_require__(19);
          var ExternWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            renderer.pipelines.clear();
            var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
            src.render.call(src, renderer, camera, calcMatrix);
            renderer.pipelines.rebind();
          };
          module2.exports = ExternWebGLRenderer;
        }, function (module2, exports2) {}, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1064);
            renderCanvas = __webpack_require__(448);
          }
          if (true) {
            renderCanvas = __webpack_require__(448);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var Commands = __webpack_require__(217);
          var GetCalcMatrix = __webpack_require__(19);
          var TransformMatrix = __webpack_require__(25);
          var Utils = __webpack_require__(12);
          var Point = function (x, y, width) {
            this.x = x;
            this.y = y;
            this.width = width;
          };
          var Path = function (x, y, width) {
            this.points = [];
            this.pointsLength = 1;
            this.points[0] = new Point(x, y, width);
          };
          var matrixStack = [];
          var tempMatrix = new TransformMatrix();
          var GraphicsWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            if (src.commandBuffer.length === 0) {
              return;
            }
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline, src);
            renderer.pipelines.preBatch(src);
            var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
            var currentMatrix = tempMatrix.loadIdentity();
            var commands = src.commandBuffer;
            var alpha = camera.alpha * src.alpha;
            var lineWidth = 1;
            var fillTint = pipeline.fillTint;
            var strokeTint = pipeline.strokeTint;
            var tx = 0;
            var ty = 0;
            var ta = 0;
            var iterStep = 0.01;
            var PI2 = Math.PI * 2;
            var cmd;
            var path = [];
            var pathIndex = 0;
            var pathOpen = true;
            var lastPath = null;
            var getTint = Utils.getTintAppendFloatAlpha;
            for (var cmdIndex = 0; cmdIndex < commands.length; cmdIndex++) {
              cmd = commands[cmdIndex];
              switch (cmd) {
                case Commands.BEGIN_PATH:
                  {
                    path.length = 0;
                    lastPath = null;
                    pathOpen = true;
                    break;
                  }
                case Commands.CLOSE_PATH:
                  {
                    pathOpen = false;
                    if (lastPath && lastPath.points.length) {
                      lastPath.points.push(lastPath.points[0]);
                    }
                    break;
                  }
                case Commands.FILL_PATH:
                  {
                    for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
                      pipeline.batchFillPath(path[pathIndex].points, currentMatrix, calcMatrix);
                    }
                    break;
                  }
                case Commands.STROKE_PATH:
                  {
                    for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
                      pipeline.batchStrokePath(path[pathIndex].points, lineWidth, pathOpen, currentMatrix, calcMatrix);
                    }
                    break;
                  }
                case Commands.LINE_STYLE:
                  {
                    lineWidth = commands[++cmdIndex];
                    var strokeColor = commands[++cmdIndex];
                    var strokeAlpha = commands[++cmdIndex] * alpha;
                    var strokeTintColor = getTint(strokeColor, strokeAlpha);
                    strokeTint.TL = strokeTintColor;
                    strokeTint.TR = strokeTintColor;
                    strokeTint.BL = strokeTintColor;
                    strokeTint.BR = strokeTintColor;
                    break;
                  }
                case Commands.FILL_STYLE:
                  {
                    var fillColor = commands[++cmdIndex];
                    var fillAlpha = commands[++cmdIndex] * alpha;
                    var fillTintColor = getTint(fillColor, fillAlpha);
                    fillTint.TL = fillTintColor;
                    fillTint.TR = fillTintColor;
                    fillTint.BL = fillTintColor;
                    fillTint.BR = fillTintColor;
                    break;
                  }
                case Commands.GRADIENT_FILL_STYLE:
                  {
                    var alphaTL = commands[++cmdIndex] * alpha;
                    var alphaTR = commands[++cmdIndex] * alpha;
                    var alphaBL = commands[++cmdIndex] * alpha;
                    var alphaBR = commands[++cmdIndex] * alpha;
                    fillTint.TL = getTint(commands[++cmdIndex], alphaTL);
                    fillTint.TR = getTint(commands[++cmdIndex], alphaTR);
                    fillTint.BL = getTint(commands[++cmdIndex], alphaBL);
                    fillTint.BR = getTint(commands[++cmdIndex], alphaBR);
                    break;
                  }
                case Commands.GRADIENT_LINE_STYLE:
                  {
                    lineWidth = commands[++cmdIndex];
                    var gradientLineAlpha = commands[++cmdIndex] * alpha;
                    strokeTint.TL = getTint(commands[++cmdIndex], gradientLineAlpha);
                    strokeTint.TR = getTint(commands[++cmdIndex], gradientLineAlpha);
                    strokeTint.BL = getTint(commands[++cmdIndex], gradientLineAlpha);
                    strokeTint.BR = getTint(commands[++cmdIndex], gradientLineAlpha);
                    break;
                  }
                case Commands.ARC:
                  {
                    var iteration = 0;
                    var x = commands[++cmdIndex];
                    var y = commands[++cmdIndex];
                    var radius = commands[++cmdIndex];
                    var startAngle = commands[++cmdIndex];
                    var endAngle = commands[++cmdIndex];
                    var anticlockwise = commands[++cmdIndex];
                    var overshoot = commands[++cmdIndex];
                    endAngle -= startAngle;
                    if (anticlockwise) {
                      if (endAngle < -PI2) {
                        endAngle = -PI2;
                      } else if (endAngle > 0) {
                        endAngle = -PI2 + endAngle % PI2;
                      }
                    } else if (endAngle > PI2) {
                      endAngle = PI2;
                    } else if (endAngle < 0) {
                      endAngle = PI2 + endAngle % PI2;
                    }
                    if (lastPath === null) {
                      lastPath = new Path(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius, lineWidth);
                      path.push(lastPath);
                      iteration += iterStep;
                    }
                    while (iteration < 1 + overshoot) {
                      ta = endAngle * iteration + startAngle;
                      tx = x + Math.cos(ta) * radius;
                      ty = y + Math.sin(ta) * radius;
                      lastPath.points.push(new Point(tx, ty, lineWidth));
                      iteration += iterStep;
                    }
                    ta = endAngle + startAngle;
                    tx = x + Math.cos(ta) * radius;
                    ty = y + Math.sin(ta) * radius;
                    lastPath.points.push(new Point(tx, ty, lineWidth));
                    break;
                  }
                case Commands.FILL_RECT:
                  {
                    pipeline.batchFillRect(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], currentMatrix, calcMatrix);
                    break;
                  }
                case Commands.FILL_TRIANGLE:
                  {
                    pipeline.batchFillTriangle(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], currentMatrix, calcMatrix);
                    break;
                  }
                case Commands.STROKE_TRIANGLE:
                  {
                    pipeline.batchStrokeTriangle(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], lineWidth, currentMatrix, calcMatrix);
                    break;
                  }
                case Commands.LINE_TO:
                  {
                    if (lastPath !== null) {
                      lastPath.points.push(new Point(commands[++cmdIndex], commands[++cmdIndex], lineWidth));
                    } else {
                      lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);
                      path.push(lastPath);
                    }
                    break;
                  }
                case Commands.MOVE_TO:
                  {
                    lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);
                    path.push(lastPath);
                    break;
                  }
                case Commands.SAVE:
                  {
                    matrixStack.push(currentMatrix.copyToArray());
                    break;
                  }
                case Commands.RESTORE:
                  {
                    currentMatrix.copyFromArray(matrixStack.pop());
                    break;
                  }
                case Commands.TRANSLATE:
                  {
                    x = commands[++cmdIndex];
                    y = commands[++cmdIndex];
                    currentMatrix.translate(x, y);
                    break;
                  }
                case Commands.SCALE:
                  {
                    x = commands[++cmdIndex];
                    y = commands[++cmdIndex];
                    currentMatrix.scale(x, y);
                    break;
                  }
                case Commands.ROTATE:
                  {
                    currentMatrix.rotate(commands[++cmdIndex]);
                    break;
                  }
              }
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = GraphicsWebGLRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1066);
          }
          if (true) {
            renderCanvas = __webpack_require__(1067);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2) {
          var SpriteWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            src.pipeline.batchSprite(src, camera, parentMatrix);
          };
          module2.exports = SpriteWebGLRenderer;
        }, function (module2, exports2) {
          var SpriteCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            renderer.batchSprite(src, src.frame, camera, parentMatrix);
          };
          module2.exports = SpriteCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1069);
          }
          if (true) {
            renderCanvas = __webpack_require__(1070);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2) {
          var ImageWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            this.pipeline.batchSprite(src, camera, parentMatrix);
          };
          module2.exports = ImageWebGLRenderer;
        }, function (module2, exports2) {
          var ImageCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            renderer.batchSprite(src, src.frame, camera, parentMatrix);
          };
          module2.exports = ImageCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1072);
          }
          if (true) {
            renderCanvas = __webpack_require__(1073);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2) {
          var LayerWebGLRenderer = function (renderer, layer, camera) {
            var children = layer.list;
            var childCount = children.length;
            if (childCount === 0) {
              return;
            }
            layer.depthSort();
            renderer.pipelines.preBatch(layer);
            var layerHasBlendMode = layer.blendMode !== -1;
            if (!layerHasBlendMode) {
              renderer.setBlendMode(0);
            }
            var alpha = layer.alpha;
            for (var i = 0; i < childCount; i++) {
              var child = children[i];
              if (!child.willRender(camera)) {
                continue;
              }
              var childAlphaTopLeft;
              var childAlphaTopRight;
              var childAlphaBottomLeft;
              var childAlphaBottomRight;
              if (child.alphaTopLeft !== void 0) {
                childAlphaTopLeft = child.alphaTopLeft;
                childAlphaTopRight = child.alphaTopRight;
                childAlphaBottomLeft = child.alphaBottomLeft;
                childAlphaBottomRight = child.alphaBottomRight;
              } else {
                var childAlpha = child.alpha;
                childAlphaTopLeft = childAlpha;
                childAlphaTopRight = childAlpha;
                childAlphaBottomLeft = childAlpha;
                childAlphaBottomRight = childAlpha;
              }
              if (!layerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
                renderer.setBlendMode(child.blendMode);
              }
              var mask = child.mask;
              if (mask) {
                mask.preRenderWebGL(renderer, child, camera);
              }
              var type = child.type;
              if (type !== renderer.currentType) {
                renderer.newType = true;
                renderer.currentType = type;
              }
              renderer.nextTypeMatch = i < childCount - 1 ? children[i + 1].type === renderer.currentType : false;
              child.setAlpha(childAlphaTopLeft * alpha, childAlphaTopRight * alpha, childAlphaBottomLeft * alpha, childAlphaBottomRight * alpha);
              child.renderWebGL(renderer, child, camera);
              child.setAlpha(childAlphaTopLeft, childAlphaTopRight, childAlphaBottomLeft, childAlphaBottomRight);
              if (mask) {
                mask.postRenderWebGL(renderer, camera);
              }
              renderer.newType = false;
            }
            renderer.pipelines.postBatch(layer);
          };
          module2.exports = LayerWebGLRenderer;
        }, function (module2, exports2) {
          var LayerCanvasRenderer = function (renderer, layer, camera) {
            var children = layer.list;
            if (children.length === 0) {
              return;
            }
            layer.depthSort();
            var layerHasBlendMode = layer.blendMode !== -1;
            if (!layerHasBlendMode) {
              renderer.setBlendMode(0);
            }
            var alpha = layer._alpha;
            if (layer.mask) {
              layer.mask.preRenderCanvas(renderer, null, camera);
            }
            for (var i = 0; i < children.length; i++) {
              var child = children[i];
              if (!child.willRender(camera)) {
                continue;
              }
              var childAlpha = child.alpha;
              if (!layerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
                renderer.setBlendMode(child.blendMode);
              }
              child.setAlpha(childAlpha * alpha);
              child.renderCanvas(renderer, child, camera);
              child.setAlpha(childAlpha);
            }
            if (layer.mask) {
              layer.mask.postRenderCanvas(renderer);
            }
          };
          module2.exports = LayerCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            EmitterOp: __webpack_require__(449),
            GravityWell: __webpack_require__(450),
            Particle: __webpack_require__(451),
            ParticleEmitter: __webpack_require__(452),
            ParticleEmitterManager: __webpack_require__(220),
            Zones: __webpack_require__(1078)
          };
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1076);
          }
          if (true) {
            renderCanvas = __webpack_require__(1077);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var TransformMatrix = __webpack_require__(25);
          var Utils = __webpack_require__(12);
          var tempMatrix1 = new TransformMatrix();
          var tempMatrix2 = new TransformMatrix();
          var tempMatrix3 = new TransformMatrix();
          var tempMatrix4 = new TransformMatrix();
          var ParticleManagerWebGLRenderer = function (renderer, emitterManager, camera, parentMatrix) {
            var emitters = emitterManager.emitters.list;
            var emittersLength = emitters.length;
            if (emittersLength === 0) {
              return;
            }
            var pipeline = renderer.pipelines.set(emitterManager.pipeline);
            var camMatrix = tempMatrix1;
            var calcMatrix = tempMatrix2;
            var particleMatrix = tempMatrix3;
            var managerMatrix = tempMatrix4;
            if (parentMatrix) {
              managerMatrix.loadIdentity();
              managerMatrix.multiply(parentMatrix);
              managerMatrix.translate(emitterManager.x, emitterManager.y);
              managerMatrix.rotate(emitterManager.rotation);
              managerMatrix.scale(emitterManager.scaleX, emitterManager.scaleY);
            } else {
              managerMatrix.applyITRS(emitterManager.x, emitterManager.y, emitterManager.rotation, emitterManager.scaleX, emitterManager.scaleY);
            }
            var roundPixels = camera.roundPixels;
            var texture = emitterManager.defaultFrame.glTexture;
            var getTint = Utils.getTintAppendFloatAlpha;
            var textureUnit = pipeline.setGameObject(emitterManager, emitterManager.defaultFrame);
            renderer.pipelines.preBatch(emitterManager);
            for (var e = 0; e < emittersLength; e++) {
              var emitter = emitters[e];
              var particles = emitter.alive;
              var particleCount = particles.length;
              if (!emitter.visible || particleCount === 0) {
                continue;
              }
              camera.addToRenderList(emitter);
              var scrollFactorX = emitter.scrollFactorX;
              var scrollFactorY = emitter.scrollFactorY;
              renderer.setBlendMode(emitter.blendMode);
              if (emitter.mask) {
                emitter.mask.preRenderWebGL(renderer, emitter, camera);
                renderer.pipelines.set(emitterManager.pipeline);
              }
              var tintEffect = 0;
              for (var i = 0; i < particleCount; i++) {
                var particle = particles[i];
                var alpha = particle.alpha * camera.alpha;
                if (alpha <= 0) {
                  continue;
                }
                particleMatrix.applyITRS(particle.x, particle.y, particle.rotation, particle.scaleX, particle.scaleY);
                camMatrix.copyFrom(camera.matrix);
                camMatrix.multiplyWithOffset(managerMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);
                particleMatrix.e = particle.x;
                particleMatrix.f = particle.y;
                camMatrix.multiply(particleMatrix, calcMatrix);
                var frame = particle.frame;
                var x = -frame.halfWidth;
                var y = -frame.halfHeight;
                var xw = x + frame.width;
                var yh = y + frame.height;
                var tx0 = calcMatrix.getXRound(x, y, roundPixels);
                var ty0 = calcMatrix.getYRound(x, y, roundPixels);
                var tx1 = calcMatrix.getXRound(x, yh, roundPixels);
                var ty1 = calcMatrix.getYRound(x, yh, roundPixels);
                var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);
                var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);
                var tx3 = calcMatrix.getXRound(xw, y, roundPixels);
                var ty3 = calcMatrix.getYRound(xw, y, roundPixels);
                var tint = getTint(particle.tint, alpha);
                pipeline.batchQuad(emitter, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, tintEffect, texture, textureUnit);
              }
              if (emitter.mask) {
                emitter.mask.postRenderWebGL(renderer, camera);
              }
            }
            renderer.pipelines.postBatch(emitterManager);
          };
          module2.exports = ParticleManagerWebGLRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var TransformMatrix = __webpack_require__(25);
          var tempMatrix1 = new TransformMatrix();
          var tempMatrix2 = new TransformMatrix();
          var tempMatrix3 = new TransformMatrix();
          var tempMatrix4 = new TransformMatrix();
          var ParticleManagerCanvasRenderer = function (renderer, emitterManager, camera, parentMatrix) {
            var emitters = emitterManager.emitters.list;
            var emittersLength = emitters.length;
            if (emittersLength === 0) {
              return;
            }
            var camMatrix = tempMatrix1.copyFrom(camera.matrix);
            var calcMatrix = tempMatrix2;
            var particleMatrix = tempMatrix3;
            var managerMatrix = tempMatrix4;
            if (parentMatrix) {
              managerMatrix.loadIdentity();
              managerMatrix.multiply(parentMatrix);
              managerMatrix.translate(emitterManager.x, emitterManager.y);
              managerMatrix.rotate(emitterManager.rotation);
              managerMatrix.scale(emitterManager.scaleX, emitterManager.scaleY);
            } else {
              managerMatrix.applyITRS(emitterManager.x, emitterManager.y, emitterManager.rotation, emitterManager.scaleX, emitterManager.scaleY);
            }
            var ctx = renderer.currentContext;
            var roundPixels = camera.roundPixels;
            for (var e = 0; e < emittersLength; e++) {
              var emitter = emitters[e];
              var particles = emitter.alive;
              var particleCount = particles.length;
              if (!emitter.visible || particleCount === 0) {
                continue;
              }
              camera.addToRenderList(emitter);
              var scrollFactorX = emitter.scrollFactorX;
              var scrollFactorY = emitter.scrollFactorY;
              ctx.save();
              ctx.globalCompositeOperation = renderer.blendModes[emitter.blendMode];
              for (var i = 0; i < particleCount; i++) {
                var particle = particles[i];
                var alpha = particle.alpha * camera.alpha;
                if (alpha <= 0) {
                  continue;
                }
                particleMatrix.applyITRS(particle.x, particle.y, particle.rotation, particle.scaleX, particle.scaleY);
                camMatrix.copyFrom(camera.matrix);
                camMatrix.multiplyWithOffset(managerMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);
                particleMatrix.e = particle.x;
                particleMatrix.f = particle.y;
                camMatrix.multiply(particleMatrix, calcMatrix);
                var frame = particle.frame;
                var cd = frame.canvasData;
                var x = -frame.halfWidth;
                var y = -frame.halfHeight;
                ctx.globalAlpha = alpha;
                ctx.save();
                calcMatrix.setToContext(ctx);
                if (roundPixels) {
                  x = Math.round(x);
                  y = Math.round(y);
                }
                ctx.imageSmoothingEnabled = !(!renderer.antialias || frame.source.scaleMode);
                ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);
                ctx.restore();
              }
              ctx.restore();
            }
          };
          module2.exports = ParticleManagerCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            DeathZone: __webpack_require__(453),
            EdgeZone: __webpack_require__(454),
            RandomZone: __webpack_require__(456)
          };
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1080);
          }
          if (true) {
            renderCanvas = __webpack_require__(1081);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var Utils = __webpack_require__(12);
          var RenderTextureWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var cameraAlpha = camera.alpha;
            var renderTarget = src.renderTarget;
            var width = renderTarget.width;
            var height = renderTarget.height;
            var getTint = Utils.getTintAppendFloatAlpha;
            var pipeline = renderer.pipelines.set(src.pipeline);
            var textureUnit = pipeline.setTexture2D(renderTarget.texture);
            renderer.pipelines.preBatch(src);
            pipeline.batchTexture(src, renderTarget.texture, width, height, src.x, src.y, width, height, src.scaleX, src.scaleY, src.rotation, src.flipX, !src.flipY, src.scrollFactorX, src.scrollFactorY, src.displayOriginX, src.displayOriginY, 0, 0, width, height, getTint(src.tintTopLeft, cameraAlpha * src._alphaTL), getTint(src.tintTopRight, cameraAlpha * src._alphaTR), getTint(src.tintBottomLeft, cameraAlpha * src._alphaBL), getTint(src.tintBottomRight, cameraAlpha * src._alphaBR), src.tintFill, 0, 0, camera, parentMatrix, true, textureUnit);
            renderer.resetTextures();
            renderer.pipelines.postBatch(src);
          };
          module2.exports = RenderTextureWebGLRenderer;
        }, function (module2, exports2) {
          var RenderTextureCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            renderer.batchSprite(src, src.frame, camera, parentMatrix);
          };
          module2.exports = RenderTextureCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var RETRO_FONT_CONST = __webpack_require__(1083);
          var Extend = __webpack_require__(17);
          var RetroFont = {
            Parse: __webpack_require__(1084)
          };
          RetroFont = Extend(false, RetroFont, RETRO_FONT_CONST);
          module2.exports = RetroFont;
        }, function (module2, exports2) {
          var RETRO_FONT_CONST = {
            TEXT_SET1: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
            TEXT_SET2: ` !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ`,
            TEXT_SET3: "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ",
            TEXT_SET4: "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789",
            TEXT_SET5: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789",
            TEXT_SET6: `ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789"(),-.' `,
            TEXT_SET7: `AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW")28FLRX-'39`,
            TEXT_SET8: "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ",
            TEXT_SET9: `ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'"?!`,
            TEXT_SET10: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
            TEXT_SET11: `ABCDEFGHIJKLMNOPQRSTUVWXYZ.,"-+!?()':;0123456789`
          };
          module2.exports = RETRO_FONT_CONST;
        }, function (module2, exports2, __webpack_require__) {
          var GetValue = __webpack_require__(6);
          var ParseRetroFont = function (scene, config) {
            var w = config.width;
            var h = config.height;
            var cx = Math.floor(w / 2);
            var cy = Math.floor(h / 2);
            var letters = GetValue(config, "chars", "");
            if (letters === "") {
              return;
            }
            var key = GetValue(config, "image", "");
            var frame = scene.sys.textures.getFrame(key);
            var textureX = frame.cutX;
            var textureY = frame.cutY;
            var textureWidth = frame.source.width;
            var textureHeight = frame.source.height;
            var offsetX = GetValue(config, "offset.x", 0);
            var offsetY = GetValue(config, "offset.y", 0);
            var spacingX = GetValue(config, "spacing.x", 0);
            var spacingY = GetValue(config, "spacing.y", 0);
            var lineSpacing = GetValue(config, "lineSpacing", 0);
            var charsPerRow = GetValue(config, "charsPerRow", null);
            if (charsPerRow === null) {
              charsPerRow = textureWidth / w;
              if (charsPerRow > letters.length) {
                charsPerRow = letters.length;
              }
            }
            var x = offsetX;
            var y = offsetY;
            var data = {
              retroFont: true,
              font: key,
              size: w,
              lineHeight: h + lineSpacing,
              chars: {}
            };
            var r = 0;
            for (var i = 0; i < letters.length; i++) {
              var charCode = letters.charCodeAt(i);
              var u0 = (textureX + x) / textureWidth;
              var v0 = (textureY + y) / textureHeight;
              var u1 = (textureX + x + w) / textureWidth;
              var v1 = (textureY + y + h) / textureHeight;
              data.chars[charCode] = {
                x,
                y,
                width: w,
                height: h,
                centerX: cx,
                centerY: cy,
                xOffset: 0,
                yOffset: 0,
                xAdvance: w,
                data: {},
                kerning: {},
                u0,
                v0,
                u1,
                v1
              };
              r++;
              if (r === charsPerRow) {
                r = 0;
                x = offsetX;
                y += h + spacingY;
              } else {
                x += w + spacingX;
              }
            }
            var entry = {
              data,
              frame: null,
              texture: key
            };
            return entry;
          };
          module2.exports = ParseRetroFont;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1086);
          }
          if (true) {
            renderCanvas = __webpack_require__(1087);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var GetCalcMatrix = __webpack_require__(19);
          var Utils = __webpack_require__(12);
          var RopeWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline, src);
            var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
            var vertices = src.vertices;
            var uvs = src.uv;
            var colors = src.colors;
            var alphas = src.alphas;
            var alpha = src.alpha;
            var getTint = Utils.getTintAppendFloatAlpha;
            var roundPixels = camera.roundPixels;
            var meshVerticesLength = vertices.length;
            var vertexCount = Math.floor(meshVerticesLength * 0.5);
            pipeline.flush();
            renderer.pipelines.preBatch(src);
            var textureUnit = pipeline.setGameObject(src);
            var vertexViewF32 = pipeline.vertexViewF32;
            var vertexViewU32 = pipeline.vertexViewU32;
            var vertexOffset = pipeline.vertexCount * pipeline.currentShader.vertexComponentCount - 1;
            var colorIndex = 0;
            var tintEffect = src.tintFill;
            if (src.dirty) {
              src.updateVertices();
            }
            var debugCallback = src.debugCallback;
            var debugVerts = [];
            for (var i = 0; i < meshVerticesLength; i += 2) {
              var x = vertices[i + 0];
              var y = vertices[i + 1];
              var tx = x * calcMatrix.a + y * calcMatrix.c + calcMatrix.e;
              var ty = x * calcMatrix.b + y * calcMatrix.d + calcMatrix.f;
              if (roundPixels) {
                tx = Math.round(tx);
                ty = Math.round(ty);
              }
              vertexViewF32[++vertexOffset] = tx;
              vertexViewF32[++vertexOffset] = ty;
              vertexViewF32[++vertexOffset] = uvs[i + 0];
              vertexViewF32[++vertexOffset] = uvs[i + 1];
              vertexViewF32[++vertexOffset] = textureUnit;
              vertexViewF32[++vertexOffset] = tintEffect;
              vertexViewU32[++vertexOffset] = getTint(colors[colorIndex], camera.alpha * (alphas[colorIndex] * alpha));
              colorIndex++;
              if (debugCallback) {
                debugVerts[i + 0] = tx;
                debugVerts[i + 1] = ty;
              }
            }
            if (debugCallback) {
              debugCallback.call(src, src, meshVerticesLength, debugVerts);
            }
            pipeline.vertexCount += vertexCount;
            renderer.pipelines.postBatch(src);
          };
          module2.exports = RopeWebGLRenderer;
        }, function (module2, exports2) {
          var RopeCanvasRenderer = function () {};
          module2.exports = RopeCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1089);
          }
          if (true) {
            renderCanvas = __webpack_require__(1090);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var Utils = __webpack_require__(12);
          var TextWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            if (src.width === 0 || src.height === 0) {
              return;
            }
            camera.addToRenderList(src);
            var frame = src.frame;
            var width = frame.width;
            var height = frame.height;
            var getTint = Utils.getTintAppendFloatAlpha;
            var pipeline = renderer.pipelines.set(src.pipeline, src);
            var textureUnit = pipeline.setTexture2D(frame.glTexture, src);
            renderer.pipelines.preBatch(src);
            pipeline.batchTexture(src, frame.glTexture, width, height, src.x, src.y, width / src.style.resolution, height / src.style.resolution, src.scaleX, src.scaleY, src.rotation, src.flipX, src.flipY, src.scrollFactorX, src.scrollFactorY, src.displayOriginX, src.displayOriginY, 0, 0, width, height, getTint(src.tintTopLeft, camera.alpha * src._alphaTL), getTint(src.tintTopRight, camera.alpha * src._alphaTR), getTint(src.tintBottomLeft, camera.alpha * src._alphaBL), getTint(src.tintBottomRight, camera.alpha * src._alphaBR), src.tintFill, 0, 0, camera, parentMatrix, false, textureUnit);
            renderer.pipelines.postBatch(src);
          };
          module2.exports = TextWebGLRenderer;
        }, function (module2, exports2) {
          var TextCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            if (src.width === 0 || src.height === 0) {
              return;
            }
            camera.addToRenderList(src);
            renderer.batchSprite(src, src.frame, camera, parentMatrix);
          };
          module2.exports = TextCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1092);
          }
          if (true) {
            renderCanvas = __webpack_require__(1093);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var Utils = __webpack_require__(12);
          var TileSpriteWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            src.updateCanvas();
            var width = src.width;
            var height = src.height;
            if (width === 0 || height === 0) {
              return;
            }
            camera.addToRenderList(src);
            renderer.pipelines.preBatch(src);
            var getTint = Utils.getTintAppendFloatAlpha;
            var pipeline = renderer.pipelines.set(src.pipeline, src);
            var textureUnit = pipeline.setTexture2D(src.fillPattern, src);
            pipeline.batchTexture(src, src.fillPattern, src.displayFrame.width * src.tileScaleX, src.displayFrame.height * src.tileScaleY, src.x, src.y, width, height, src.scaleX, src.scaleY, src.rotation, src.flipX, src.flipY, src.scrollFactorX, src.scrollFactorY, src.originX * width, src.originY * height, 0, 0, width, height, getTint(src.tintTopLeft, camera.alpha * src._alphaTL), getTint(src.tintTopRight, camera.alpha * src._alphaTR), getTint(src.tintBottomLeft, camera.alpha * src._alphaBL), getTint(src.tintBottomRight, camera.alpha * src._alphaBR), src.tintFill, src.tilePositionX % src.displayFrame.width / src.displayFrame.width, src.tilePositionY % src.displayFrame.height / src.displayFrame.height, camera, parentMatrix, false, textureUnit);
            renderer.pipelines.postBatch(src);
          };
          module2.exports = TileSpriteWebGLRenderer;
        }, function (module2, exports2) {
          var TileSpriteCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            src.updateCanvas();
            camera.addToRenderList(src);
            renderer.batchSprite(src, src.frame, camera, parentMatrix);
          };
          module2.exports = TileSpriteCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1095);
          }
          if (true) {
            renderCanvas = __webpack_require__(1096);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2) {
          var VideoWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            if (src.videoTexture) {
              camera.addToRenderList(src);
              src.pipeline.batchSprite(src, camera, parentMatrix);
            }
          };
          module2.exports = VideoWebGLRenderer;
        }, function (module2, exports2) {
          var VideoCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            if (src.videoTexture) {
              camera.addToRenderList(src);
              renderer.batchSprite(src, src.frame, camera, parentMatrix);
            }
          };
          module2.exports = VideoCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1098);
          }
          if (true) {
            renderCanvas = __webpack_require__(1099);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var GetCalcMatrix = __webpack_require__(19);
          var FillPathWebGL = __webpack_require__(114);
          var StrokePathWebGL = __webpack_require__(81);
          var ArcWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            var alpha = camera.alpha * src.alpha;
            renderer.pipelines.preBatch(src);
            if (src.isFilled) {
              FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
            }
            if (src.isStroked) {
              StrokePathWebGL(pipeline, src, alpha, dx, dy);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = ArcWebGLRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var DegToRad = __webpack_require__(36);
          var FillStyleCanvas = __webpack_require__(48);
          var LineStyleCanvas = __webpack_require__(60);
          var SetTransform = __webpack_require__(30);
          var ArcCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              var radius = src.radius;
              ctx.beginPath();
              ctx.arc(radius - src.originX * (radius * 2), radius - src.originY * (radius * 2), radius, DegToRad(src._startAngle), DegToRad(src._endAngle), src.anticlockwise);
              if (src.closePath) {
                ctx.closePath();
              }
              if (src.isFilled) {
                FillStyleCanvas(ctx, src);
                ctx.fill();
              }
              if (src.isStroked) {
                LineStyleCanvas(ctx, src);
                ctx.stroke();
              }
              ctx.restore();
            }
          };
          module2.exports = ArcCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1101);
          }
          if (true) {
            renderCanvas = __webpack_require__(1102);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var FillPathWebGL = __webpack_require__(114);
          var GetCalcMatrix = __webpack_require__(19);
          var StrokePathWebGL = __webpack_require__(81);
          var CurveWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
            var dx = src._displayOriginX + src._curveBounds.x;
            var dy = src._displayOriginY + src._curveBounds.y;
            var alpha = camera.alpha * src.alpha;
            renderer.pipelines.preBatch(src);
            if (src.isFilled) {
              FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
            }
            if (src.isStroked) {
              StrokePathWebGL(pipeline, src, alpha, dx, dy);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = CurveWebGLRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var FillStyleCanvas = __webpack_require__(48);
          var LineStyleCanvas = __webpack_require__(60);
          var SetTransform = __webpack_require__(30);
          var CurveCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              var dx = src._displayOriginX + src._curveBounds.x;
              var dy = src._displayOriginY + src._curveBounds.y;
              var path = src.pathData;
              var pathLength = path.length - 1;
              var px1 = path[0] - dx;
              var py1 = path[1] - dy;
              ctx.beginPath();
              ctx.moveTo(px1, py1);
              if (!src.closePath) {
                pathLength -= 2;
              }
              for (var i = 2; i < pathLength; i += 2) {
                var px2 = path[i] - dx;
                var py2 = path[i + 1] - dy;
                ctx.lineTo(px2, py2);
              }
              if (src.closePath) {
                ctx.closePath();
              }
              if (src.isFilled) {
                FillStyleCanvas(ctx, src);
                ctx.fill();
              }
              if (src.isStroked) {
                LineStyleCanvas(ctx, src);
                ctx.stroke();
              }
              ctx.restore();
            }
          };
          module2.exports = CurveCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1104);
          }
          if (true) {
            renderCanvas = __webpack_require__(1105);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var FillPathWebGL = __webpack_require__(114);
          var GetCalcMatrix = __webpack_require__(19);
          var StrokePathWebGL = __webpack_require__(81);
          var EllipseWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            var alpha = camera.alpha * src.alpha;
            renderer.pipelines.preBatch(src);
            if (src.isFilled) {
              FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
            }
            if (src.isStroked) {
              StrokePathWebGL(pipeline, src, alpha, dx, dy);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = EllipseWebGLRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var FillStyleCanvas = __webpack_require__(48);
          var LineStyleCanvas = __webpack_require__(60);
          var SetTransform = __webpack_require__(30);
          var EllipseCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              var dx = src._displayOriginX;
              var dy = src._displayOriginY;
              var path = src.pathData;
              var pathLength = path.length - 1;
              var px1 = path[0] - dx;
              var py1 = path[1] - dy;
              ctx.beginPath();
              ctx.moveTo(px1, py1);
              if (!src.closePath) {
                pathLength -= 2;
              }
              for (var i = 2; i < pathLength; i += 2) {
                var px2 = path[i] - dx;
                var py2 = path[i + 1] - dy;
                ctx.lineTo(px2, py2);
              }
              ctx.closePath();
              if (src.isFilled) {
                FillStyleCanvas(ctx, src);
                ctx.fill();
              }
              if (src.isStroked) {
                LineStyleCanvas(ctx, src);
                ctx.stroke();
              }
              ctx.restore();
            }
          };
          module2.exports = EllipseCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1107);
          }
          if (true) {
            renderCanvas = __webpack_require__(1108);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var GetCalcMatrix = __webpack_require__(19);
          var Utils = __webpack_require__(12);
          var GridWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
            calcMatrix.translate(-src._displayOriginX, -src._displayOriginY);
            var alpha = camera.alpha * src.alpha;
            var width = src.width;
            var height = src.height;
            var cellWidth = src.cellWidth;
            var cellHeight = src.cellHeight;
            var gridWidth = Math.ceil(width / cellWidth);
            var gridHeight = Math.ceil(height / cellHeight);
            var cellWidthA = cellWidth;
            var cellHeightA = cellHeight;
            var cellWidthB = cellWidth - (gridWidth * cellWidth - width);
            var cellHeightB = cellHeight - (gridHeight * cellHeight - height);
            var fillTint;
            var fillTintColor;
            var showCells = src.showCells;
            var showAltCells = src.showAltCells;
            var showOutline = src.showOutline;
            var x = 0;
            var y = 0;
            var r = 0;
            var cw = 0;
            var ch = 0;
            if (showOutline) {
              cellWidthA--;
              cellHeightA--;
              if (cellWidthB === cellWidth) {
                cellWidthB--;
              }
              if (cellHeightB === cellHeight) {
                cellHeightB--;
              }
            }
            renderer.pipelines.preBatch(src);
            if (showCells && src.fillAlpha > 0) {
              fillTint = pipeline.fillTint;
              fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
              fillTint.TL = fillTintColor;
              fillTint.TR = fillTintColor;
              fillTint.BL = fillTintColor;
              fillTint.BR = fillTintColor;
              for (y = 0; y < gridHeight; y++) {
                if (showAltCells) {
                  r = y % 2;
                }
                for (x = 0; x < gridWidth; x++) {
                  if (showAltCells && r) {
                    r = 0;
                    continue;
                  }
                  r++;
                  cw = x < gridWidth - 1 ? cellWidthA : cellWidthB;
                  ch = y < gridHeight - 1 ? cellHeightA : cellHeightB;
                  pipeline.batchFillRect(x * cellWidth, y * cellHeight, cw, ch);
                }
              }
            }
            if (showAltCells && src.altFillAlpha > 0) {
              fillTint = pipeline.fillTint;
              fillTintColor = Utils.getTintAppendFloatAlpha(src.altFillColor, src.altFillAlpha * alpha);
              fillTint.TL = fillTintColor;
              fillTint.TR = fillTintColor;
              fillTint.BL = fillTintColor;
              fillTint.BR = fillTintColor;
              for (y = 0; y < gridHeight; y++) {
                if (showAltCells) {
                  r = y % 2;
                }
                for (x = 0; x < gridWidth; x++) {
                  if (showAltCells && !r) {
                    r = 1;
                    continue;
                  }
                  r = 0;
                  cw = x < gridWidth - 1 ? cellWidthA : cellWidthB;
                  ch = y < gridHeight - 1 ? cellHeightA : cellHeightB;
                  pipeline.batchFillRect(x * cellWidth, y * cellHeight, cw, ch);
                }
              }
            }
            if (showOutline && src.outlineFillAlpha > 0) {
              var strokeTint = pipeline.strokeTint;
              var color = Utils.getTintAppendFloatAlpha(src.outlineFillColor, src.outlineFillAlpha * alpha);
              strokeTint.TL = color;
              strokeTint.TR = color;
              strokeTint.BL = color;
              strokeTint.BR = color;
              for (x = 1; x < gridWidth; x++) {
                var x1 = x * cellWidth;
                pipeline.batchLine(x1, 0, x1, height, 1, 1, 1, 0, false);
              }
              for (y = 1; y < gridHeight; y++) {
                var y1 = y * cellHeight;
                pipeline.batchLine(0, y1, width, y1, 1, 1, 1, 0, false);
              }
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = GridWebGLRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var FillStyleCanvas = __webpack_require__(48);
          var LineStyleCanvas = __webpack_require__(60);
          var SetTransform = __webpack_require__(30);
          var GridCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              var dx = -src._displayOriginX;
              var dy = -src._displayOriginY;
              var alpha = camera.alpha * src.alpha;
              var width = src.width;
              var height = src.height;
              var cellWidth = src.cellWidth;
              var cellHeight = src.cellHeight;
              var gridWidth = Math.ceil(width / cellWidth);
              var gridHeight = Math.ceil(height / cellHeight);
              var cellWidthA = cellWidth;
              var cellHeightA = cellHeight;
              var cellWidthB = cellWidth - (gridWidth * cellWidth - width);
              var cellHeightB = cellHeight - (gridHeight * cellHeight - height);
              var showCells = src.showCells;
              var showAltCells = src.showAltCells;
              var showOutline = src.showOutline;
              var x = 0;
              var y = 0;
              var r = 0;
              var cw = 0;
              var ch = 0;
              if (showOutline) {
                cellWidthA--;
                cellHeightA--;
                if (cellWidthB === cellWidth) {
                  cellWidthB--;
                }
                if (cellHeightB === cellHeight) {
                  cellHeightB--;
                }
              }
              if (showCells && src.fillAlpha > 0) {
                FillStyleCanvas(ctx, src);
                for (y = 0; y < gridHeight; y++) {
                  if (showAltCells) {
                    r = y % 2;
                  }
                  for (x = 0; x < gridWidth; x++) {
                    if (showAltCells && r) {
                      r = 0;
                      continue;
                    }
                    r++;
                    cw = x < gridWidth - 1 ? cellWidthA : cellWidthB;
                    ch = y < gridHeight - 1 ? cellHeightA : cellHeightB;
                    ctx.fillRect(dx + x * cellWidth, dy + y * cellHeight, cw, ch);
                  }
                }
              }
              if (showAltCells && src.altFillAlpha > 0) {
                FillStyleCanvas(ctx, src, src.altFillColor, src.altFillAlpha * alpha);
                for (y = 0; y < gridHeight; y++) {
                  if (showAltCells) {
                    r = y % 2;
                  }
                  for (x = 0; x < gridWidth; x++) {
                    if (showAltCells && !r) {
                      r = 1;
                      continue;
                    }
                    r = 0;
                    cw = x < gridWidth - 1 ? cellWidthA : cellWidthB;
                    ch = y < gridHeight - 1 ? cellHeightA : cellHeightB;
                    ctx.fillRect(dx + x * cellWidth, dy + y * cellHeight, cw, ch);
                  }
                }
              }
              if (showOutline && src.outlineFillAlpha > 0) {
                LineStyleCanvas(ctx, src, src.outlineFillColor, src.outlineFillAlpha * alpha);
                for (x = 1; x < gridWidth; x++) {
                  var x1 = x * cellWidth;
                  ctx.beginPath();
                  ctx.moveTo(x1 + dx, dy);
                  ctx.lineTo(x1 + dx, height + dy);
                  ctx.stroke();
                }
                for (y = 1; y < gridHeight; y++) {
                  var y1 = y * cellHeight;
                  ctx.beginPath();
                  ctx.moveTo(dx, y1 + dy);
                  ctx.lineTo(dx + width, y1 + dy);
                  ctx.stroke();
                }
              }
              ctx.restore();
            }
          };
          module2.exports = GridCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1110);
          }
          if (true) {
            renderCanvas = __webpack_require__(1111);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var GetCalcMatrix = __webpack_require__(19);
          var Utils = __webpack_require__(12);
          var IsoBoxWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
            var size = src.width;
            var height = src.height;
            var sizeA = size / 2;
            var sizeB = size / src.projection;
            var alpha = camera.alpha * src.alpha;
            if (!src.isFilled) {
              return;
            }
            var tint;
            var x0;
            var y0;
            var x1;
            var y1;
            var x2;
            var y2;
            var x3;
            var y3;
            renderer.pipelines.preBatch(src);
            if (src.showTop) {
              tint = Utils.getTintAppendFloatAlpha(src.fillTop, alpha);
              x0 = calcMatrix.getX(-sizeA, -height);
              y0 = calcMatrix.getY(-sizeA, -height);
              x1 = calcMatrix.getX(0, -sizeB - height);
              y1 = calcMatrix.getY(0, -sizeB - height);
              x2 = calcMatrix.getX(sizeA, -height);
              y2 = calcMatrix.getY(sizeA, -height);
              x3 = calcMatrix.getX(0, sizeB - height);
              y3 = calcMatrix.getY(0, sizeB - height);
              pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
            }
            if (src.showLeft) {
              tint = Utils.getTintAppendFloatAlpha(src.fillLeft, alpha);
              x0 = calcMatrix.getX(-sizeA, 0);
              y0 = calcMatrix.getY(-sizeA, 0);
              x1 = calcMatrix.getX(0, sizeB);
              y1 = calcMatrix.getY(0, sizeB);
              x2 = calcMatrix.getX(0, sizeB - height);
              y2 = calcMatrix.getY(0, sizeB - height);
              x3 = calcMatrix.getX(-sizeA, -height);
              y3 = calcMatrix.getY(-sizeA, -height);
              pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
            }
            if (src.showRight) {
              tint = Utils.getTintAppendFloatAlpha(src.fillRight, alpha);
              x0 = calcMatrix.getX(sizeA, 0);
              y0 = calcMatrix.getY(sizeA, 0);
              x1 = calcMatrix.getX(0, sizeB);
              y1 = calcMatrix.getY(0, sizeB);
              x2 = calcMatrix.getX(0, sizeB - height);
              y2 = calcMatrix.getY(0, sizeB - height);
              x3 = calcMatrix.getX(sizeA, -height);
              y3 = calcMatrix.getY(sizeA, -height);
              pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = IsoBoxWebGLRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var FillStyleCanvas = __webpack_require__(48);
          var SetTransform = __webpack_require__(30);
          var IsoBoxCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix) && src.isFilled) {
              var size = src.width;
              var height = src.height;
              var sizeA = size / 2;
              var sizeB = size / src.projection;
              if (src.showTop) {
                FillStyleCanvas(ctx, src, src.fillTop);
                ctx.beginPath();
                ctx.moveTo(-sizeA, -height);
                ctx.lineTo(0, -sizeB - height);
                ctx.lineTo(sizeA, -height);
                ctx.lineTo(sizeA, -1);
                ctx.lineTo(0, sizeB - 1);
                ctx.lineTo(-sizeA, -1);
                ctx.lineTo(-sizeA, -height);
                ctx.fill();
              }
              if (src.showLeft) {
                FillStyleCanvas(ctx, src, src.fillLeft);
                ctx.beginPath();
                ctx.moveTo(-sizeA, 0);
                ctx.lineTo(0, sizeB);
                ctx.lineTo(0, sizeB - height);
                ctx.lineTo(-sizeA, -height);
                ctx.lineTo(-sizeA, 0);
                ctx.fill();
              }
              if (src.showRight) {
                FillStyleCanvas(ctx, src, src.fillRight);
                ctx.beginPath();
                ctx.moveTo(sizeA, 0);
                ctx.lineTo(0, sizeB);
                ctx.lineTo(0, sizeB - height);
                ctx.lineTo(sizeA, -height);
                ctx.lineTo(sizeA, 0);
                ctx.fill();
              }
              ctx.restore();
            }
          };
          module2.exports = IsoBoxCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1113);
          }
          if (true) {
            renderCanvas = __webpack_require__(1114);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var GetCalcMatrix = __webpack_require__(19);
          var Utils = __webpack_require__(12);
          var IsoTriangleWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
            var size = src.width;
            var height = src.height;
            var sizeA = size / 2;
            var sizeB = size / src.projection;
            var reversed = src.isReversed;
            var alpha = camera.alpha * src.alpha;
            if (!src.isFilled) {
              return;
            }
            renderer.pipelines.preBatch(src);
            var tint;
            var x0;
            var y0;
            var x1;
            var y1;
            var x2;
            var y2;
            if (src.showTop && reversed) {
              tint = Utils.getTintAppendFloatAlpha(src.fillTop, alpha);
              x0 = calcMatrix.getX(-sizeA, -height);
              y0 = calcMatrix.getY(-sizeA, -height);
              x1 = calcMatrix.getX(0, -sizeB - height);
              y1 = calcMatrix.getY(0, -sizeB - height);
              x2 = calcMatrix.getX(sizeA, -height);
              y2 = calcMatrix.getY(sizeA, -height);
              var x3 = calcMatrix.getX(0, sizeB - height);
              var y3 = calcMatrix.getY(0, sizeB - height);
              pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
            }
            if (src.showLeft) {
              tint = Utils.getTintAppendFloatAlpha(src.fillLeft, alpha);
              if (reversed) {
                x0 = calcMatrix.getX(-sizeA, -height);
                y0 = calcMatrix.getY(-sizeA, -height);
                x1 = calcMatrix.getX(0, sizeB);
                y1 = calcMatrix.getY(0, sizeB);
                x2 = calcMatrix.getX(0, sizeB - height);
                y2 = calcMatrix.getY(0, sizeB - height);
              } else {
                x0 = calcMatrix.getX(-sizeA, 0);
                y0 = calcMatrix.getY(-sizeA, 0);
                x1 = calcMatrix.getX(0, sizeB);
                y1 = calcMatrix.getY(0, sizeB);
                x2 = calcMatrix.getX(0, sizeB - height);
                y2 = calcMatrix.getY(0, sizeB - height);
              }
              pipeline.batchTri(src, x0, y0, x1, y1, x2, y2, 0, 0, 1, 1, tint, tint, tint, 2);
            }
            if (src.showRight) {
              tint = Utils.getTintAppendFloatAlpha(src.fillRight, alpha);
              if (reversed) {
                x0 = calcMatrix.getX(sizeA, -height);
                y0 = calcMatrix.getY(sizeA, -height);
                x1 = calcMatrix.getX(0, sizeB);
                y1 = calcMatrix.getY(0, sizeB);
                x2 = calcMatrix.getX(0, sizeB - height);
                y2 = calcMatrix.getY(0, sizeB - height);
              } else {
                x0 = calcMatrix.getX(sizeA, 0);
                y0 = calcMatrix.getY(sizeA, 0);
                x1 = calcMatrix.getX(0, sizeB);
                y1 = calcMatrix.getY(0, sizeB);
                x2 = calcMatrix.getX(0, sizeB - height);
                y2 = calcMatrix.getY(0, sizeB - height);
              }
              pipeline.batchTri(src, x0, y0, x1, y1, x2, y2, 0, 0, 1, 1, tint, tint, tint, 2);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = IsoTriangleWebGLRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var FillStyleCanvas = __webpack_require__(48);
          var SetTransform = __webpack_require__(30);
          var IsoTriangleCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix) && src.isFilled) {
              var size = src.width;
              var height = src.height;
              var sizeA = size / 2;
              var sizeB = size / src.projection;
              var reversed = src.isReversed;
              if (src.showTop && reversed) {
                FillStyleCanvas(ctx, src, src.fillTop);
                ctx.beginPath();
                ctx.moveTo(-sizeA, -height);
                ctx.lineTo(0, -sizeB - height);
                ctx.lineTo(sizeA, -height);
                ctx.lineTo(0, sizeB - height);
                ctx.fill();
              }
              if (src.showLeft) {
                FillStyleCanvas(ctx, src, src.fillLeft);
                ctx.beginPath();
                if (reversed) {
                  ctx.moveTo(-sizeA, -height);
                  ctx.lineTo(0, sizeB);
                  ctx.lineTo(0, sizeB - height);
                } else {
                  ctx.moveTo(-sizeA, 0);
                  ctx.lineTo(0, sizeB);
                  ctx.lineTo(0, sizeB - height);
                }
                ctx.fill();
              }
              if (src.showRight) {
                FillStyleCanvas(ctx, src, src.fillRight);
                ctx.beginPath();
                if (reversed) {
                  ctx.moveTo(sizeA, -height);
                  ctx.lineTo(0, sizeB);
                  ctx.lineTo(0, sizeB - height);
                } else {
                  ctx.moveTo(sizeA, 0);
                  ctx.lineTo(0, sizeB);
                  ctx.lineTo(0, sizeB - height);
                }
                ctx.fill();
              }
              ctx.restore();
            }
          };
          module2.exports = IsoTriangleCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1116);
          }
          if (true) {
            renderCanvas = __webpack_require__(1117);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var GetCalcMatrix = __webpack_require__(19);
          var Utils = __webpack_require__(12);
          var LineWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            pipeline.calcMatrix.copyFrom(result.calc);
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            var alpha = camera.alpha * src.alpha;
            renderer.pipelines.preBatch(src);
            if (src.isStroked) {
              var strokeTint = pipeline.strokeTint;
              var color = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);
              strokeTint.TL = color;
              strokeTint.TR = color;
              strokeTint.BL = color;
              strokeTint.BR = color;
              var startWidth = src._startWidth;
              var endWidth = src._endWidth;
              pipeline.batchLine(src.geom.x1 - dx, src.geom.y1 - dy, src.geom.x2 - dx, src.geom.y2 - dy, startWidth, endWidth, 1, 0, false, result.sprite, result.camera);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = LineWebGLRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var LineStyleCanvas = __webpack_require__(60);
          var SetTransform = __webpack_require__(30);
          var LineCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              var dx = src._displayOriginX;
              var dy = src._displayOriginY;
              if (src.isStroked) {
                LineStyleCanvas(ctx, src);
                ctx.beginPath();
                ctx.moveTo(src.geom.x1 - dx, src.geom.y1 - dy);
                ctx.lineTo(src.geom.x2 - dx, src.geom.y2 - dy);
                ctx.stroke();
              }
              ctx.restore();
            }
          };
          module2.exports = LineCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1119);
          }
          if (true) {
            renderCanvas = __webpack_require__(1120);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var FillPathWebGL = __webpack_require__(114);
          var GetCalcMatrix = __webpack_require__(19);
          var StrokePathWebGL = __webpack_require__(81);
          var PolygonWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            var alpha = camera.alpha * src.alpha;
            renderer.pipelines.preBatch(src);
            if (src.isFilled) {
              FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
            }
            if (src.isStroked) {
              StrokePathWebGL(pipeline, src, alpha, dx, dy);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = PolygonWebGLRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var FillStyleCanvas = __webpack_require__(48);
          var LineStyleCanvas = __webpack_require__(60);
          var SetTransform = __webpack_require__(30);
          var PolygonCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              var dx = src._displayOriginX;
              var dy = src._displayOriginY;
              var path = src.pathData;
              var pathLength = path.length - 1;
              var px1 = path[0] - dx;
              var py1 = path[1] - dy;
              ctx.beginPath();
              ctx.moveTo(px1, py1);
              if (!src.closePath) {
                pathLength -= 2;
              }
              for (var i = 2; i < pathLength; i += 2) {
                var px2 = path[i] - dx;
                var py2 = path[i + 1] - dy;
                ctx.lineTo(px2, py2);
              }
              ctx.closePath();
              if (src.isFilled) {
                FillStyleCanvas(ctx, src);
                ctx.fill();
              }
              if (src.isStroked) {
                LineStyleCanvas(ctx, src);
                ctx.stroke();
              }
              ctx.restore();
            }
          };
          module2.exports = PolygonCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1122);
          }
          if (true) {
            renderCanvas = __webpack_require__(1123);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var GetCalcMatrix = __webpack_require__(19);
          var StrokePathWebGL = __webpack_require__(81);
          var Utils = __webpack_require__(12);
          var RectangleWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            pipeline.calcMatrix.copyFrom(result.calc);
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            var alpha = camera.alpha * src.alpha;
            renderer.pipelines.preBatch(src);
            if (src.isFilled) {
              var fillTint = pipeline.fillTint;
              var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
              fillTint.TL = fillTintColor;
              fillTint.TR = fillTintColor;
              fillTint.BL = fillTintColor;
              fillTint.BR = fillTintColor;
              pipeline.batchFillRect(-dx, -dy, src.width, src.height);
            }
            if (src.isStroked) {
              StrokePathWebGL(pipeline, src, alpha, dx, dy);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = RectangleWebGLRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var FillStyleCanvas = __webpack_require__(48);
          var LineStyleCanvas = __webpack_require__(60);
          var SetTransform = __webpack_require__(30);
          var RectangleCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              var dx = src._displayOriginX;
              var dy = src._displayOriginY;
              if (src.isFilled) {
                FillStyleCanvas(ctx, src);
                ctx.fillRect(-dx, -dy, src.width, src.height);
              }
              if (src.isStroked) {
                LineStyleCanvas(ctx, src);
                ctx.beginPath();
                ctx.rect(-dx, -dy, src.width, src.height);
                ctx.stroke();
              }
              ctx.restore();
            }
          };
          module2.exports = RectangleCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1125);
          }
          if (true) {
            renderCanvas = __webpack_require__(1126);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var FillPathWebGL = __webpack_require__(114);
          var GetCalcMatrix = __webpack_require__(19);
          var StrokePathWebGL = __webpack_require__(81);
          var StarWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            var alpha = camera.alpha * src.alpha;
            renderer.pipelines.preBatch(src);
            if (src.isFilled) {
              FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
            }
            if (src.isStroked) {
              StrokePathWebGL(pipeline, src, alpha, dx, dy);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = StarWebGLRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var FillStyleCanvas = __webpack_require__(48);
          var LineStyleCanvas = __webpack_require__(60);
          var SetTransform = __webpack_require__(30);
          var StarCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              var dx = src._displayOriginX;
              var dy = src._displayOriginY;
              var path = src.pathData;
              var pathLength = path.length - 1;
              var px1 = path[0] - dx;
              var py1 = path[1] - dy;
              ctx.beginPath();
              ctx.moveTo(px1, py1);
              if (!src.closePath) {
                pathLength -= 2;
              }
              for (var i = 2; i < pathLength; i += 2) {
                var px2 = path[i] - dx;
                var py2 = path[i + 1] - dy;
                ctx.lineTo(px2, py2);
              }
              ctx.closePath();
              if (src.isFilled) {
                FillStyleCanvas(ctx, src);
                ctx.fill();
              }
              if (src.isStroked) {
                LineStyleCanvas(ctx, src);
                ctx.stroke();
              }
              ctx.restore();
            }
          };
          module2.exports = StarCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1128);
          }
          if (true) {
            renderCanvas = __webpack_require__(1129);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var GetCalcMatrix = __webpack_require__(19);
          var StrokePathWebGL = __webpack_require__(81);
          var Utils = __webpack_require__(12);
          var TriangleWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var result = GetCalcMatrix(src, camera, parentMatrix);
            pipeline.calcMatrix.copyFrom(result.calc);
            var dx = src._displayOriginX;
            var dy = src._displayOriginY;
            var alpha = camera.alpha * src.alpha;
            renderer.pipelines.preBatch(src);
            if (src.isFilled) {
              var fillTint = pipeline.fillTint;
              var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
              fillTint.TL = fillTintColor;
              fillTint.TR = fillTintColor;
              fillTint.BL = fillTintColor;
              fillTint.BR = fillTintColor;
              var x1 = src.geom.x1 - dx;
              var y1 = src.geom.y1 - dy;
              var x2 = src.geom.x2 - dx;
              var y2 = src.geom.y2 - dy;
              var x3 = src.geom.x3 - dx;
              var y3 = src.geom.y3 - dy;
              pipeline.batchFillTriangle(x1, y1, x2, y2, x3, y3, result.sprite, result.camera);
            }
            if (src.isStroked) {
              StrokePathWebGL(pipeline, src, alpha, dx, dy);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = TriangleWebGLRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var FillStyleCanvas = __webpack_require__(48);
          var LineStyleCanvas = __webpack_require__(60);
          var SetTransform = __webpack_require__(30);
          var TriangleCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var ctx = renderer.currentContext;
            if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
              var dx = src._displayOriginX;
              var dy = src._displayOriginY;
              var x1 = src.geom.x1 - dx;
              var y1 = src.geom.y1 - dy;
              var x2 = src.geom.x2 - dx;
              var y2 = src.geom.y2 - dy;
              var x3 = src.geom.x3 - dx;
              var y3 = src.geom.y3 - dy;
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x2, y2);
              ctx.lineTo(x3, y3);
              ctx.closePath();
              if (src.isFilled) {
                FillStyleCanvas(ctx, src);
                ctx.fill();
              }
              if (src.isStroked) {
                LineStyleCanvas(ctx, src);
                ctx.stroke();
              }
              ctx.restore();
            }
          };
          module2.exports = TriangleCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var Blitter = __webpack_require__(213);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("blitter", function (x, y, key, frame) {
            return this.displayList.add(new Blitter(this.scene, x, y, key, frame));
          });
        }, function (module2, exports2, __webpack_require__) {
          var Container = __webpack_require__(214);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("container", function (x, y, children) {
            return this.displayList.add(new Container(this.scene, x, y, children));
          });
        }, function (module2, exports2, __webpack_require__) {
          var DOMElement = __webpack_require__(442);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("dom", function (x, y, element, style, innerText) {
            var gameObject = new DOMElement(this.scene, x, y, element, style, innerText);
            this.displayList.add(gameObject);
            return gameObject;
          });
        }, function (module2, exports2, __webpack_require__) {
          var DynamicBitmapText = __webpack_require__(215);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("dynamicBitmapText", function (x, y, font, text, size) {
            return this.displayList.add(new DynamicBitmapText(this.scene, x, y, font, text, size));
          });
        }, function (module2, exports2, __webpack_require__) {
          var Extern = __webpack_require__(444);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("extern", function () {
            var extern = new Extern(this.scene);
            this.displayList.add(extern);
            return extern;
          });
        }, function (module2, exports2, __webpack_require__) {
          var Graphics = __webpack_require__(216);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("graphics", function (config) {
            return this.displayList.add(new Graphics(this.scene, config));
          });
        }, function (module2, exports2, __webpack_require__) {
          var Group = __webpack_require__(113);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("group", function (children, config) {
            return this.updateList.add(new Group(this.scene, children, config));
          });
        }, function (module2, exports2, __webpack_require__) {
          var Image2 = __webpack_require__(125);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("image", function (x, y, key, frame) {
            return this.displayList.add(new Image2(this.scene, x, y, key, frame));
          });
        }, function (module2, exports2, __webpack_require__) {
          var Layer = __webpack_require__(219);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("layer", function (children) {
            return this.displayList.add(new Layer(this.scene, children));
          });
        }, function (module2, exports2, __webpack_require__) {
          var GameObjectFactory = __webpack_require__(5);
          var ParticleEmitterManager = __webpack_require__(220);
          GameObjectFactory.register("particles", function (key, frame, emitters) {
            return this.displayList.add(new ParticleEmitterManager(this.scene, key, frame, emitters));
          });
        }, function (module2, exports2, __webpack_require__) {
          var GameObjectFactory = __webpack_require__(5);
          var PathFollower = __webpack_require__(457);
          GameObjectFactory.register("follower", function (path, x, y, key, frame) {
            var sprite = new PathFollower(this.scene, path, x, y, key, frame);
            this.displayList.add(sprite);
            this.updateList.add(sprite);
            return sprite;
          });
        }, function (module2, exports2, __webpack_require__) {
          var GameObjectFactory = __webpack_require__(5);
          var RenderTexture = __webpack_require__(221);
          GameObjectFactory.register("renderTexture", function (x, y, width, height, key, frame) {
            return this.displayList.add(new RenderTexture(this.scene, x, y, width, height, key, frame));
          });
        }, function (module2, exports2, __webpack_require__) {
          var Rope = __webpack_require__(223);
          var GameObjectFactory = __webpack_require__(5);
          if (true) {
            GameObjectFactory.register("rope", function (x, y, texture, frame, points, horizontal, colors, alphas) {
              return this.displayList.add(new Rope(this.scene, x, y, texture, frame, points, horizontal, colors, alphas));
            });
          }
        }, function (module2, exports2, __webpack_require__) {
          var GameObjectFactory = __webpack_require__(5);
          var Sprite = __webpack_require__(73);
          GameObjectFactory.register("sprite", function (x, y, key, frame) {
            var sprite = new Sprite(this.scene, x, y, key, frame);
            this.displayList.add(sprite);
            return sprite;
          });
        }, function (module2, exports2, __webpack_require__) {
          var BitmapText = __webpack_require__(148);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("bitmapText", function (x, y, font, text, size, align) {
            return this.displayList.add(new BitmapText(this.scene, x, y, font, text, size, align));
          });
        }, function (module2, exports2, __webpack_require__) {
          var Text = __webpack_require__(224);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("text", function (x, y, text, style) {
            return this.displayList.add(new Text(this.scene, x, y, text, style));
          });
        }, function (module2, exports2, __webpack_require__) {
          var TileSprite = __webpack_require__(225);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("tileSprite", function (x, y, width, height, key, frame) {
            return this.displayList.add(new TileSprite(this.scene, x, y, width, height, key, frame));
          });
        }, function (module2, exports2, __webpack_require__) {
          var Zone = __webpack_require__(129);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("zone", function (x, y, width, height) {
            return this.displayList.add(new Zone(this.scene, x, y, width, height));
          });
        }, function (module2, exports2, __webpack_require__) {
          var Video = __webpack_require__(226);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("video", function (x, y, key) {
            return this.displayList.add(new Video(this.scene, x, y, key));
          });
        }, function (module2, exports2, __webpack_require__) {
          var Arc = __webpack_require__(461);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("arc", function (x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha) {
            return this.displayList.add(new Arc(this.scene, x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha));
          });
          GameObjectFactory.register("circle", function (x, y, radius, fillColor, fillAlpha) {
            return this.displayList.add(new Arc(this.scene, x, y, radius, 0, 360, false, fillColor, fillAlpha));
          });
        }, function (module2, exports2, __webpack_require__) {
          var GameObjectFactory = __webpack_require__(5);
          var Curve = __webpack_require__(462);
          GameObjectFactory.register("curve", function (x, y, curve, fillColor, fillAlpha) {
            return this.displayList.add(new Curve(this.scene, x, y, curve, fillColor, fillAlpha));
          });
        }, function (module2, exports2, __webpack_require__) {
          var Ellipse = __webpack_require__(463);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("ellipse", function (x, y, width, height, fillColor, fillAlpha) {
            return this.displayList.add(new Ellipse(this.scene, x, y, width, height, fillColor, fillAlpha));
          });
        }, function (module2, exports2, __webpack_require__) {
          var GameObjectFactory = __webpack_require__(5);
          var Grid = __webpack_require__(464);
          GameObjectFactory.register("grid", function (x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha) {
            return this.displayList.add(new Grid(this.scene, x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha));
          });
        }, function (module2, exports2, __webpack_require__) {
          var GameObjectFactory = __webpack_require__(5);
          var IsoBox = __webpack_require__(465);
          GameObjectFactory.register("isobox", function (x, y, size, height, fillTop, fillLeft, fillRight) {
            return this.displayList.add(new IsoBox(this.scene, x, y, size, height, fillTop, fillLeft, fillRight));
          });
        }, function (module2, exports2, __webpack_require__) {
          var GameObjectFactory = __webpack_require__(5);
          var IsoTriangle = __webpack_require__(466);
          GameObjectFactory.register("isotriangle", function (x, y, size, height, reversed, fillTop, fillLeft, fillRight) {
            return this.displayList.add(new IsoTriangle(this.scene, x, y, size, height, reversed, fillTop, fillLeft, fillRight));
          });
        }, function (module2, exports2, __webpack_require__) {
          var GameObjectFactory = __webpack_require__(5);
          var Line = __webpack_require__(467);
          GameObjectFactory.register("line", function (x, y, x1, y1, x2, y2, strokeColor, strokeAlpha) {
            return this.displayList.add(new Line(this.scene, x, y, x1, y1, x2, y2, strokeColor, strokeAlpha));
          });
        }, function (module2, exports2, __webpack_require__) {
          var GameObjectFactory = __webpack_require__(5);
          var Polygon = __webpack_require__(468);
          GameObjectFactory.register("polygon", function (x, y, points, fillColor, fillAlpha) {
            return this.displayList.add(new Polygon(this.scene, x, y, points, fillColor, fillAlpha));
          });
        }, function (module2, exports2, __webpack_require__) {
          var GameObjectFactory = __webpack_require__(5);
          var Rectangle = __webpack_require__(473);
          GameObjectFactory.register("rectangle", function (x, y, width, height, fillColor, fillAlpha) {
            return this.displayList.add(new Rectangle(this.scene, x, y, width, height, fillColor, fillAlpha));
          });
        }, function (module2, exports2, __webpack_require__) {
          var Star = __webpack_require__(474);
          var GameObjectFactory = __webpack_require__(5);
          GameObjectFactory.register("star", function (x, y, points, innerRadius, outerRadius, fillColor, fillAlpha) {
            return this.displayList.add(new Star(this.scene, x, y, points, innerRadius, outerRadius, fillColor, fillAlpha));
          });
        }, function (module2, exports2, __webpack_require__) {
          var GameObjectFactory = __webpack_require__(5);
          var Triangle = __webpack_require__(475);
          GameObjectFactory.register("triangle", function (x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha) {
            return this.displayList.add(new Triangle(this.scene, x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha));
          });
        }, function (module2, exports2, __webpack_require__) {
          var Blitter = __webpack_require__(213);
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          GameObjectCreator.register("blitter", function (config, addToScene) {
            if (config === void 0) {
              config = {};
            }
            var key = GetAdvancedValue(config, "key", null);
            var frame = GetAdvancedValue(config, "frame", null);
            var blitter = new Blitter(this.scene, 0, 0, key, frame);
            if (addToScene !== void 0) {
              config.add = addToScene;
            }
            BuildGameObject(this.scene, blitter, config);
            return blitter;
          });
        }, function (module2, exports2, __webpack_require__) {
          var BuildGameObject = __webpack_require__(28);
          var Container = __webpack_require__(214);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          GameObjectCreator.register("container", function (config, addToScene) {
            if (config === void 0) {
              config = {};
            }
            var x = GetAdvancedValue(config, "x", 0);
            var y = GetAdvancedValue(config, "y", 0);
            var children = GetAdvancedValue(config, "children", null);
            var container = new Container(this.scene, x, y, children);
            if (addToScene !== void 0) {
              config.add = addToScene;
            }
            BuildGameObject(this.scene, container, config);
            return container;
          });
        }, function (module2, exports2, __webpack_require__) {
          var BitmapText = __webpack_require__(215);
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          GameObjectCreator.register("dynamicBitmapText", function (config, addToScene) {
            if (config === void 0) {
              config = {};
            }
            var font = GetAdvancedValue(config, "font", "");
            var text = GetAdvancedValue(config, "text", "");
            var size = GetAdvancedValue(config, "size", false);
            var bitmapText = new BitmapText(this.scene, 0, 0, font, text, size);
            if (addToScene !== void 0) {
              config.add = addToScene;
            }
            BuildGameObject(this.scene, bitmapText, config);
            return bitmapText;
          });
        }, function (module2, exports2, __webpack_require__) {
          var GameObjectCreator = __webpack_require__(16);
          var Graphics = __webpack_require__(216);
          GameObjectCreator.register("graphics", function (config, addToScene) {
            if (config === void 0) {
              config = {};
            }
            if (addToScene !== void 0) {
              config.add = addToScene;
            }
            var graphics = new Graphics(this.scene, config);
            if (config.add) {
              this.scene.sys.displayList.add(graphics);
            }
            return graphics;
          });
        }, function (module2, exports2, __webpack_require__) {
          var GameObjectCreator = __webpack_require__(16);
          var Group = __webpack_require__(113);
          GameObjectCreator.register("group", function (config) {
            return new Group(this.scene, null, config);
          });
        }, function (module2, exports2, __webpack_require__) {
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var Image2 = __webpack_require__(125);
          GameObjectCreator.register("image", function (config, addToScene) {
            if (config === void 0) {
              config = {};
            }
            var key = GetAdvancedValue(config, "key", null);
            var frame = GetAdvancedValue(config, "frame", null);
            var image = new Image2(this.scene, 0, 0, key, frame);
            if (addToScene !== void 0) {
              config.add = addToScene;
            }
            BuildGameObject(this.scene, image, config);
            return image;
          });
        }, function (module2, exports2, __webpack_require__) {
          var BuildGameObject = __webpack_require__(28);
          var Layer = __webpack_require__(219);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          GameObjectCreator.register("layer", function (config, addToScene) {
            if (config === void 0) {
              config = {};
            }
            var children = GetAdvancedValue(config, "children", null);
            var layer = new Layer(this.scene, children);
            if (addToScene !== void 0) {
              config.add = addToScene;
            }
            BuildGameObject(this.scene, layer, config);
            return layer;
          });
        }, function (module2, exports2, __webpack_require__) {
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var GetFastValue = __webpack_require__(2);
          var ParticleEmitterManager = __webpack_require__(220);
          GameObjectCreator.register("particles", function (config, addToScene) {
            if (config === void 0) {
              config = {};
            }
            var key = GetAdvancedValue(config, "key", null);
            var frame = GetAdvancedValue(config, "frame", null);
            var emitters = GetFastValue(config, "emitters", null);
            var manager = new ParticleEmitterManager(this.scene, key, frame, emitters);
            if (addToScene !== void 0) {
              config.add = addToScene;
            }
            var add = GetFastValue(config, "add", false);
            if (add) {
              this.displayList.add(manager);
            } else {
              this.updateList.add(manager);
            }
            return manager;
          });
        }, function (module2, exports2, __webpack_require__) {
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var RenderTexture = __webpack_require__(221);
          GameObjectCreator.register("renderTexture", function (config, addToScene) {
            if (config === void 0) {
              config = {};
            }
            var x = GetAdvancedValue(config, "x", 0);
            var y = GetAdvancedValue(config, "y", 0);
            var width = GetAdvancedValue(config, "width", 32);
            var height = GetAdvancedValue(config, "height", 32);
            var key = GetAdvancedValue(config, "key", void 0);
            var frame = GetAdvancedValue(config, "frame", void 0);
            var renderTexture = new RenderTexture(this.scene, x, y, width, height, key, frame);
            if (addToScene !== void 0) {
              config.add = addToScene;
            }
            BuildGameObject(this.scene, renderTexture, config);
            return renderTexture;
          });
        }, function (module2, exports2, __webpack_require__) {
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var GetValue = __webpack_require__(6);
          var Rope = __webpack_require__(223);
          GameObjectCreator.register("rope", function (config, addToScene) {
            if (config === void 0) {
              config = {};
            }
            var key = GetAdvancedValue(config, "key", null);
            var frame = GetAdvancedValue(config, "frame", null);
            var horizontal = GetAdvancedValue(config, "horizontal", true);
            var points = GetValue(config, "points", void 0);
            var colors = GetValue(config, "colors", void 0);
            var alphas = GetValue(config, "alphas", void 0);
            var rope = new Rope(this.scene, 0, 0, key, frame, points, horizontal, colors, alphas);
            if (addToScene !== void 0) {
              config.add = addToScene;
            }
            BuildGameObject(this.scene, rope, config);
            if (!config.add) {
              this.updateList.add(rope);
            }
            return rope;
          });
        }, function (module2, exports2, __webpack_require__) {
          var BuildGameObject = __webpack_require__(28);
          var BuildGameObjectAnimation = __webpack_require__(439);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var Sprite = __webpack_require__(73);
          GameObjectCreator.register("sprite", function (config, addToScene) {
            if (config === void 0) {
              config = {};
            }
            var key = GetAdvancedValue(config, "key", null);
            var frame = GetAdvancedValue(config, "frame", null);
            var sprite = new Sprite(this.scene, 0, 0, key, frame);
            if (addToScene !== void 0) {
              config.add = addToScene;
            }
            BuildGameObject(this.scene, sprite, config);
            BuildGameObjectAnimation(sprite, config);
            return sprite;
          });
        }, function (module2, exports2, __webpack_require__) {
          var BitmapText = __webpack_require__(148);
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var GetValue = __webpack_require__(6);
          GameObjectCreator.register("bitmapText", function (config, addToScene) {
            if (config === void 0) {
              config = {};
            }
            var font = GetValue(config, "font", "");
            var text = GetAdvancedValue(config, "text", "");
            var size = GetAdvancedValue(config, "size", false);
            var align = GetValue(config, "align", 0);
            var bitmapText = new BitmapText(this.scene, 0, 0, font, text, size, align);
            if (addToScene !== void 0) {
              config.add = addToScene;
            }
            BuildGameObject(this.scene, bitmapText, config);
            return bitmapText;
          });
        }, function (module2, exports2, __webpack_require__) {
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var Text = __webpack_require__(224);
          GameObjectCreator.register("text", function (config, addToScene) {
            if (config === void 0) {
              config = {};
            }
            var content = GetAdvancedValue(config, "text", "");
            var style = GetAdvancedValue(config, "style", null);
            var padding = GetAdvancedValue(config, "padding", null);
            if (padding !== null) {
              style.padding = padding;
            }
            var text = new Text(this.scene, 0, 0, content, style);
            if (addToScene !== void 0) {
              config.add = addToScene;
            }
            BuildGameObject(this.scene, text, config);
            text.autoRound = GetAdvancedValue(config, "autoRound", true);
            text.resolution = GetAdvancedValue(config, "resolution", 1);
            return text;
          });
        }, function (module2, exports2, __webpack_require__) {
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var TileSprite = __webpack_require__(225);
          GameObjectCreator.register("tileSprite", function (config, addToScene) {
            if (config === void 0) {
              config = {};
            }
            var x = GetAdvancedValue(config, "x", 0);
            var y = GetAdvancedValue(config, "y", 0);
            var width = GetAdvancedValue(config, "width", 512);
            var height = GetAdvancedValue(config, "height", 512);
            var key = GetAdvancedValue(config, "key", "");
            var frame = GetAdvancedValue(config, "frame", "");
            var tile = new TileSprite(this.scene, x, y, width, height, key, frame);
            if (addToScene !== void 0) {
              config.add = addToScene;
            }
            BuildGameObject(this.scene, tile, config);
            return tile;
          });
        }, function (module2, exports2, __webpack_require__) {
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var Zone = __webpack_require__(129);
          GameObjectCreator.register("zone", function (config) {
            var x = GetAdvancedValue(config, "x", 0);
            var y = GetAdvancedValue(config, "y", 0);
            var width = GetAdvancedValue(config, "width", 1);
            var height = GetAdvancedValue(config, "height", width);
            return new Zone(this.scene, x, y, width, height);
          });
        }, function (module2, exports2, __webpack_require__) {
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var Video = __webpack_require__(226);
          GameObjectCreator.register("video", function (config, addToScene) {
            if (config === void 0) {
              config = {};
            }
            var key = GetAdvancedValue(config, "key", null);
            var video = new Video(this.scene, 0, 0, key);
            if (addToScene !== void 0) {
              config.add = addToScene;
            }
            BuildGameObject(this.scene, video, config);
            if (!config.add) {
              this.updateList.add(video);
            }
            return video;
          });
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1177);
          }
          if (true) {
            renderCanvas = __webpack_require__(1178);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var GetCalcMatrix = __webpack_require__(19);
          var ShaderWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            if (!src.shader) {
              return;
            }
            camera.addToRenderList(src);
            renderer.pipelines.clear();
            if (src.renderToTexture) {
              src.load();
              src.flush();
            } else {
              var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
              if (renderer.width !== src._rendererWidth || renderer.height !== src._rendererHeight) {
                src.projOrtho(0, renderer.width, renderer.height, 0);
              }
              src.load(calcMatrix.matrix);
              src.flush();
            }
            renderer.pipelines.rebind();
          };
          module2.exports = ShaderWebGLRenderer;
        }, function (module2, exports2) {
          var ShaderCanvasRenderer = function () {};
          module2.exports = ShaderCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1180);
          }
          if (true) {
            renderCanvas = __webpack_require__(1181);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var GetCalcMatrix = __webpack_require__(19);
          var MeshWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            var faces = src.faces;
            var totalFaces = faces.length;
            if (totalFaces === 0) {
              return;
            }
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline, src);
            var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
            var textureUnit = pipeline.setGameObject(src);
            var F32 = pipeline.vertexViewF32;
            var U32 = pipeline.vertexViewU32;
            var vertexOffset = pipeline.vertexCount * pipeline.currentShader.vertexComponentCount - 1;
            var tintEffect = src.tintFill;
            var debugFaces = [];
            var debugCallback = src.debugCallback;
            var a = calcMatrix.a;
            var b = calcMatrix.b;
            var c = calcMatrix.c;
            var d = calcMatrix.d;
            var e = calcMatrix.e;
            var f = calcMatrix.f;
            var z = src.viewPosition.z;
            var hideCCW = src.hideCCW;
            var roundPixels = camera.roundPixels;
            var alpha = camera.alpha * src.alpha;
            var totalFacesRendered = 0;
            renderer.pipelines.preBatch(src);
            for (var i = 0; i < totalFaces; i++) {
              var face = faces[i];
              if (!face.isInView(camera, hideCCW, z, alpha, a, b, c, d, e, f, roundPixels)) {
                continue;
              }
              if (pipeline.shouldFlush(3)) {
                pipeline.flush();
                vertexOffset = 0;
              }
              vertexOffset = face.load(F32, U32, vertexOffset, textureUnit, tintEffect);
              totalFacesRendered++;
              pipeline.vertexCount += 3;
              if (debugCallback) {
                debugFaces.push(face);
              }
            }
            src.totalFrame += totalFacesRendered;
            if (debugCallback) {
              debugCallback.call(src, src, debugFaces);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = MeshWebGLRenderer;
        }, function (module2, exports2) {
          var MeshCanvasRenderer = function () {};
          module2.exports = MeshCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1183);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var GetCalcMatrix = __webpack_require__(19);
          var PointLightWebGLRenderer = function (renderer, src, camera, parentMatrix) {
            camera.addToRenderList(src);
            var pipeline = renderer.pipelines.set(src.pipeline);
            var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
            var width = src.width;
            var height = src.height;
            var x = -src._radius;
            var y = -src._radius;
            var xw = x + width;
            var yh = y + height;
            var lightX = calcMatrix.getX(0, 0);
            var lightY = calcMatrix.getY(0, 0);
            var tx0 = calcMatrix.getX(x, y);
            var ty0 = calcMatrix.getY(x, y);
            var tx1 = calcMatrix.getX(x, yh);
            var ty1 = calcMatrix.getY(x, yh);
            var tx2 = calcMatrix.getX(xw, yh);
            var ty2 = calcMatrix.getY(xw, yh);
            var tx3 = calcMatrix.getX(xw, y);
            var ty3 = calcMatrix.getY(xw, y);
            renderer.pipelines.preBatch(src);
            pipeline.batchPointLight(src, camera, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, lightX, lightY);
            renderer.pipelines.postBatch(src);
          };
          module2.exports = PointLightWebGLRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var Shader = __webpack_require__(229);
          var GameObjectFactory = __webpack_require__(5);
          if (true) {
            GameObjectFactory.register("shader", function (key, x, y, width, height, textures, textureData) {
              return this.displayList.add(new Shader(this.scene, key, x, y, width, height, textures, textureData));
            });
          }
        }, function (module2, exports2, __webpack_require__) {
          var Mesh = __webpack_require__(230);
          var GameObjectFactory = __webpack_require__(5);
          if (true) {
            GameObjectFactory.register("mesh", function (x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas) {
              return this.displayList.add(new Mesh(this.scene, x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas));
            });
          }
        }, function (module2, exports2, __webpack_require__) {
          var GameObjectFactory = __webpack_require__(5);
          var PointLight = __webpack_require__(150);
          GameObjectFactory.register("pointlight", function (x, y, color, radius, intensity, attenuation) {
            return this.displayList.add(new PointLight(this.scene, x, y, color, radius, intensity, attenuation));
          });
        }, function (module2, exports2, __webpack_require__) {
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var Shader = __webpack_require__(229);
          GameObjectCreator.register("shader", function (config, addToScene) {
            if (config === void 0) {
              config = {};
            }
            var key = GetAdvancedValue(config, "key", null);
            var x = GetAdvancedValue(config, "x", 0);
            var y = GetAdvancedValue(config, "y", 0);
            var width = GetAdvancedValue(config, "width", 128);
            var height = GetAdvancedValue(config, "height", 128);
            var shader = new Shader(this.scene, key, x, y, width, height);
            if (addToScene !== void 0) {
              config.add = addToScene;
            }
            BuildGameObject(this.scene, shader, config);
            return shader;
          });
        }, function (module2, exports2, __webpack_require__) {
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var GetValue = __webpack_require__(6);
          var Mesh = __webpack_require__(230);
          GameObjectCreator.register("mesh", function (config, addToScene) {
            if (config === void 0) {
              config = {};
            }
            var key = GetAdvancedValue(config, "key", null);
            var frame = GetAdvancedValue(config, "frame", null);
            var vertices = GetValue(config, "vertices", []);
            var uvs = GetValue(config, "uvs", []);
            var indicies = GetValue(config, "indicies", []);
            var containsZ = GetValue(config, "containsZ", false);
            var normals = GetValue(config, "normals", []);
            var colors = GetValue(config, "colors", 16777215);
            var alphas = GetValue(config, "alphas", 1);
            var mesh = new Mesh(this.scene, 0, 0, key, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas);
            if (addToScene !== void 0) {
              config.add = addToScene;
            }
            BuildGameObject(this.scene, mesh, config);
            return mesh;
          });
        }, function (module2, exports2, __webpack_require__) {
          var BuildGameObject = __webpack_require__(28);
          var GameObjectCreator = __webpack_require__(16);
          var GetAdvancedValue = __webpack_require__(13);
          var PointLight = __webpack_require__(150);
          GameObjectCreator.register("pointlight", function (config, addToScene) {
            if (config === void 0) {
              config = {};
            }
            var color = GetAdvancedValue(config, "color", 16777215);
            var radius = GetAdvancedValue(config, "radius", 128);
            var intensity = GetAdvancedValue(config, "intensity", 1);
            var attenuation = GetAdvancedValue(config, "attenuation", 0.1);
            var layer = new PointLight(this.scene, 0, 0, color, radius, intensity, attenuation);
            if (addToScene !== void 0) {
              config.add = addToScene;
            }
            BuildGameObject(this.scene, layer, config);
            return layer;
          });
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var LightsManager = __webpack_require__(482);
          var PluginCache = __webpack_require__(24);
          var SceneEvents = __webpack_require__(20);
          var LightsPlugin = new Class({
            Extends: LightsManager,
            initialize: function LightsPlugin2(scene) {
              this.scene = scene;
              this.systems = scene.sys;
              if (!scene.sys.settings.isBooted) {
                scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              }
              LightsManager.call(this);
            },
            boot: function () {
              var eventEmitter = this.systems.events;
              eventEmitter.on(SceneEvents.SHUTDOWN, this.shutdown, this);
              eventEmitter.on(SceneEvents.DESTROY, this.destroy, this);
            },
            destroy: function () {
              this.shutdown();
              this.scene = void 0;
              this.systems = void 0;
            }
          });
          PluginCache.register("LightsPlugin", LightsPlugin, "lights");
          module2.exports = LightsPlugin;
        }, function (module2, exports2, __webpack_require__) {
          var Circle = __webpack_require__(65);
          Circle.Area = __webpack_require__(1192);
          Circle.Circumference = __webpack_require__(302);
          Circle.CircumferencePoint = __webpack_require__(169);
          Circle.Clone = __webpack_require__(1193);
          Circle.Contains = __webpack_require__(66);
          Circle.ContainsPoint = __webpack_require__(1194);
          Circle.ContainsRect = __webpack_require__(1195);
          Circle.CopyFrom = __webpack_require__(1196);
          Circle.Equals = __webpack_require__(1197);
          Circle.GetBounds = __webpack_require__(1198);
          Circle.GetPoint = __webpack_require__(300);
          Circle.GetPoints = __webpack_require__(301);
          Circle.Offset = __webpack_require__(1199);
          Circle.OffsetPoint = __webpack_require__(1200);
          Circle.Random = __webpack_require__(170);
          module2.exports = Circle;
        }, function (module2, exports2) {
          var Area = function (circle) {
            return circle.radius > 0 ? Math.PI * circle.radius * circle.radius : 0;
          };
          module2.exports = Area;
        }, function (module2, exports2, __webpack_require__) {
          var Circle = __webpack_require__(65);
          var Clone = function (source) {
            return new Circle(source.x, source.y, source.radius);
          };
          module2.exports = Clone;
        }, function (module2, exports2, __webpack_require__) {
          var Contains = __webpack_require__(66);
          var ContainsPoint = function (circle, point) {
            return Contains(circle, point.x, point.y);
          };
          module2.exports = ContainsPoint;
        }, function (module2, exports2, __webpack_require__) {
          var Contains = __webpack_require__(66);
          var ContainsRect = function (circle, rect) {
            return Contains(circle, rect.x, rect.y) && Contains(circle, rect.right, rect.y) && Contains(circle, rect.x, rect.bottom) && Contains(circle, rect.right, rect.bottom);
          };
          module2.exports = ContainsRect;
        }, function (module2, exports2) {
          var CopyFrom = function (source, dest) {
            return dest.setTo(source.x, source.y, source.radius);
          };
          module2.exports = CopyFrom;
        }, function (module2, exports2) {
          var Equals = function (circle, toCompare) {
            return circle.x === toCompare.x && circle.y === toCompare.y && circle.radius === toCompare.radius;
          };
          module2.exports = Equals;
        }, function (module2, exports2, __webpack_require__) {
          var Rectangle = __webpack_require__(10);
          var GetBounds = function (circle, out) {
            if (out === void 0) {
              out = new Rectangle();
            }
            out.x = circle.left;
            out.y = circle.top;
            out.width = circle.diameter;
            out.height = circle.diameter;
            return out;
          };
          module2.exports = GetBounds;
        }, function (module2, exports2) {
          var Offset = function (circle, x, y) {
            circle.x += x;
            circle.y += y;
            return circle;
          };
          module2.exports = Offset;
        }, function (module2, exports2) {
          var OffsetPoint = function (circle, point) {
            circle.x += point.x;
            circle.y += point.y;
            return circle;
          };
          module2.exports = OffsetPoint;
        }, function (module2, exports2, __webpack_require__) {
          var Ellipse = __webpack_require__(111);
          Ellipse.Area = __webpack_require__(1202);
          Ellipse.Circumference = __webpack_require__(447);
          Ellipse.CircumferencePoint = __webpack_require__(218);
          Ellipse.Clone = __webpack_require__(1203);
          Ellipse.Contains = __webpack_require__(112);
          Ellipse.ContainsPoint = __webpack_require__(1204);
          Ellipse.ContainsRect = __webpack_require__(1205);
          Ellipse.CopyFrom = __webpack_require__(1206);
          Ellipse.Equals = __webpack_require__(1207);
          Ellipse.GetBounds = __webpack_require__(1208);
          Ellipse.GetPoint = __webpack_require__(445);
          Ellipse.GetPoints = __webpack_require__(446);
          Ellipse.Offset = __webpack_require__(1209);
          Ellipse.OffsetPoint = __webpack_require__(1210);
          Ellipse.Random = __webpack_require__(180);
          module2.exports = Ellipse;
        }, function (module2, exports2) {
          var Area = function (ellipse) {
            if (ellipse.isEmpty()) {
              return 0;
            }
            return ellipse.getMajorRadius() * ellipse.getMinorRadius() * Math.PI;
          };
          module2.exports = Area;
        }, function (module2, exports2, __webpack_require__) {
          var Ellipse = __webpack_require__(111);
          var Clone = function (source) {
            return new Ellipse(source.x, source.y, source.width, source.height);
          };
          module2.exports = Clone;
        }, function (module2, exports2, __webpack_require__) {
          var Contains = __webpack_require__(112);
          var ContainsPoint = function (ellipse, point) {
            return Contains(ellipse, point.x, point.y);
          };
          module2.exports = ContainsPoint;
        }, function (module2, exports2, __webpack_require__) {
          var Contains = __webpack_require__(112);
          var ContainsRect = function (ellipse, rect) {
            return Contains(ellipse, rect.x, rect.y) && Contains(ellipse, rect.right, rect.y) && Contains(ellipse, rect.x, rect.bottom) && Contains(ellipse, rect.right, rect.bottom);
          };
          module2.exports = ContainsRect;
        }, function (module2, exports2) {
          var CopyFrom = function (source, dest) {
            return dest.setTo(source.x, source.y, source.width, source.height);
          };
          module2.exports = CopyFrom;
        }, function (module2, exports2) {
          var Equals = function (ellipse, toCompare) {
            return ellipse.x === toCompare.x && ellipse.y === toCompare.y && ellipse.width === toCompare.width && ellipse.height === toCompare.height;
          };
          module2.exports = Equals;
        }, function (module2, exports2, __webpack_require__) {
          var Rectangle = __webpack_require__(10);
          var GetBounds = function (ellipse, out) {
            if (out === void 0) {
              out = new Rectangle();
            }
            out.x = ellipse.left;
            out.y = ellipse.top;
            out.width = ellipse.width;
            out.height = ellipse.height;
            return out;
          };
          module2.exports = GetBounds;
        }, function (module2, exports2) {
          var Offset = function (ellipse, x, y) {
            ellipse.x += x;
            ellipse.y += y;
            return ellipse;
          };
          module2.exports = Offset;
        }, function (module2, exports2) {
          var OffsetPoint = function (ellipse, point) {
            ellipse.x += point.x;
            ellipse.y += point.y;
            return ellipse;
          };
          module2.exports = OffsetPoint;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var CircleToCircle = __webpack_require__(231);
          var GetCircleToCircle = function (circleA, circleB, out) {
            if (out === void 0) {
              out = [];
            }
            if (CircleToCircle(circleA, circleB)) {
              var x0 = circleA.x;
              var y0 = circleA.y;
              var r0 = circleA.radius;
              var x1 = circleB.x;
              var y1 = circleB.y;
              var r1 = circleB.radius;
              var coefficientA, coefficientB, coefficientC, lambda, x;
              if (y0 === y1) {
                x = (r1 * r1 - r0 * r0 - x1 * x1 + x0 * x0) / (2 * (x0 - x1));
                coefficientA = 1;
                coefficientB = -2 * y1;
                coefficientC = x1 * x1 + x * x - 2 * x1 * x + y1 * y1 - r1 * r1;
                lambda = coefficientB * coefficientB - 4 * coefficientA * coefficientC;
                if (lambda === 0) {
                  out.push(new Point(x, -coefficientB / (2 * coefficientA)));
                } else if (lambda > 0) {
                  out.push(new Point(x, (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA)));
                  out.push(new Point(x, (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA)));
                }
              } else {
                var v1 = (x0 - x1) / (y0 - y1);
                var n = (r1 * r1 - r0 * r0 - x1 * x1 + x0 * x0 - y1 * y1 + y0 * y0) / (2 * (y0 - y1));
                coefficientA = v1 * v1 + 1;
                coefficientB = 2 * y0 * v1 - 2 * n * v1 - 2 * x0;
                coefficientC = x0 * x0 + y0 * y0 + n * n - r0 * r0 - 2 * y0 * n;
                lambda = coefficientB * coefficientB - 4 * coefficientA * coefficientC;
                if (lambda === 0) {
                  x = -coefficientB / (2 * coefficientA);
                  out.push(new Point(x, n - x * v1));
                } else if (lambda > 0) {
                  x = (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA);
                  out.push(new Point(x, n - x * v1));
                  x = (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA);
                  out.push(new Point(x, n - x * v1));
                }
              }
            }
            return out;
          };
          module2.exports = GetCircleToCircle;
        }, function (module2, exports2, __webpack_require__) {
          var GetLineToCircle = __webpack_require__(232);
          var CircleToRectangle = __webpack_require__(151);
          var GetCircleToRectangle = function (circle, rect, out) {
            if (out === void 0) {
              out = [];
            }
            if (CircleToRectangle(circle, rect)) {
              var lineA = rect.getLineA();
              var lineB = rect.getLineB();
              var lineC = rect.getLineC();
              var lineD = rect.getLineD();
              GetLineToCircle(lineA, circle, out);
              GetLineToCircle(lineB, circle, out);
              GetLineToCircle(lineC, circle, out);
              GetLineToCircle(lineD, circle, out);
            }
            return out;
          };
          module2.exports = GetCircleToRectangle;
        }, function (module2, exports2, __webpack_require__) {
          var Vector4 = __webpack_require__(140);
          var GetLineToPolygon = __webpack_require__(487);
          var Line = __webpack_require__(47);
          var segment = new Line();
          function CheckIntersects(angle, x, y, polygons, intersects) {
            var dx = Math.cos(angle);
            var dy = Math.sin(angle);
            segment.setTo(x, y, x + dx, y + dy);
            var closestIntersect = GetLineToPolygon(segment, polygons);
            if (closestIntersect) {
              intersects.push(new Vector4(closestIntersect.x, closestIntersect.y, angle, closestIntersect.w));
            }
          }
          function SortIntersects(a, b) {
            return a.z - b.z;
          }
          var GetRaysFromPointToPolygon = function (x, y, polygons) {
            if (!Array.isArray(polygons)) {
              polygons = [polygons];
            }
            var intersects = [];
            var angles = [];
            for (var i = 0; i < polygons.length; i++) {
              var points = polygons[i].points;
              for (var p3 = 0; p3 < points.length; p3++) {
                var angle = Math.atan2(points[p3].y - y, points[p3].x - x);
                if (angles.indexOf(angle) === -1) {
                  CheckIntersects(angle, x, y, polygons, intersects);
                  CheckIntersects(angle - 1e-5, x, y, polygons, intersects);
                  CheckIntersects(angle + 1e-5, x, y, polygons, intersects);
                  angles.push(angle);
                }
              }
            }
            return intersects.sort(SortIntersects);
          };
          module2.exports = GetRaysFromPointToPolygon;
        }, function (module2, exports2, __webpack_require__) {
          var Rectangle = __webpack_require__(10);
          var RectangleToRectangle = __webpack_require__(152);
          var GetRectangleIntersection = function (rectA, rectB, output) {
            if (output === void 0) {
              output = new Rectangle();
            }
            if (RectangleToRectangle(rectA, rectB)) {
              output.x = Math.max(rectA.x, rectB.x);
              output.y = Math.max(rectA.y, rectB.y);
              output.width = Math.min(rectA.right, rectB.right) - output.x;
              output.height = Math.min(rectA.bottom, rectB.bottom) - output.y;
            }
            return output;
          };
          module2.exports = GetRectangleIntersection;
        }, function (module2, exports2, __webpack_require__) {
          var GetLineToRectangle = __webpack_require__(234);
          var RectangleToRectangle = __webpack_require__(152);
          var GetRectangleToRectangle = function (rectA, rectB, out) {
            if (out === void 0) {
              out = [];
            }
            if (RectangleToRectangle(rectA, rectB)) {
              var lineA = rectA.getLineA();
              var lineB = rectA.getLineB();
              var lineC = rectA.getLineC();
              var lineD = rectA.getLineD();
              GetLineToRectangle(lineA, rectB, out);
              GetLineToRectangle(lineB, rectB, out);
              GetLineToRectangle(lineC, rectB, out);
              GetLineToRectangle(lineD, rectB, out);
            }
            return out;
          };
          module2.exports = GetRectangleToRectangle;
        }, function (module2, exports2, __webpack_require__) {
          var RectangleToTriangle = __webpack_require__(489);
          var GetLineToRectangle = __webpack_require__(234);
          var GetRectangleToTriangle = function (rect, triangle, out) {
            if (out === void 0) {
              out = [];
            }
            if (RectangleToTriangle(rect, triangle)) {
              var lineA = triangle.getLineA();
              var lineB = triangle.getLineB();
              var lineC = triangle.getLineC();
              GetLineToRectangle(lineA, rect, out);
              GetLineToRectangle(lineB, rect, out);
              GetLineToRectangle(lineC, rect, out);
            }
            return out;
          };
          module2.exports = GetRectangleToTriangle;
        }, function (module2, exports2, __webpack_require__) {
          var GetLineToCircle = __webpack_require__(232);
          var TriangleToCircle = __webpack_require__(491);
          var GetTriangleToCircle = function (triangle, circle, out) {
            if (out === void 0) {
              out = [];
            }
            if (TriangleToCircle(triangle, circle)) {
              var lineA = triangle.getLineA();
              var lineB = triangle.getLineB();
              var lineC = triangle.getLineC();
              GetLineToCircle(lineA, circle, out);
              GetLineToCircle(lineB, circle, out);
              GetLineToCircle(lineC, circle, out);
            }
            return out;
          };
          module2.exports = GetTriangleToCircle;
        }, function (module2, exports2, __webpack_require__) {
          var TriangleToTriangle = __webpack_require__(494);
          var GetTriangleToLine = __webpack_require__(492);
          var GetTriangleToTriangle = function (triangleA, triangleB, out) {
            if (out === void 0) {
              out = [];
            }
            if (TriangleToTriangle(triangleA, triangleB)) {
              var lineA = triangleB.getLineA();
              var lineB = triangleB.getLineB();
              var lineC = triangleB.getLineC();
              GetTriangleToLine(triangleA, lineA, out);
              GetTriangleToLine(triangleA, lineB, out);
              GetTriangleToLine(triangleA, lineC, out);
            }
            return out;
          };
          module2.exports = GetTriangleToTriangle;
        }, function (module2, exports2, __webpack_require__) {
          var PointToLine = __webpack_require__(496);
          var PointToLineSegment = function (point, line) {
            if (!PointToLine(point, line)) {
              return false;
            }
            var xMin = Math.min(line.x1, line.x2);
            var xMax = Math.max(line.x1, line.x2);
            var yMin = Math.min(line.y1, line.y2);
            var yMax = Math.max(line.y1, line.y2);
            return point.x >= xMin && point.x <= xMax && (point.y >= yMin && point.y <= yMax);
          };
          module2.exports = PointToLineSegment;
        }, function (module2, exports2) {
          var RectangleToValues = function (rect, left, right, top, bottom, tolerance) {
            if (tolerance === void 0) {
              tolerance = 0;
            }
            return !(left > rect.right + tolerance || right < rect.left - tolerance || top > rect.bottom + tolerance || bottom < rect.top - tolerance);
          };
          module2.exports = RectangleToValues;
        }, function (module2, exports2, __webpack_require__) {
          var Line = __webpack_require__(47);
          Line.Angle = __webpack_require__(97);
          Line.BresenhamPoints = __webpack_require__(317);
          Line.CenterOn = __webpack_require__(1222);
          Line.Clone = __webpack_require__(1223);
          Line.CopyFrom = __webpack_require__(1224);
          Line.Equals = __webpack_require__(1225);
          Line.Extend = __webpack_require__(1226);
          Line.GetEasedPoints = __webpack_require__(1227);
          Line.GetMidPoint = __webpack_require__(1228);
          Line.GetNearestPoint = __webpack_require__(1229);
          Line.GetNormal = __webpack_require__(1230);
          Line.GetPoint = __webpack_require__(307);
          Line.GetPoints = __webpack_require__(172);
          Line.GetShortestDistance = __webpack_require__(1231);
          Line.Height = __webpack_require__(1232);
          Line.Length = __webpack_require__(67);
          Line.NormalAngle = __webpack_require__(497);
          Line.NormalX = __webpack_require__(1233);
          Line.NormalY = __webpack_require__(1234);
          Line.Offset = __webpack_require__(1235);
          Line.PerpSlope = __webpack_require__(1236);
          Line.Random = __webpack_require__(173);
          Line.ReflectAngle = __webpack_require__(1237);
          Line.Rotate = __webpack_require__(1238);
          Line.RotateAroundPoint = __webpack_require__(1239);
          Line.RotateAroundXY = __webpack_require__(236);
          Line.SetToAngle = __webpack_require__(1240);
          Line.Slope = __webpack_require__(1241);
          Line.Width = __webpack_require__(1242);
          module2.exports = Line;
        }, function (module2, exports2) {
          var CenterOn = function (line, x, y) {
            var tx = x - (line.x1 + line.x2) / 2;
            var ty = y - (line.y1 + line.y2) / 2;
            line.x1 += tx;
            line.y1 += ty;
            line.x2 += tx;
            line.y2 += ty;
            return line;
          };
          module2.exports = CenterOn;
        }, function (module2, exports2, __webpack_require__) {
          var Line = __webpack_require__(47);
          var Clone = function (source) {
            return new Line(source.x1, source.y1, source.x2, source.y2);
          };
          module2.exports = Clone;
        }, function (module2, exports2) {
          var CopyFrom = function (source, dest) {
            return dest.setTo(source.x1, source.y1, source.x2, source.y2);
          };
          module2.exports = CopyFrom;
        }, function (module2, exports2) {
          var Equals = function (line, toCompare) {
            return line.x1 === toCompare.x1 && line.y1 === toCompare.y1 && line.x2 === toCompare.x2 && line.y2 === toCompare.y2;
          };
          module2.exports = Equals;
        }, function (module2, exports2, __webpack_require__) {
          var Length = __webpack_require__(67);
          var Extend = function (line, left, right) {
            if (right === void 0) {
              right = left;
            }
            var length = Length(line);
            var slopX = line.x2 - line.x1;
            var slopY = line.y2 - line.y1;
            if (left) {
              line.x1 = line.x1 - slopX / length * left;
              line.y1 = line.y1 - slopY / length * left;
            }
            if (right) {
              line.x2 = line.x2 + slopX / length * right;
              line.y2 = line.y2 + slopY / length * right;
            }
            return line;
          };
          module2.exports = Extend;
        }, function (module2, exports2, __webpack_require__) {
          var DistanceBetweenPoints = __webpack_require__(352);
          var GetEaseFunction = __webpack_require__(80);
          var Point = __webpack_require__(4);
          var GetEasedPoints = function (line, ease, quantity, collinearThreshold, easeParams) {
            if (collinearThreshold === void 0) {
              collinearThreshold = 0;
            }
            if (easeParams === void 0) {
              easeParams = [];
            }
            var results = [];
            var x1 = line.x1;
            var y1 = line.y1;
            var spaceX = line.x2 - x1;
            var spaceY = line.y2 - y1;
            var easeFunc = GetEaseFunction(ease, easeParams);
            var i;
            var v;
            var q = quantity - 1;
            for (i = 0; i < q; i++) {
              v = easeFunc(i / q);
              results.push(new Point(x1 + spaceX * v, y1 + spaceY * v));
            }
            v = easeFunc(1);
            results.push(new Point(x1 + spaceX * v, y1 + spaceY * v));
            if (collinearThreshold > 0) {
              var prevPoint = results[0];
              var sortedResults = [prevPoint];
              for (i = 1; i < results.length - 1; i++) {
                var point = results[i];
                if (DistanceBetweenPoints(prevPoint, point) >= collinearThreshold) {
                  sortedResults.push(point);
                  prevPoint = point;
                }
              }
              var endPoint = results[results.length - 1];
              if (DistanceBetweenPoints(prevPoint, endPoint) < collinearThreshold) {
                sortedResults.pop();
              }
              sortedResults.push(endPoint);
              return sortedResults;
            } else {
              return results;
            }
          };
          module2.exports = GetEasedPoints;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var GetMidPoint = function (line, out) {
            if (out === void 0) {
              out = new Point();
            }
            out.x = (line.x1 + line.x2) / 2;
            out.y = (line.y1 + line.y2) / 2;
            return out;
          };
          module2.exports = GetMidPoint;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var GetNearestPoint = function (line, point, out) {
            if (out === void 0) {
              out = new Point();
            }
            var x1 = line.x1;
            var y1 = line.y1;
            var x2 = line.x2;
            var y2 = line.y2;
            var L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
            if (L2 === 0) {
              return out;
            }
            var r = ((point.x - x1) * (x2 - x1) + (point.y - y1) * (y2 - y1)) / L2;
            out.x = x1 + r * (x2 - x1);
            out.y = y1 + r * (y2 - y1);
            return out;
          };
          module2.exports = GetNearestPoint;
        }, function (module2, exports2, __webpack_require__) {
          var MATH_CONST = __webpack_require__(14);
          var Angle = __webpack_require__(97);
          var Point = __webpack_require__(4);
          var GetNormal = function (line, out) {
            if (out === void 0) {
              out = new Point();
            }
            var a = Angle(line) - MATH_CONST.TAU;
            out.x = Math.cos(a);
            out.y = Math.sin(a);
            return out;
          };
          module2.exports = GetNormal;
        }, function (module2, exports2) {
          var GetShortestDistance = function (line, point) {
            var x1 = line.x1;
            var y1 = line.y1;
            var x2 = line.x2;
            var y2 = line.y2;
            var L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
            if (L2 === 0) {
              return false;
            }
            var s = ((y1 - point.y) * (x2 - x1) - (x1 - point.x) * (y2 - y1)) / L2;
            return Math.abs(s) * Math.sqrt(L2);
          };
          module2.exports = GetShortestDistance;
        }, function (module2, exports2) {
          var Height = function (line) {
            return Math.abs(line.y1 - line.y2);
          };
          module2.exports = Height;
        }, function (module2, exports2, __webpack_require__) {
          var MATH_CONST = __webpack_require__(14);
          var Angle = __webpack_require__(97);
          var NormalX = function (line) {
            return Math.cos(Angle(line) - MATH_CONST.TAU);
          };
          module2.exports = NormalX;
        }, function (module2, exports2, __webpack_require__) {
          var MATH_CONST = __webpack_require__(14);
          var Angle = __webpack_require__(97);
          var NormalY = function (line) {
            return Math.sin(Angle(line) - MATH_CONST.TAU);
          };
          module2.exports = NormalY;
        }, function (module2, exports2) {
          var Offset = function (line, x, y) {
            line.x1 += x;
            line.y1 += y;
            line.x2 += x;
            line.y2 += y;
            return line;
          };
          module2.exports = Offset;
        }, function (module2, exports2) {
          var PerpSlope = function (line) {
            return -((line.x2 - line.x1) / (line.y2 - line.y1));
          };
          module2.exports = PerpSlope;
        }, function (module2, exports2, __webpack_require__) {
          var Angle = __webpack_require__(97);
          var NormalAngle = __webpack_require__(497);
          var ReflectAngle = function (lineA, lineB) {
            return 2 * NormalAngle(lineB) - Math.PI - Angle(lineA);
          };
          module2.exports = ReflectAngle;
        }, function (module2, exports2, __webpack_require__) {
          var RotateAroundXY = __webpack_require__(236);
          var Rotate = function (line, angle) {
            var x = (line.x1 + line.x2) / 2;
            var y = (line.y1 + line.y2) / 2;
            return RotateAroundXY(line, x, y, angle);
          };
          module2.exports = Rotate;
        }, function (module2, exports2, __webpack_require__) {
          var RotateAroundXY = __webpack_require__(236);
          var RotateAroundPoint = function (line, point, angle) {
            return RotateAroundXY(line, point.x, point.y, angle);
          };
          module2.exports = RotateAroundPoint;
        }, function (module2, exports2) {
          var SetToAngle = function (line, x, y, angle, length) {
            line.x1 = x;
            line.y1 = y;
            line.x2 = x + Math.cos(angle) * length;
            line.y2 = y + Math.sin(angle) * length;
            return line;
          };
          module2.exports = SetToAngle;
        }, function (module2, exports2) {
          var Slope = function (line) {
            return (line.y2 - line.y1) / (line.x2 - line.x1);
          };
          module2.exports = Slope;
        }, function (module2, exports2) {
          var Width = function (line) {
            return Math.abs(line.x1 - line.x2);
          };
          module2.exports = Width;
        }, function (module2, exports2, __webpack_require__) {
          var Mesh = {
            Face: __webpack_require__(116),
            GenerateGridVerts: __webpack_require__(1244),
            GenerateObjVerts: __webpack_require__(480),
            GenerateVerts: __webpack_require__(479),
            ParseObj: __webpack_require__(498),
            ParseObjMaterial: __webpack_require__(499),
            RotateFace: __webpack_require__(1245),
            Vertex: __webpack_require__(117)
          };
          module2.exports = Mesh;
        }, function (module2, exports2, __webpack_require__) {
          var Face = __webpack_require__(116);
          var GetFastValue = __webpack_require__(2);
          var Matrix4 = __webpack_require__(69);
          var Vector3 = __webpack_require__(39);
          var Vertex = __webpack_require__(117);
          var tempPosition = new Vector3();
          var tempRotation = new Vector3();
          var tempMatrix = new Matrix4();
          var GenerateGridVerts = function (config) {
            var mesh = GetFastValue(config, "mesh");
            var texture = GetFastValue(config, "texture", null);
            var frame = GetFastValue(config, "frame");
            var width = GetFastValue(config, "width", 1);
            var height = GetFastValue(config, "height", width);
            var widthSegments = GetFastValue(config, "widthSegments", 1);
            var heightSegments = GetFastValue(config, "heightSegments", widthSegments);
            var posX = GetFastValue(config, "x", 0);
            var posY = GetFastValue(config, "y", 0);
            var posZ = GetFastValue(config, "z", 0);
            var rotateX = GetFastValue(config, "rotateX", 0);
            var rotateY = GetFastValue(config, "rotateY", 0);
            var rotateZ = GetFastValue(config, "rotateZ", 0);
            var zIsUp = GetFastValue(config, "zIsUp", true);
            var isOrtho = GetFastValue(config, "isOrtho", mesh ? mesh.dirtyCache[11] : false);
            var colors = GetFastValue(config, "colors", [16777215]);
            var alphas = GetFastValue(config, "alphas", [1]);
            var tile = GetFastValue(config, "tile", false);
            var flipY = GetFastValue(config, "flipY", false);
            var widthSet = GetFastValue(config, "width", null);
            var result = {
              faces: [],
              verts: []
            };
            tempPosition.set(posX, posY, posZ);
            tempRotation.set(rotateX, rotateY, rotateZ);
            tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, zIsUp);
            if (!texture && mesh) {
              texture = mesh.texture;
            } else if (mesh && typeof texture === "string") {
              texture = mesh.scene.sys.textures.get(texture);
            } else {
              return result;
            }
            var textureFrame = texture.get(frame);
            if (!widthSet && isOrtho && texture && mesh) {
              width = textureFrame.width / mesh.height;
              height = textureFrame.height / mesh.height;
            }
            var halfWidth = width / 2;
            var halfHeight = height / 2;
            var gridX = Math.floor(widthSegments);
            var gridY = Math.floor(heightSegments);
            var gridX1 = gridX + 1;
            var gridY1 = gridY + 1;
            var segmentWidth = width / gridX;
            var segmentHeight = height / gridY;
            var uvs = [];
            var vertices = [];
            var ix;
            var iy;
            var frameU0 = 0;
            var frameU1 = 1;
            var frameV0 = 0;
            var frameV1 = 1;
            if (textureFrame) {
              frameU0 = textureFrame.u0;
              frameU1 = textureFrame.u1;
              if (!flipY) {
                frameV0 = textureFrame.v0;
                frameV1 = textureFrame.v1;
              } else {
                frameV0 = textureFrame.v1;
                frameV1 = textureFrame.v0;
              }
            }
            var frameU = frameU1 - frameU0;
            var frameV = frameV1 - frameV0;
            for (iy = 0; iy < gridY1; iy++) {
              var y = iy * segmentHeight - halfHeight;
              for (ix = 0; ix < gridX1; ix++) {
                var x = ix * segmentWidth - halfWidth;
                vertices.push(x, -y);
                var tu = frameU0 + frameU * (ix / gridX);
                var tv = frameV0 + frameV * (iy / gridY);
                uvs.push(tu, tv);
              }
            }
            if (!Array.isArray(colors)) {
              colors = [colors];
            }
            if (!Array.isArray(alphas)) {
              alphas = [alphas];
            }
            var alphaIndex = 0;
            var colorIndex = 0;
            for (iy = 0; iy < gridY; iy++) {
              for (ix = 0; ix < gridX; ix++) {
                var a = (ix + gridX1 * iy) * 2;
                var b = (ix + gridX1 * (iy + 1)) * 2;
                var c = (ix + 1 + gridX1 * (iy + 1)) * 2;
                var d = (ix + 1 + gridX1 * iy) * 2;
                var color = colors[colorIndex];
                var alpha = alphas[alphaIndex];
                var vert1 = new Vertex(vertices[a], vertices[a + 1], 0, uvs[a], uvs[a + 1], color, alpha).transformMat4(tempMatrix);
                var vert2 = new Vertex(vertices[b], vertices[b + 1], 0, uvs[b], uvs[b + 1], color, alpha).transformMat4(tempMatrix);
                var vert3 = new Vertex(vertices[d], vertices[d + 1], 0, uvs[d], uvs[d + 1], color, alpha).transformMat4(tempMatrix);
                var vert4 = new Vertex(vertices[b], vertices[b + 1], 0, uvs[b], uvs[b + 1], color, alpha).transformMat4(tempMatrix);
                var vert5 = new Vertex(vertices[c], vertices[c + 1], 0, uvs[c], uvs[c + 1], color, alpha).transformMat4(tempMatrix);
                var vert6 = new Vertex(vertices[d], vertices[d + 1], 0, uvs[d], uvs[d + 1], color, alpha).transformMat4(tempMatrix);
                if (tile) {
                  vert1.setUVs(frameU0, frameV1);
                  vert2.setUVs(frameU0, frameV0);
                  vert3.setUVs(frameU1, frameV1);
                  vert4.setUVs(frameU0, frameV0);
                  vert5.setUVs(frameU1, frameV0);
                  vert6.setUVs(frameU1, frameV1);
                }
                colorIndex++;
                if (colorIndex === colors.length) {
                  colorIndex = 0;
                }
                alphaIndex++;
                if (alphaIndex === alphas.length) {
                  alphaIndex = 0;
                }
                result.verts.push(vert1, vert2, vert3, vert4, vert5, vert6);
                result.faces.push(new Face(vert1, vert2, vert3), new Face(vert4, vert5, vert6));
              }
            }
            if (mesh) {
              mesh.faces = mesh.faces.concat(result.faces);
              mesh.vertices = mesh.vertices.concat(result.verts);
            }
            return result;
          };
          module2.exports = GenerateGridVerts;
        }, function (module2, exports2) {
          var RotateFace = function (face, angle, cx, cy) {
            var x;
            var y;
            if (cx === void 0 && cy === void 0) {
              var inCenter = face.getInCenter();
              x = inCenter.x;
              y = inCenter.y;
            }
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var v1 = face.vertex1;
            var v2 = face.vertex2;
            var v3 = face.vertex3;
            var tx = v1.x - x;
            var ty = v1.y - y;
            v1.set(tx * c - ty * s + x, tx * s + ty * c + y);
            tx = v2.x - x;
            ty = v2.y - y;
            v2.set(tx * c - ty * s + x, tx * s + ty * c + y);
            tx = v3.x - x;
            ty = v3.y - y;
            v3.set(tx * c - ty * s + x, tx * s + ty * c + y);
          };
          module2.exports = RotateFace;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          Point.Ceil = __webpack_require__(1247);
          Point.Clone = __webpack_require__(1248);
          Point.CopyFrom = __webpack_require__(1249);
          Point.Equals = __webpack_require__(1250);
          Point.Floor = __webpack_require__(1251);
          Point.GetCentroid = __webpack_require__(1252);
          Point.GetMagnitude = __webpack_require__(500);
          Point.GetMagnitudeSq = __webpack_require__(501);
          Point.GetRectangleFromPoints = __webpack_require__(1253);
          Point.Interpolate = __webpack_require__(1254);
          Point.Invert = __webpack_require__(1255);
          Point.Negative = __webpack_require__(1256);
          Point.Project = __webpack_require__(1257);
          Point.ProjectUnit = __webpack_require__(1258);
          Point.SetMagnitude = __webpack_require__(1259);
          module2.exports = Point;
        }, function (module2, exports2) {
          var Ceil = function (point) {
            return point.setTo(Math.ceil(point.x), Math.ceil(point.y));
          };
          module2.exports = Ceil;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var Clone = function (source) {
            return new Point(source.x, source.y);
          };
          module2.exports = Clone;
        }, function (module2, exports2) {
          var CopyFrom = function (source, dest) {
            return dest.setTo(source.x, source.y);
          };
          module2.exports = CopyFrom;
        }, function (module2, exports2) {
          var Equals = function (point, toCompare) {
            return point.x === toCompare.x && point.y === toCompare.y;
          };
          module2.exports = Equals;
        }, function (module2, exports2) {
          var Floor = function (point) {
            return point.setTo(Math.floor(point.x), Math.floor(point.y));
          };
          module2.exports = Floor;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var GetCentroid = function (points, out) {
            if (out === void 0) {
              out = new Point();
            }
            if (!Array.isArray(points)) {
              throw new Error("GetCentroid points argument must be an array");
            }
            var len = points.length;
            if (len < 1) {
              throw new Error("GetCentroid points array must not be empty");
            } else if (len === 1) {
              out.x = points[0].x;
              out.y = points[0].y;
            } else {
              for (var i = 0; i < len; i++) {
                out.x += points[i].x;
                out.y += points[i].y;
              }
              out.x /= len;
              out.y /= len;
            }
            return out;
          };
          module2.exports = GetCentroid;
        }, function (module2, exports2, __webpack_require__) {
          var Rectangle = __webpack_require__(10);
          var GetRectangleFromPoints = function (points, out) {
            if (out === void 0) {
              out = new Rectangle();
            }
            var xMax = Number.NEGATIVE_INFINITY;
            var xMin = Number.POSITIVE_INFINITY;
            var yMax = Number.NEGATIVE_INFINITY;
            var yMin = Number.POSITIVE_INFINITY;
            for (var i = 0; i < points.length; i++) {
              var point = points[i];
              if (point.x > xMax) {
                xMax = point.x;
              }
              if (point.x < xMin) {
                xMin = point.x;
              }
              if (point.y > yMax) {
                yMax = point.y;
              }
              if (point.y < yMin) {
                yMin = point.y;
              }
            }
            out.x = xMin;
            out.y = yMin;
            out.width = xMax - xMin;
            out.height = yMax - yMin;
            return out;
          };
          module2.exports = GetRectangleFromPoints;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var Interpolate = function (pointA, pointB, t, out) {
            if (t === void 0) {
              t = 0;
            }
            if (out === void 0) {
              out = new Point();
            }
            out.x = pointA.x + (pointB.x - pointA.x) * t;
            out.y = pointA.y + (pointB.y - pointA.y) * t;
            return out;
          };
          module2.exports = Interpolate;
        }, function (module2, exports2) {
          var Invert = function (point) {
            return point.setTo(point.y, point.x);
          };
          module2.exports = Invert;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var Negative = function (point, out) {
            if (out === void 0) {
              out = new Point();
            }
            return out.setTo(-point.x, -point.y);
          };
          module2.exports = Negative;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var GetMagnitudeSq = __webpack_require__(501);
          var Project = function (pointA, pointB, out) {
            if (out === void 0) {
              out = new Point();
            }
            var dot = pointA.x * pointB.x + pointA.y * pointB.y;
            var amt = dot / GetMagnitudeSq(pointB);
            if (amt !== 0) {
              out.x = amt * pointB.x;
              out.y = amt * pointB.y;
            }
            return out;
          };
          module2.exports = Project;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var ProjectUnit = function (pointA, pointB, out) {
            if (out === void 0) {
              out = new Point();
            }
            var amt = pointA.x * pointB.x + pointA.y * pointB.y;
            if (amt !== 0) {
              out.x = amt * pointB.x;
              out.y = amt * pointB.y;
            }
            return out;
          };
          module2.exports = ProjectUnit;
        }, function (module2, exports2, __webpack_require__) {
          var GetMagnitude = __webpack_require__(500);
          var SetMagnitude = function (point, magnitude) {
            if (point.x !== 0 || point.y !== 0) {
              var m = GetMagnitude(point);
              point.x /= m;
              point.y /= m;
            }
            point.x *= magnitude;
            point.y *= magnitude;
            return point;
          };
          module2.exports = SetMagnitude;
        }, function (module2, exports2, __webpack_require__) {
          var Polygon = __webpack_require__(227);
          Polygon.Clone = __webpack_require__(1261);
          Polygon.Contains = __webpack_require__(228);
          Polygon.ContainsPoint = __webpack_require__(1262);
          Polygon.Earcut = __webpack_require__(59);
          Polygon.GetAABB = __webpack_require__(469);
          Polygon.GetNumberArray = __webpack_require__(1263);
          Polygon.GetPoints = __webpack_require__(470);
          Polygon.Perimeter = __webpack_require__(471);
          Polygon.Reverse = __webpack_require__(1264);
          Polygon.Simplify = __webpack_require__(1265);
          Polygon.Smooth = __webpack_require__(472);
          Polygon.Translate = __webpack_require__(1266);
          module2.exports = Polygon;
        }, function (module2, exports2, __webpack_require__) {
          var Polygon = __webpack_require__(227);
          var Clone = function (polygon) {
            return new Polygon(polygon.points);
          };
          module2.exports = Clone;
        }, function (module2, exports2, __webpack_require__) {
          var Contains = __webpack_require__(228);
          var ContainsPoint = function (polygon, point) {
            return Contains(polygon, point.x, point.y);
          };
          module2.exports = ContainsPoint;
        }, function (module2, exports2) {
          var GetNumberArray = function (polygon, output) {
            if (output === void 0) {
              output = [];
            }
            for (var i = 0; i < polygon.points.length; i++) {
              output.push(polygon.points[i].x);
              output.push(polygon.points[i].y);
            }
            return output;
          };
          module2.exports = GetNumberArray;
        }, function (module2, exports2) {
          var Reverse = function (polygon) {
            polygon.points.reverse();
            return polygon;
          };
          module2.exports = Reverse;
        }, function (module2, exports2) {
          function getSqDist(p1, p22) {
            var dx = p1.x - p22.x, dy = p1.y - p22.y;
            return dx * dx + dy * dy;
          }
          function getSqSegDist(p3, p1, p22) {
            var x = p1.x, y = p1.y, dx = p22.x - x, dy = p22.y - y;
            if (dx !== 0 || dy !== 0) {
              var t = ((p3.x - x) * dx + (p3.y - y) * dy) / (dx * dx + dy * dy);
              if (t > 1) {
                x = p22.x;
                y = p22.y;
              } else if (t > 0) {
                x += dx * t;
                y += dy * t;
              }
            }
            dx = p3.x - x;
            dy = p3.y - y;
            return dx * dx + dy * dy;
          }
          function simplifyRadialDist(points, sqTolerance) {
            var prevPoint = points[0], newPoints = [prevPoint], point;
            for (var i = 1, len = points.length; i < len; i++) {
              point = points[i];
              if (getSqDist(point, prevPoint) > sqTolerance) {
                newPoints.push(point);
                prevPoint = point;
              }
            }
            if (prevPoint !== point) {
              newPoints.push(point);
            }
            return newPoints;
          }
          function simplifyDPStep(points, first, last, sqTolerance, simplified) {
            var maxSqDist = sqTolerance, index;
            for (var i = first + 1; i < last; i++) {
              var sqDist = getSqSegDist(points[i], points[first], points[last]);
              if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
              }
            }
            if (maxSqDist > sqTolerance) {
              if (index - first > 1) {
                simplifyDPStep(points, first, index, sqTolerance, simplified);
              }
              simplified.push(points[index]);
              if (last - index > 1) {
                simplifyDPStep(points, index, last, sqTolerance, simplified);
              }
            }
          }
          function simplifyDouglasPeucker(points, sqTolerance) {
            var last = points.length - 1;
            var simplified = [points[0]];
            simplifyDPStep(points, 0, last, sqTolerance, simplified);
            simplified.push(points[last]);
            return simplified;
          }
          var Simplify = function (polygon, tolerance, highestQuality) {
            if (tolerance === void 0) {
              tolerance = 1;
            }
            if (highestQuality === void 0) {
              highestQuality = false;
            }
            var points = polygon.points;
            if (points.length > 2) {
              var sqTolerance = tolerance * tolerance;
              if (!highestQuality) {
                points = simplifyRadialDist(points, sqTolerance);
              }
              polygon.setTo(simplifyDouglasPeucker(points, sqTolerance));
            }
            return polygon;
          };
          module2.exports = Simplify;
        }, function (module2, exports2) {
          var Translate = function (polygon, x, y) {
            var points = polygon.points;
            for (var i = 0; i < points.length; i++) {
              points[i].x += x;
              points[i].y += y;
            }
            return polygon;
          };
          module2.exports = Translate;
        }, function (module2, exports2) {
          var Area = function (rect) {
            return rect.width * rect.height;
          };
          module2.exports = Area;
        }, function (module2, exports2) {
          var Ceil = function (rect) {
            rect.x = Math.ceil(rect.x);
            rect.y = Math.ceil(rect.y);
            return rect;
          };
          module2.exports = Ceil;
        }, function (module2, exports2) {
          var CeilAll = function (rect) {
            rect.x = Math.ceil(rect.x);
            rect.y = Math.ceil(rect.y);
            rect.width = Math.ceil(rect.width);
            rect.height = Math.ceil(rect.height);
            return rect;
          };
          module2.exports = CeilAll;
        }, function (module2, exports2, __webpack_require__) {
          var Rectangle = __webpack_require__(10);
          var Clone = function (source) {
            return new Rectangle(source.x, source.y, source.width, source.height);
          };
          module2.exports = Clone;
        }, function (module2, exports2, __webpack_require__) {
          var Contains = __webpack_require__(57);
          var ContainsPoint = function (rect, point) {
            return Contains(rect, point.x, point.y);
          };
          module2.exports = ContainsPoint;
        }, function (module2, exports2) {
          var CopyFrom = function (source, dest) {
            return dest.setTo(source.x, source.y, source.width, source.height);
          };
          module2.exports = CopyFrom;
        }, function (module2, exports2) {
          var Equals = function (rect, toCompare) {
            return rect.x === toCompare.x && rect.y === toCompare.y && rect.width === toCompare.width && rect.height === toCompare.height;
          };
          module2.exports = Equals;
        }, function (module2, exports2, __webpack_require__) {
          var GetAspectRatio = __webpack_require__(237);
          var FitInside = function (target, source) {
            var ratio = GetAspectRatio(target);
            if (ratio < GetAspectRatio(source)) {
              target.setSize(source.height * ratio, source.height);
            } else {
              target.setSize(source.width, source.width / ratio);
            }
            return target.setPosition(source.centerX - target.width / 2, source.centerY - target.height / 2);
          };
          module2.exports = FitInside;
        }, function (module2, exports2, __webpack_require__) {
          var GetAspectRatio = __webpack_require__(237);
          var FitOutside = function (target, source) {
            var ratio = GetAspectRatio(target);
            if (ratio > GetAspectRatio(source)) {
              target.setSize(source.height * ratio, source.height);
            } else {
              target.setSize(source.width, source.width / ratio);
            }
            return target.setPosition(source.centerX - target.width / 2, source.centerY - target.height / 2);
          };
          module2.exports = FitOutside;
        }, function (module2, exports2) {
          var Floor = function (rect) {
            rect.x = Math.floor(rect.x);
            rect.y = Math.floor(rect.y);
            return rect;
          };
          module2.exports = Floor;
        }, function (module2, exports2) {
          var FloorAll = function (rect) {
            rect.x = Math.floor(rect.x);
            rect.y = Math.floor(rect.y);
            rect.width = Math.floor(rect.width);
            rect.height = Math.floor(rect.height);
            return rect;
          };
          module2.exports = FloorAll;
        }, function (module2, exports2, __webpack_require__) {
          var Rectangle = __webpack_require__(10);
          var FromXY = function (x1, y1, x2, y2, out) {
            if (out === void 0) {
              out = new Rectangle();
            }
            return out.setTo(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x1 - x2), Math.abs(y1 - y2));
          };
          module2.exports = FromXY;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var GetCenter = function (rect, out) {
            if (out === void 0) {
              out = new Point();
            }
            out.x = rect.centerX;
            out.y = rect.centerY;
            return out;
          };
          module2.exports = GetCenter;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var GetSize = function (rect, out) {
            if (out === void 0) {
              out = new Point();
            }
            out.x = rect.width;
            out.y = rect.height;
            return out;
          };
          module2.exports = GetSize;
        }, function (module2, exports2, __webpack_require__) {
          var CenterOn = __webpack_require__(190);
          var Inflate = function (rect, x, y) {
            var cx = rect.centerX;
            var cy = rect.centerY;
            rect.setSize(rect.width + x * 2, rect.height + y * 2);
            return CenterOn(rect, cx, cy);
          };
          module2.exports = Inflate;
        }, function (module2, exports2, __webpack_require__) {
          var Rectangle = __webpack_require__(10);
          var Intersects = __webpack_require__(152);
          var Intersection = function (rectA, rectB, out) {
            if (out === void 0) {
              out = new Rectangle();
            }
            if (Intersects(rectA, rectB)) {
              out.x = Math.max(rectA.x, rectB.x);
              out.y = Math.max(rectA.y, rectB.y);
              out.width = Math.min(rectA.right, rectB.right) - out.x;
              out.height = Math.min(rectA.bottom, rectB.bottom) - out.y;
            } else {
              out.setEmpty();
            }
            return out;
          };
          module2.exports = Intersection;
        }, function (module2, exports2) {
          var MergePoints = function (target, points) {
            var minX = target.x;
            var maxX = target.right;
            var minY = target.y;
            var maxY = target.bottom;
            for (var i = 0; i < points.length; i++) {
              minX = Math.min(minX, points[i].x);
              maxX = Math.max(maxX, points[i].x);
              minY = Math.min(minY, points[i].y);
              maxY = Math.max(maxY, points[i].y);
            }
            target.x = minX;
            target.y = minY;
            target.width = maxX - minX;
            target.height = maxY - minY;
            return target;
          };
          module2.exports = MergePoints;
        }, function (module2, exports2) {
          var MergeRect = function (target, source) {
            var minX = Math.min(target.x, source.x);
            var maxX = Math.max(target.right, source.right);
            target.x = minX;
            target.width = maxX - minX;
            var minY = Math.min(target.y, source.y);
            var maxY = Math.max(target.bottom, source.bottom);
            target.y = minY;
            target.height = maxY - minY;
            return target;
          };
          module2.exports = MergeRect;
        }, function (module2, exports2) {
          var MergeXY = function (target, x, y) {
            var minX = Math.min(target.x, x);
            var maxX = Math.max(target.right, x);
            target.x = minX;
            target.width = maxX - minX;
            var minY = Math.min(target.y, y);
            var maxY = Math.max(target.bottom, y);
            target.y = minY;
            target.height = maxY - minY;
            return target;
          };
          module2.exports = MergeXY;
        }, function (module2, exports2) {
          var Offset = function (rect, x, y) {
            rect.x += x;
            rect.y += y;
            return rect;
          };
          module2.exports = Offset;
        }, function (module2, exports2) {
          var OffsetPoint = function (rect, point) {
            rect.x += point.x;
            rect.y += point.y;
            return rect;
          };
          module2.exports = OffsetPoint;
        }, function (module2, exports2) {
          var Overlaps = function (rectA, rectB) {
            return rectA.x < rectB.right && rectA.right > rectB.x && rectA.y < rectB.bottom && rectA.bottom > rectB.y;
          };
          module2.exports = Overlaps;
        }, function (module2, exports2, __webpack_require__) {
          var Point = __webpack_require__(4);
          var DegToRad = __webpack_require__(36);
          var PerimeterPoint = function (rectangle, angle, out) {
            if (out === void 0) {
              out = new Point();
            }
            angle = DegToRad(angle);
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            var dx = c > 0 ? rectangle.width / 2 : rectangle.width / -2;
            var dy = s > 0 ? rectangle.height / 2 : rectangle.height / -2;
            if (Math.abs(dx * s) < Math.abs(dy * c)) {
              dy = dx * s / c;
            } else {
              dx = dy * c / s;
            }
            out.x = dx + rectangle.centerX;
            out.y = dy + rectangle.centerY;
            return out;
          };
          module2.exports = PerimeterPoint;
        }, function (module2, exports2, __webpack_require__) {
          var Between = __webpack_require__(195);
          var ContainsRect = __webpack_require__(503);
          var Point = __webpack_require__(4);
          var RandomOutside = function (outer, inner, out) {
            if (out === void 0) {
              out = new Point();
            }
            if (ContainsRect(outer, inner)) {
              switch (Between(0, 3)) {
                case 0:
                  out.x = outer.x + Math.random() * (inner.right - outer.x);
                  out.y = outer.y + Math.random() * (inner.top - outer.y);
                  break;
                case 1:
                  out.x = inner.x + Math.random() * (outer.right - inner.x);
                  out.y = inner.bottom + Math.random() * (outer.bottom - inner.bottom);
                  break;
                case 2:
                  out.x = outer.x + Math.random() * (inner.x - outer.x);
                  out.y = inner.y + Math.random() * (outer.bottom - inner.y);
                  break;
                case 3:
                  out.x = inner.right + Math.random() * (outer.right - inner.right);
                  out.y = outer.y + Math.random() * (inner.bottom - outer.y);
                  break;
              }
            }
            return out;
          };
          module2.exports = RandomOutside;
        }, function (module2, exports2) {
          var SameDimensions = function (rect, toCompare) {
            return rect.width === toCompare.width && rect.height === toCompare.height;
          };
          module2.exports = SameDimensions;
        }, function (module2, exports2) {
          var Scale = function (rect, x, y) {
            if (y === void 0) {
              y = x;
            }
            rect.width *= x;
            rect.height *= y;
            return rect;
          };
          module2.exports = Scale;
        }, function (module2, exports2, __webpack_require__) {
          var Triangle = __webpack_require__(82);
          Triangle.Area = __webpack_require__(1294);
          Triangle.BuildEquilateral = __webpack_require__(1295);
          Triangle.BuildFromPolygon = __webpack_require__(1296);
          Triangle.BuildRight = __webpack_require__(1297);
          Triangle.CenterOn = __webpack_require__(1298);
          Triangle.Centroid = __webpack_require__(504);
          Triangle.CircumCenter = __webpack_require__(1299);
          Triangle.CircumCircle = __webpack_require__(1300);
          Triangle.Clone = __webpack_require__(1301);
          Triangle.Contains = __webpack_require__(115);
          Triangle.ContainsArray = __webpack_require__(235);
          Triangle.ContainsPoint = __webpack_require__(1302);
          Triangle.CopyFrom = __webpack_require__(1303);
          Triangle.Decompose = __webpack_require__(495);
          Triangle.Equals = __webpack_require__(1304);
          Triangle.GetPoint = __webpack_require__(476);
          Triangle.GetPoints = __webpack_require__(477);
          Triangle.InCenter = __webpack_require__(506);
          Triangle.Perimeter = __webpack_require__(1305);
          Triangle.Offset = __webpack_require__(505);
          Triangle.Random = __webpack_require__(181);
          Triangle.Rotate = __webpack_require__(1306);
          Triangle.RotateAroundPoint = __webpack_require__(1307);
          Triangle.RotateAroundXY = __webpack_require__(238);
          module2.exports = Triangle;
        }, function (module2, exports2) {
          var Area = function (triangle) {
            var x1 = triangle.x1;
            var y1 = triangle.y1;
            var x2 = triangle.x2;
            var y2 = triangle.y2;
            var x3 = triangle.x3;
            var y3 = triangle.y3;
            return Math.abs(((x3 - x1) * (y2 - y1) - (x2 - x1) * (y3 - y1)) / 2);
          };
          module2.exports = Area;
        }, function (module2, exports2, __webpack_require__) {
          var Triangle = __webpack_require__(82);
          var BuildEquilateral = function (x, y, length) {
            var height = length * (Math.sqrt(3) / 2);
            var x1 = x;
            var y1 = y;
            var x2 = x + length / 2;
            var y2 = y + height;
            var x3 = x - length / 2;
            var y3 = y + height;
            return new Triangle(x1, y1, x2, y2, x3, y3);
          };
          module2.exports = BuildEquilateral;
        }, function (module2, exports2, __webpack_require__) {
          var EarCut = __webpack_require__(59);
          var Triangle = __webpack_require__(82);
          var BuildFromPolygon = function (data, holes, scaleX, scaleY, out) {
            if (holes === void 0) {
              holes = null;
            }
            if (scaleX === void 0) {
              scaleX = 1;
            }
            if (scaleY === void 0) {
              scaleY = 1;
            }
            if (out === void 0) {
              out = [];
            }
            var tris = EarCut(data, holes);
            var a;
            var b;
            var c;
            var x1;
            var y1;
            var x2;
            var y2;
            var x3;
            var y3;
            for (var i = 0; i < tris.length; i += 3) {
              a = tris[i];
              b = tris[i + 1];
              c = tris[i + 2];
              x1 = data[a * 2] * scaleX;
              y1 = data[a * 2 + 1] * scaleY;
              x2 = data[b * 2] * scaleX;
              y2 = data[b * 2 + 1] * scaleY;
              x3 = data[c * 2] * scaleX;
              y3 = data[c * 2 + 1] * scaleY;
              out.push(new Triangle(x1, y1, x2, y2, x3, y3));
            }
            return out;
          };
          module2.exports = BuildFromPolygon;
        }, function (module2, exports2, __webpack_require__) {
          var Triangle = __webpack_require__(82);
          var BuildRight = function (x, y, width, height) {
            if (height === void 0) {
              height = width;
            }
            var x1 = x;
            var y1 = y;
            var x2 = x;
            var y2 = y - height;
            var x3 = x + width;
            var y3 = y;
            return new Triangle(x1, y1, x2, y2, x3, y3);
          };
          module2.exports = BuildRight;
        }, function (module2, exports2, __webpack_require__) {
          var Centroid = __webpack_require__(504);
          var Offset = __webpack_require__(505);
          var CenterOn = function (triangle, x, y, centerFunc) {
            if (centerFunc === void 0) {
              centerFunc = Centroid;
            }
            var center = centerFunc(triangle);
            var diffX = x - center.x;
            var diffY = y - center.y;
            return Offset(triangle, diffX, diffY);
          };
          module2.exports = CenterOn;
        }, function (module2, exports2, __webpack_require__) {
          var Vector2 = __webpack_require__(3);
          function det(m00, m01, m10, m11) {
            return m00 * m11 - m01 * m10;
          }
          var CircumCenter = function (triangle, out) {
            if (out === void 0) {
              out = new Vector2();
            }
            var cx = triangle.x3;
            var cy = triangle.y3;
            var ax = triangle.x1 - cx;
            var ay = triangle.y1 - cy;
            var bx = triangle.x2 - cx;
            var by = triangle.y2 - cy;
            var denom = 2 * det(ax, ay, bx, by);
            var numx = det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
            var numy = det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);
            out.x = cx - numx / denom;
            out.y = cy + numy / denom;
            return out;
          };
          module2.exports = CircumCenter;
        }, function (module2, exports2, __webpack_require__) {
          var Circle = __webpack_require__(65);
          var CircumCircle = function (triangle, out) {
            if (out === void 0) {
              out = new Circle();
            }
            var x1 = triangle.x1;
            var y1 = triangle.y1;
            var x2 = triangle.x2;
            var y2 = triangle.y2;
            var x3 = triangle.x3;
            var y3 = triangle.y3;
            var A = x2 - x1;
            var B = y2 - y1;
            var C = x3 - x1;
            var D = y3 - y1;
            var E = A * (x1 + x2) + B * (y1 + y2);
            var F = C * (x1 + x3) + D * (y1 + y3);
            var G = 2 * (A * (y3 - y2) - B * (x3 - x2));
            var dx;
            var dy;
            if (Math.abs(G) < 1e-6) {
              var minX = Math.min(x1, x2, x3);
              var minY = Math.min(y1, y2, y3);
              dx = (Math.max(x1, x2, x3) - minX) * 0.5;
              dy = (Math.max(y1, y2, y3) - minY) * 0.5;
              out.x = minX + dx;
              out.y = minY + dy;
              out.radius = Math.sqrt(dx * dx + dy * dy);
            } else {
              out.x = (D * E - B * F) / G;
              out.y = (A * F - C * E) / G;
              dx = out.x - x1;
              dy = out.y - y1;
              out.radius = Math.sqrt(dx * dx + dy * dy);
            }
            return out;
          };
          module2.exports = CircumCircle;
        }, function (module2, exports2, __webpack_require__) {
          var Triangle = __webpack_require__(82);
          var Clone = function (source) {
            return new Triangle(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
          };
          module2.exports = Clone;
        }, function (module2, exports2, __webpack_require__) {
          var Contains = __webpack_require__(115);
          var ContainsPoint = function (triangle, point) {
            return Contains(triangle, point.x, point.y);
          };
          module2.exports = ContainsPoint;
        }, function (module2, exports2) {
          var CopyFrom = function (source, dest) {
            return dest.setTo(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
          };
          module2.exports = CopyFrom;
        }, function (module2, exports2) {
          var Equals = function (triangle, toCompare) {
            return triangle.x1 === toCompare.x1 && triangle.y1 === toCompare.y1 && triangle.x2 === toCompare.x2 && triangle.y2 === toCompare.y2 && triangle.x3 === toCompare.x3 && triangle.y3 === toCompare.y3;
          };
          module2.exports = Equals;
        }, function (module2, exports2, __webpack_require__) {
          var Length = __webpack_require__(67);
          var Perimeter = function (triangle) {
            var line1 = triangle.getLineA();
            var line2 = triangle.getLineB();
            var line3 = triangle.getLineC();
            return Length(line1) + Length(line2) + Length(line3);
          };
          module2.exports = Perimeter;
        }, function (module2, exports2, __webpack_require__) {
          var RotateAroundXY = __webpack_require__(238);
          var InCenter = __webpack_require__(506);
          var Rotate = function (triangle, angle) {
            var point = InCenter(triangle);
            return RotateAroundXY(triangle, point.x, point.y, angle);
          };
          module2.exports = Rotate;
        }, function (module2, exports2, __webpack_require__) {
          var RotateAroundXY = __webpack_require__(238);
          var RotateAroundPoint = function (triangle, point, angle) {
            return RotateAroundXY(triangle, point.x, point.y, angle);
          };
          module2.exports = RotateAroundPoint;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(203);
          var Extend = __webpack_require__(17);
          var Input = {
            CreatePixelPerfectHandler: __webpack_require__(507),
            CreateInteractiveObject: __webpack_require__(508),
            Events: __webpack_require__(51),
            Gamepad: __webpack_require__(1309),
            InputManager: __webpack_require__(409),
            InputPlugin: __webpack_require__(1321),
            InputPluginCache: __webpack_require__(153),
            Keyboard: __webpack_require__(1322),
            Mouse: __webpack_require__(1336),
            Pointer: __webpack_require__(412),
            Touch: __webpack_require__(1337)
          };
          Input = Extend(false, Input, CONST);
          module2.exports = Input;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Axis: __webpack_require__(509),
            Button: __webpack_require__(510),
            Events: __webpack_require__(239),
            Gamepad: __webpack_require__(511),
            GamepadPlugin: __webpack_require__(1316),
            Configs: __webpack_require__(1317)
          };
        }, function (module2, exports2) {
          module2.exports = "down";
        }, function (module2, exports2) {
          module2.exports = "up";
        }, function (module2, exports2) {
          module2.exports = "connected";
        }, function (module2, exports2) {
          module2.exports = "disconnected";
        }, function (module2, exports2) {
          module2.exports = "down";
        }, function (module2, exports2) {
          module2.exports = "up";
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(239);
          var Gamepad = __webpack_require__(511);
          var GetValue = __webpack_require__(6);
          var InputPluginCache = __webpack_require__(153);
          var InputEvents = __webpack_require__(51);
          var GamepadPlugin = new Class({
            Extends: EventEmitter,
            initialize: function GamepadPlugin2(sceneInputPlugin) {
              EventEmitter.call(this);
              this.scene = sceneInputPlugin.scene;
              this.settings = this.scene.sys.settings;
              this.sceneInputPlugin = sceneInputPlugin;
              this.enabled = true;
              this.target;
              this.gamepads = [];
              this.queue = [];
              this.onGamepadHandler;
              this._pad1;
              this._pad2;
              this._pad3;
              this._pad4;
              sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);
              sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);
            },
            boot: function () {
              var game = this.scene.sys.game;
              var settings = this.settings.input;
              var config = game.config;
              this.enabled = GetValue(settings, "gamepad", config.inputGamepad) && game.device.input.gamepads;
              this.target = GetValue(settings, "gamepad.target", config.inputGamepadEventTarget);
              this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);
            },
            start: function () {
              if (this.enabled) {
                this.startListeners();
                this.refreshPads();
              }
              this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);
            },
            isActive: function () {
              return this.enabled && this.scene.sys.isActive();
            },
            startListeners: function () {
              var _this = this;
              var target = this.target;
              var handler = function (event) {
                if (event.defaultPrevented || !_this.isActive()) {
                  return;
                }
                _this.refreshPads();
                _this.queue.push(event);
              };
              this.onGamepadHandler = handler;
              target.addEventListener("gamepadconnected", handler, false);
              target.addEventListener("gamepaddisconnected", handler, false);
              this.sceneInputPlugin.pluginEvents.on(InputEvents.UPDATE, this.update, this);
            },
            stopListeners: function () {
              this.target.removeEventListener("gamepadconnected", this.onGamepadHandler);
              this.target.removeEventListener("gamepaddisconnected", this.onGamepadHandler);
              this.sceneInputPlugin.pluginEvents.off(InputEvents.UPDATE, this.update);
              for (var i = 0; i < this.gamepads.length; i++) {
                this.gamepads[i].removeAllListeners();
              }
            },
            disconnectAll: function () {
              for (var i = 0; i < this.gamepads.length; i++) {
                this.gamepads[i].pad.connected = false;
              }
            },
            refreshPads: function () {
              var connectedPads = navigator.getGamepads();
              if (!connectedPads) {
                this.disconnectAll();
              } else {
                var currentPads = this.gamepads;
                for (var i = 0; i < connectedPads.length; i++) {
                  var livePad = connectedPads[i];
                  if (!livePad) {
                    continue;
                  }
                  var id = livePad.id;
                  var index = livePad.index;
                  var currentPad = currentPads[index];
                  if (!currentPad) {
                    var newPad = new Gamepad(this, livePad);
                    currentPads[index] = newPad;
                    if (!this._pad1) {
                      this._pad1 = newPad;
                    } else if (!this._pad2) {
                      this._pad2 = newPad;
                    } else if (!this._pad3) {
                      this._pad3 = newPad;
                    } else if (!this._pad4) {
                      this._pad4 = newPad;
                    }
                  } else if (currentPad.id !== id) {
                    currentPad.destroy();
                    currentPads[index] = new Gamepad(this, livePad);
                  } else {
                    currentPad.update(livePad);
                  }
                }
              }
            },
            getAll: function () {
              var out = [];
              var pads = this.gamepads;
              for (var i = 0; i < pads.length; i++) {
                if (pads[i]) {
                  out.push(pads[i]);
                }
              }
              return out;
            },
            getPad: function (index) {
              var pads = this.gamepads;
              for (var i = 0; i < pads.length; i++) {
                if (pads[i] && pads[i].index === index) {
                  return pads[i];
                }
              }
            },
            update: function () {
              if (!this.enabled) {
                return;
              }
              this.refreshPads();
              var len = this.queue.length;
              if (len === 0) {
                return;
              }
              var queue = this.queue.splice(0, len);
              for (var i = 0; i < len; i++) {
                var event = queue[i];
                var pad = this.getPad(event.gamepad.index);
                if (event.type === "gamepadconnected") {
                  this.emit(Events.CONNECTED, pad, event);
                } else if (event.type === "gamepaddisconnected") {
                  this.emit(Events.DISCONNECTED, pad, event);
                }
              }
            },
            shutdown: function () {
              this.stopListeners();
              this.removeAllListeners();
            },
            destroy: function () {
              this.shutdown();
              for (var i = 0; i < this.gamepads.length; i++) {
                if (this.gamepads[i]) {
                  this.gamepads[i].destroy();
                }
              }
              this.gamepads = [];
              this.scene = null;
              this.settings = null;
              this.sceneInputPlugin = null;
              this.target = null;
            },
            total: {
              get: function () {
                return this.gamepads.length;
              }
            },
            pad1: {
              get: function () {
                return this._pad1;
              }
            },
            pad2: {
              get: function () {
                return this._pad2;
              }
            },
            pad3: {
              get: function () {
                return this._pad3;
              }
            },
            pad4: {
              get: function () {
                return this._pad4;
              }
            }
          });
          InputPluginCache.register("GamepadPlugin", GamepadPlugin, "gamepad", "gamepad", "inputGamepad");
          module2.exports = GamepadPlugin;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            DUALSHOCK_4: __webpack_require__(1318),
            SNES_USB: __webpack_require__(1319),
            XBOX_360: __webpack_require__(1320)
          };
        }, function (module2, exports2) {
          module2.exports = {
            UP: 12,
            DOWN: 13,
            LEFT: 14,
            RIGHT: 15,
            SHARE: 8,
            OPTIONS: 9,
            PS: 16,
            TOUCHBAR: 17,
            X: 0,
            CIRCLE: 1,
            SQUARE: 2,
            TRIANGLE: 3,
            L1: 4,
            R1: 5,
            L2: 6,
            R2: 7,
            L3: 10,
            R3: 11,
            LEFT_STICK_H: 0,
            LEFT_STICK_V: 1,
            RIGHT_STICK_H: 2,
            RIGHT_STICK_V: 3
          };
        }, function (module2, exports2) {
          module2.exports = {
            UP: 12,
            DOWN: 13,
            LEFT: 14,
            RIGHT: 15,
            SELECT: 8,
            START: 9,
            B: 0,
            A: 1,
            Y: 2,
            X: 3,
            LEFT_SHOULDER: 4,
            RIGHT_SHOULDER: 5
          };
        }, function (module2, exports2) {
          module2.exports = {
            UP: 12,
            DOWN: 13,
            LEFT: 14,
            RIGHT: 15,
            MENU: 16,
            A: 0,
            B: 1,
            X: 2,
            Y: 3,
            LB: 4,
            RB: 5,
            LT: 6,
            RT: 7,
            BACK: 8,
            START: 9,
            LS: 10,
            RS: 11,
            LEFT_STICK_H: 0,
            LEFT_STICK_V: 1,
            RIGHT_STICK_H: 2,
            RIGHT_STICK_V: 3
          };
        }, function (module2, exports2, __webpack_require__) {
          var Circle = __webpack_require__(65);
          var CircleContains = __webpack_require__(66);
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(203);
          var CreateInteractiveObject = __webpack_require__(508);
          var CreatePixelPerfectHandler = __webpack_require__(507);
          var DistanceBetween = __webpack_require__(50);
          var Ellipse = __webpack_require__(111);
          var EllipseContains = __webpack_require__(112);
          var Events = __webpack_require__(51);
          var EventEmitter = __webpack_require__(9);
          var GetFastValue = __webpack_require__(2);
          var GEOM_CONST = __webpack_require__(56);
          var InputPluginCache = __webpack_require__(153);
          var IsPlainObject = __webpack_require__(7);
          var PluginCache = __webpack_require__(24);
          var Rectangle = __webpack_require__(10);
          var RectangleContains = __webpack_require__(57);
          var SceneEvents = __webpack_require__(20);
          var Triangle = __webpack_require__(82);
          var TriangleContains = __webpack_require__(115);
          var InputPlugin = new Class({
            Extends: EventEmitter,
            initialize: function InputPlugin2(scene) {
              EventEmitter.call(this);
              this.scene = scene;
              this.systems = scene.sys;
              this.settings = scene.sys.settings;
              this.manager = scene.sys.game.input;
              this.pluginEvents = new EventEmitter();
              this.enabled = true;
              this.displayList;
              this.cameras;
              InputPluginCache.install(this);
              this.mouse = this.manager.mouse;
              this.topOnly = true;
              this.pollRate = -1;
              this._pollTimer = 0;
              var _eventData = {
                cancelled: false
              };
              this._eventContainer = {
                stopPropagation: function () {
                  _eventData.cancelled = true;
                }
              };
              this._eventData = _eventData;
              this.dragDistanceThreshold = 0;
              this.dragTimeThreshold = 0;
              this._temp = [];
              this._tempZones = [];
              this._list = [];
              this._pendingInsertion = [];
              this._pendingRemoval = [];
              this._draggable = [];
              this._drag = {
                0: [],
                1: [],
                2: [],
                3: [],
                4: [],
                5: [],
                6: [],
                7: [],
                8: [],
                9: [],
                10: []
              };
              this._dragState = [];
              this._over = {
                0: [],
                1: [],
                2: [],
                3: [],
                4: [],
                5: [],
                6: [],
                7: [],
                8: [],
                9: [],
                10: []
              };
              this._validTypes = ["onDown", "onUp", "onOver", "onOut", "onMove", "onDragStart", "onDrag", "onDragEnd", "onDragEnter", "onDragLeave", "onDragOver", "onDrop"];
              this._updatedThisFrame = false;
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              scene.sys.events.on(SceneEvents.START, this.start, this);
            },
            boot: function () {
              this.cameras = this.systems.cameras;
              this.displayList = this.systems.displayList;
              this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
              this.pluginEvents.emit(Events.BOOT);
            },
            start: function () {
              var eventEmitter = this.systems.events;
              eventEmitter.on(SceneEvents.TRANSITION_START, this.transitionIn, this);
              eventEmitter.on(SceneEvents.TRANSITION_OUT, this.transitionOut, this);
              eventEmitter.on(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);
              eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
              eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
              this.manager.events.on(Events.GAME_OUT, this.onGameOut, this);
              this.manager.events.on(Events.GAME_OVER, this.onGameOver, this);
              this.enabled = true;
              this._dragState = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              this.pluginEvents.emit(Events.START);
            },
            onGameOver: function (event) {
              if (this.isActive()) {
                this.emit(Events.GAME_OVER, event.timeStamp, event);
              }
            },
            onGameOut: function (event) {
              if (this.isActive()) {
                this.emit(Events.GAME_OUT, event.timeStamp, event);
              }
            },
            preUpdate: function () {
              this.pluginEvents.emit(Events.PRE_UPDATE);
              var removeList = this._pendingRemoval;
              var insertList = this._pendingInsertion;
              var toRemove = removeList.length;
              var toInsert = insertList.length;
              if (toRemove === 0 && toInsert === 0) {
                return;
              }
              var current = this._list;
              for (var i = 0; i < toRemove; i++) {
                var gameObject = removeList[i];
                var index = current.indexOf(gameObject);
                if (index > -1) {
                  current.splice(index, 1);
                  this.clear(gameObject, true);
                }
              }
              removeList.length = 0;
              this._pendingRemoval.length = 0;
              this._list = current.concat(insertList.splice(0));
            },
            isActive: function () {
              return this.enabled && this.scene.sys.isActive();
            },
            updatePoll: function (time, delta) {
              if (!this.isActive()) {
                return false;
              }
              this.pluginEvents.emit(Events.UPDATE, time, delta);
              if (this._updatedThisFrame) {
                this._updatedThisFrame = false;
                return false;
              }
              var i;
              var manager = this.manager;
              var pointers = manager.pointers;
              var pointersTotal = manager.pointersTotal;
              for (i = 0; i < pointersTotal; i++) {
                pointers[i].updateMotion();
              }
              if (this._list.length === 0) {
                return false;
              }
              var rate = this.pollRate;
              if (rate === -1) {
                return false;
              } else if (rate > 0) {
                this._pollTimer -= delta;
                if (this._pollTimer < 0) {
                  this._pollTimer = this.pollRate;
                } else {
                  return false;
                }
              }
              var captured = false;
              for (i = 0; i < pointersTotal; i++) {
                var total = 0;
                var pointer = pointers[i];
                this._tempZones = [];
                this._temp = this.hitTestPointer(pointer);
                this.sortGameObjects(this._temp, pointer);
                this.sortDropZones(this._tempZones);
                if (this.topOnly) {
                  if (this._temp.length) {
                    this._temp.splice(1);
                  }
                  if (this._tempZones.length) {
                    this._tempZones.splice(1);
                  }
                }
                total += this.processOverOutEvents(pointer);
                if (this.getDragState(pointer) === 2) {
                  this.processDragThresholdEvent(pointer, time);
                }
                if (total > 0) {
                  captured = true;
                }
              }
              return captured;
            },
            update: function (type, pointers) {
              if (!this.isActive()) {
                return false;
              }
              var pointersTotal = pointers.length;
              var captured = false;
              for (var i = 0; i < pointersTotal; i++) {
                var total = 0;
                var pointer = pointers[i];
                this._tempZones = [];
                this._temp = this.hitTestPointer(pointer);
                this.sortGameObjects(this._temp, pointer);
                this.sortDropZones(this._tempZones);
                if (this.topOnly) {
                  if (this._temp.length) {
                    this._temp.splice(1);
                  }
                  if (this._tempZones.length) {
                    this._tempZones.splice(1);
                  }
                }
                switch (type) {
                  case CONST.MOUSE_DOWN:
                    total += this.processDragDownEvent(pointer);
                    total += this.processDownEvents(pointer);
                    total += this.processOverOutEvents(pointer);
                    break;
                  case CONST.MOUSE_UP:
                    total += this.processDragUpEvent(pointer);
                    total += this.processUpEvents(pointer);
                    total += this.processOverOutEvents(pointer);
                    break;
                  case CONST.TOUCH_START:
                    total += this.processDragDownEvent(pointer);
                    total += this.processDownEvents(pointer);
                    total += this.processOverEvents(pointer);
                    break;
                  case CONST.TOUCH_END:
                  case CONST.TOUCH_CANCEL:
                    total += this.processDragUpEvent(pointer);
                    total += this.processUpEvents(pointer);
                    total += this.processOutEvents(pointer);
                    break;
                  case CONST.MOUSE_MOVE:
                  case CONST.TOUCH_MOVE:
                    total += this.processDragMoveEvent(pointer);
                    total += this.processMoveEvents(pointer);
                    total += this.processOverOutEvents(pointer);
                    break;
                  case CONST.MOUSE_WHEEL:
                    total += this.processWheelEvent(pointer);
                    break;
                }
                if (total > 0) {
                  captured = true;
                }
              }
              this._updatedThisFrame = true;
              return captured;
            },
            clear: function (gameObject, skipQueue) {
              if (skipQueue === void 0) {
                skipQueue = false;
              }
              var input = gameObject.input;
              if (!input) {
                return;
              }
              if (!skipQueue) {
                this.queueForRemoval(gameObject);
              }
              input.gameObject = void 0;
              input.target = void 0;
              input.hitArea = void 0;
              input.hitAreaCallback = void 0;
              input.callbackContext = void 0;
              gameObject.input = null;
              var index = this._draggable.indexOf(gameObject);
              if (index > -1) {
                this._draggable.splice(index, 1);
              }
              index = this._drag[0].indexOf(gameObject);
              if (index > -1) {
                this._drag[0].splice(index, 1);
              }
              index = this._over[0].indexOf(gameObject);
              if (index > -1) {
                this._over[0].splice(index, 1);
                this.manager.resetCursor(input);
              }
              return gameObject;
            },
            disable: function (gameObject) {
              gameObject.input.enabled = false;
            },
            enable: function (gameObject, hitArea, hitAreaCallback, dropZone) {
              if (dropZone === void 0) {
                dropZone = false;
              }
              if (gameObject.input) {
                gameObject.input.enabled = true;
              } else {
                this.setHitArea(gameObject, hitArea, hitAreaCallback);
              }
              if (gameObject.input && dropZone && !gameObject.input.dropZone) {
                gameObject.input.dropZone = dropZone;
              }
              return this;
            },
            hitTestPointer: function (pointer) {
              var cameras = this.cameras.getCamerasBelowPointer(pointer);
              for (var c = 0; c < cameras.length; c++) {
                var camera = cameras[c];
                var over = this.manager.hitTest(pointer, this._list, camera);
                for (var i = 0; i < over.length; i++) {
                  var obj = over[i];
                  if (obj.input.dropZone) {
                    this._tempZones.push(obj);
                  }
                }
                if (over.length > 0) {
                  pointer.camera = camera;
                  return over;
                }
              }
              pointer.camera = cameras[0];
              return [];
            },
            processDownEvents: function (pointer) {
              var total = 0;
              var currentlyOver = this._temp;
              var _eventData = this._eventData;
              var _eventContainer = this._eventContainer;
              _eventData.cancelled = false;
              var aborted = false;
              for (var i = 0; i < currentlyOver.length; i++) {
                var gameObject = currentlyOver[i];
                if (!gameObject.input) {
                  continue;
                }
                total++;
                gameObject.emit(Events.GAMEOBJECT_POINTER_DOWN, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
                this.emit(Events.GAMEOBJECT_DOWN, pointer, gameObject, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
              }
              if (!aborted && this.manager) {
                if (pointer.downElement === this.manager.game.canvas) {
                  this.emit(Events.POINTER_DOWN, pointer, currentlyOver);
                } else {
                  this.emit(Events.POINTER_DOWN_OUTSIDE, pointer);
                }
              }
              return total;
            },
            getDragState: function (pointer) {
              return this._dragState[pointer.id];
            },
            setDragState: function (pointer, state) {
              this._dragState[pointer.id] = state;
            },
            processDragThresholdEvent: function (pointer, time) {
              var passed = false;
              var timeThreshold = this.dragTimeThreshold;
              var distanceThreshold = this.dragDistanceThreshold;
              if (distanceThreshold > 0 && DistanceBetween(pointer.x, pointer.y, pointer.downX, pointer.downY) >= distanceThreshold) {
                passed = true;
              } else if (timeThreshold > 0 && time >= pointer.downTime + timeThreshold) {
                passed = true;
              }
              if (passed) {
                this.setDragState(pointer, 3);
                return this.processDragStartList(pointer);
              }
            },
            processDragStartList: function (pointer) {
              if (this.getDragState(pointer) !== 3) {
                return 0;
              }
              var list = this._drag[pointer.id];
              for (var i = 0; i < list.length; i++) {
                var gameObject = list[i];
                var input = gameObject.input;
                input.dragState = 2;
                input.dragStartX = gameObject.x;
                input.dragStartY = gameObject.y;
                input.dragStartXGlobal = pointer.worldX;
                input.dragStartYGlobal = pointer.worldY;
                input.dragX = input.dragStartXGlobal - input.dragStartX;
                input.dragY = input.dragStartYGlobal - input.dragStartY;
                gameObject.emit(Events.GAMEOBJECT_DRAG_START, pointer, input.dragX, input.dragY);
                this.emit(Events.DRAG_START, pointer, gameObject);
              }
              this.setDragState(pointer, 4);
              return list.length;
            },
            processDragDownEvent: function (pointer) {
              var currentlyOver = this._temp;
              if (this._draggable.length === 0 || currentlyOver.length === 0 || !pointer.primaryDown || this.getDragState(pointer) !== 0) {
                return 0;
              }
              this.setDragState(pointer, 1);
              var draglist = [];
              for (var i = 0; i < currentlyOver.length; i++) {
                var gameObject = currentlyOver[i];
                if (gameObject.input.draggable && gameObject.input.dragState === 0) {
                  draglist.push(gameObject);
                }
              }
              if (draglist.length === 0) {
                this.setDragState(pointer, 0);
                return 0;
              } else if (draglist.length > 1) {
                this.sortGameObjects(draglist, pointer);
                if (this.topOnly) {
                  draglist.splice(1);
                }
              }
              this._drag[pointer.id] = draglist;
              if (this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0) {
                this.setDragState(pointer, 3);
                return this.processDragStartList(pointer);
              } else {
                this.setDragState(pointer, 2);
                return 0;
              }
            },
            processDragMoveEvent: function (pointer) {
              if (this.getDragState(pointer) === 2) {
                this.processDragThresholdEvent(pointer, this.manager.game.loop.now);
              }
              if (this.getDragState(pointer) !== 4) {
                return 0;
              }
              var dropZones = this._tempZones;
              var list = this._drag[pointer.id];
              for (var i = 0; i < list.length; i++) {
                var gameObject = list[i];
                var input = gameObject.input;
                var target = input.target;
                if (target) {
                  var index = dropZones.indexOf(target);
                  if (index === 0) {
                    gameObject.emit(Events.GAMEOBJECT_DRAG_OVER, pointer, target);
                    this.emit(Events.DRAG_OVER, pointer, gameObject, target);
                  } else if (index > 0) {
                    gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);
                    this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);
                    input.target = dropZones[0];
                    target = input.target;
                    gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);
                    this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
                  } else {
                    gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);
                    this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);
                    if (dropZones[0]) {
                      input.target = dropZones[0];
                      target = input.target;
                      gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);
                      this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
                    } else {
                      input.target = null;
                    }
                  }
                } else if (!target && dropZones[0]) {
                  input.target = dropZones[0];
                  target = input.target;
                  gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);
                  this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
                }
                var dragX;
                var dragY;
                if (!gameObject.parentContainer) {
                  dragX = pointer.worldX - input.dragX;
                  dragY = pointer.worldY - input.dragY;
                } else {
                  var dx = pointer.worldX - input.dragStartXGlobal;
                  var dy = pointer.worldY - input.dragStartYGlobal;
                  var rotation = gameObject.getParentRotation();
                  var dxRotated = dx * Math.cos(rotation) + dy * Math.sin(rotation);
                  var dyRotated = dy * Math.cos(rotation) - dx * Math.sin(rotation);
                  dxRotated *= 1 / gameObject.parentContainer.scaleX;
                  dyRotated *= 1 / gameObject.parentContainer.scaleY;
                  dragX = dxRotated + input.dragStartX;
                  dragY = dyRotated + input.dragStartY;
                }
                gameObject.emit(Events.GAMEOBJECT_DRAG, pointer, dragX, dragY);
                this.emit(Events.DRAG, pointer, gameObject, dragX, dragY);
              }
              return list.length;
            },
            processDragUpEvent: function (pointer) {
              var list = this._drag[pointer.id];
              for (var i = 0; i < list.length; i++) {
                var gameObject = list[i];
                var input = gameObject.input;
                if (input && input.dragState === 2) {
                  input.dragState = 0;
                  input.dragX = input.localX - gameObject.displayOriginX;
                  input.dragY = input.localY - gameObject.displayOriginY;
                  var dropped = false;
                  var target = input.target;
                  if (target) {
                    gameObject.emit(Events.GAMEOBJECT_DROP, pointer, target);
                    this.emit(Events.DROP, pointer, gameObject, target);
                    input.target = null;
                    dropped = true;
                  }
                  if (gameObject.input) {
                    gameObject.emit(Events.GAMEOBJECT_DRAG_END, pointer, input.dragX, input.dragY, dropped);
                    this.emit(Events.DRAG_END, pointer, gameObject, dropped);
                  }
                }
              }
              this.setDragState(pointer, 0);
              list.splice(0);
              return 0;
            },
            processMoveEvents: function (pointer) {
              var total = 0;
              var currentlyOver = this._temp;
              var _eventData = this._eventData;
              var _eventContainer = this._eventContainer;
              _eventData.cancelled = false;
              var aborted = false;
              for (var i = 0; i < currentlyOver.length; i++) {
                var gameObject = currentlyOver[i];
                if (!gameObject.input) {
                  continue;
                }
                total++;
                gameObject.emit(Events.GAMEOBJECT_POINTER_MOVE, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
                this.emit(Events.GAMEOBJECT_MOVE, pointer, gameObject, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
                if (this.topOnly) {
                  break;
                }
              }
              if (!aborted) {
                this.emit(Events.POINTER_MOVE, pointer, currentlyOver);
              }
              return total;
            },
            processWheelEvent: function (pointer) {
              var total = 0;
              var currentlyOver = this._temp;
              var _eventData = this._eventData;
              var _eventContainer = this._eventContainer;
              _eventData.cancelled = false;
              var aborted = false;
              var dx = pointer.deltaX;
              var dy = pointer.deltaY;
              var dz = pointer.deltaZ;
              for (var i = 0; i < currentlyOver.length; i++) {
                var gameObject = currentlyOver[i];
                if (!gameObject.input) {
                  continue;
                }
                total++;
                gameObject.emit(Events.GAMEOBJECT_POINTER_WHEEL, pointer, dx, dy, dz, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
                this.emit(Events.GAMEOBJECT_WHEEL, pointer, gameObject, dx, dy, dz, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
              }
              if (!aborted) {
                this.emit(Events.POINTER_WHEEL, pointer, currentlyOver, dx, dy, dz);
              }
              return total;
            },
            processOverEvents: function (pointer) {
              var currentlyOver = this._temp;
              var totalInteracted = 0;
              var total = currentlyOver.length;
              var justOver = [];
              if (total > 0) {
                var manager = this.manager;
                var _eventData = this._eventData;
                var _eventContainer = this._eventContainer;
                _eventData.cancelled = false;
                var aborted = false;
                for (var i = 0; i < total; i++) {
                  var gameObject = currentlyOver[i];
                  if (!gameObject.input) {
                    continue;
                  }
                  justOver.push(gameObject);
                  manager.setCursor(gameObject.input);
                  gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
                  totalInteracted++;
                  if (_eventData.cancelled || !gameObject.input) {
                    aborted = true;
                    break;
                  }
                  this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);
                  if (_eventData.cancelled || !gameObject.input) {
                    aborted = true;
                    break;
                  }
                }
                if (!aborted) {
                  this.emit(Events.POINTER_OVER, pointer, justOver);
                }
              }
              this._over[pointer.id] = justOver;
              return totalInteracted;
            },
            processOutEvents: function (pointer) {
              var previouslyOver = this._over[pointer.id];
              var totalInteracted = 0;
              var total = previouslyOver.length;
              if (total > 0) {
                var manager = this.manager;
                var _eventData = this._eventData;
                var _eventContainer = this._eventContainer;
                _eventData.cancelled = false;
                var aborted = false;
                this.sortGameObjects(previouslyOver, pointer);
                for (var i = 0; i < total; i++) {
                  var gameObject = previouslyOver[i];
                  gameObject = previouslyOver[i];
                  if (!gameObject.input) {
                    continue;
                  }
                  manager.resetCursor(gameObject.input);
                  gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);
                  totalInteracted++;
                  if (_eventData.cancelled || !gameObject.input) {
                    aborted = true;
                    break;
                  }
                  this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);
                  if (_eventData.cancelled || !gameObject.input) {
                    aborted = true;
                    break;
                  }
                  if (!aborted) {
                    this.emit(Events.POINTER_OUT, pointer, previouslyOver);
                  }
                }
                this._over[pointer.id] = [];
              }
              return totalInteracted;
            },
            processOverOutEvents: function (pointer) {
              var currentlyOver = this._temp;
              var i;
              var gameObject;
              var justOut = [];
              var justOver = [];
              var stillOver = [];
              var previouslyOver = this._over[pointer.id];
              var currentlyDragging = this._drag[pointer.id];
              var manager = this.manager;
              for (i = 0; i < previouslyOver.length; i++) {
                gameObject = previouslyOver[i];
                if (currentlyOver.indexOf(gameObject) === -1 && currentlyDragging.indexOf(gameObject) === -1) {
                  justOut.push(gameObject);
                } else {
                  stillOver.push(gameObject);
                }
              }
              for (i = 0; i < currentlyOver.length; i++) {
                gameObject = currentlyOver[i];
                if (previouslyOver.indexOf(gameObject) === -1) {
                  justOver.push(gameObject);
                }
              }
              var total = justOut.length;
              var totalInteracted = 0;
              var _eventData = this._eventData;
              var _eventContainer = this._eventContainer;
              _eventData.cancelled = false;
              var aborted = false;
              if (total > 0) {
                this.sortGameObjects(justOut, pointer);
                for (i = 0; i < total; i++) {
                  gameObject = justOut[i];
                  if (!gameObject.input) {
                    continue;
                  }
                  manager.resetCursor(gameObject.input);
                  gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);
                  totalInteracted++;
                  if (_eventData.cancelled || !gameObject.input) {
                    aborted = true;
                    break;
                  }
                  this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);
                  if (_eventData.cancelled || !gameObject.input) {
                    aborted = true;
                    break;
                  }
                }
                if (!aborted) {
                  this.emit(Events.POINTER_OUT, pointer, justOut);
                }
              }
              total = justOver.length;
              _eventData.cancelled = false;
              aborted = false;
              if (total > 0) {
                this.sortGameObjects(justOver, pointer);
                for (i = 0; i < total; i++) {
                  gameObject = justOver[i];
                  if (!gameObject.input) {
                    continue;
                  }
                  manager.setCursor(gameObject.input);
                  gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
                  totalInteracted++;
                  if (_eventData.cancelled || !gameObject.input) {
                    aborted = true;
                    break;
                  }
                  this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);
                  if (_eventData.cancelled || !gameObject.input) {
                    aborted = true;
                    break;
                  }
                }
                if (!aborted) {
                  this.emit(Events.POINTER_OVER, pointer, justOver);
                }
              }
              previouslyOver = stillOver.concat(justOver);
              this._over[pointer.id] = this.sortGameObjects(previouslyOver, pointer);
              return totalInteracted;
            },
            processUpEvents: function (pointer) {
              var currentlyOver = this._temp;
              var _eventData = this._eventData;
              var _eventContainer = this._eventContainer;
              _eventData.cancelled = false;
              var aborted = false;
              for (var i = 0; i < currentlyOver.length; i++) {
                var gameObject = currentlyOver[i];
                if (!gameObject.input) {
                  continue;
                }
                gameObject.emit(Events.GAMEOBJECT_POINTER_UP, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
                this.emit(Events.GAMEOBJECT_UP, pointer, gameObject, _eventContainer);
                if (_eventData.cancelled || !gameObject.input) {
                  aborted = true;
                  break;
                }
              }
              if (!aborted && this.manager) {
                if (pointer.upElement === this.manager.game.canvas) {
                  this.emit(Events.POINTER_UP, pointer, currentlyOver);
                } else {
                  this.emit(Events.POINTER_UP_OUTSIDE, pointer);
                }
              }
              return currentlyOver.length;
            },
            queueForInsertion: function (child) {
              if (this._pendingInsertion.indexOf(child) === -1 && this._list.indexOf(child) === -1) {
                this._pendingInsertion.push(child);
              }
              return this;
            },
            queueForRemoval: function (child) {
              this._pendingRemoval.push(child);
              return this;
            },
            setDraggable: function (gameObjects, value) {
              if (value === void 0) {
                value = true;
              }
              if (!Array.isArray(gameObjects)) {
                gameObjects = [gameObjects];
              }
              for (var i = 0; i < gameObjects.length; i++) {
                var gameObject = gameObjects[i];
                gameObject.input.draggable = value;
                var index = this._draggable.indexOf(gameObject);
                if (value && index === -1) {
                  this._draggable.push(gameObject);
                } else if (!value && index > -1) {
                  this._draggable.splice(index, 1);
                }
              }
              return this;
            },
            makePixelPerfect: function (alphaTolerance) {
              if (alphaTolerance === void 0) {
                alphaTolerance = 1;
              }
              var textureManager = this.systems.textures;
              return CreatePixelPerfectHandler(textureManager, alphaTolerance);
            },
            setHitArea: function (gameObjects, hitArea, hitAreaCallback) {
              if (hitArea === void 0) {
                return this.setHitAreaFromTexture(gameObjects);
              }
              if (!Array.isArray(gameObjects)) {
                gameObjects = [gameObjects];
              }
              var draggable = false;
              var dropZone = false;
              var cursor = false;
              var useHandCursor = false;
              var pixelPerfect = false;
              var customHitArea = true;
              if (IsPlainObject(hitArea)) {
                var config = hitArea;
                hitArea = GetFastValue(config, "hitArea", null);
                hitAreaCallback = GetFastValue(config, "hitAreaCallback", null);
                draggable = GetFastValue(config, "draggable", false);
                dropZone = GetFastValue(config, "dropZone", false);
                cursor = GetFastValue(config, "cursor", false);
                useHandCursor = GetFastValue(config, "useHandCursor", false);
                pixelPerfect = GetFastValue(config, "pixelPerfect", false);
                var alphaTolerance = GetFastValue(config, "alphaTolerance", 1);
                if (pixelPerfect) {
                  hitArea = {};
                  hitAreaCallback = this.makePixelPerfect(alphaTolerance);
                }
                if (!hitArea || !hitAreaCallback) {
                  this.setHitAreaFromTexture(gameObjects);
                  customHitArea = false;
                }
              } else if (typeof hitArea === "function" && !hitAreaCallback) {
                hitAreaCallback = hitArea;
                hitArea = {};
              }
              for (var i = 0; i < gameObjects.length; i++) {
                var gameObject = gameObjects[i];
                if (pixelPerfect && gameObject.type === "Container") {
                  console.warn("Cannot pixelPerfect test a Container. Use a custom callback.");
                  continue;
                }
                var io = !gameObject.input ? CreateInteractiveObject(gameObject, hitArea, hitAreaCallback) : gameObject.input;
                io.customHitArea = customHitArea;
                io.dropZone = dropZone;
                io.cursor = useHandCursor ? "pointer" : cursor;
                gameObject.input = io;
                if (draggable) {
                  this.setDraggable(gameObject);
                }
                this.queueForInsertion(gameObject);
              }
              return this;
            },
            setHitAreaCircle: function (gameObjects, x, y, radius, callback) {
              if (callback === void 0) {
                callback = CircleContains;
              }
              var shape = new Circle(x, y, radius);
              return this.setHitArea(gameObjects, shape, callback);
            },
            setHitAreaEllipse: function (gameObjects, x, y, width, height, callback) {
              if (callback === void 0) {
                callback = EllipseContains;
              }
              var shape = new Ellipse(x, y, width, height);
              return this.setHitArea(gameObjects, shape, callback);
            },
            setHitAreaFromTexture: function (gameObjects, callback) {
              if (callback === void 0) {
                callback = RectangleContains;
              }
              if (!Array.isArray(gameObjects)) {
                gameObjects = [gameObjects];
              }
              for (var i = 0; i < gameObjects.length; i++) {
                var gameObject = gameObjects[i];
                var frame = gameObject.frame;
                var width = 0;
                var height = 0;
                if (gameObject.width) {
                  width = gameObject.width;
                  height = gameObject.height;
                } else if (frame) {
                  width = frame.realWidth;
                  height = frame.realHeight;
                }
                if (gameObject.type === "Container" && (width === 0 || height === 0)) {
                  console.warn("Container.setInteractive must specify a Shape or call setSize() first");
                  continue;
                }
                if (width !== 0 && height !== 0) {
                  gameObject.input = CreateInteractiveObject(gameObject, new Rectangle(0, 0, width, height), callback);
                  this.queueForInsertion(gameObject);
                }
              }
              return this;
            },
            setHitAreaRectangle: function (gameObjects, x, y, width, height, callback) {
              if (callback === void 0) {
                callback = RectangleContains;
              }
              var shape = new Rectangle(x, y, width, height);
              return this.setHitArea(gameObjects, shape, callback);
            },
            setHitAreaTriangle: function (gameObjects, x1, y1, x2, y2, x3, y3, callback) {
              if (callback === void 0) {
                callback = TriangleContains;
              }
              var shape = new Triangle(x1, y1, x2, y2, x3, y3);
              return this.setHitArea(gameObjects, shape, callback);
            },
            enableDebug: function (gameObject, color) {
              if (color === void 0) {
                color = 65280;
              }
              var input = gameObject.input;
              if (!input || !input.hitArea) {
                return this;
              }
              var shape = input.hitArea;
              var shapeType = shape.type;
              var debug = input.hitAreaDebug;
              var factory = this.systems.add;
              var updateList = this.systems.updateList;
              if (debug) {
                updateList.remove(debug);
                debug.destroy();
                debug = null;
              }
              var offsetx = 0;
              var offsety = 0;
              switch (shapeType) {
                case GEOM_CONST.CIRCLE:
                  debug = factory.arc(0, 0, shape.radius);
                  offsetx = shape.x - shape.radius;
                  offsety = shape.y - shape.radius;
                  break;
                case GEOM_CONST.ELLIPSE:
                  debug = factory.ellipse(0, 0, shape.width, shape.height);
                  offsetx = shape.x - shape.width / 2;
                  offsety = shape.y - shape.height / 2;
                  break;
                case GEOM_CONST.LINE:
                  debug = factory.line(0, 0, shape.x1, shape.y1, shape.x2, shape.y2);
                  break;
                case GEOM_CONST.POLYGON:
                  debug = factory.polygon(0, 0, shape.points);
                  break;
                case GEOM_CONST.RECTANGLE:
                  debug = factory.rectangle(0, 0, shape.width, shape.height);
                  offsetx = shape.x;
                  offsety = shape.y;
                  break;
                case GEOM_CONST.TRIANGLE:
                  debug = factory.triangle(0, 0, shape.x1, shape.y1, shape.x2, shape.y2, shape.x3, shape.y3);
                  break;
              }
              if (debug) {
                debug.isFilled = false;
                debug.preUpdate = function () {
                  debug.setStrokeStyle(1 / gameObject.scale, color);
                  debug.setDisplayOrigin(gameObject.displayOriginX, gameObject.displayOriginY);
                  var x = gameObject.x;
                  var y = gameObject.y;
                  var rotation = gameObject.rotation;
                  var scaleX = gameObject.scaleX;
                  var scaleY = gameObject.scaleY;
                  if (gameObject.parentContainer) {
                    var matrix = gameObject.getWorldTransformMatrix();
                    x = matrix.tx;
                    y = matrix.ty;
                    rotation = matrix.rotation;
                    scaleX = matrix.scaleX;
                    scaleY = matrix.scaleY;
                  }
                  debug.setRotation(rotation);
                  debug.setScale(scaleX, scaleY);
                  debug.setPosition(x + offsetx, y + offsety);
                  debug.setScrollFactor(gameObject.scrollFactorX, gameObject.scrollFactorY);
                  debug.setDepth(gameObject.depth);
                };
                updateList.add(debug);
                input.hitAreaDebug = debug;
              }
              return this;
            },
            removeDebug: function (gameObject) {
              var input = gameObject.input;
              if (input && input.hitAreaDebug) {
                var debug = input.hitAreaDebug;
                this.systems.updateList.remove(debug);
                debug.destroy();
                input.hitAreaDebug = null;
              }
              return this;
            },
            setPollAlways: function () {
              return this.setPollRate(0);
            },
            setPollOnMove: function () {
              return this.setPollRate(-1);
            },
            setPollRate: function (value) {
              this.pollRate = value;
              this._pollTimer = 0;
              return this;
            },
            setGlobalTopOnly: function (value) {
              this.manager.globalTopOnly = value;
              return this;
            },
            setTopOnly: function (value) {
              this.topOnly = value;
              return this;
            },
            sortGameObjects: function (gameObjects, pointer) {
              if (gameObjects.length < 2) {
                return gameObjects;
              }
              var list = pointer.camera.renderList;
              return gameObjects.sort(function (childA, childB) {
                return list.indexOf(childB) - list.indexOf(childA);
              });
            },
            sortDropZones: function (gameObjects) {
              if (gameObjects.length < 2) {
                return gameObjects;
              }
              this.scene.sys.depthSort();
              return gameObjects.sort(this.sortDropZoneHandler.bind(this));
            },
            sortDropZoneHandler: function (childA, childB) {
              if (!childA.parentContainer && !childB.parentContainer) {
                return this.displayList.getIndex(childB) - this.displayList.getIndex(childA);
              } else if (childA.parentContainer === childB.parentContainer) {
                return childB.parentContainer.getIndex(childB) - childA.parentContainer.getIndex(childA);
              } else if (childA.parentContainer === childB) {
                return -1;
              } else if (childB.parentContainer === childA) {
                return 1;
              } else {
                var listA = childA.getIndexList();
                var listB = childB.getIndexList();
                var len = Math.min(listA.length, listB.length);
                for (var i = 0; i < len; i++) {
                  var indexA = listA[i];
                  var indexB = listB[i];
                  if (indexA === indexB) {
                    continue;
                  } else {
                    return indexB - indexA;
                  }
                }
                return listB.length - listA.length;
              }
              return 0;
            },
            stopPropagation: function () {
              this.manager._tempSkip = true;
              return this;
            },
            addPointer: function (quantity) {
              return this.manager.addPointer(quantity);
            },
            setDefaultCursor: function (cursor) {
              this.manager.setDefaultCursor(cursor);
              return this;
            },
            transitionIn: function () {
              this.enabled = this.settings.transitionAllowInput;
            },
            transitionComplete: function () {
              if (!this.settings.transitionAllowInput) {
                this.enabled = true;
              }
            },
            transitionOut: function () {
              this.enabled = this.settings.transitionAllowInput;
            },
            shutdown: function () {
              this.pluginEvents.emit(Events.SHUTDOWN);
              this._temp.length = 0;
              this._list.length = 0;
              this._draggable.length = 0;
              this._pendingRemoval.length = 0;
              this._pendingInsertion.length = 0;
              this._dragState.length = 0;
              for (var i = 0; i < 10; i++) {
                this._drag[i] = [];
                this._over[i] = [];
              }
              this.removeAllListeners();
              var manager = this.manager;
              manager.canvas.style.cursor = manager.defaultCursor;
              var eventEmitter = this.systems.events;
              eventEmitter.off(SceneEvents.TRANSITION_START, this.transitionIn, this);
              eventEmitter.off(SceneEvents.TRANSITION_OUT, this.transitionOut, this);
              eventEmitter.off(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);
              eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
              manager.events.off(Events.GAME_OUT, this.onGameOut, this);
              manager.events.off(Events.GAME_OVER, this.onGameOver, this);
              eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function () {
              this.shutdown();
              this.pluginEvents.emit(Events.DESTROY);
              this.pluginEvents.removeAllListeners();
              this.scene.sys.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.cameras = null;
              this.manager = null;
              this.events = null;
              this.mouse = null;
            },
            x: {
              get: function () {
                return this.manager.activePointer.x;
              }
            },
            y: {
              get: function () {
                return this.manager.activePointer.y;
              }
            },
            isOver: {
              get: function () {
                return this.manager.isOver;
              }
            },
            mousePointer: {
              get: function () {
                return this.manager.mousePointer;
              }
            },
            activePointer: {
              get: function () {
                return this.manager.activePointer;
              }
            },
            pointer1: {
              get: function () {
                return this.manager.pointers[1];
              }
            },
            pointer2: {
              get: function () {
                return this.manager.pointers[2];
              }
            },
            pointer3: {
              get: function () {
                return this.manager.pointers[3];
              }
            },
            pointer4: {
              get: function () {
                return this.manager.pointers[4];
              }
            },
            pointer5: {
              get: function () {
                return this.manager.pointers[5];
              }
            },
            pointer6: {
              get: function () {
                return this.manager.pointers[6];
              }
            },
            pointer7: {
              get: function () {
                return this.manager.pointers[7];
              }
            },
            pointer8: {
              get: function () {
                return this.manager.pointers[8];
              }
            },
            pointer9: {
              get: function () {
                return this.manager.pointers[9];
              }
            },
            pointer10: {
              get: function () {
                return this.manager.pointers[10];
              }
            }
          });
          PluginCache.register("InputPlugin", InputPlugin, "input");
          module2.exports = InputPlugin;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Events: __webpack_require__(154),
            KeyboardManager: __webpack_require__(410),
            KeyboardPlugin: __webpack_require__(1330),
            Key: __webpack_require__(512),
            KeyCodes: __webpack_require__(143),
            KeyCombo: __webpack_require__(513),
            AdvanceKeyCombo: __webpack_require__(515),
            ProcessKeyCombo: __webpack_require__(514),
            ResetKeyCombo: __webpack_require__(516),
            JustDown: __webpack_require__(1332),
            JustUp: __webpack_require__(1333),
            DownDuration: __webpack_require__(1334),
            UpDuration: __webpack_require__(1335)
          };
        }, function (module2, exports2) {
          module2.exports = "keydown";
        }, function (module2, exports2) {
          module2.exports = "keyup";
        }, function (module2, exports2) {
          module2.exports = "keycombomatch";
        }, function (module2, exports2) {
          module2.exports = "down";
        }, function (module2, exports2) {
          module2.exports = "keydown-";
        }, function (module2, exports2) {
          module2.exports = "keyup-";
        }, function (module2, exports2) {
          module2.exports = "up";
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(154);
          var GameEvents = __webpack_require__(22);
          var GetValue = __webpack_require__(6);
          var InputEvents = __webpack_require__(51);
          var InputPluginCache = __webpack_require__(153);
          var Key = __webpack_require__(512);
          var KeyCodes = __webpack_require__(143);
          var KeyCombo = __webpack_require__(513);
          var KeyMap = __webpack_require__(1331);
          var SceneEvents = __webpack_require__(20);
          var SnapFloor = __webpack_require__(76);
          var KeyboardPlugin = new Class({
            Extends: EventEmitter,
            initialize: function KeyboardPlugin2(sceneInputPlugin) {
              EventEmitter.call(this);
              this.game = sceneInputPlugin.systems.game;
              this.scene = sceneInputPlugin.scene;
              this.settings = this.scene.sys.settings;
              this.sceneInputPlugin = sceneInputPlugin;
              this.manager = sceneInputPlugin.manager.keyboard;
              this.enabled = true;
              this.keys = [];
              this.combos = [];
              this.prevCode = null;
              this.prevTime = 0;
              this.prevType = null;
              sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);
              sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);
            },
            boot: function () {
              var settings = this.settings.input;
              this.enabled = GetValue(settings, "keyboard", true);
              var captures = GetValue(settings, "keyboard.capture", null);
              if (captures) {
                this.addCaptures(captures);
              }
              this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);
            },
            start: function () {
              this.sceneInputPlugin.manager.events.on(InputEvents.MANAGER_PROCESS, this.update, this);
              this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);
              this.game.events.on(GameEvents.BLUR, this.resetKeys, this);
              this.scene.sys.events.on(SceneEvents.PAUSE, this.resetKeys, this);
              this.scene.sys.events.on(SceneEvents.SLEEP, this.resetKeys, this);
            },
            isActive: function () {
              return this.enabled && this.scene.sys.isActive();
            },
            addCapture: function (keycode) {
              this.manager.addCapture(keycode);
              return this;
            },
            removeCapture: function (keycode) {
              this.manager.removeCapture(keycode);
              return this;
            },
            getCaptures: function () {
              return this.manager.captures;
            },
            enableGlobalCapture: function () {
              this.manager.preventDefault = true;
              return this;
            },
            disableGlobalCapture: function () {
              this.manager.preventDefault = false;
              return this;
            },
            clearCaptures: function () {
              this.manager.clearCaptures();
              return this;
            },
            createCursorKeys: function () {
              return this.addKeys({
                up: KeyCodes.UP,
                down: KeyCodes.DOWN,
                left: KeyCodes.LEFT,
                right: KeyCodes.RIGHT,
                space: KeyCodes.SPACE,
                shift: KeyCodes.SHIFT
              });
            },
            addKeys: function (keys, enableCapture, emitOnRepeat) {
              if (enableCapture === void 0) {
                enableCapture = true;
              }
              if (emitOnRepeat === void 0) {
                emitOnRepeat = false;
              }
              var output = {};
              if (typeof keys === "string") {
                keys = keys.split(",");
                for (var i = 0; i < keys.length; i++) {
                  var currentKey = keys[i].trim();
                  if (currentKey) {
                    output[currentKey] = this.addKey(currentKey, enableCapture, emitOnRepeat);
                  }
                }
              } else {
                for (var key in keys) {
                  output[key] = this.addKey(keys[key], enableCapture, emitOnRepeat);
                }
              }
              return output;
            },
            addKey: function (key, enableCapture, emitOnRepeat) {
              if (enableCapture === void 0) {
                enableCapture = true;
              }
              if (emitOnRepeat === void 0) {
                emitOnRepeat = false;
              }
              var keys = this.keys;
              if (key instanceof Key) {
                var idx = keys.indexOf(key);
                if (idx > -1) {
                  keys[idx] = key;
                } else {
                  keys[key.keyCode] = key;
                }
                if (enableCapture) {
                  this.addCapture(key.keyCode);
                }
                key.setEmitOnRepeat(emitOnRepeat);
                return key;
              }
              if (typeof key === "string") {
                key = KeyCodes[key.toUpperCase()];
              }
              if (!keys[key]) {
                keys[key] = new Key(this, key);
                if (enableCapture) {
                  this.addCapture(key);
                }
                keys[key].setEmitOnRepeat(emitOnRepeat);
              }
              return keys[key];
            },
            removeKey: function (key, destroy) {
              if (destroy === void 0) {
                destroy = false;
              }
              var keys = this.keys;
              var ref;
              if (key instanceof Key) {
                var idx = keys.indexOf(key);
                if (idx > -1) {
                  ref = this.keys[idx];
                  this.keys[idx] = void 0;
                }
              } else if (typeof key === "string") {
                key = KeyCodes[key.toUpperCase()];
              }
              if (keys[key]) {
                ref = keys[key];
                keys[key] = void 0;
              }
              if (ref) {
                ref.plugin = null;
                if (destroy) {
                  ref.destroy();
                }
              }
              return this;
            },
            removeAllKeys: function (destroy) {
              var keys = this.keys;
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (key) {
                  keys[i] = void 0;
                  if (destroy) {
                    key.destroy();
                  }
                }
              }
              return this;
            },
            createCombo: function (keys, config) {
              return new KeyCombo(this, keys, config);
            },
            checkDown: function (key, duration) {
              if (duration === void 0) {
                duration = 0;
              }
              if (this.enabled && key.isDown) {
                var t = SnapFloor(this.time - key.timeDown, duration);
                if (t > key._tick) {
                  key._tick = t;
                  return true;
                }
              }
              return false;
            },
            update: function () {
              var queue = this.manager.queue;
              var len = queue.length;
              if (!this.isActive() || len === 0) {
                return;
              }
              var keys = this.keys;
              for (var i = 0; i < len; i++) {
                var event = queue[i];
                var code = event.keyCode;
                var key = keys[code];
                var repeat = false;
                if (event.cancelled === void 0) {
                  event.cancelled = 0;
                  event.stopImmediatePropagation = function () {
                    event.cancelled = 1;
                  };
                  event.stopPropagation = function () {
                    event.cancelled = -1;
                  };
                }
                if (event.cancelled === -1) {
                  continue;
                }
                if (code === this.prevCode && event.timeStamp === this.prevTime && event.type === this.prevType) {
                  continue;
                }
                this.prevCode = code;
                this.prevTime = event.timeStamp;
                this.prevType = event.type;
                if (event.type === "keydown") {
                  if (key) {
                    repeat = key.isDown;
                    key.onDown(event);
                  }
                  if (!event.cancelled && (!key || !repeat)) {
                    if (KeyMap[code]) {
                      this.emit(Events.KEY_DOWN + KeyMap[code], event);
                    }
                    if (!event.cancelled) {
                      this.emit(Events.ANY_KEY_DOWN, event);
                    }
                  }
                } else {
                  if (key) {
                    key.onUp(event);
                  }
                  if (!event.cancelled) {
                    if (KeyMap[code]) {
                      this.emit(Events.KEY_UP + KeyMap[code], event);
                    }
                    if (!event.cancelled) {
                      this.emit(Events.ANY_KEY_UP, event);
                    }
                  }
                }
                if (event.cancelled === 1) {
                  event.cancelled = 0;
                }
              }
            },
            resetKeys: function () {
              var keys = this.keys;
              for (var i = 0; i < keys.length; i++) {
                if (keys[i]) {
                  keys[i].reset();
                }
              }
              return this;
            },
            shutdown: function () {
              this.removeAllKeys(true);
              this.removeAllListeners();
              this.sceneInputPlugin.manager.events.off(InputEvents.MANAGER_PROCESS, this.update, this);
              this.game.events.off(GameEvents.BLUR, this.resetKeys);
              this.scene.sys.events.off(SceneEvents.PAUSE, this.resetKeys, this);
              this.scene.sys.events.off(SceneEvents.SLEEP, this.resetKeys, this);
              this.queue = [];
            },
            destroy: function () {
              this.shutdown();
              var keys = this.keys;
              for (var i = 0; i < keys.length; i++) {
                if (keys[i]) {
                  keys[i].destroy();
                }
              }
              this.keys = [];
              this.combos = [];
              this.queue = [];
              this.scene = null;
              this.settings = null;
              this.sceneInputPlugin = null;
              this.manager = null;
            },
            time: {
              get: function () {
                return this.sceneInputPlugin.manager.time;
              }
            }
          });
          InputPluginCache.register("KeyboardPlugin", KeyboardPlugin, "keyboard", "keyboard", "inputKeyboard");
          module2.exports = KeyboardPlugin;
        }, function (module2, exports2, __webpack_require__) {
          var KeyCodes = __webpack_require__(143);
          var KeyMap = {};
          for (var key in KeyCodes) {
            KeyMap[KeyCodes[key]] = key;
          }
          module2.exports = KeyMap;
        }, function (module2, exports2) {
          var JustDown = function (key) {
            if (key._justDown) {
              key._justDown = false;
              return true;
            } else {
              return false;
            }
          };
          module2.exports = JustDown;
        }, function (module2, exports2) {
          var JustUp = function (key) {
            if (key._justUp) {
              key._justUp = false;
              return true;
            } else {
              return false;
            }
          };
          module2.exports = JustUp;
        }, function (module2, exports2) {
          var DownDuration = function (key, duration) {
            if (duration === void 0) {
              duration = 50;
            }
            var current = key.plugin.game.loop.time - key.timeDown;
            return key.isDown && current < duration;
          };
          module2.exports = DownDuration;
        }, function (module2, exports2) {
          var UpDuration = function (key, duration) {
            if (duration === void 0) {
              duration = 50;
            }
            var current = key.plugin.game.loop.time - key.timeUp;
            return key.isUp && current < duration;
          };
          module2.exports = UpDuration;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            MouseManager: __webpack_require__(411)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            TouchManager: __webpack_require__(413)
          };
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(21);
          var Extend = __webpack_require__(17);
          var Loader = {
            Events: __webpack_require__(95),
            FileTypes: __webpack_require__(1339),
            File: __webpack_require__(23),
            FileTypesManager: __webpack_require__(8),
            GetURL: __webpack_require__(155),
            LoaderPlugin: __webpack_require__(1365),
            MergeXHRSettings: __webpack_require__(240),
            MultiFile: __webpack_require__(49),
            XHRLoader: __webpack_require__(517),
            XHRSettings: __webpack_require__(156)
          };
          Loader = Extend(false, Loader, CONST);
          module2.exports = Loader;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            AnimationJSONFile: __webpack_require__(1340),
            AsepriteFile: __webpack_require__(1341),
            AtlasJSONFile: __webpack_require__(1342),
            AtlasXMLFile: __webpack_require__(1343),
            AudioFile: __webpack_require__(518),
            AudioSpriteFile: __webpack_require__(1344),
            BinaryFile: __webpack_require__(1345),
            BitmapFontFile: __webpack_require__(1346),
            CSSFile: __webpack_require__(1347),
            GLSLFile: __webpack_require__(1348),
            HTML5AudioFile: __webpack_require__(519),
            HTMLFile: __webpack_require__(1349),
            HTMLTextureFile: __webpack_require__(1350),
            ImageFile: __webpack_require__(71),
            JSONFile: __webpack_require__(61),
            MultiAtlasFile: __webpack_require__(1351),
            MultiScriptFile: __webpack_require__(1352),
            OBJFile: __webpack_require__(1353),
            PackFile: __webpack_require__(1354),
            PluginFile: __webpack_require__(1355),
            SceneFile: __webpack_require__(1356),
            ScenePluginFile: __webpack_require__(1357),
            ScriptFile: __webpack_require__(520),
            SpriteSheetFile: __webpack_require__(1358),
            SVGFile: __webpack_require__(1359),
            TextFile: __webpack_require__(242),
            TilemapCSVFile: __webpack_require__(1360),
            TilemapImpactFile: __webpack_require__(1361),
            TilemapJSONFile: __webpack_require__(1362),
            UnityAtlasFile: __webpack_require__(1363),
            VideoFile: __webpack_require__(1364),
            XMLFile: __webpack_require__(241)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var JSONFile = __webpack_require__(61);
          var LoaderEvents = __webpack_require__(95);
          var AnimationJSONFile = new Class({
            Extends: JSONFile,
            initialize: function AnimationJSONFile2(loader, key, url, xhrSettings, dataKey) {
              JSONFile.call(this, loader, key, url, xhrSettings, dataKey);
              this.type = "animationJSON";
            },
            onProcess: function () {
              this.loader.once(LoaderEvents.POST_PROCESS, this.onLoadComplete, this);
              JSONFile.prototype.onProcess.call(this);
            },
            onLoadComplete: function () {
              this.loader.systems.anims.fromJSON(this.data);
            }
          });
          FileTypesManager.register("animation", function (key, url, dataKey, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new AnimationJSONFile(this, key[i]));
              }
            } else {
              this.addFile(new AnimationJSONFile(this, key, url, xhrSettings, dataKey));
            }
            return this;
          });
          module2.exports = AnimationJSONFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var ImageFile = __webpack_require__(71);
          var IsPlainObject = __webpack_require__(7);
          var JSONFile = __webpack_require__(61);
          var MultiFile = __webpack_require__(49);
          var AsepriteFile = new Class({
            Extends: MultiFile,
            initialize: function AsepriteFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
              var image;
              var data;
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                image = new ImageFile(loader, {
                  key,
                  url: GetFastValue(config, "textureURL"),
                  extension: GetFastValue(config, "textureExtension", "png"),
                  normalMap: GetFastValue(config, "normalMap"),
                  xhrSettings: GetFastValue(config, "textureXhrSettings")
                });
                data = new JSONFile(loader, {
                  key,
                  url: GetFastValue(config, "atlasURL"),
                  extension: GetFastValue(config, "atlasExtension", "json"),
                  xhrSettings: GetFastValue(config, "atlasXhrSettings")
                });
              } else {
                image = new ImageFile(loader, key, textureURL, textureXhrSettings);
                data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);
              }
              if (image.linkFile) {
                MultiFile.call(this, loader, "atlasjson", key, [image, data, image.linkFile]);
              } else {
                MultiFile.call(this, loader, "atlasjson", key, [image, data]);
              }
            },
            addToCache: function () {
              if (this.isReadyToProcess()) {
                var image = this.files[0];
                var json = this.files[1];
                var normalMap = this.files[2] ? this.files[2].data : null;
                this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap);
                json.addToCache();
                this.complete = true;
              }
            }
          });
          FileTypesManager.register("aseprite", function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
            var multifile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                multifile = new AsepriteFile(this, key[i]);
                this.addFile(multifile.files);
              }
            } else {
              multifile = new AsepriteFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
              this.addFile(multifile.files);
            }
            return this;
          });
          module2.exports = AsepriteFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var ImageFile = __webpack_require__(71);
          var IsPlainObject = __webpack_require__(7);
          var JSONFile = __webpack_require__(61);
          var MultiFile = __webpack_require__(49);
          var AtlasJSONFile = new Class({
            Extends: MultiFile,
            initialize: function AtlasJSONFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
              var image;
              var data;
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                image = new ImageFile(loader, {
                  key,
                  url: GetFastValue(config, "textureURL"),
                  extension: GetFastValue(config, "textureExtension", "png"),
                  normalMap: GetFastValue(config, "normalMap"),
                  xhrSettings: GetFastValue(config, "textureXhrSettings")
                });
                data = new JSONFile(loader, {
                  key,
                  url: GetFastValue(config, "atlasURL"),
                  extension: GetFastValue(config, "atlasExtension", "json"),
                  xhrSettings: GetFastValue(config, "atlasXhrSettings")
                });
              } else {
                image = new ImageFile(loader, key, textureURL, textureXhrSettings);
                data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);
              }
              if (image.linkFile) {
                MultiFile.call(this, loader, "atlasjson", key, [image, data, image.linkFile]);
              } else {
                MultiFile.call(this, loader, "atlasjson", key, [image, data]);
              }
            },
            addToCache: function () {
              if (this.isReadyToProcess()) {
                var image = this.files[0];
                var json = this.files[1];
                var normalMap = this.files[2] ? this.files[2].data : null;
                this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap);
                json.pendingDestroy();
                this.complete = true;
              }
            }
          });
          FileTypesManager.register("atlas", function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
            var multifile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                multifile = new AtlasJSONFile(this, key[i]);
                this.addFile(multifile.files);
              }
            } else {
              multifile = new AtlasJSONFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
              this.addFile(multifile.files);
            }
            return this;
          });
          module2.exports = AtlasJSONFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var ImageFile = __webpack_require__(71);
          var IsPlainObject = __webpack_require__(7);
          var MultiFile = __webpack_require__(49);
          var XMLFile = __webpack_require__(241);
          var AtlasXMLFile = new Class({
            Extends: MultiFile,
            initialize: function AtlasXMLFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
              var image;
              var data;
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                image = new ImageFile(loader, {
                  key,
                  url: GetFastValue(config, "textureURL"),
                  extension: GetFastValue(config, "textureExtension", "png"),
                  normalMap: GetFastValue(config, "normalMap"),
                  xhrSettings: GetFastValue(config, "textureXhrSettings")
                });
                data = new XMLFile(loader, {
                  key,
                  url: GetFastValue(config, "atlasURL"),
                  extension: GetFastValue(config, "atlasExtension", "xml"),
                  xhrSettings: GetFastValue(config, "atlasXhrSettings")
                });
              } else {
                image = new ImageFile(loader, key, textureURL, textureXhrSettings);
                data = new XMLFile(loader, key, atlasURL, atlasXhrSettings);
              }
              if (image.linkFile) {
                MultiFile.call(this, loader, "atlasxml", key, [image, data, image.linkFile]);
              } else {
                MultiFile.call(this, loader, "atlasxml", key, [image, data]);
              }
            },
            addToCache: function () {
              if (this.isReadyToProcess()) {
                var image = this.files[0];
                var xml = this.files[1];
                var normalMap = this.files[2] ? this.files[2].data : null;
                this.loader.textureManager.addAtlasXML(image.key, image.data, xml.data, normalMap);
                xml.pendingDestroy();
                this.complete = true;
              }
            }
          });
          FileTypesManager.register("atlasXML", function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
            var multifile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                multifile = new AtlasXMLFile(this, key[i]);
                this.addFile(multifile.files);
              }
            } else {
              multifile = new AtlasXMLFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
              this.addFile(multifile.files);
            }
            return this;
          });
          module2.exports = AtlasXMLFile;
        }, function (module2, exports2, __webpack_require__) {
          var AudioFile = __webpack_require__(518);
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var JSONFile = __webpack_require__(61);
          var MultiFile = __webpack_require__(49);
          var AudioSpriteFile = new Class({
            Extends: MultiFile,
            initialize: function AudioSpriteFile2(loader, key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings) {
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                jsonURL = GetFastValue(config, "jsonURL");
                audioURL = GetFastValue(config, "audioURL");
                audioConfig = GetFastValue(config, "audioConfig");
                audioXhrSettings = GetFastValue(config, "audioXhrSettings");
                jsonXhrSettings = GetFastValue(config, "jsonXhrSettings");
              }
              var data;
              if (!audioURL) {
                data = new JSONFile(loader, key, jsonURL, jsonXhrSettings);
                MultiFile.call(this, loader, "audiosprite", key, [data]);
                this.config.resourceLoad = true;
                this.config.audioConfig = audioConfig;
                this.config.audioXhrSettings = audioXhrSettings;
              } else {
                var audio = AudioFile.create(loader, key, audioURL, audioConfig, audioXhrSettings);
                if (audio) {
                  data = new JSONFile(loader, key, jsonURL, jsonXhrSettings);
                  MultiFile.call(this, loader, "audiosprite", key, [audio, data]);
                  this.config.resourceLoad = false;
                }
              }
            },
            onFileComplete: function (file) {
              var index = this.files.indexOf(file);
              if (index !== -1) {
                this.pending--;
                if (this.config.resourceLoad && file.type === "json" && file.data.hasOwnProperty("resources")) {
                  var urls = file.data.resources;
                  var audioConfig = GetFastValue(this.config, "audioConfig");
                  var audioXhrSettings = GetFastValue(this.config, "audioXhrSettings");
                  var audio = AudioFile.create(this.loader, file.key, urls, audioConfig, audioXhrSettings);
                  if (audio) {
                    this.addToMultiFile(audio);
                    this.loader.addFile(audio);
                  }
                }
              }
            },
            addToCache: function () {
              if (this.isReadyToProcess()) {
                var fileA = this.files[0];
                var fileB = this.files[1];
                fileA.addToCache();
                fileB.addToCache();
                this.complete = true;
              }
            }
          });
          FileTypesManager.register("audioSprite", function (key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings) {
            var game = this.systems.game;
            var gameAudioConfig = game.config.audio;
            var deviceAudio = game.device.audio;
            if (gameAudioConfig && gameAudioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
              return this;
            }
            var multifile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                multifile = new AudioSpriteFile(this, key[i]);
                if (multifile.files) {
                  this.addFile(multifile.files);
                }
              }
            } else {
              multifile = new AudioSpriteFile(this, key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings);
              if (multifile.files) {
                this.addFile(multifile.files);
              }
            }
            return this;
          });
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var BinaryFile = new Class({
            Extends: File,
            initialize: function BinaryFile2(loader, key, url, xhrSettings, dataType) {
              var extension = "bin";
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                url = GetFastValue(config, "url");
                xhrSettings = GetFastValue(config, "xhrSettings");
                extension = GetFastValue(config, "extension", extension);
                dataType = GetFastValue(config, "dataType", dataType);
              }
              var fileConfig = {
                type: "binary",
                cache: loader.cacheManager.binary,
                extension,
                responseType: "arraybuffer",
                key,
                url,
                xhrSettings,
                config: {
                  dataType
                }
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function () {
              this.state = CONST.FILE_PROCESSING;
              var ctor = this.config.dataType;
              this.data = ctor ? new ctor(this.xhrLoader.response) : this.xhrLoader.response;
              this.onProcessComplete();
            }
          });
          FileTypesManager.register("binary", function (key, url, dataType, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new BinaryFile(this, key[i]));
              }
            } else {
              this.addFile(new BinaryFile(this, key, url, xhrSettings, dataType));
            }
            return this;
          });
          module2.exports = BinaryFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var ImageFile = __webpack_require__(71);
          var IsPlainObject = __webpack_require__(7);
          var MultiFile = __webpack_require__(49);
          var ParseXMLBitmapFont = __webpack_require__(212);
          var XMLFile = __webpack_require__(241);
          var BitmapFontFile = new Class({
            Extends: MultiFile,
            initialize: function BitmapFontFile2(loader, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings) {
              var image;
              var data;
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                image = new ImageFile(loader, {
                  key,
                  url: GetFastValue(config, "textureURL"),
                  extension: GetFastValue(config, "textureExtension", "png"),
                  normalMap: GetFastValue(config, "normalMap"),
                  xhrSettings: GetFastValue(config, "textureXhrSettings")
                });
                data = new XMLFile(loader, {
                  key,
                  url: GetFastValue(config, "fontDataURL"),
                  extension: GetFastValue(config, "fontDataExtension", "xml"),
                  xhrSettings: GetFastValue(config, "fontDataXhrSettings")
                });
              } else {
                image = new ImageFile(loader, key, textureURL, textureXhrSettings);
                data = new XMLFile(loader, key, fontDataURL, fontDataXhrSettings);
              }
              if (image.linkFile) {
                MultiFile.call(this, loader, "bitmapfont", key, [image, data, image.linkFile]);
              } else {
                MultiFile.call(this, loader, "bitmapfont", key, [image, data]);
              }
            },
            addToCache: function () {
              if (this.isReadyToProcess()) {
                var image = this.files[0];
                var xml = this.files[1];
                image.addToCache();
                xml.pendingDestroy();
                var texture = image.cache.get(image.key);
                var data = ParseXMLBitmapFont(xml.data, image.cache.getFrame(image.key), 0, 0, texture);
                this.loader.cacheManager.bitmapFont.add(image.key, {
                  data,
                  texture: image.key,
                  frame: null
                });
                this.complete = true;
              }
            }
          });
          FileTypesManager.register("bitmapFont", function (key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings) {
            var multifile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                multifile = new BitmapFontFile(this, key[i]);
                this.addFile(multifile.files);
              }
            } else {
              multifile = new BitmapFontFile(this, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings);
              this.addFile(multifile.files);
            }
            return this;
          });
          module2.exports = BitmapFontFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var CSSFile = new Class({
            Extends: File,
            initialize: function CSSFile2(loader, key, url, xhrSettings) {
              var extension = "css";
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                url = GetFastValue(config, "url");
                xhrSettings = GetFastValue(config, "xhrSettings");
                extension = GetFastValue(config, "extension", extension);
              }
              var fileConfig = {
                type: "script",
                cache: false,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function () {
              this.state = CONST.FILE_PROCESSING;
              this.data = document.createElement("style");
              this.data.defer = false;
              this.data.innerHTML = this.xhrLoader.responseText;
              document.head.appendChild(this.data);
              this.onProcessComplete();
            }
          });
          FileTypesManager.register("css", function (key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new CSSFile(this, key[i]));
              }
            } else {
              this.addFile(new CSSFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = CSSFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var Shader = __webpack_require__(396);
          var GLSLFile = new Class({
            Extends: File,
            initialize: function GLSLFile2(loader, key, url, shaderType, xhrSettings) {
              var extension = "glsl";
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                url = GetFastValue(config, "url");
                shaderType = GetFastValue(config, "shaderType", "fragment");
                xhrSettings = GetFastValue(config, "xhrSettings");
                extension = GetFastValue(config, "extension", extension);
              } else if (shaderType === void 0) {
                shaderType = "fragment";
              }
              var fileConfig = {
                type: "glsl",
                cache: loader.cacheManager.shader,
                extension,
                responseType: "text",
                key,
                url,
                config: {
                  shaderType
                },
                xhrSettings
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function () {
              this.state = CONST.FILE_PROCESSING;
              this.data = this.xhrLoader.responseText;
              this.onProcessComplete();
            },
            addToCache: function () {
              var data = this.data.split("\n");
              var block = this.extractBlock(data, 0);
              if (block) {
                while (block) {
                  var key = this.getShaderName(block.header);
                  var shaderType = this.getShaderType(block.header);
                  var uniforms = this.getShaderUniforms(block.header);
                  var shaderSrc = block.shader;
                  if (this.cache.has(key)) {
                    var shader = this.cache.get(key);
                    if (shaderType === "fragment") {
                      shader.fragmentSrc = shaderSrc;
                    } else {
                      shader.vertexSrc = shaderSrc;
                    }
                    if (!shader.uniforms) {
                      shader.uniforms = uniforms;
                    }
                  } else if (shaderType === "fragment") {
                    this.cache.add(key, new Shader(key, shaderSrc, "", uniforms));
                  } else {
                    this.cache.add(key, new Shader(key, "", shaderSrc, uniforms));
                  }
                  block = this.extractBlock(data, block.offset);
                }
              } else if (this.config.shaderType === "fragment") {
                this.cache.add(this.key, new Shader(this.key, this.data));
              } else {
                this.cache.add(this.key, new Shader(this.key, "", this.data));
              }
              this.pendingDestroy();
            },
            getShaderName: function (headerSource) {
              for (var i = 0; i < headerSource.length; i++) {
                var line = headerSource[i].trim();
                if (line.substring(0, 5) === "name:") {
                  return line.substring(5).trim();
                }
              }
              return this.key;
            },
            getShaderType: function (headerSource) {
              for (var i = 0; i < headerSource.length; i++) {
                var line = headerSource[i].trim();
                if (line.substring(0, 5) === "type:") {
                  return line.substring(5).trim();
                }
              }
              return this.config.shaderType;
            },
            getShaderUniforms: function (headerSource) {
              var uniforms = {};
              for (var i = 0; i < headerSource.length; i++) {
                var line = headerSource[i].trim();
                if (line.substring(0, 8) === "uniform.") {
                  var pos = line.indexOf(":");
                  if (pos) {
                    var key = line.substring(8, pos);
                    try {
                      uniforms[key] = JSON.parse(line.substring(pos + 1));
                    } catch (e) {
                      console.warn("Invalid uniform JSON: " + key);
                    }
                  }
                }
              }
              return uniforms;
            },
            extractBlock: function (data, offset) {
              var headerStart = -1;
              var headerEnd = -1;
              var blockEnd = -1;
              var headerOpen = false;
              var captureSource = false;
              var headerSource = [];
              var shaderSource = [];
              for (var i = offset; i < data.length; i++) {
                var line = data[i].trim();
                if (line === "---") {
                  if (headerStart === -1) {
                    headerStart = i;
                    headerOpen = true;
                  } else if (headerOpen) {
                    headerEnd = i;
                    headerOpen = false;
                    captureSource = true;
                  } else {
                    captureSource = false;
                    break;
                  }
                } else if (headerOpen) {
                  headerSource.push(line);
                } else if (captureSource) {
                  shaderSource.push(line);
                  blockEnd = i;
                }
              }
              if (!headerOpen && headerEnd !== -1) {
                return {
                  header: headerSource,
                  shader: shaderSource.join("\n"),
                  offset: blockEnd
                };
              } else {
                return null;
              }
            }
          });
          FileTypesManager.register("glsl", function (key, url, shaderType, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new GLSLFile(this, key[i]));
              }
            } else {
              this.addFile(new GLSLFile(this, key, url, shaderType, xhrSettings));
            }
            return this;
          });
          module2.exports = GLSLFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var HTMLFile = new Class({
            Extends: File,
            initialize: function HTMLFile2(loader, key, url, xhrSettings) {
              var extension = "html";
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                url = GetFastValue(config, "url");
                xhrSettings = GetFastValue(config, "xhrSettings");
                extension = GetFastValue(config, "extension", extension);
              }
              var fileConfig = {
                type: "text",
                cache: loader.cacheManager.html,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function () {
              this.state = CONST.FILE_PROCESSING;
              this.data = this.xhrLoader.responseText;
              this.onProcessComplete();
            }
          });
          FileTypesManager.register("html", function (key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new HTMLFile(this, key[i]));
              }
            } else {
              this.addFile(new HTMLFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = HTMLFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var HTMLTextureFile = new Class({
            Extends: File,
            initialize: function HTMLTextureFile2(loader, key, url, width, height, xhrSettings) {
              if (width === void 0) {
                width = 512;
              }
              if (height === void 0) {
                height = 512;
              }
              var extension = "html";
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                url = GetFastValue(config, "url");
                xhrSettings = GetFastValue(config, "xhrSettings");
                extension = GetFastValue(config, "extension", extension);
                width = GetFastValue(config, "width", width);
                height = GetFastValue(config, "height", height);
              }
              var fileConfig = {
                type: "html",
                cache: loader.textureManager,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings,
                config: {
                  width,
                  height
                }
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function () {
              this.state = CONST.FILE_PROCESSING;
              var w = this.config.width;
              var h = this.config.height;
              var data = [];
              data.push('<svg width="' + w + 'px" height="' + h + 'px" viewBox="0 0 ' + w + " " + h + '" xmlns="http://www.w3.org/2000/svg">');
              data.push('<foreignObject width="100%" height="100%">');
              data.push('<body xmlns="http://www.w3.org/1999/xhtml">');
              data.push(this.xhrLoader.responseText);
              data.push("</body>");
              data.push("</foreignObject>");
              data.push("</svg>");
              var svg = [data.join("\n")];
              var _this = this;
              try {
                var blob = new window.Blob(svg, {
                  type: "image/svg+xml;charset=utf-8"
                });
              } catch (e) {
                _this.state = CONST.FILE_ERRORED;
                _this.onProcessComplete();
                return;
              }
              this.data = new Image();
              this.data.crossOrigin = this.crossOrigin;
              this.data.onload = function () {
                File.revokeObjectURL(_this.data);
                _this.onProcessComplete();
              };
              this.data.onerror = function () {
                File.revokeObjectURL(_this.data);
                _this.onProcessError();
              };
              File.createObjectURL(this.data, blob, "image/svg+xml");
            },
            addToCache: function () {
              var texture = this.cache.addImage(this.key, this.data);
              this.pendingDestroy(texture);
            }
          });
          FileTypesManager.register("htmlTexture", function (key, url, width, height, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new HTMLTextureFile(this, key[i]));
              }
            } else {
              this.addFile(new HTMLTextureFile(this, key, url, width, height, xhrSettings));
            }
            return this;
          });
          module2.exports = HTMLTextureFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var ImageFile = __webpack_require__(71);
          var IsPlainObject = __webpack_require__(7);
          var JSONFile = __webpack_require__(61);
          var MultiFile = __webpack_require__(49);
          var MultiAtlasFile = new Class({
            Extends: MultiFile,
            initialize: function MultiAtlasFile2(loader, key, atlasURL, path, baseURL, atlasXhrSettings, textureXhrSettings) {
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                if (GetFastValue(config, "url", false)) {
                  atlasURL = GetFastValue(config, "url");
                } else {
                  atlasURL = GetFastValue(config, "atlasURL");
                }
                atlasXhrSettings = GetFastValue(config, "xhrSettings");
                path = GetFastValue(config, "path");
                baseURL = GetFastValue(config, "baseURL");
                textureXhrSettings = GetFastValue(config, "textureXhrSettings");
              }
              var data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);
              MultiFile.call(this, loader, "multiatlas", key, [data]);
              this.config.path = path;
              this.config.baseURL = baseURL;
              this.config.textureXhrSettings = textureXhrSettings;
            },
            onFileComplete: function (file) {
              var index = this.files.indexOf(file);
              if (index !== -1) {
                this.pending--;
                if (file.type === "json" && file.data.hasOwnProperty("textures")) {
                  var textures = file.data.textures;
                  var config = this.config;
                  var loader = this.loader;
                  var currentBaseURL = loader.baseURL;
                  var currentPath = loader.path;
                  var currentPrefix = loader.prefix;
                  var baseURL = GetFastValue(config, "baseURL", this.baseURL);
                  var path = GetFastValue(config, "path", this.path);
                  var prefix = GetFastValue(config, "prefix", this.prefix);
                  var textureXhrSettings = GetFastValue(config, "textureXhrSettings");
                  loader.setBaseURL(baseURL);
                  loader.setPath(path);
                  loader.setPrefix(prefix);
                  for (var i = 0; i < textures.length; i++) {
                    var textureURL = textures[i].image;
                    var key = "MA" + this.multiKeyIndex + "_" + textureURL;
                    var image = new ImageFile(loader, key, textureURL, textureXhrSettings);
                    this.addToMultiFile(image);
                    loader.addFile(image);
                    if (textures[i].normalMap) {
                      var normalMap = new ImageFile(loader, key, textures[i].normalMap, textureXhrSettings);
                      normalMap.type = "normalMap";
                      image.setLink(normalMap);
                      this.addToMultiFile(normalMap);
                      loader.addFile(normalMap);
                    }
                  }
                  loader.setBaseURL(currentBaseURL);
                  loader.setPath(currentPath);
                  loader.setPrefix(currentPrefix);
                }
              }
            },
            addToCache: function () {
              if (this.isReadyToProcess()) {
                var fileJSON = this.files[0];
                var data = [];
                var images = [];
                var normalMaps = [];
                for (var i = 1; i < this.files.length; i++) {
                  var file = this.files[i];
                  if (file.type === "normalMap") {
                    continue;
                  }
                  var pos = file.key.indexOf("_");
                  var key = file.key.substr(pos + 1);
                  var image = file.data;
                  for (var t = 0; t < fileJSON.data.textures.length; t++) {
                    var item = fileJSON.data.textures[t];
                    if (item.image === key) {
                      images.push(image);
                      data.push(item);
                      if (file.linkFile) {
                        normalMaps.push(file.linkFile.data);
                      }
                      break;
                    }
                  }
                }
                if (normalMaps.length === 0) {
                  normalMaps = void 0;
                }
                this.loader.textureManager.addAtlasJSONArray(this.key, images, data, normalMaps);
                this.complete = true;
                for (i = 0; i < this.files.length; i++) {
                  this.files[i].pendingDestroy();
                }
              }
            }
          });
          FileTypesManager.register("multiatlas", function (key, atlasURL, path, baseURL, atlasXhrSettings) {
            var multifile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                multifile = new MultiAtlasFile(this, key[i]);
                this.addFile(multifile.files);
              }
            } else {
              multifile = new MultiAtlasFile(this, key, atlasURL, path, baseURL, atlasXhrSettings);
              this.addFile(multifile.files);
            }
            return this;
          });
          module2.exports = MultiAtlasFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var MultiFile = __webpack_require__(49);
          var ScriptFile = __webpack_require__(520);
          var MultiScriptFile = new Class({
            Extends: MultiFile,
            initialize: function MultiScriptFile2(loader, key, url, xhrSettings) {
              var extension = "js";
              var files = [];
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                url = GetFastValue(config, "url");
                xhrSettings = GetFastValue(config, "xhrSettings");
                extension = GetFastValue(config, "extension", extension);
              }
              if (!Array.isArray(url)) {
                url = [url];
              }
              for (var i = 0; i < url.length; i++) {
                var scriptFile = new ScriptFile(loader, {
                  key: key + "_" + i.toString(),
                  url: url[i],
                  extension,
                  xhrSettings
                });
                scriptFile.onProcess = function () {
                  this.onProcessComplete();
                };
                files.push(scriptFile);
              }
              MultiFile.call(this, loader, "scripts", key, files);
            },
            addToCache: function () {
              if (this.isReadyToProcess()) {
                for (var i = 0; i < this.files.length; i++) {
                  var file = this.files[i];
                  file.data = document.createElement("script");
                  file.data.language = "javascript";
                  file.data.type = "text/javascript";
                  file.data.defer = false;
                  file.data.text = file.xhrLoader.responseText;
                  document.head.appendChild(file.data);
                }
                this.complete = true;
              }
            }
          });
          FileTypesManager.register("scripts", function (key, url, xhrSettings) {
            var multifile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                multifile = new MultiScriptFile(this, key[i]);
                this.addFile(multifile.files);
              }
            } else {
              multifile = new MultiScriptFile(this, key, url, xhrSettings);
              this.addFile(multifile.files);
            }
            return this;
          });
          module2.exports = MultiScriptFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var MultiFile = __webpack_require__(49);
          var ParseObj = __webpack_require__(498);
          var ParseObjMaterial = __webpack_require__(499);
          var TextFile = __webpack_require__(242);
          var OBJFile = new Class({
            Extends: MultiFile,
            initialize: function OBJFile2(loader, key, objURL, matURL, flipUV, xhrSettings) {
              var obj;
              var mat;
              var cache = loader.cacheManager.obj;
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                obj = new TextFile(loader, {
                  key,
                  type: "obj",
                  cache,
                  url: GetFastValue(config, "url"),
                  extension: GetFastValue(config, "extension", "obj"),
                  xhrSettings: GetFastValue(config, "xhrSettings"),
                  config: {
                    flipUV: GetFastValue(config, "flipUV", flipUV)
                  }
                });
                matURL = GetFastValue(config, "matURL");
                if (matURL) {
                  mat = new TextFile(loader, {
                    key,
                    type: "mat",
                    cache,
                    url: matURL,
                    extension: GetFastValue(config, "matExtension", "mat"),
                    xhrSettings: GetFastValue(config, "xhrSettings")
                  });
                }
              } else {
                obj = new TextFile(loader, {
                  key,
                  url: objURL,
                  type: "obj",
                  cache,
                  extension: "obj",
                  xhrSettings,
                  config: {
                    flipUV
                  }
                });
                if (matURL) {
                  mat = new TextFile(loader, {
                    key,
                    url: matURL,
                    type: "mat",
                    cache,
                    extension: "mat",
                    xhrSettings
                  });
                }
              }
              MultiFile.call(this, loader, "obj", key, [obj, mat]);
            },
            addToCache: function () {
              if (this.isReadyToProcess()) {
                var obj = this.files[0];
                var mat = this.files[1];
                var objData = ParseObj(obj.data, obj.config.flipUV);
                if (mat) {
                  objData.materials = ParseObjMaterial(mat.data);
                }
                obj.cache.add(obj.key, objData);
                this.complete = true;
              }
            }
          });
          FileTypesManager.register("obj", function (key, objURL, matURL, flipUVs, xhrSettings) {
            var multifile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                multifile = new OBJFile(this, key[i]);
                this.addFile(multifile.files);
              }
            } else {
              multifile = new OBJFile(this, key, objURL, matURL, flipUVs, xhrSettings);
              this.addFile(multifile.files);
            }
            return this;
          });
          module2.exports = OBJFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var FileTypesManager = __webpack_require__(8);
          var JSONFile = __webpack_require__(61);
          var PackFile = new Class({
            Extends: JSONFile,
            initialize: function PackFile2(loader, key, url, xhrSettings, dataKey) {
              JSONFile.call(this, loader, key, url, xhrSettings, dataKey);
              this.type = "packfile";
            },
            onProcess: function () {
              if (this.state !== CONST.FILE_POPULATED) {
                this.state = CONST.FILE_PROCESSING;
                this.data = JSON.parse(this.xhrLoader.responseText);
              }
              this.loader.addPack(this.data, this.config);
              this.onProcessComplete();
            }
          });
          FileTypesManager.register("pack", function (key, url, packKey, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new PackFile(this, key[i]));
              }
            } else {
              this.addFile(new PackFile(this, key, url, xhrSettings, packKey));
            }
            return this;
          });
          module2.exports = PackFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var PluginFile = new Class({
            Extends: File,
            initialize: function PluginFile2(loader, key, url, start, mapping, xhrSettings) {
              var extension = "js";
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                url = GetFastValue(config, "url");
                xhrSettings = GetFastValue(config, "xhrSettings");
                extension = GetFastValue(config, "extension", extension);
                start = GetFastValue(config, "start");
                mapping = GetFastValue(config, "mapping");
              }
              var fileConfig = {
                type: "plugin",
                cache: false,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings,
                config: {
                  start,
                  mapping
                }
              };
              File.call(this, loader, fileConfig);
              if (typeof url === "function") {
                this.data = url;
                this.state = CONST.FILE_POPULATED;
              }
            },
            onProcess: function () {
              var pluginManager = this.loader.systems.plugins;
              var config = this.config;
              var start = GetFastValue(config, "start", false);
              var mapping = GetFastValue(config, "mapping", null);
              if (this.state === CONST.FILE_POPULATED) {
                pluginManager.install(this.key, this.data, start, mapping);
              } else {
                this.state = CONST.FILE_PROCESSING;
                this.data = document.createElement("script");
                this.data.language = "javascript";
                this.data.type = "text/javascript";
                this.data.defer = false;
                this.data.text = this.xhrLoader.responseText;
                document.head.appendChild(this.data);
                var plugin = pluginManager.install(this.key, window[this.key], start, mapping);
                if (start || mapping) {
                  this.loader.systems[mapping] = plugin;
                  this.loader.scene[mapping] = plugin;
                }
              }
              this.onProcessComplete();
            }
          });
          FileTypesManager.register("plugin", function (key, url, start, mapping, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new PluginFile(this, key[i]));
              }
            } else {
              this.addFile(new PluginFile(this, key, url, start, mapping, xhrSettings));
            }
            return this;
          });
          module2.exports = PluginFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var SceneFile = new Class({
            Extends: File,
            initialize: function SceneFile2(loader, key, url, xhrSettings) {
              var extension = "js";
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                url = GetFastValue(config, "url");
                xhrSettings = GetFastValue(config, "xhrSettings");
                extension = GetFastValue(config, "extension", extension);
              }
              var fileConfig = {
                type: "text",
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function () {
              this.state = CONST.FILE_PROCESSING;
              this.data = this.xhrLoader.responseText;
              this.onProcessComplete();
            },
            addToCache: function () {
              var code = this.data.concat("(function(){\nreturn new " + this.key + "();\n}).call(this);");
              var eval2 = eval;
              this.loader.sceneManager.add(this.key, eval2(code));
              this.complete = true;
            }
          });
          FileTypesManager.register("sceneFile", function (key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new SceneFile(this, key[i]));
              }
            } else {
              this.addFile(new SceneFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = SceneFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var ScenePluginFile = new Class({
            Extends: File,
            initialize: function ScenePluginFile2(loader, key, url, systemKey, sceneKey, xhrSettings) {
              var extension = "js";
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                url = GetFastValue(config, "url");
                xhrSettings = GetFastValue(config, "xhrSettings");
                extension = GetFastValue(config, "extension", extension);
                systemKey = GetFastValue(config, "systemKey");
                sceneKey = GetFastValue(config, "sceneKey");
              }
              var fileConfig = {
                type: "scenePlugin",
                cache: false,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings,
                config: {
                  systemKey,
                  sceneKey
                }
              };
              File.call(this, loader, fileConfig);
              if (typeof url === "function") {
                this.data = url;
                this.state = CONST.FILE_POPULATED;
              }
            },
            onProcess: function () {
              var pluginManager = this.loader.systems.plugins;
              var config = this.config;
              var key = this.key;
              var systemKey = GetFastValue(config, "systemKey", key);
              var sceneKey = GetFastValue(config, "sceneKey", key);
              if (this.state === CONST.FILE_POPULATED) {
                pluginManager.installScenePlugin(systemKey, this.data, sceneKey, this.loader.scene, true);
              } else {
                this.state = CONST.FILE_PROCESSING;
                this.data = document.createElement("script");
                this.data.language = "javascript";
                this.data.type = "text/javascript";
                this.data.defer = false;
                this.data.text = this.xhrLoader.responseText;
                document.head.appendChild(this.data);
                pluginManager.installScenePlugin(systemKey, window[this.key], sceneKey, this.loader.scene, true);
              }
              this.onProcessComplete();
            }
          });
          FileTypesManager.register("scenePlugin", function (key, url, systemKey, sceneKey, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new ScenePluginFile(this, key[i]));
              }
            } else {
              this.addFile(new ScenePluginFile(this, key, url, systemKey, sceneKey, xhrSettings));
            }
            return this;
          });
          module2.exports = ScenePluginFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var ImageFile = __webpack_require__(71);
          var SpriteSheetFile = new Class({
            Extends: ImageFile,
            initialize: function SpriteSheetFile2(loader, key, url, frameConfig, xhrSettings) {
              ImageFile.call(this, loader, key, url, xhrSettings, frameConfig);
              this.type = "spritesheet";
            },
            addToCache: function () {
              var texture = this.cache.addSpriteSheet(this.key, this.data, this.config);
              this.pendingDestroy(texture);
            }
          });
          FileTypesManager.register("spritesheet", function (key, url, frameConfig, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new SpriteSheetFile(this, key[i]));
              }
            } else {
              this.addFile(new SpriteSheetFile(this, key, url, frameConfig, xhrSettings));
            }
            return this;
          });
          module2.exports = SpriteSheetFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var SVGFile = new Class({
            Extends: File,
            initialize: function SVGFile2(loader, key, url, svgConfig, xhrSettings) {
              var extension = "svg";
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                url = GetFastValue(config, "url");
                svgConfig = GetFastValue(config, "svgConfig", {});
                xhrSettings = GetFastValue(config, "xhrSettings");
                extension = GetFastValue(config, "extension", extension);
              }
              var fileConfig = {
                type: "svg",
                cache: loader.textureManager,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings,
                config: {
                  width: GetFastValue(svgConfig, "width"),
                  height: GetFastValue(svgConfig, "height"),
                  scale: GetFastValue(svgConfig, "scale")
                }
              };
              File.call(this, loader, fileConfig);
            },
            onProcess: function () {
              this.state = CONST.FILE_PROCESSING;
              var text = this.xhrLoader.responseText;
              var svg = [text];
              var width = this.config.width;
              var height = this.config.height;
              var scale = this.config.scale;
              resize: if (width && height || scale) {
                var xml = null;
                var parser = new DOMParser();
                xml = parser.parseFromString(text, "text/xml");
                var svgXML = xml.getElementsByTagName("svg")[0];
                var hasViewBox = svgXML.hasAttribute("viewBox");
                var svgWidth = parseFloat(svgXML.getAttribute("width"));
                var svgHeight = parseFloat(svgXML.getAttribute("height"));
                if (!hasViewBox && svgWidth && svgHeight) {
                  svgXML.setAttribute("viewBox", "0  0 " + svgWidth + " " + svgHeight);
                } else if (hasViewBox && !svgWidth && !svgHeight) {
                  var viewBox = svgXML.getAttribute("viewBox").split(/\s+|,/);
                  svgWidth = viewBox[2];
                  svgHeight = viewBox[3];
                }
                if (scale) {
                  if (svgWidth && svgHeight) {
                    width = svgWidth * scale;
                    height = svgHeight * scale;
                  } else {
                    break resize;
                  }
                }
                svgXML.setAttribute("width", width.toString() + "px");
                svgXML.setAttribute("height", height.toString() + "px");
                svg = [new XMLSerializer().serializeToString(svgXML)];
              }
              try {
                var blob = new window.Blob(svg, {
                  type: "image/svg+xml;charset=utf-8"
                });
              } catch (e) {
                this.onProcessError();
                return;
              }
              this.data = new Image();
              this.data.crossOrigin = this.crossOrigin;
              var _this = this;
              var retry = false;
              this.data.onload = function () {
                if (!retry) {
                  File.revokeObjectURL(_this.data);
                }
                _this.onProcessComplete();
              };
              this.data.onerror = function () {
                if (!retry) {
                  retry = true;
                  File.revokeObjectURL(_this.data);
                  _this.data.src = "data:image/svg+xml," + encodeURIComponent(svg.join(""));
                } else {
                  _this.onProcessError();
                }
              };
              File.createObjectURL(this.data, blob, "image/svg+xml");
            },
            addToCache: function () {
              var texture = this.cache.addImage(this.key, this.data);
              this.pendingDestroy(texture);
            }
          });
          FileTypesManager.register("svg", function (key, url, svgConfig, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new SVGFile(this, key[i]));
              }
            } else {
              this.addFile(new SVGFile(this, key, url, svgConfig, xhrSettings));
            }
            return this;
          });
          module2.exports = SVGFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var TILEMAP_FORMATS = __webpack_require__(40);
          var TilemapCSVFile = new Class({
            Extends: File,
            initialize: function TilemapCSVFile2(loader, key, url, xhrSettings) {
              var extension = "csv";
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                url = GetFastValue(config, "url");
                xhrSettings = GetFastValue(config, "xhrSettings");
                extension = GetFastValue(config, "extension", extension);
              }
              var fileConfig = {
                type: "tilemapCSV",
                cache: loader.cacheManager.tilemap,
                extension,
                responseType: "text",
                key,
                url,
                xhrSettings
              };
              File.call(this, loader, fileConfig);
              this.tilemapFormat = TILEMAP_FORMATS.CSV;
            },
            onProcess: function () {
              this.state = CONST.FILE_PROCESSING;
              this.data = this.xhrLoader.responseText;
              this.onProcessComplete();
            },
            addToCache: function () {
              var tiledata = {
                format: this.tilemapFormat,
                data: this.data
              };
              this.cache.add(this.key, tiledata);
              this.pendingDestroy(tiledata);
            }
          });
          FileTypesManager.register("tilemapCSV", function (key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new TilemapCSVFile(this, key[i]));
              }
            } else {
              this.addFile(new TilemapCSVFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = TilemapCSVFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var JSONFile = __webpack_require__(61);
          var TILEMAP_FORMATS = __webpack_require__(40);
          var TilemapImpactFile = new Class({
            Extends: JSONFile,
            initialize: function TilemapImpactFile2(loader, key, url, xhrSettings) {
              JSONFile.call(this, loader, key, url, xhrSettings);
              this.type = "tilemapJSON";
              this.cache = loader.cacheManager.tilemap;
            },
            addToCache: function () {
              var tiledata = {
                format: TILEMAP_FORMATS.WELTMEISTER,
                data: this.data
              };
              this.cache.add(this.key, tiledata);
              this.pendingDestroy(tiledata);
            }
          });
          FileTypesManager.register("tilemapImpact", function (key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new TilemapImpactFile(this, key[i]));
              }
            } else {
              this.addFile(new TilemapImpactFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = TilemapImpactFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var JSONFile = __webpack_require__(61);
          var TILEMAP_FORMATS = __webpack_require__(40);
          var TilemapJSONFile = new Class({
            Extends: JSONFile,
            initialize: function TilemapJSONFile2(loader, key, url, xhrSettings) {
              JSONFile.call(this, loader, key, url, xhrSettings);
              this.type = "tilemapJSON";
              this.cache = loader.cacheManager.tilemap;
            },
            addToCache: function () {
              var tiledata = {
                format: TILEMAP_FORMATS.TILED_JSON,
                data: this.data
              };
              this.cache.add(this.key, tiledata);
              this.pendingDestroy(tiledata);
            }
          });
          FileTypesManager.register("tilemapTiledJSON", function (key, url, xhrSettings) {
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                this.addFile(new TilemapJSONFile(this, key[i]));
              }
            } else {
              this.addFile(new TilemapJSONFile(this, key, url, xhrSettings));
            }
            return this;
          });
          module2.exports = TilemapJSONFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var ImageFile = __webpack_require__(71);
          var IsPlainObject = __webpack_require__(7);
          var MultiFile = __webpack_require__(49);
          var TextFile = __webpack_require__(242);
          var UnityAtlasFile = new Class({
            Extends: MultiFile,
            initialize: function UnityAtlasFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
              var image;
              var data;
              if (IsPlainObject(key)) {
                var config = key;
                key = GetFastValue(config, "key");
                image = new ImageFile(loader, {
                  key,
                  url: GetFastValue(config, "textureURL"),
                  extension: GetFastValue(config, "textureExtension", "png"),
                  normalMap: GetFastValue(config, "normalMap"),
                  xhrSettings: GetFastValue(config, "textureXhrSettings")
                });
                data = new TextFile(loader, {
                  key,
                  url: GetFastValue(config, "atlasURL"),
                  extension: GetFastValue(config, "atlasExtension", "txt"),
                  xhrSettings: GetFastValue(config, "atlasXhrSettings")
                });
              } else {
                image = new ImageFile(loader, key, textureURL, textureXhrSettings);
                data = new TextFile(loader, key, atlasURL, atlasXhrSettings);
              }
              if (image.linkFile) {
                MultiFile.call(this, loader, "unityatlas", key, [image, data, image.linkFile]);
              } else {
                MultiFile.call(this, loader, "unityatlas", key, [image, data]);
              }
            },
            addToCache: function () {
              if (this.isReadyToProcess()) {
                var image = this.files[0];
                var text = this.files[1];
                var normalMap = this.files[2] ? this.files[2].data : null;
                this.loader.textureManager.addUnityAtlas(image.key, image.data, text.data, normalMap);
                text.pendingDestroy();
                this.complete = true;
              }
            }
          });
          FileTypesManager.register("unityAtlas", function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
            var multifile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                multifile = new UnityAtlasFile(this, key[i]);
                this.addFile(multifile.files);
              }
            } else {
              multifile = new UnityAtlasFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
              this.addFile(multifile.files);
            }
            return this;
          });
          module2.exports = UnityAtlasFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var File = __webpack_require__(23);
          var FileTypesManager = __webpack_require__(8);
          var GetURL = __webpack_require__(155);
          var GetFastValue = __webpack_require__(2);
          var IsPlainObject = __webpack_require__(7);
          var VideoFile = new Class({
            Extends: File,
            initialize: function VideoFile2(loader, key, urlConfig, loadEvent, asBlob, noAudio, xhrSettings) {
              if (loadEvent === void 0) {
                loadEvent = "loadeddata";
              }
              if (asBlob === void 0) {
                asBlob = false;
              }
              if (noAudio === void 0) {
                noAudio = false;
              }
              if (loadEvent !== "loadeddata" && loadEvent !== "canplay" && loadEvent !== "canplaythrough") {
                loadEvent = "loadeddata";
              }
              var fileConfig = {
                type: "video",
                cache: loader.cacheManager.video,
                extension: urlConfig.type,
                responseType: "blob",
                key,
                url: urlConfig.url,
                xhrSettings,
                config: {
                  loadEvent,
                  asBlob,
                  noAudio
                }
              };
              this.onLoadCallback = this.onVideoLoadHandler.bind(this);
              this.onErrorCallback = this.onVideoErrorHandler.bind(this);
              File.call(this, loader, fileConfig);
            },
            onProcess: function () {
              this.state = CONST.FILE_PROCESSING;
              if (!this.config.asBlob) {
                this.onProcessComplete();
                return;
              }
              var video = this.createVideoElement();
              this.data = video;
              var _this = this;
              this.data.onloadeddata = function () {
                _this.onProcessComplete();
              };
              this.data.onerror = function () {
                File.revokeObjectURL(_this.data);
                _this.onProcessError();
              };
              File.createObjectURL(video, this.xhrLoader.response, "");
              video.load();
            },
            createVideoElement: function () {
              var video = document.createElement("video");
              video.controls = false;
              video.crossOrigin = this.loader.crossOrigin;
              if (this.config.noAudio) {
                video.muted = true;
                video.defaultMuted = true;
                video.setAttribute("autoplay", "autoplay");
              }
              video.setAttribute("playsinline", "playsinline");
              video.setAttribute("preload", "auto");
              return video;
            },
            onVideoLoadHandler: function (event) {
              var video = event.target;
              video.removeEventListener(this.config.loadEvent, this.onLoadCallback, true);
              video.removeEventListener("error", this.onErrorCallback, true);
              this.data = video;
              this.resetXHR();
              this.loader.nextFile(this, true);
            },
            onVideoErrorHandler: function (event) {
              var video = event.target;
              if (video) {
                video.removeEventListener(this.config.loadEvent, this.onLoadCallback, true);
                video.removeEventListener("error", this.onErrorCallback, true);
              }
              this.resetXHR();
              this.loader.nextFile(this, false);
            },
            load: function () {
              var loadEvent = this.config.loadEvent;
              if (this.config.asBlob) {
                File.prototype.load.call(this);
              } else {
                this.percentComplete = 0;
                var video = this.createVideoElement();
                video.addEventListener(loadEvent, this.onLoadCallback, true);
                video.addEventListener("error", this.onErrorCallback, true);
                video.src = GetURL(this, this.loader.baseURL);
                video.load();
              }
            }
          });
          VideoFile.create = function (loader, key, urls, loadEvent, asBlob, noAudio, xhrSettings) {
            var game = loader.systems.game;
            if (IsPlainObject(key)) {
              urls = GetFastValue(key, "url", []);
              loadEvent = GetFastValue(key, "loadEvent", "loadeddata");
              asBlob = GetFastValue(key, "asBlob", false);
              noAudio = GetFastValue(key, "noAudio", false);
              xhrSettings = GetFastValue(key, "xhrSettings");
              key = GetFastValue(key, "key");
            }
            var urlConfig = VideoFile.getVideoURL(game, urls);
            if (urlConfig) {
              return new VideoFile(loader, key, urlConfig, loadEvent, asBlob, noAudio, xhrSettings);
            }
          };
          VideoFile.getVideoURL = function (game, urls) {
            if (!Array.isArray(urls)) {
              urls = [urls];
            }
            for (var i = 0; i < urls.length; i++) {
              var url = GetFastValue(urls[i], "url", urls[i]);
              if (url.indexOf("blob:") === 0) {
                return {
                  url,
                  type: ""
                };
              }
              var videoType;
              if (url.indexOf("data:") === 0) {
                videoType = url.split(",")[0].match(/\/(.*?);/);
              } else {
                videoType = url.match(/\.([a-zA-Z0-9]+)($|\?)/);
              }
              videoType = GetFastValue(urls[i], "type", videoType ? videoType[1] : "").toLowerCase();
              if (game.device.video[videoType]) {
                return {
                  url,
                  type: videoType
                };
              }
            }
            return null;
          };
          FileTypesManager.register("video", function (key, urls, loadEvent, asBlob, noAudio, xhrSettings) {
            var videoFile;
            if (Array.isArray(key)) {
              for (var i = 0; i < key.length; i++) {
                videoFile = VideoFile.create(this, key[i]);
                if (videoFile) {
                  this.addFile(videoFile);
                }
              }
            } else {
              videoFile = VideoFile.create(this, key, urls, loadEvent, asBlob, noAudio, xhrSettings);
              if (videoFile) {
                this.addFile(videoFile);
              }
            }
            return this;
          });
          module2.exports = VideoFile;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var CONST = __webpack_require__(21);
          var CustomSet = __webpack_require__(149);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(95);
          var FileTypesManager = __webpack_require__(8);
          var GetFastValue = __webpack_require__(2);
          var PluginCache = __webpack_require__(24);
          var SceneEvents = __webpack_require__(20);
          var XHRSettings = __webpack_require__(156);
          var LoaderPlugin = new Class({
            Extends: EventEmitter,
            initialize: function LoaderPlugin2(scene) {
              EventEmitter.call(this);
              var gameConfig = scene.sys.game.config;
              var sceneConfig = scene.sys.settings.loader;
              this.scene = scene;
              this.systems = scene.sys;
              this.cacheManager = scene.sys.cache;
              this.textureManager = scene.sys.textures;
              this.sceneManager = scene.sys.game.scene;
              FileTypesManager.install(this);
              this.prefix = "";
              this.path = "";
              this.baseURL = "";
              this.setBaseURL(GetFastValue(sceneConfig, "baseURL", gameConfig.loaderBaseURL));
              this.setPath(GetFastValue(sceneConfig, "path", gameConfig.loaderPath));
              this.setPrefix(GetFastValue(sceneConfig, "prefix", gameConfig.loaderPrefix));
              this.maxParallelDownloads = GetFastValue(sceneConfig, "maxParallelDownloads", gameConfig.loaderMaxParallelDownloads);
              this.xhr = XHRSettings(GetFastValue(sceneConfig, "responseType", gameConfig.loaderResponseType), GetFastValue(sceneConfig, "async", gameConfig.loaderAsync), GetFastValue(sceneConfig, "user", gameConfig.loaderUser), GetFastValue(sceneConfig, "password", gameConfig.loaderPassword), GetFastValue(sceneConfig, "timeout", gameConfig.loaderTimeout), GetFastValue(sceneConfig, "withCredentials", gameConfig.loaderWithCredentials));
              this.crossOrigin = GetFastValue(sceneConfig, "crossOrigin", gameConfig.loaderCrossOrigin);
              this.totalToLoad = 0;
              this.progress = 0;
              this.list = new CustomSet();
              this.inflight = new CustomSet();
              this.queue = new CustomSet();
              this._deleteQueue = new CustomSet();
              this.totalFailed = 0;
              this.totalComplete = 0;
              this.state = CONST.LOADER_IDLE;
              this.multiKeyIndex = 0;
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              scene.sys.events.on(SceneEvents.START, this.pluginStart, this);
            },
            boot: function () {
              this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            pluginStart: function () {
              this.systems.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            setBaseURL: function (url) {
              if (url === void 0) {
                url = "";
              }
              if (url !== "" && url.substr(-1) !== "/") {
                url = url.concat("/");
              }
              this.baseURL = url;
              return this;
            },
            setPath: function (path) {
              if (path === void 0) {
                path = "";
              }
              if (path !== "" && path.substr(-1) !== "/") {
                path = path.concat("/");
              }
              this.path = path;
              return this;
            },
            setPrefix: function (prefix) {
              if (prefix === void 0) {
                prefix = "";
              }
              this.prefix = prefix;
              return this;
            },
            setCORS: function (crossOrigin) {
              this.crossOrigin = crossOrigin;
              return this;
            },
            addFile: function (file) {
              if (!Array.isArray(file)) {
                file = [file];
              }
              for (var i = 0; i < file.length; i++) {
                var item = file[i];
                if (!this.keyExists(item)) {
                  this.list.set(item);
                  this.emit(Events.ADD, item.key, item.type, this, item);
                  if (this.isLoading()) {
                    this.totalToLoad++;
                    this.updateProgress();
                  }
                }
              }
            },
            keyExists: function (file) {
              var keyConflict = file.hasCacheConflict();
              if (!keyConflict) {
                this.list.iterate(function (item) {
                  if (item.type === file.type && item.key === file.key) {
                    keyConflict = true;
                    return false;
                  }
                });
              }
              if (!keyConflict && this.isLoading()) {
                this.inflight.iterate(function (item) {
                  if (item.type === file.type && item.key === file.key) {
                    keyConflict = true;
                    return false;
                  }
                });
                this.queue.iterate(function (item) {
                  if (item.type === file.type && item.key === file.key) {
                    keyConflict = true;
                    return false;
                  }
                });
              }
              return keyConflict;
            },
            addPack: function (pack, packKey) {
              if (packKey && pack.hasOwnProperty(packKey)) {
                pack = {
                  packKey: pack[packKey]
                };
              }
              var total = 0;
              var currentBaseURL = this.baseURL;
              var currentPath = this.path;
              var currentPrefix = this.prefix;
              for (var key in pack) {
                if (!Object.prototype.hasOwnProperty.call(pack, key)) {
                  continue;
                }
                var config = pack[key];
                var baseURL = GetFastValue(config, "baseURL", currentBaseURL);
                var path = GetFastValue(config, "path", currentPath);
                var prefix = GetFastValue(config, "prefix", currentPrefix);
                var files = GetFastValue(config, "files", null);
                var defaultType = GetFastValue(config, "defaultType", "void");
                if (Array.isArray(files)) {
                  this.setBaseURL(baseURL);
                  this.setPath(path);
                  this.setPrefix(prefix);
                  for (var i = 0; i < files.length; i++) {
                    var file = files[i];
                    var type = file.hasOwnProperty("type") ? file.type : defaultType;
                    if (this[type]) {
                      this[type](file);
                      total++;
                    }
                  }
                }
              }
              this.setBaseURL(currentBaseURL);
              this.setPath(currentPath);
              this.setPrefix(currentPrefix);
              return total > 0;
            },
            isLoading: function () {
              return this.state === CONST.LOADER_LOADING || this.state === CONST.LOADER_PROCESSING;
            },
            isReady: function () {
              return this.state === CONST.LOADER_IDLE || this.state === CONST.LOADER_COMPLETE;
            },
            start: function () {
              if (!this.isReady()) {
                return;
              }
              this.progress = 0;
              this.totalFailed = 0;
              this.totalComplete = 0;
              this.totalToLoad = this.list.size;
              this.emit(Events.START, this);
              if (this.list.size === 0) {
                this.loadComplete();
              } else {
                this.state = CONST.LOADER_LOADING;
                this.inflight.clear();
                this.queue.clear();
                this.updateProgress();
                this.checkLoadQueue();
                this.systems.events.on(SceneEvents.UPDATE, this.update, this);
              }
            },
            updateProgress: function () {
              this.progress = 1 - (this.list.size + this.inflight.size) / this.totalToLoad;
              this.emit(Events.PROGRESS, this.progress);
            },
            update: function () {
              if (this.state === CONST.LOADER_LOADING && this.list.size > 0 && this.inflight.size < this.maxParallelDownloads) {
                this.checkLoadQueue();
              }
            },
            checkLoadQueue: function () {
              this.list.each(function (file) {
                if (file.state === CONST.FILE_POPULATED || file.state === CONST.FILE_PENDING && this.inflight.size < this.maxParallelDownloads) {
                  this.inflight.set(file);
                  this.list.delete(file);
                  if (!file.crossOrigin) {
                    file.crossOrigin = this.crossOrigin;
                  }
                  file.load();
                }
                if (this.inflight.size === this.maxParallelDownloads) {
                  return false;
                }
              }, this);
            },
            nextFile: function (file, success) {
              if (!this.inflight) {
                return;
              }
              this.inflight.delete(file);
              this.updateProgress();
              if (success) {
                this.totalComplete++;
                this.queue.set(file);
                this.emit(Events.FILE_LOAD, file);
                file.onProcess();
              } else {
                this.totalFailed++;
                this._deleteQueue.set(file);
                this.emit(Events.FILE_LOAD_ERROR, file);
                this.fileProcessComplete(file);
              }
            },
            fileProcessComplete: function (file) {
              if (!this.scene || !this.systems || !this.systems.game || this.systems.game.pendingDestroy) {
                return;
              }
              if (file.state === CONST.FILE_ERRORED) {
                if (file.multiFile) {
                  file.multiFile.onFileFailed(file);
                }
              } else if (file.state === CONST.FILE_COMPLETE) {
                if (file.multiFile) {
                  if (file.multiFile.isReadyToProcess()) {
                    file.multiFile.addToCache();
                  }
                } else {
                  file.addToCache();
                }
              }
              this.queue.delete(file);
              if (this.list.size === 0 && this.inflight.size === 0 && this.queue.size === 0) {
                this.loadComplete();
              }
            },
            loadComplete: function () {
              this.emit(Events.POST_PROCESS, this);
              this.list.clear();
              this.inflight.clear();
              this.queue.clear();
              this.progress = 1;
              this.state = CONST.LOADER_COMPLETE;
              this.systems.events.off(SceneEvents.UPDATE, this.update, this);
              this._deleteQueue.iterateLocal("destroy");
              this._deleteQueue.clear();
              this.emit(Events.COMPLETE, this, this.totalComplete, this.totalFailed);
            },
            flagForRemoval: function (file) {
              this._deleteQueue.set(file);
            },
            saveJSON: function (data, filename) {
              return this.save(JSON.stringify(data), filename);
            },
            save: function (data, filename, filetype) {
              if (filename === void 0) {
                filename = "file.json";
              }
              if (filetype === void 0) {
                filetype = "application/json";
              }
              var blob = new Blob([data], {
                type: filetype
              });
              var url = URL.createObjectURL(blob);
              var a = document.createElement("a");
              a.download = filename;
              a.textContent = "Download " + filename;
              a.href = url;
              a.click();
              return this;
            },
            reset: function () {
              this.list.clear();
              this.inflight.clear();
              this.queue.clear();
              var gameConfig = this.systems.game.config;
              var sceneConfig = this.systems.settings.loader;
              this.setBaseURL(GetFastValue(sceneConfig, "baseURL", gameConfig.loaderBaseURL));
              this.setPath(GetFastValue(sceneConfig, "path", gameConfig.loaderPath));
              this.setPrefix(GetFastValue(sceneConfig, "prefix", gameConfig.loaderPrefix));
              this.state = CONST.LOADER_IDLE;
            },
            shutdown: function () {
              this.reset();
              this.state = CONST.LOADER_SHUTDOWN;
              this.systems.events.off(SceneEvents.UPDATE, this.update, this);
              this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function () {
              this.shutdown();
              this.state = CONST.LOADER_DESTROYED;
              this.systems.events.off(SceneEvents.UPDATE, this.update, this);
              this.systems.events.off(SceneEvents.START, this.pluginStart, this);
              this.list = null;
              this.inflight = null;
              this.queue = null;
              this.scene = null;
              this.systems = null;
              this.textureManager = null;
              this.cacheManager = null;
              this.sceneManager = null;
            }
          });
          PluginCache.register("Loader", LoaderPlugin, "load");
          module2.exports = LoaderPlugin;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(62);
          var Extend = __webpack_require__(17);
          var Arcade = {
            ArcadePhysics: __webpack_require__(1367),
            Body: __webpack_require__(527),
            Collider: __webpack_require__(528),
            Components: __webpack_require__(243),
            Events: __webpack_require__(245),
            Factory: __webpack_require__(521),
            GetOverlapX: __webpack_require__(246),
            GetOverlapY: __webpack_require__(247),
            SeparateX: __webpack_require__(537),
            SeparateY: __webpack_require__(538),
            Group: __webpack_require__(524),
            Image: __webpack_require__(522),
            Sprite: __webpack_require__(157),
            StaticBody: __webpack_require__(539),
            StaticGroup: __webpack_require__(525),
            Tilemap: __webpack_require__(1391),
            World: __webpack_require__(526)
          };
          Arcade = Extend(false, Arcade, CONST);
          module2.exports = Arcade;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var DegToRad = __webpack_require__(36);
          var DistanceBetween = __webpack_require__(50);
          var DistanceSquared = __webpack_require__(353);
          var Factory = __webpack_require__(521);
          var GetFastValue = __webpack_require__(2);
          var Merge = __webpack_require__(127);
          var OverlapCirc = __webpack_require__(523);
          var OverlapRect = __webpack_require__(244);
          var PluginCache = __webpack_require__(24);
          var SceneEvents = __webpack_require__(20);
          var Vector2 = __webpack_require__(3);
          var World = __webpack_require__(526);
          var ArcadePhysics = new Class({
            initialize: function ArcadePhysics2(scene) {
              this.scene = scene;
              this.systems = scene.sys;
              this.config = this.getConfig();
              this.world;
              this.add;
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              scene.sys.events.on(SceneEvents.START, this.start, this);
            },
            boot: function () {
              this.world = new World(this.scene, this.config);
              this.add = new Factory(this.world);
              this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            start: function () {
              if (!this.world) {
                this.world = new World(this.scene, this.config);
                this.add = new Factory(this.world);
              }
              var eventEmitter = this.systems.events;
              if (!GetFastValue(this.config, "customUpdate", false)) {
                eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world);
              }
              eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
              eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            enableUpdate: function () {
              this.systems.events.on(SceneEvents.UPDATE, this.world.update, this.world);
            },
            disableUpdate: function () {
              this.systems.events.off(SceneEvents.UPDATE, this.world.update, this.world);
            },
            getConfig: function () {
              var gameConfig = this.systems.game.config.physics;
              var sceneConfig = this.systems.settings.physics;
              var config = Merge(GetFastValue(sceneConfig, "arcade", {}), GetFastValue(gameConfig, "arcade", {}));
              return config;
            },
            overlap: function (object1, object2, overlapCallback, processCallback, callbackContext) {
              if (overlapCallback === void 0) {
                overlapCallback = null;
              }
              if (processCallback === void 0) {
                processCallback = null;
              }
              if (callbackContext === void 0) {
                callbackContext = overlapCallback;
              }
              return this.world.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);
            },
            collide: function (object1, object2, collideCallback, processCallback, callbackContext) {
              if (collideCallback === void 0) {
                collideCallback = null;
              }
              if (processCallback === void 0) {
                processCallback = null;
              }
              if (callbackContext === void 0) {
                callbackContext = collideCallback;
              }
              return this.world.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);
            },
            collideTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext) {
              return this.world.collideTiles(sprite, tiles, collideCallback, processCallback, callbackContext);
            },
            overlapTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext) {
              return this.world.overlapTiles(sprite, tiles, collideCallback, processCallback, callbackContext);
            },
            pause: function () {
              return this.world.pause();
            },
            resume: function () {
              return this.world.resume();
            },
            accelerateTo: function (gameObject, x, y, speed, xSpeedMax, ySpeedMax) {
              if (speed === void 0) {
                speed = 60;
              }
              var angle = Math.atan2(y - gameObject.y, x - gameObject.x);
              gameObject.body.acceleration.setToPolar(angle, speed);
              if (xSpeedMax !== void 0 && ySpeedMax !== void 0) {
                gameObject.body.maxVelocity.set(xSpeedMax, ySpeedMax);
              }
              return angle;
            },
            accelerateToObject: function (gameObject, destination, speed, xSpeedMax, ySpeedMax) {
              return this.accelerateTo(gameObject, destination.x, destination.y, speed, xSpeedMax, ySpeedMax);
            },
            closest: function (source, targets) {
              if (!targets) {
                targets = this.world.bodies.entries;
              }
              var min = Number.MAX_VALUE;
              var closest = null;
              var x = source.x;
              var y = source.y;
              var len = targets.length;
              for (var i = 0; i < len; i++) {
                var target = targets[i];
                var body = target.body || target;
                if (source === target || source === body || source === body.gameObject || source === body.center) {
                  continue;
                }
                var distance = DistanceSquared(x, y, body.center.x, body.center.y);
                if (distance < min) {
                  closest = target;
                  min = distance;
                }
              }
              return closest;
            },
            furthest: function (source, targets) {
              if (!targets) {
                targets = this.world.bodies.entries;
              }
              var max = -1;
              var farthest = null;
              var x = source.x;
              var y = source.y;
              var len = targets.length;
              for (var i = 0; i < len; i++) {
                var target = targets[i];
                var body = target.body || target;
                if (source === target || source === body || source === body.gameObject || source === body.center) {
                  continue;
                }
                var distance = DistanceSquared(x, y, body.center.x, body.center.y);
                if (distance > max) {
                  farthest = target;
                  max = distance;
                }
              }
              return farthest;
            },
            moveTo: function (gameObject, x, y, speed, maxTime) {
              if (speed === void 0) {
                speed = 60;
              }
              if (maxTime === void 0) {
                maxTime = 0;
              }
              var angle = Math.atan2(y - gameObject.y, x - gameObject.x);
              if (maxTime > 0) {
                speed = DistanceBetween(gameObject.x, gameObject.y, x, y) / (maxTime / 1e3);
              }
              gameObject.body.velocity.setToPolar(angle, speed);
              return angle;
            },
            moveToObject: function (gameObject, destination, speed, maxTime) {
              return this.moveTo(gameObject, destination.x, destination.y, speed, maxTime);
            },
            velocityFromAngle: function (angle, speed, vec2) {
              if (speed === void 0) {
                speed = 60;
              }
              if (vec2 === void 0) {
                vec2 = new Vector2();
              }
              return vec2.setToPolar(DegToRad(angle), speed);
            },
            velocityFromRotation: function (rotation, speed, vec2) {
              if (speed === void 0) {
                speed = 60;
              }
              if (vec2 === void 0) {
                vec2 = new Vector2();
              }
              return vec2.setToPolar(rotation, speed);
            },
            overlapRect: function (x, y, width, height, includeDynamic, includeStatic) {
              return OverlapRect(this.world, x, y, width, height, includeDynamic, includeStatic);
            },
            overlapCirc: function (x, y, radius, includeDynamic, includeStatic) {
              return OverlapCirc(this.world, x, y, radius, includeDynamic, includeStatic);
            },
            shutdown: function () {
              if (!this.world) {
                return;
              }
              var eventEmitter = this.systems.events;
              eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world);
              eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
              eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
              this.add.destroy();
              this.world.destroy();
              this.add = null;
              this.world = null;
            },
            destroy: function () {
              this.shutdown();
              this.scene.sys.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
            }
          });
          PluginCache.register("ArcadePhysics", ArcadePhysics, "arcadePhysics");
          module2.exports = ArcadePhysics;
        }, function (module2, exports2) {
          var Acceleration = {
            setAcceleration: function (x, y) {
              this.body.acceleration.set(x, y);
              return this;
            },
            setAccelerationX: function (value) {
              this.body.acceleration.x = value;
              return this;
            },
            setAccelerationY: function (value) {
              this.body.acceleration.y = value;
              return this;
            }
          };
          module2.exports = Acceleration;
        }, function (module2, exports2) {
          var Angular = {
            setAngularVelocity: function (value) {
              this.body.angularVelocity = value;
              return this;
            },
            setAngularAcceleration: function (value) {
              this.body.angularAcceleration = value;
              return this;
            },
            setAngularDrag: function (value) {
              this.body.angularDrag = value;
              return this;
            }
          };
          module2.exports = Angular;
        }, function (module2, exports2) {
          var Bounce = {
            setBounce: function (x, y) {
              this.body.bounce.set(x, y);
              return this;
            },
            setBounceX: function (value) {
              this.body.bounce.x = value;
              return this;
            },
            setBounceY: function (value) {
              this.body.bounce.y = value;
              return this;
            },
            setCollideWorldBounds: function (value, bounceX, bounceY) {
              this.body.setCollideWorldBounds(value, bounceX, bounceY);
              return this;
            }
          };
          module2.exports = Bounce;
        }, function (module2, exports2) {
          var Debug = {
            setDebug: function (showBody, showVelocity, bodyColor) {
              this.debugShowBody = showBody;
              this.debugShowVelocity = showVelocity;
              this.debugBodyColor = bodyColor;
              return this;
            },
            setDebugBodyColor: function (value) {
              this.body.debugBodyColor = value;
              return this;
            },
            debugShowBody: {
              get: function () {
                return this.body.debugShowBody;
              },
              set: function (value) {
                this.body.debugShowBody = value;
              }
            },
            debugShowVelocity: {
              get: function () {
                return this.body.debugShowVelocity;
              },
              set: function (value) {
                this.body.debugShowVelocity = value;
              }
            },
            debugBodyColor: {
              get: function () {
                return this.body.debugBodyColor;
              },
              set: function (value) {
                this.body.debugBodyColor = value;
              }
            }
          };
          module2.exports = Debug;
        }, function (module2, exports2) {
          var Drag = {
            setDrag: function (x, y) {
              this.body.drag.set(x, y);
              return this;
            },
            setDragX: function (value) {
              this.body.drag.x = value;
              return this;
            },
            setDragY: function (value) {
              this.body.drag.y = value;
              return this;
            },
            setDamping: function (value) {
              this.body.useDamping = value;
              return this;
            }
          };
          module2.exports = Drag;
        }, function (module2, exports2) {
          var Enable = {
            enableBody: function (reset, x, y, enableGameObject, showGameObject) {
              if (reset) {
                this.body.reset(x, y);
              }
              if (enableGameObject) {
                this.body.gameObject.active = true;
              }
              if (showGameObject) {
                this.body.gameObject.visible = true;
              }
              this.body.enable = true;
              return this;
            },
            disableBody: function (disableGameObject, hideGameObject) {
              if (disableGameObject === void 0) {
                disableGameObject = false;
              }
              if (hideGameObject === void 0) {
                hideGameObject = false;
              }
              this.body.stop();
              this.body.enable = false;
              if (disableGameObject) {
                this.body.gameObject.active = false;
              }
              if (hideGameObject) {
                this.body.gameObject.visible = false;
              }
              return this;
            },
            refreshBody: function () {
              this.body.updateFromGameObject();
              return this;
            }
          };
          module2.exports = Enable;
        }, function (module2, exports2) {
          var Friction = {
            setFriction: function (x, y) {
              this.body.friction.set(x, y);
              return this;
            },
            setFrictionX: function (x) {
              this.body.friction.x = x;
              return this;
            },
            setFrictionY: function (y) {
              this.body.friction.y = y;
              return this;
            }
          };
          module2.exports = Friction;
        }, function (module2, exports2) {
          var Gravity = {
            setGravity: function (x, y) {
              this.body.gravity.set(x, y);
              return this;
            },
            setGravityX: function (x) {
              this.body.gravity.x = x;
              return this;
            },
            setGravityY: function (y) {
              this.body.gravity.y = y;
              return this;
            }
          };
          module2.exports = Gravity;
        }, function (module2, exports2) {
          var Immovable = {
            setImmovable: function (value) {
              if (value === void 0) {
                value = true;
              }
              this.body.immovable = value;
              return this;
            }
          };
          module2.exports = Immovable;
        }, function (module2, exports2) {
          var Mass = {
            setMass: function (value) {
              this.body.mass = value;
              return this;
            }
          };
          module2.exports = Mass;
        }, function (module2, exports2) {
          var Pushable = {
            setPushable: function (value) {
              if (value === void 0) {
                value = true;
              }
              this.body.pushable = value;
              return this;
            }
          };
          module2.exports = Pushable;
        }, function (module2, exports2) {
          var Size = {
            setOffset: function (x, y) {
              this.body.setOffset(x, y);
              return this;
            },
            setSize: function (width, height, center) {
              this.body.setSize(width, height, center);
              return this;
            },
            setBodySize: function (width, height, center) {
              this.body.setSize(width, height, center);
              return this;
            },
            setCircle: function (radius, offsetX, offsetY) {
              this.body.setCircle(radius, offsetX, offsetY);
              return this;
            }
          };
          module2.exports = Size;
        }, function (module2, exports2) {
          var Velocity = {
            setVelocity: function (x, y) {
              this.body.setVelocity(x, y);
              return this;
            },
            setVelocityX: function (x) {
              this.body.setVelocityX(x);
              return this;
            },
            setVelocityY: function (y) {
              this.body.setVelocityY(y);
              return this;
            },
            setMaxVelocity: function (x, y) {
              this.body.maxVelocity.set(x, y);
              return this;
            }
          };
          module2.exports = Velocity;
        }, function (module2, exports2) {
          module2.exports = "collide";
        }, function (module2, exports2) {
          module2.exports = "overlap";
        }, function (module2, exports2) {
          module2.exports = "pause";
        }, function (module2, exports2) {
          module2.exports = "resume";
        }, function (module2, exports2) {
          module2.exports = "tilecollide";
        }, function (module2, exports2) {
          module2.exports = "tileoverlap";
        }, function (module2, exports2) {
          module2.exports = "worldbounds";
        }, function (module2, exports2) {
          module2.exports = "worldstep";
        }, function (module2, exports2) {
          var body1;
          var body2;
          var body1Pushable;
          var body2Pushable;
          var body1MassImpact;
          var body2MassImpact;
          var body1FullImpact;
          var body2FullImpact;
          var body1MovingLeft;
          var body1MovingRight;
          var body1Stationary;
          var body2MovingLeft;
          var body2MovingRight;
          var body2Stationary;
          var body1OnLeft;
          var body2OnLeft;
          var overlap;
          var Set = function (b1, b2, ov) {
            body1 = b1;
            body2 = b2;
            var v1 = body1.velocity.x;
            var v2 = body2.velocity.x;
            body1Pushable = body1.pushable;
            body1MovingLeft = body1._dx < 0;
            body1MovingRight = body1._dx > 0;
            body1Stationary = body1._dx === 0;
            body1OnLeft = Math.abs(body1.right - body2.x) <= Math.abs(body2.right - body1.x);
            body1FullImpact = v2 - v1 * body1.bounce.x;
            body2Pushable = body2.pushable;
            body2MovingLeft = body2._dx < 0;
            body2MovingRight = body2._dx > 0;
            body2Stationary = body2._dx === 0;
            body2OnLeft = !body1OnLeft;
            body2FullImpact = v1 - v2 * body2.bounce.x;
            overlap = Math.abs(ov);
            return BlockCheck();
          };
          var BlockCheck = function () {
            if (body1MovingRight && body1OnLeft && body2.blocked.right) {
              body1.processX(-overlap, body1FullImpact, false, true);
              return 1;
            }
            if (body1MovingLeft && body2OnLeft && body2.blocked.left) {
              body1.processX(overlap, body1FullImpact, true);
              return 1;
            }
            if (body2MovingRight && body2OnLeft && body1.blocked.right) {
              body2.processX(-overlap, body2FullImpact, false, true);
              return 2;
            }
            if (body2MovingLeft && body1OnLeft && body1.blocked.left) {
              body2.processX(overlap, body2FullImpact, true);
              return 2;
            }
            return 0;
          };
          var Check = function () {
            var v1 = body1.velocity.x;
            var v2 = body2.velocity.x;
            var nv1 = Math.sqrt(v2 * v2 * body2.mass / body1.mass) * (v2 > 0 ? 1 : -1);
            var nv2 = Math.sqrt(v1 * v1 * body1.mass / body2.mass) * (v1 > 0 ? 1 : -1);
            var avg = (nv1 + nv2) * 0.5;
            nv1 -= avg;
            nv2 -= avg;
            body1MassImpact = avg + nv1 * body1.bounce.x;
            body2MassImpact = avg + nv2 * body2.bounce.x;
            if (body1MovingLeft && body2OnLeft) {
              return Run(0);
            }
            if (body2MovingLeft && body1OnLeft) {
              return Run(1);
            }
            if (body1MovingRight && body1OnLeft) {
              return Run(2);
            }
            if (body2MovingRight && body2OnLeft) {
              return Run(3);
            }
            return false;
          };
          var Run = function (side) {
            if (body1Pushable && body2Pushable) {
              overlap *= 0.5;
              if (side === 0 || side === 3) {
                body1.processX(overlap, body1MassImpact);
                body2.processX(-overlap, body2MassImpact);
              } else {
                body1.processX(-overlap, body1MassImpact);
                body2.processX(overlap, body2MassImpact);
              }
            } else if (body1Pushable && !body2Pushable) {
              if (side === 0 || side === 3) {
                body1.processX(overlap, body1FullImpact, true);
              } else {
                body1.processX(-overlap, body1FullImpact, false, true);
              }
            } else if (!body1Pushable && body2Pushable) {
              if (side === 0 || side === 3) {
                body2.processX(-overlap, body2FullImpact, false, true);
              } else {
                body2.processX(overlap, body2FullImpact, true);
              }
            } else {
              var halfOverlap = overlap * 0.5;
              if (side === 0) {
                if (body2Stationary) {
                  body1.processX(overlap, 0, true);
                  body2.processX(0, null, false, true);
                } else if (body2MovingRight) {
                  body1.processX(halfOverlap, 0, true);
                  body2.processX(-halfOverlap, 0, false, true);
                } else {
                  body1.processX(halfOverlap, body2.velocity.x, true);
                  body2.processX(-halfOverlap, null, false, true);
                }
              } else if (side === 1) {
                if (body1Stationary) {
                  body1.processX(0, null, false, true);
                  body2.processX(overlap, 0, true);
                } else if (body1MovingRight) {
                  body1.processX(-halfOverlap, 0, false, true);
                  body2.processX(halfOverlap, 0, true);
                } else {
                  body1.processX(-halfOverlap, null, false, true);
                  body2.processX(halfOverlap, body1.velocity.x, true);
                }
              } else if (side === 2) {
                if (body2Stationary) {
                  body1.processX(-overlap, 0, false, true);
                  body2.processX(0, null, true);
                } else if (body2MovingLeft) {
                  body1.processX(-halfOverlap, 0, false, true);
                  body2.processX(halfOverlap, 0, true);
                } else {
                  body1.processX(-halfOverlap, body2.velocity.x, false, true);
                  body2.processX(halfOverlap, null, true);
                }
              } else if (side === 3) {
                if (body1Stationary) {
                  body1.processX(0, null, true);
                  body2.processX(-overlap, 0, false, true);
                } else if (body1MovingLeft) {
                  body1.processX(halfOverlap, 0, true);
                  body2.processX(-halfOverlap, 0, false, true);
                } else {
                  body1.processX(halfOverlap, body2.velocity.y, true);
                  body2.processX(-halfOverlap, null, false, true);
                }
              }
            }
            return true;
          };
          var RunImmovableBody1 = function (blockedState) {
            if (blockedState === 1) {
              body2.velocity.x = 0;
            } else if (body1OnLeft) {
              body2.processX(overlap, body2FullImpact, true);
            } else {
              body2.processX(-overlap, body2FullImpact, false, true);
            }
            if (body1.moves) {
              body2.y += (body1.y - body1.prev.y) * body1.friction.y;
              body2._dy = body2.y - body2.prev.y;
            }
          };
          var RunImmovableBody2 = function (blockedState) {
            if (blockedState === 2) {
              body1.velocity.x = 0;
            } else if (body2OnLeft) {
              body1.processX(overlap, body1FullImpact, true);
            } else {
              body1.processX(-overlap, body1FullImpact, false, true);
            }
            if (body2.moves) {
              body1.y += (body2.y - body2.prev.y) * body2.friction.y;
              body1._dy = body1.y - body1.prev.y;
            }
          };
          module2.exports = {
            BlockCheck,
            Check,
            Set,
            Run,
            RunImmovableBody1,
            RunImmovableBody2
          };
        }, function (module2, exports2) {
          var body1;
          var body2;
          var body1Pushable;
          var body2Pushable;
          var body1MassImpact;
          var body2MassImpact;
          var body1FullImpact;
          var body2FullImpact;
          var body1MovingUp;
          var body1MovingDown;
          var body1Stationary;
          var body2MovingUp;
          var body2MovingDown;
          var body2Stationary;
          var body1OnTop;
          var body2OnTop;
          var overlap;
          var Set = function (b1, b2, ov) {
            body1 = b1;
            body2 = b2;
            var v1 = body1.velocity.y;
            var v2 = body2.velocity.y;
            body1Pushable = body1.pushable;
            body1MovingUp = body1._dy < 0;
            body1MovingDown = body1._dy > 0;
            body1Stationary = body1._dy === 0;
            body1OnTop = Math.abs(body1.bottom - body2.y) <= Math.abs(body2.bottom - body1.y);
            body1FullImpact = v2 - v1 * body1.bounce.y;
            body2Pushable = body2.pushable;
            body2MovingUp = body2._dy < 0;
            body2MovingDown = body2._dy > 0;
            body2Stationary = body2._dy === 0;
            body2OnTop = !body1OnTop;
            body2FullImpact = v1 - v2 * body2.bounce.y;
            overlap = Math.abs(ov);
            return BlockCheck();
          };
          var BlockCheck = function () {
            if (body1MovingDown && body1OnTop && body2.blocked.down) {
              body1.processY(-overlap, body1FullImpact, false, true);
              return 1;
            }
            if (body1MovingUp && body2OnTop && body2.blocked.up) {
              body1.processY(overlap, body1FullImpact, true);
              return 1;
            }
            if (body2MovingDown && body2OnTop && body1.blocked.down) {
              body2.processY(-overlap, body2FullImpact, false, true);
              return 2;
            }
            if (body2MovingUp && body1OnTop && body1.blocked.up) {
              body2.processY(overlap, body2FullImpact, true);
              return 2;
            }
            return 0;
          };
          var Check = function () {
            var v1 = body1.velocity.y;
            var v2 = body2.velocity.y;
            var nv1 = Math.sqrt(v2 * v2 * body2.mass / body1.mass) * (v2 > 0 ? 1 : -1);
            var nv2 = Math.sqrt(v1 * v1 * body1.mass / body2.mass) * (v1 > 0 ? 1 : -1);
            var avg = (nv1 + nv2) * 0.5;
            nv1 -= avg;
            nv2 -= avg;
            body1MassImpact = avg + nv1 * body1.bounce.y;
            body2MassImpact = avg + nv2 * body2.bounce.y;
            if (body1MovingUp && body2OnTop) {
              return Run(0);
            }
            if (body2MovingUp && body1OnTop) {
              return Run(1);
            }
            if (body1MovingDown && body1OnTop) {
              return Run(2);
            }
            if (body2MovingDown && body2OnTop) {
              return Run(3);
            }
            return false;
          };
          var Run = function (side) {
            if (body1Pushable && body2Pushable) {
              overlap *= 0.5;
              if (side === 0 || side === 3) {
                body1.processY(overlap, body1MassImpact);
                body2.processY(-overlap, body2MassImpact);
              } else {
                body1.processY(-overlap, body1MassImpact);
                body2.processY(overlap, body2MassImpact);
              }
            } else if (body1Pushable && !body2Pushable) {
              if (side === 0 || side === 3) {
                body1.processY(overlap, body1FullImpact, true);
              } else {
                body1.processY(-overlap, body1FullImpact, false, true);
              }
            } else if (!body1Pushable && body2Pushable) {
              if (side === 0 || side === 3) {
                body2.processY(-overlap, body2FullImpact, false, true);
              } else {
                body2.processY(overlap, body2FullImpact, true);
              }
            } else {
              var halfOverlap = overlap * 0.5;
              if (side === 0) {
                if (body2Stationary) {
                  body1.processY(overlap, 0, true);
                  body2.processY(0, null, false, true);
                } else if (body2MovingDown) {
                  body1.processY(halfOverlap, 0, true);
                  body2.processY(-halfOverlap, 0, false, true);
                } else {
                  body1.processY(halfOverlap, body2.velocity.y, true);
                  body2.processY(-halfOverlap, null, false, true);
                }
              } else if (side === 1) {
                if (body1Stationary) {
                  body1.processY(0, null, false, true);
                  body2.processY(overlap, 0, true);
                } else if (body1MovingDown) {
                  body1.processY(-halfOverlap, 0, false, true);
                  body2.processY(halfOverlap, 0, true);
                } else {
                  body1.processY(-halfOverlap, null, false, true);
                  body2.processY(halfOverlap, body1.velocity.y, true);
                }
              } else if (side === 2) {
                if (body2Stationary) {
                  body1.processY(-overlap, 0, false, true);
                  body2.processY(0, null, true);
                } else if (body2MovingUp) {
                  body1.processY(-halfOverlap, 0, false, true);
                  body2.processY(halfOverlap, 0, true);
                } else {
                  body1.processY(-halfOverlap, body2.velocity.y, false, true);
                  body2.processY(halfOverlap, null, true);
                }
              } else if (side === 3) {
                if (body1Stationary) {
                  body1.processY(0, null, true);
                  body2.processY(-overlap, 0, false, true);
                } else if (body1MovingUp) {
                  body1.processY(halfOverlap, 0, true);
                  body2.processY(-halfOverlap, 0, false, true);
                } else {
                  body1.processY(halfOverlap, body2.velocity.y, true);
                  body2.processY(-halfOverlap, null, false, true);
                }
              }
            }
            return true;
          };
          var RunImmovableBody1 = function (blockedState) {
            if (blockedState === 1) {
              body2.velocity.y = 0;
            } else if (body1OnTop) {
              body2.processY(overlap, body2FullImpact, true);
            } else {
              body2.processY(-overlap, body2FullImpact, false, true);
            }
            if (body1.moves) {
              body2.x += (body1.x - body1.prev.x) * body1.friction.x;
              body2._dx = body2.x - body2.prev.x;
            }
          };
          var RunImmovableBody2 = function (blockedState) {
            if (blockedState === 2) {
              body1.velocity.y = 0;
            } else if (body2OnTop) {
              body1.processY(overlap, body1FullImpact, true);
            } else {
              body1.processY(-overlap, body1FullImpact, false, true);
            }
            if (body2.moves) {
              body1.x += (body2.x - body2.prev.x) * body2.friction.x;
              body1._dx = body1.x - body1.prev.x;
            }
          };
          module2.exports = {
            BlockCheck,
            Check,
            Set,
            Run,
            RunImmovableBody1,
            RunImmovableBody2
          };
        }, function (module2, exports2, __webpack_require__) {
          var Tilemap = {
            ProcessTileCallbacks: __webpack_require__(530),
            ProcessTileSeparationX: __webpack_require__(534),
            ProcessTileSeparationY: __webpack_require__(536),
            SeparateTile: __webpack_require__(532),
            TileCheckX: __webpack_require__(533),
            TileCheckY: __webpack_require__(535),
            TileIntersectsBody: __webpack_require__(248)
          };
          module2.exports = Tilemap;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Vector2 = __webpack_require__(3);
          var BodyBounds = new Class({
            initialize: function BodyBounds2() {
              this.boundsCenter = new Vector2();
              this.centerDiff = new Vector2();
            },
            parseBody: function (body) {
              body = body.hasOwnProperty("body") ? body.body : body;
              if (!body.hasOwnProperty("bounds") || !body.hasOwnProperty("centerOfMass")) {
                return false;
              }
              var boundsCenter = this.boundsCenter;
              var centerDiff = this.centerDiff;
              var boundsWidth = body.bounds.max.x - body.bounds.min.x;
              var boundsHeight = body.bounds.max.y - body.bounds.min.y;
              var bodyCenterX = boundsWidth * body.centerOfMass.x;
              var bodyCenterY = boundsHeight * body.centerOfMass.y;
              boundsCenter.set(boundsWidth / 2, boundsHeight / 2);
              centerDiff.set(bodyCenterX - boundsCenter.x, bodyCenterY - boundsCenter.y);
              return true;
            },
            getTopLeft: function (body, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (this.parseBody(body)) {
                var center = this.boundsCenter;
                var diff = this.centerDiff;
                return new Vector2(x + center.x + diff.x, y + center.y + diff.y);
              }
              return false;
            },
            getTopCenter: function (body, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (this.parseBody(body)) {
                var center = this.boundsCenter;
                var diff = this.centerDiff;
                return new Vector2(x + diff.x, y + center.y + diff.y);
              }
              return false;
            },
            getTopRight: function (body, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (this.parseBody(body)) {
                var center = this.boundsCenter;
                var diff = this.centerDiff;
                return new Vector2(x - (center.x - diff.x), y + center.y + diff.y);
              }
              return false;
            },
            getLeftCenter: function (body, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (this.parseBody(body)) {
                var center = this.boundsCenter;
                var diff = this.centerDiff;
                return new Vector2(x + center.x + diff.x, y + diff.y);
              }
              return false;
            },
            getCenter: function (body, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (this.parseBody(body)) {
                var diff = this.centerDiff;
                return new Vector2(x + diff.x, y + diff.y);
              }
              return false;
            },
            getRightCenter: function (body, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (this.parseBody(body)) {
                var center = this.boundsCenter;
                var diff = this.centerDiff;
                return new Vector2(x - (center.x - diff.x), y + diff.y);
              }
              return false;
            },
            getBottomLeft: function (body, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (this.parseBody(body)) {
                var center = this.boundsCenter;
                var diff = this.centerDiff;
                return new Vector2(x + center.x + diff.x, y - (center.y - diff.y));
              }
              return false;
            },
            getBottomCenter: function (body, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (this.parseBody(body)) {
                var center = this.boundsCenter;
                var diff = this.centerDiff;
                return new Vector2(x + diff.x, y - (center.y - diff.y));
              }
              return false;
            },
            getBottomRight: function (body, x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (this.parseBody(body)) {
                var center = this.boundsCenter;
                var diff = this.centerDiff;
                return new Vector2(x - (center.x - diff.x), y - (center.y - diff.y));
              }
              return false;
            }
          });
          module2.exports = BodyBounds;
        }, function (module2, exports2) {
          module2.exports = {
            decomp: polygonDecomp,
            quickDecomp: polygonQuickDecomp,
            isSimple: polygonIsSimple,
            removeCollinearPoints: polygonRemoveCollinearPoints,
            removeDuplicatePoints: polygonRemoveDuplicatePoints,
            makeCCW: polygonMakeCCW
          };
          function lineInt(l1, l2, precision) {
            precision = precision || 0;
            var i = [0, 0];
            var a1, b1, c1, a2, b2, c2, det;
            a1 = l1[1][1] - l1[0][1];
            b1 = l1[0][0] - l1[1][0];
            c1 = a1 * l1[0][0] + b1 * l1[0][1];
            a2 = l2[1][1] - l2[0][1];
            b2 = l2[0][0] - l2[1][0];
            c2 = a2 * l2[0][0] + b2 * l2[0][1];
            det = a1 * b2 - a2 * b1;
            if (!scalar_eq(det, 0, precision)) {
              i[0] = (b2 * c1 - b1 * c2) / det;
              i[1] = (a1 * c2 - a2 * c1) / det;
            }
            return i;
          }
          function lineSegmentsIntersect(p1, p22, q1, q2) {
            var dx = p22[0] - p1[0];
            var dy = p22[1] - p1[1];
            var da = q2[0] - q1[0];
            var db = q2[1] - q1[1];
            if (da * dy - db * dx === 0) {
              return false;
            }
            var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);
            var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);
            return s >= 0 && s <= 1 && t >= 0 && t <= 1;
          }
          function triangleArea(a, b, c) {
            return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
          }
          function isLeft(a, b, c) {
            return triangleArea(a, b, c) > 0;
          }
          function isLeftOn(a, b, c) {
            return triangleArea(a, b, c) >= 0;
          }
          function isRight(a, b, c) {
            return triangleArea(a, b, c) < 0;
          }
          function isRightOn(a, b, c) {
            return triangleArea(a, b, c) <= 0;
          }
          var tmpPoint1 = [], tmpPoint2 = [];
          function collinear(a, b, c, thresholdAngle) {
            if (!thresholdAngle) {
              return triangleArea(a, b, c) === 0;
            } else {
              var ab = tmpPoint1, bc = tmpPoint2;
              ab[0] = b[0] - a[0];
              ab[1] = b[1] - a[1];
              bc[0] = c[0] - b[0];
              bc[1] = c[1] - b[1];
              var dot = ab[0] * bc[0] + ab[1] * bc[1], magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]), magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]), angle = Math.acos(dot / (magA * magB));
              return angle < thresholdAngle;
            }
          }
          function sqdist(a, b) {
            var dx = b[0] - a[0];
            var dy = b[1] - a[1];
            return dx * dx + dy * dy;
          }
          function polygonAt(polygon, i) {
            var s = polygon.length;
            return polygon[i < 0 ? i % s + s : i % s];
          }
          function polygonClear(polygon) {
            polygon.length = 0;
          }
          function polygonAppend(polygon, poly, from, to) {
            for (var i = from; i < to; i++) {
              polygon.push(poly[i]);
            }
          }
          function polygonMakeCCW(polygon) {
            var br = 0, v = polygon;
            for (var i = 1; i < polygon.length; ++i) {
              if (v[i][1] < v[br][1] || v[i][1] === v[br][1] && v[i][0] > v[br][0]) {
                br = i;
              }
            }
            if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {
              polygonReverse(polygon);
              return true;
            } else {
              return false;
            }
          }
          function polygonReverse(polygon) {
            var tmp = [];
            var N = polygon.length;
            for (var i = 0; i !== N; i++) {
              tmp.push(polygon.pop());
            }
            for (var i = 0; i !== N; i++) {
              polygon[i] = tmp[i];
            }
          }
          function polygonIsReflex(polygon, i) {
            return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));
          }
          var tmpLine1 = [], tmpLine2 = [];
          function polygonCanSee(polygon, a, b) {
            var p3, dist, l1 = tmpLine1, l2 = tmpLine2;
            if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {
              return false;
            }
            dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));
            for (var i = 0; i !== polygon.length; ++i) {
              if ((i + 1) % polygon.length === a || i === a) {
                continue;
              }
              if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) {
                l1[0] = polygonAt(polygon, a);
                l1[1] = polygonAt(polygon, b);
                l2[0] = polygonAt(polygon, i);
                l2[1] = polygonAt(polygon, i + 1);
                p3 = lineInt(l1, l2);
                if (sqdist(polygonAt(polygon, a), p3) < dist) {
                  return false;
                }
              }
            }
            return true;
          }
          function polygonCanSee2(polygon, a, b) {
            for (var i = 0; i !== polygon.length; ++i) {
              if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b) {
                continue;
              }
              if (lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i + 1))) {
                return false;
              }
            }
            return true;
          }
          function polygonCopy(polygon, i, j, targetPoly) {
            var p3 = targetPoly || [];
            polygonClear(p3);
            if (i < j) {
              for (var k = i; k <= j; k++) {
                p3.push(polygon[k]);
              }
            } else {
              for (var k = 0; k <= j; k++) {
                p3.push(polygon[k]);
              }
              for (var k = i; k < polygon.length; k++) {
                p3.push(polygon[k]);
              }
            }
            return p3;
          }
          function polygonGetCutEdges(polygon) {
            var min = [], tmp1 = [], tmp2 = [], tmpPoly = [];
            var nDiags = Number.MAX_VALUE;
            for (var i = 0; i < polygon.length; ++i) {
              if (polygonIsReflex(polygon, i)) {
                for (var j = 0; j < polygon.length; ++j) {
                  if (polygonCanSee(polygon, i, j)) {
                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));
                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));
                    for (var k = 0; k < tmp2.length; k++) {
                      tmp1.push(tmp2[k]);
                    }
                    if (tmp1.length < nDiags) {
                      min = tmp1;
                      nDiags = tmp1.length;
                      min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);
                    }
                  }
                }
              }
            }
            return min;
          }
          function polygonDecomp(polygon) {
            var edges = polygonGetCutEdges(polygon);
            if (edges.length > 0) {
              return polygonSlice(polygon, edges);
            } else {
              return [polygon];
            }
          }
          function polygonSlice(polygon, cutEdges) {
            if (cutEdges.length === 0) {
              return [polygon];
            }
            if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length === 2 && cutEdges[0][0] instanceof Array) {
              var polys = [polygon];
              for (var i = 0; i < cutEdges.length; i++) {
                var cutEdge = cutEdges[i];
                for (var j = 0; j < polys.length; j++) {
                  var poly = polys[j];
                  var result = polygonSlice(poly, cutEdge);
                  if (result) {
                    polys.splice(j, 1);
                    polys.push(result[0], result[1]);
                    break;
                  }
                }
              }
              return polys;
            } else {
              var cutEdge = cutEdges;
              var i = polygon.indexOf(cutEdge[0]);
              var j = polygon.indexOf(cutEdge[1]);
              if (i !== -1 && j !== -1) {
                return [polygonCopy(polygon, i, j), polygonCopy(polygon, j, i)];
              } else {
                return false;
              }
            }
          }
          function polygonIsSimple(polygon) {
            var path = polygon, i;
            for (i = 0; i < path.length - 1; i++) {
              for (var j = 0; j < i - 1; j++) {
                if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {
                  return false;
                }
              }
            }
            for (i = 1; i < path.length - 2; i++) {
              if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {
                return false;
              }
            }
            return true;
          }
          function getIntersectionPoint(p1, p22, q1, q2, delta) {
            delta = delta || 0;
            var a1 = p22[1] - p1[1];
            var b1 = p1[0] - p22[0];
            var c1 = a1 * p1[0] + b1 * p1[1];
            var a2 = q2[1] - q1[1];
            var b2 = q1[0] - q2[0];
            var c2 = a2 * q1[0] + b2 * q1[1];
            var det = a1 * b2 - a2 * b1;
            if (!scalar_eq(det, 0, delta)) {
              return [(b2 * c1 - b1 * c2) / det, (a1 * c2 - a2 * c1) / det];
            } else {
              return [0, 0];
            }
          }
          function polygonQuickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {
            maxlevel = maxlevel || 100;
            level = level || 0;
            delta = delta || 25;
            result = typeof result !== "undefined" ? result : [];
            reflexVertices = reflexVertices || [];
            steinerPoints = steinerPoints || [];
            var upperInt = [0, 0], lowerInt = [0, 0], p3 = [0, 0];
            var upperDist = 0, lowerDist = 0, d = 0, closestDist = 0;
            var upperIndex = 0, lowerIndex = 0, closestIndex = 0;
            var lowerPoly = [], upperPoly = [];
            var poly = polygon, v = polygon;
            if (v.length < 3) {
              return result;
            }
            level++;
            if (level > maxlevel) {
              console.warn("quickDecomp: max level (" + maxlevel + ") reached.");
              return result;
            }
            for (var i = 0; i < polygon.length; ++i) {
              if (polygonIsReflex(poly, i)) {
                reflexVertices.push(poly[i]);
                upperDist = lowerDist = Number.MAX_VALUE;
                for (var j = 0; j < polygon.length; ++j) {
                  if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) {
                    p3 = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1));
                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p3)) {
                      d = sqdist(poly[i], p3);
                      if (d < lowerDist) {
                        lowerDist = d;
                        lowerInt = p3;
                        lowerIndex = j;
                      }
                    }
                  }
                  if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                    p3 = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));
                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p3)) {
                      d = sqdist(poly[i], p3);
                      if (d < upperDist) {
                        upperDist = d;
                        upperInt = p3;
                        upperIndex = j;
                      }
                    }
                  }
                }
                if (lowerIndex === (upperIndex + 1) % polygon.length) {
                  p3[0] = (lowerInt[0] + upperInt[0]) / 2;
                  p3[1] = (lowerInt[1] + upperInt[1]) / 2;
                  steinerPoints.push(p3);
                  if (i < upperIndex) {
                    polygonAppend(lowerPoly, poly, i, upperIndex + 1);
                    lowerPoly.push(p3);
                    upperPoly.push(p3);
                    if (lowerIndex !== 0) {
                      polygonAppend(upperPoly, poly, lowerIndex, poly.length);
                    }
                    polygonAppend(upperPoly, poly, 0, i + 1);
                  } else {
                    if (i !== 0) {
                      polygonAppend(lowerPoly, poly, i, poly.length);
                    }
                    polygonAppend(lowerPoly, poly, 0, upperIndex + 1);
                    lowerPoly.push(p3);
                    upperPoly.push(p3);
                    polygonAppend(upperPoly, poly, lowerIndex, i + 1);
                  }
                } else {
                  if (lowerIndex > upperIndex) {
                    upperIndex += polygon.length;
                  }
                  closestDist = Number.MAX_VALUE;
                  if (upperIndex < lowerIndex) {
                    return result;
                  }
                  for (var j = lowerIndex; j <= upperIndex; ++j) {
                    if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                      d = sqdist(polygonAt(poly, i), polygonAt(poly, j));
                      if (d < closestDist && polygonCanSee2(poly, i, j)) {
                        closestDist = d;
                        closestIndex = j % polygon.length;
                      }
                    }
                  }
                  if (i < closestIndex) {
                    polygonAppend(lowerPoly, poly, i, closestIndex + 1);
                    if (closestIndex !== 0) {
                      polygonAppend(upperPoly, poly, closestIndex, v.length);
                    }
                    polygonAppend(upperPoly, poly, 0, i + 1);
                  } else {
                    if (i !== 0) {
                      polygonAppend(lowerPoly, poly, i, v.length);
                    }
                    polygonAppend(lowerPoly, poly, 0, closestIndex + 1);
                    polygonAppend(upperPoly, poly, closestIndex, i + 1);
                  }
                }
                if (lowerPoly.length < upperPoly.length) {
                  polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                  polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                } else {
                  polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                  polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                }
                return result;
              }
            }
            result.push(polygon);
            return result;
          }
          function polygonRemoveCollinearPoints(polygon, precision) {
            var num = 0;
            for (var i = polygon.length - 1; polygon.length > 3 && i >= 0; --i) {
              if (collinear(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1), precision)) {
                polygon.splice(i % polygon.length, 1);
                num++;
              }
            }
            return num;
          }
          function polygonRemoveDuplicatePoints(polygon, precision) {
            for (var i = polygon.length - 1; i >= 1; --i) {
              var pi = polygon[i];
              for (var j = i - 1; j >= 0; --j) {
                if (points_eq(pi, polygon[j], precision)) {
                  polygon.splice(i, 1);
                  continue;
                }
              }
            }
          }
          function scalar_eq(a, b, precision) {
            precision = precision || 0;
            return Math.abs(a - b) <= precision;
          }
          function points_eq(a, b, precision) {
            return scalar_eq(a[0], b[0], precision) && scalar_eq(a[1], b[1], precision);
          }
        }, function (module2, exports2, __webpack_require__) {
          var Bodies = __webpack_require__(86);
          var Class = __webpack_require__(0);
          var Composites = __webpack_require__(591);
          var Constraint = __webpack_require__(128);
          var Svg = __webpack_require__(592);
          var MatterGameObject = __webpack_require__(1395);
          var MatterImage = __webpack_require__(1396);
          var MatterSprite = __webpack_require__(1397);
          var MatterTileBody = __webpack_require__(593);
          var PhysicsEditorParser = __webpack_require__(589);
          var PhysicsJSONParser = __webpack_require__(590);
          var PointerConstraint = __webpack_require__(1398);
          var Vertices = __webpack_require__(64);
          var Factory = new Class({
            initialize: function Factory2(world) {
              this.world = world;
              this.scene = world.scene;
              this.sys = world.scene.sys;
            },
            rectangle: function (x, y, width, height, options) {
              var body = Bodies.rectangle(x, y, width, height, options);
              this.world.add(body);
              return body;
            },
            trapezoid: function (x, y, width, height, slope, options) {
              var body = Bodies.trapezoid(x, y, width, height, slope, options);
              this.world.add(body);
              return body;
            },
            circle: function (x, y, radius, options, maxSides) {
              var body = Bodies.circle(x, y, radius, options, maxSides);
              this.world.add(body);
              return body;
            },
            polygon: function (x, y, sides, radius, options) {
              var body = Bodies.polygon(x, y, sides, radius, options);
              this.world.add(body);
              return body;
            },
            fromVertices: function (x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea) {
              if (typeof vertexSets === "string") {
                vertexSets = Vertices.fromPath(vertexSets);
              }
              var body = Bodies.fromVertices(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea);
              this.world.add(body);
              return body;
            },
            fromPhysicsEditor: function (x, y, config, options, addToWorld) {
              if (addToWorld === void 0) {
                addToWorld = true;
              }
              var body = PhysicsEditorParser.parseBody(x, y, config, options);
              if (addToWorld && !this.world.has(body)) {
                this.world.add(body);
              }
              return body;
            },
            fromSVG: function (x, y, xml, scale, options, addToWorld) {
              if (scale === void 0) {
                scale = 1;
              }
              if (options === void 0) {
                options = {};
              }
              if (addToWorld === void 0) {
                addToWorld = true;
              }
              var path = xml.getElementsByTagName("path");
              var vertexSets = [];
              for (var i = 0; i < path.length; i++) {
                var points = Svg.pathToVertices(path[i], 30);
                if (scale !== 1) {
                  Vertices.scale(points, scale, scale);
                }
                vertexSets.push(points);
              }
              var body = Bodies.fromVertices(x, y, vertexSets, options);
              if (addToWorld) {
                this.world.add(body);
              }
              return body;
            },
            fromJSON: function (x, y, config, options, addToWorld) {
              if (options === void 0) {
                options = {};
              }
              if (addToWorld === void 0) {
                addToWorld = true;
              }
              var body = PhysicsJSONParser.parseBody(x, y, config, options);
              if (body && addToWorld) {
                this.world.add(body);
              }
              return body;
            },
            imageStack: function (key, frame, x, y, columns, rows, columnGap, rowGap, options) {
              if (columnGap === void 0) {
                columnGap = 0;
              }
              if (rowGap === void 0) {
                rowGap = 0;
              }
              if (options === void 0) {
                options = {};
              }
              var world = this.world;
              var displayList = this.sys.displayList;
              options.addToWorld = false;
              var stack = Composites.stack(x, y, columns, rows, columnGap, rowGap, function (x2, y2) {
                var image = new MatterImage(world, x2, y2, key, frame, options);
                displayList.add(image);
                return image.body;
              });
              world.add(stack);
              return stack;
            },
            stack: function (x, y, columns, rows, columnGap, rowGap, callback) {
              var stack = Composites.stack(x, y, columns, rows, columnGap, rowGap, callback);
              this.world.add(stack);
              return stack;
            },
            pyramid: function (x, y, columns, rows, columnGap, rowGap, callback) {
              var stack = Composites.pyramid(x, y, columns, rows, columnGap, rowGap, callback);
              this.world.add(stack);
              return stack;
            },
            chain: function (composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {
              return Composites.chain(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options);
            },
            mesh: function (composite, columns, rows, crossBrace, options) {
              return Composites.mesh(composite, columns, rows, crossBrace, options);
            },
            newtonsCradle: function (x, y, number, size, length) {
              var composite = Composites.newtonsCradle(x, y, number, size, length);
              this.world.add(composite);
              return composite;
            },
            car: function (x, y, width, height, wheelSize) {
              var composite = Composites.car(x, y, width, height, wheelSize);
              this.world.add(composite);
              return composite;
            },
            softBody: function (x, y, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {
              var composite = Composites.softBody(x, y, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions);
              this.world.add(composite);
              return composite;
            },
            joint: function (bodyA, bodyB, length, stiffness, options) {
              return this.constraint(bodyA, bodyB, length, stiffness, options);
            },
            spring: function (bodyA, bodyB, length, stiffness, options) {
              return this.constraint(bodyA, bodyB, length, stiffness, options);
            },
            constraint: function (bodyA, bodyB, length, stiffness, options) {
              if (stiffness === void 0) {
                stiffness = 1;
              }
              if (options === void 0) {
                options = {};
              }
              options.bodyA = bodyA.type === "body" ? bodyA : bodyA.body;
              options.bodyB = bodyB.type === "body" ? bodyB : bodyB.body;
              if (!isNaN(length)) {
                options.length = length;
              }
              options.stiffness = stiffness;
              var constraint = Constraint.create(options);
              this.world.add(constraint);
              return constraint;
            },
            worldConstraint: function (body, length, stiffness, options) {
              if (stiffness === void 0) {
                stiffness = 1;
              }
              if (options === void 0) {
                options = {};
              }
              options.bodyB = body.type === "body" ? body : body.body;
              if (!isNaN(length)) {
                options.length = length;
              }
              options.stiffness = stiffness;
              var constraint = Constraint.create(options);
              this.world.add(constraint);
              return constraint;
            },
            mouseSpring: function (options) {
              return this.pointerConstraint(options);
            },
            pointerConstraint: function (options) {
              if (options === void 0) {
                options = {};
              }
              if (!options.hasOwnProperty("render")) {
                options.render = {
                  visible: false
                };
              }
              var pointerConstraint = new PointerConstraint(this.scene, this.world, options);
              this.world.add(pointerConstraint.constraint);
              return pointerConstraint;
            },
            image: function (x, y, key, frame, options) {
              var image = new MatterImage(this.world, x, y, key, frame, options);
              this.sys.displayList.add(image);
              return image;
            },
            tileBody: function (tile, options) {
              return new MatterTileBody(this.world, tile, options);
            },
            sprite: function (x, y, key, frame, options) {
              var sprite = new MatterSprite(this.world, x, y, key, frame, options);
              this.sys.displayList.add(sprite);
              this.sys.updateList.add(sprite);
              return sprite;
            },
            gameObject: function (gameObject, options, addToWorld) {
              return MatterGameObject(this.world, gameObject, options, addToWorld);
            },
            destroy: function () {
              this.world = null;
              this.scene = null;
              this.sys = null;
            }
          });
          module2.exports = Factory;
        }, function (module2, exports2, __webpack_require__) {
          var Components = __webpack_require__(249);
          var GetFastValue = __webpack_require__(2);
          var Vector2 = __webpack_require__(3);
          function hasGetterOrSetter(def) {
            return !!def.get && typeof def.get === "function" || !!def.set && typeof def.set === "function";
          }
          var MatterGameObject = function (world, gameObject, options, addToWorld) {
            if (options === void 0) {
              options = {};
            }
            if (addToWorld === void 0) {
              addToWorld = true;
            }
            var x = gameObject.x;
            var y = gameObject.y;
            gameObject.body = {
              temp: true,
              position: {
                x,
                y
              }
            };
            var mixins = [Components.Bounce, Components.Collision, Components.Force, Components.Friction, Components.Gravity, Components.Mass, Components.Sensor, Components.SetBody, Components.Sleep, Components.Static, Components.Transform, Components.Velocity];
            mixins.forEach(function (mixin) {
              for (var key in mixin) {
                if (hasGetterOrSetter(mixin[key])) {
                  Object.defineProperty(gameObject, key, {
                    get: mixin[key].get,
                    set: mixin[key].set
                  });
                } else {
                  Object.defineProperty(gameObject, key, {
                    value: mixin[key]
                  });
                }
              }
            });
            gameObject.world = world;
            gameObject._tempVec2 = new Vector2(x, y);
            if (options.hasOwnProperty("type") && options.type === "body") {
              gameObject.setExistingBody(options, addToWorld);
            } else {
              var shape = GetFastValue(options, "shape", null);
              if (!shape) {
                shape = "rectangle";
              }
              options.addToWorld = addToWorld;
              gameObject.setBody(shape, options);
            }
            return gameObject;
          };
          module2.exports = MatterGameObject;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(249);
          var GameObject = __webpack_require__(15);
          var GetFastValue = __webpack_require__(2);
          var Image2 = __webpack_require__(125);
          var Pipeline = __webpack_require__(167);
          var Vector2 = __webpack_require__(3);
          var MatterImage = new Class({
            Extends: Image2,
            Mixins: [Components.Bounce, Components.Collision, Components.Force, Components.Friction, Components.Gravity, Components.Mass, Components.Sensor, Components.SetBody, Components.Sleep, Components.Static, Components.Transform, Components.Velocity, Pipeline],
            initialize: function MatterImage2(world, x, y, texture, frame, options) {
              GameObject.call(this, world.scene, "Image");
              this._crop = this.resetCropObject();
              this.setTexture(texture, frame);
              this.setSizeToFrame();
              this.setOrigin();
              this.world = world;
              this._tempVec2 = new Vector2(x, y);
              var shape = GetFastValue(options, "shape", null);
              if (shape) {
                this.setBody(shape, options);
              } else {
                this.setRectangle(this.width, this.height, options);
              }
              this.setPosition(x, y);
              this.initPipeline();
            }
          });
          module2.exports = MatterImage;
        }, function (module2, exports2, __webpack_require__) {
          var AnimationState = __webpack_require__(164);
          var Class = __webpack_require__(0);
          var Components = __webpack_require__(249);
          var GameObject = __webpack_require__(15);
          var GetFastValue = __webpack_require__(2);
          var Pipeline = __webpack_require__(167);
          var Sprite = __webpack_require__(73);
          var Vector2 = __webpack_require__(3);
          var MatterSprite = new Class({
            Extends: Sprite,
            Mixins: [Components.Bounce, Components.Collision, Components.Force, Components.Friction, Components.Gravity, Components.Mass, Components.Sensor, Components.SetBody, Components.Sleep, Components.Static, Components.Transform, Components.Velocity, Pipeline],
            initialize: function MatterSprite2(world, x, y, texture, frame, options) {
              GameObject.call(this, world.scene, "Sprite");
              this._crop = this.resetCropObject();
              this.anims = new AnimationState(this);
              this.setTexture(texture, frame);
              this.setSizeToFrame();
              this.setOrigin();
              this.world = world;
              this._tempVec2 = new Vector2(x, y);
              var shape = GetFastValue(options, "shape", null);
              if (shape) {
                this.setBody(shape, options);
              } else {
                this.setRectangle(this.width, this.height, options);
              }
              this.setPosition(x, y);
              this.initPipeline();
            }
          });
          module2.exports = MatterSprite;
        }, function (module2, exports2, __webpack_require__) {
          var Bounds = __webpack_require__(84);
          var Class = __webpack_require__(0);
          var Composite = __webpack_require__(118);
          var Constraint = __webpack_require__(128);
          var Detector = __webpack_require__(273);
          var Events = __webpack_require__(272);
          var InputEvents = __webpack_require__(51);
          var Merge = __webpack_require__(127);
          var Sleeping = __webpack_require__(165);
          var Vector2 = __webpack_require__(3);
          var Vertices = __webpack_require__(64);
          var PointerConstraint = new Class({
            initialize: function PointerConstraint2(scene, world, options) {
              if (options === void 0) {
                options = {};
              }
              var defaults = {
                label: "Pointer Constraint",
                pointA: {
                  x: 0,
                  y: 0
                },
                pointB: {
                  x: 0,
                  y: 0
                },
                length: 0.01,
                stiffness: 0.1,
                angularStiffness: 1,
                collisionFilter: {
                  category: 1,
                  mask: 4294967295,
                  group: 0
                }
              };
              this.scene = scene;
              this.world = world;
              this.camera = null;
              this.pointer = null;
              this.active = true;
              this.position = new Vector2();
              this.body = null;
              this.part = null;
              this.constraint = Constraint.create(Merge(options, defaults));
              this.world.on(Events.BEFORE_UPDATE, this.update, this);
              scene.sys.input.on(InputEvents.POINTER_DOWN, this.onDown, this);
              scene.sys.input.on(InputEvents.POINTER_UP, this.onUp, this);
            },
            onDown: function (pointer) {
              if (!this.pointer) {
                this.pointer = pointer;
                this.camera = pointer.camera;
              }
            },
            onUp: function (pointer) {
              if (pointer === this.pointer) {
                this.pointer = null;
              }
            },
            getBody: function (pointer) {
              var pos = this.position;
              var constraint = this.constraint;
              this.camera.getWorldPoint(pointer.x, pointer.y, pos);
              var bodies = Composite.allBodies(this.world.localWorld);
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                if (!body.ignorePointer && Bounds.contains(body.bounds, pos) && Detector.canCollide(body.collisionFilter, constraint.collisionFilter)) {
                  if (this.hitTestBody(body, pos)) {
                    this.world.emit(Events.DRAG_START, body, this.part, this);
                    return true;
                  }
                }
              }
              return false;
            },
            hitTestBody: function (body, position) {
              var constraint = this.constraint;
              var partsLength = body.parts.length;
              var start = partsLength > 1 ? 1 : 0;
              for (var i = start; i < partsLength; i++) {
                var part = body.parts[i];
                if (Vertices.contains(part.vertices, position)) {
                  constraint.pointA = position;
                  constraint.pointB = {
                    x: position.x - body.position.x,
                    y: position.y - body.position.y
                  };
                  constraint.bodyB = body;
                  constraint.angleB = body.angle;
                  Sleeping.set(body, false);
                  this.part = part;
                  this.body = body;
                  return true;
                }
              }
              return false;
            },
            update: function () {
              var pointer = this.pointer;
              var body = this.body;
              if (!this.active || !pointer) {
                if (body) {
                  this.stopDrag();
                }
                return;
              }
              if (!pointer.isDown && body) {
                this.stopDrag();
                return;
              } else if (pointer.isDown) {
                if (!body && !this.getBody(pointer)) {
                  return;
                }
                body = this.body;
                var pos = this.position;
                var constraint = this.constraint;
                this.camera.getWorldPoint(pointer.x, pointer.y, pos);
                constraint.pointA.x = pos.x;
                constraint.pointA.y = pos.y;
                Sleeping.set(body, false);
                this.world.emit(Events.DRAG, body, this);
              }
            },
            stopDrag: function () {
              var body = this.body;
              var constraint = this.constraint;
              constraint.bodyB = null;
              constraint.pointB = null;
              this.pointer = null;
              this.body = null;
              this.part = null;
              if (body) {
                this.world.emit(Events.DRAG_END, body, this);
              }
            },
            destroy: function () {
              this.world.removeConstraint(this.constraint);
              this.pointer = null;
              this.constraint = null;
              this.body = null;
              this.part = null;
              this.world.off(Events.BEFORE_UPDATE, this.update);
              this.scene.sys.input.off(InputEvents.POINTER_DOWN, this.onDown, this);
              this.scene.sys.input.off(InputEvents.POINTER_UP, this.onUp, this);
            }
          });
          module2.exports = PointerConstraint;
        }, function (module2, exports2, __webpack_require__) {
          var Matter = {};
          module2.exports = Matter;
          var Plugin = __webpack_require__(595);
          var Common = __webpack_require__(32);
          (function () {
            Matter.name = "matter-js";
            Matter.version = "0.14.2";
            Matter.uses = [];
            Matter.used = [];
            Matter.use = function () {
              Plugin.use(Matter, Array.prototype.slice.call(arguments));
            };
            Matter.before = function (path, func) {
              path = path.replace(/^Matter./, "");
              return Common.chainPathBefore(Matter, path, func);
            };
            Matter.after = function (path, func) {
              path = path.replace(/^Matter./, "");
              return Common.chainPathAfter(Matter, path, func);
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          var Query = {};
          module2.exports = Query;
          var Vector = __webpack_require__(83);
          var SAT = __webpack_require__(274);
          var Bounds = __webpack_require__(84);
          var Bodies = __webpack_require__(86);
          var Vertices = __webpack_require__(64);
          (function () {
            Query.collides = function (body, bodies) {
              var collisions = [];
              for (var i = 0; i < bodies.length; i++) {
                var bodyA = bodies[i];
                if (body === bodyA) {
                  continue;
                }
                if (Bounds.overlaps(bodyA.bounds, body.bounds)) {
                  for (var j = bodyA.parts.length === 1 ? 0 : 1; j < bodyA.parts.length; j++) {
                    var part = bodyA.parts[j];
                    if (Bounds.overlaps(part.bounds, body.bounds)) {
                      var collision = SAT.collides(part, body);
                      if (collision.collided) {
                        collisions.push(collision);
                        break;
                      }
                    }
                  }
                }
              }
              return collisions;
            };
            Query.ray = function (bodies, startPoint, endPoint, rayWidth) {
              rayWidth = rayWidth || 1e-100;
              var rayAngle = Vector.angle(startPoint, endPoint), rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)), rayX = (endPoint.x + startPoint.x) * 0.5, rayY = (endPoint.y + startPoint.y) * 0.5, ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, {
                angle: rayAngle
              }), collisions = Query.collides(ray, bodies);
              for (var i = 0; i < collisions.length; i += 1) {
                var collision = collisions[i];
                collision.body = collision.bodyB = collision.bodyA;
              }
              return collisions;
            };
            Query.region = function (bodies, bounds, outside) {
              var result = [];
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i], overlaps = Bounds.overlaps(body.bounds, bounds);
                if (overlaps && !outside || !overlaps && outside) result.push(body);
              }
              return result;
            };
            Query.point = function (bodies, point) {
              var result = [];
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                if (Bounds.contains(body.bounds, point)) {
                  for (var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++) {
                    var part = body.parts[j];
                    if (Bounds.contains(part.bounds, point) && Vertices.contains(part.vertices, point)) {
                      result.push(body);
                      break;
                    }
                  }
                }
              }
              return result;
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          var Engine = {};
          module2.exports = Engine;
          var World = __webpack_require__(596);
          var Sleeping = __webpack_require__(165);
          var Resolver = __webpack_require__(599);
          var Pairs = __webpack_require__(598);
          var Metrics = __webpack_require__(1523);
          var Grid = __webpack_require__(597);
          var Events = __webpack_require__(166);
          var Composite = __webpack_require__(118);
          var Constraint = __webpack_require__(128);
          var Common = __webpack_require__(32);
          var Body = __webpack_require__(41);
          (function () {
            Engine.create = function (element, options) {
              options = Common.isElement(element) ? options : element;
              element = Common.isElement(element) ? element : null;
              options = options || ({});
              if (element || options.render) {
                Common.warn("Engine.create: engine.render is deprecated (see docs)");
              }
              var defaults = {
                positionIterations: 6,
                velocityIterations: 4,
                constraintIterations: 2,
                enableSleeping: false,
                events: [],
                plugin: {},
                timing: {
                  timestamp: 0,
                  timeScale: 1
                },
                broadphase: {
                  controller: Grid
                }
              };
              var engine = Common.extend(defaults, options);
              engine.world = options.world || World.create(engine.world);
              engine.pairs = Pairs.create();
              engine.broadphase = engine.broadphase.controller.create(engine.broadphase);
              engine.metrics = engine.metrics || ({
                extended: false
              });
              engine.metrics = Metrics.create(engine.metrics);
              return engine;
            };
            Engine.update = function (engine, delta, correction) {
              delta = delta || 1e3 / 60;
              correction = correction || 1;
              var world = engine.world, timing = engine.timing, broadphase = engine.broadphase, broadphasePairs = [], i;
              timing.timestamp += delta * timing.timeScale;
              var event = {
                timestamp: timing.timestamp
              };
              Events.trigger(engine, "beforeUpdate", event);
              var allBodies = Composite.allBodies(world), allConstraints = Composite.allConstraints(world);
              Metrics.reset(engine.metrics);
              if (engine.enableSleeping) Sleeping.update(allBodies, timing.timeScale);
              Engine._bodiesApplyGravity(allBodies, world.gravity);
              Engine._bodiesUpdate(allBodies, delta, timing.timeScale, correction, world.bounds);
              Constraint.preSolveAll(allBodies);
              for (i = 0; i < engine.constraintIterations; i++) {
                Constraint.solveAll(allConstraints, timing.timeScale);
              }
              Constraint.postSolveAll(allBodies);
              if (broadphase.controller) {
                if (world.isModified) broadphase.controller.clear(broadphase);
                broadphase.controller.update(broadphase, allBodies, engine, world.isModified);
                broadphasePairs = broadphase.pairsList;
              } else {
                broadphasePairs = allBodies;
              }
              if (world.isModified) {
                Composite.setModified(world, false, false, true);
              }
              var collisions = broadphase.detector(broadphasePairs, engine);
              var pairs = engine.pairs, timestamp = timing.timestamp;
              Pairs.update(pairs, collisions, timestamp);
              Pairs.removeOld(pairs, timestamp);
              if (engine.enableSleeping) Sleeping.afterCollisions(pairs.list, timing.timeScale);
              if (pairs.collisionStart.length > 0) Events.trigger(engine, "collisionStart", {
                pairs: pairs.collisionStart
              });
              Resolver.preSolvePosition(pairs.list);
              for (i = 0; i < engine.positionIterations; i++) {
                Resolver.solvePosition(pairs.list, allBodies, timing.timeScale);
              }
              Resolver.postSolvePosition(allBodies);
              Constraint.preSolveAll(allBodies);
              for (i = 0; i < engine.constraintIterations; i++) {
                Constraint.solveAll(allConstraints, timing.timeScale);
              }
              Constraint.postSolveAll(allBodies);
              Resolver.preSolveVelocity(pairs.list);
              for (i = 0; i < engine.velocityIterations; i++) {
                Resolver.solveVelocity(pairs.list, timing.timeScale);
              }
              if (pairs.collisionActive.length > 0) Events.trigger(engine, "collisionActive", {
                pairs: pairs.collisionActive
              });
              if (pairs.collisionEnd.length > 0) Events.trigger(engine, "collisionEnd", {
                pairs: pairs.collisionEnd
              });
              Metrics.update(engine.metrics, engine);
              Engine._bodiesClearForces(allBodies);
              Events.trigger(engine, "afterUpdate", event);
              return engine;
            };
            Engine.merge = function (engineA, engineB) {
              Common.extend(engineA, engineB);
              if (engineB.world) {
                engineA.world = engineB.world;
                Engine.clear(engineA);
                var bodies = Composite.allBodies(engineA.world);
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i];
                  Sleeping.set(body, false);
                  body.id = Common.nextId();
                }
              }
            };
            Engine.clear = function (engine) {
              var world = engine.world;
              Pairs.clear(engine.pairs);
              var broadphase = engine.broadphase;
              if (broadphase.controller) {
                var bodies = Composite.allBodies(world);
                broadphase.controller.clear(broadphase);
                broadphase.controller.update(broadphase, bodies, engine, true);
              }
            };
            Engine._bodiesClearForces = function (bodies) {
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                body.force.x = 0;
                body.force.y = 0;
                body.torque = 0;
              }
            };
            Engine._bodiesApplyGravity = function (bodies, gravity) {
              var gravityScale = typeof gravity.scale !== "undefined" ? gravity.scale : 1e-3;
              if (gravity.x === 0 && gravity.y === 0 || gravityScale === 0) {
                return;
              }
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                if (body.ignoreGravity || body.isStatic || body.isSleeping) continue;
                body.force.x += body.mass * gravity.x * gravityScale * body.gravityScale.x;
                body.force.y += body.mass * gravity.y * gravityScale * body.gravityScale.y;
              }
            };
            Engine._bodiesUpdate = function (bodies, deltaTime, timeScale, correction, worldBounds) {
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                if (body.isStatic || body.isSleeping) continue;
                Body.update(body, deltaTime, timeScale, correction);
              }
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          var Bodies = __webpack_require__(86);
          var Body = __webpack_require__(41);
          var Class = __webpack_require__(0);
          var Common = __webpack_require__(32);
          var Composite = __webpack_require__(118);
          var Engine = __webpack_require__(1401);
          var EventEmitter = __webpack_require__(9);
          var Events = __webpack_require__(272);
          var GetFastValue = __webpack_require__(2);
          var GetValue = __webpack_require__(6);
          var MatterBody = __webpack_require__(41);
          var MatterEvents = __webpack_require__(166);
          var MatterTileBody = __webpack_require__(593);
          var MatterWorld = __webpack_require__(596);
          var Vector = __webpack_require__(83);
          var World = new Class({
            Extends: EventEmitter,
            initialize: function World2(scene, config) {
              EventEmitter.call(this);
              this.scene = scene;
              this.engine = Engine.create(config);
              this.localWorld = this.engine.world;
              var gravity = GetValue(config, "gravity", null);
              if (gravity) {
                this.setGravity(gravity.x, gravity.y, gravity.scale);
              } else if (gravity === false) {
                this.setGravity(0, 0, 0);
              }
              this.walls = {
                left: null,
                right: null,
                top: null,
                bottom: null
              };
              this.enabled = GetValue(config, "enabled", true);
              this.correction = GetValue(config, "correction", 1);
              this.getDelta = GetValue(config, "getDelta", this.update60Hz);
              var runnerConfig = GetFastValue(config, "runner", {});
              var hasFPS = GetFastValue(runnerConfig, "fps", false);
              var fps = GetFastValue(runnerConfig, "fps", 60);
              var delta = GetFastValue(runnerConfig, "delta", 1e3 / fps);
              var deltaMin = GetFastValue(runnerConfig, "deltaMin", 1e3 / fps);
              var deltaMax = GetFastValue(runnerConfig, "deltaMax", 1e3 / (fps * 0.5));
              if (!hasFPS) {
                fps = 1e3 / delta;
              }
              this.runner = {
                fps,
                correction: GetFastValue(runnerConfig, "correction", 1),
                deltaSampleSize: GetFastValue(runnerConfig, "deltaSampleSize", 60),
                counterTimestamp: 0,
                frameCounter: 0,
                deltaHistory: [],
                timePrev: null,
                timeScalePrev: 1,
                frameRequestId: null,
                isFixed: GetFastValue(runnerConfig, "isFixed", false),
                delta,
                deltaMin,
                deltaMax
              };
              this.autoUpdate = GetValue(config, "autoUpdate", true);
              var debugConfig = GetValue(config, "debug", false);
              this.drawDebug = typeof debugConfig === "object" ? true : debugConfig;
              this.debugGraphic;
              this.debugConfig = {
                showAxes: GetFastValue(debugConfig, "showAxes", false),
                showAngleIndicator: GetFastValue(debugConfig, "showAngleIndicator", false),
                angleColor: GetFastValue(debugConfig, "angleColor", 15208787),
                showBroadphase: GetFastValue(debugConfig, "showBroadphase", false),
                broadphaseColor: GetFastValue(debugConfig, "broadphaseColor", 16757760),
                showBounds: GetFastValue(debugConfig, "showBounds", false),
                boundsColor: GetFastValue(debugConfig, "boundsColor", 16777215),
                showVelocity: GetFastValue(debugConfig, "showVelocity", false),
                velocityColor: GetFastValue(debugConfig, "velocityColor", 44783),
                showCollisions: GetFastValue(debugConfig, "showCollisions", false),
                collisionColor: GetFastValue(debugConfig, "collisionColor", 16094476),
                showSeparations: GetFastValue(debugConfig, "showSeparations", false),
                separationColor: GetFastValue(debugConfig, "separationColor", 16753920),
                showBody: GetFastValue(debugConfig, "showBody", true),
                showStaticBody: GetFastValue(debugConfig, "showStaticBody", true),
                showInternalEdges: GetFastValue(debugConfig, "showInternalEdges", false),
                renderFill: GetFastValue(debugConfig, "renderFill", false),
                renderLine: GetFastValue(debugConfig, "renderLine", true),
                fillColor: GetFastValue(debugConfig, "fillColor", 1075465),
                fillOpacity: GetFastValue(debugConfig, "fillOpacity", 1),
                lineColor: GetFastValue(debugConfig, "lineColor", 2678297),
                lineOpacity: GetFastValue(debugConfig, "lineOpacity", 1),
                lineThickness: GetFastValue(debugConfig, "lineThickness", 1),
                staticFillColor: GetFastValue(debugConfig, "staticFillColor", 857979),
                staticLineColor: GetFastValue(debugConfig, "staticLineColor", 1255396),
                showSleeping: GetFastValue(debugConfig, "showSleeping", false),
                staticBodySleepOpacity: GetFastValue(debugConfig, "staticBodySleepOpacity", 0.7),
                sleepFillColor: GetFastValue(debugConfig, "sleepFillColor", 4605510),
                sleepLineColor: GetFastValue(debugConfig, "sleepLineColor", 10066585),
                showSensors: GetFastValue(debugConfig, "showSensors", true),
                sensorFillColor: GetFastValue(debugConfig, "sensorFillColor", 857979),
                sensorLineColor: GetFastValue(debugConfig, "sensorLineColor", 1255396),
                showPositions: GetFastValue(debugConfig, "showPositions", true),
                positionSize: GetFastValue(debugConfig, "positionSize", 4),
                positionColor: GetFastValue(debugConfig, "positionColor", 14697178),
                showJoint: GetFastValue(debugConfig, "showJoint", true),
                jointColor: GetFastValue(debugConfig, "jointColor", 14737474),
                jointLineOpacity: GetFastValue(debugConfig, "jointLineOpacity", 1),
                jointLineThickness: GetFastValue(debugConfig, "jointLineThickness", 2),
                pinSize: GetFastValue(debugConfig, "pinSize", 4),
                pinColor: GetFastValue(debugConfig, "pinColor", 4382944),
                springColor: GetFastValue(debugConfig, "springColor", 14697184),
                anchorColor: GetFastValue(debugConfig, "anchorColor", 15724527),
                anchorSize: GetFastValue(debugConfig, "anchorSize", 4),
                showConvexHulls: GetFastValue(debugConfig, "showConvexHulls", false),
                hullColor: GetFastValue(debugConfig, "hullColor", 14091216)
              };
              if (this.drawDebug) {
                this.createDebugGraphic();
              }
              this.setEventsProxy();
              if (GetFastValue(config, "setBounds", false)) {
                var boundsConfig = config["setBounds"];
                if (typeof boundsConfig === "boolean") {
                  this.setBounds();
                } else {
                  var x = GetFastValue(boundsConfig, "x", 0);
                  var y = GetFastValue(boundsConfig, "y", 0);
                  var width = GetFastValue(boundsConfig, "width", scene.sys.scale.width);
                  var height = GetFastValue(boundsConfig, "height", scene.sys.scale.height);
                  var thickness = GetFastValue(boundsConfig, "thickness", 64);
                  var left = GetFastValue(boundsConfig, "left", true);
                  var right = GetFastValue(boundsConfig, "right", true);
                  var top = GetFastValue(boundsConfig, "top", true);
                  var bottom = GetFastValue(boundsConfig, "bottom", true);
                  this.setBounds(x, y, width, height, thickness, left, right, top, bottom);
                }
              }
            },
            setCompositeRenderStyle: function (composite) {
              var bodies = composite.bodies;
              var constraints = composite.constraints;
              var composites = composite.composites;
              var i;
              var obj;
              var render;
              for (i = 0; i < bodies.length; i++) {
                obj = bodies[i];
                render = obj.render;
                this.setBodyRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.fillColor, render.fillOpacity);
              }
              for (i = 0; i < constraints.length; i++) {
                obj = constraints[i];
                render = obj.render;
                this.setConstraintRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.pinSize, render.anchorColor, render.anchorSize);
              }
              for (i = 0; i < composites.length; i++) {
                obj = composites[i];
                this.setCompositeRenderStyle(obj);
              }
              return this;
            },
            setBodyRenderStyle: function (body, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity) {
              var render = body.render;
              var config = this.debugConfig;
              if (!render) {
                return this;
              }
              if (lineColor === void 0 || lineColor === null) {
                lineColor = body.isStatic ? config.staticLineColor : config.lineColor;
              }
              if (lineOpacity === void 0 || lineOpacity === null) {
                lineOpacity = config.lineOpacity;
              }
              if (lineThickness === void 0 || lineThickness === null) {
                lineThickness = config.lineThickness;
              }
              if (fillColor === void 0 || fillColor === null) {
                fillColor = body.isStatic ? config.staticFillColor : config.fillColor;
              }
              if (fillOpacity === void 0 || fillOpacity === null) {
                fillOpacity = config.fillOpacity;
              }
              if (lineColor !== false) {
                render.lineColor = lineColor;
              }
              if (lineOpacity !== false) {
                render.lineOpacity = lineOpacity;
              }
              if (lineThickness !== false) {
                render.lineThickness = lineThickness;
              }
              if (fillColor !== false) {
                render.fillColor = fillColor;
              }
              if (fillOpacity !== false) {
                render.fillOpacity = fillOpacity;
              }
              return this;
            },
            setConstraintRenderStyle: function (constraint, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize) {
              var render = constraint.render;
              var config = this.debugConfig;
              if (!render) {
                return this;
              }
              if (lineColor === void 0 || lineColor === null) {
                var type = render.type;
                if (type === "line") {
                  lineColor = config.jointColor;
                } else if (type === "pin") {
                  lineColor = config.pinColor;
                } else if (type === "spring") {
                  lineColor = config.springColor;
                }
              }
              if (lineOpacity === void 0 || lineOpacity === null) {
                lineOpacity = config.jointLineOpacity;
              }
              if (lineThickness === void 0 || lineThickness === null) {
                lineThickness = config.jointLineThickness;
              }
              if (pinSize === void 0 || pinSize === null) {
                pinSize = config.pinSize;
              }
              if (anchorColor === void 0 || anchorColor === null) {
                anchorColor = config.anchorColor;
              }
              if (anchorSize === void 0 || anchorSize === null) {
                anchorSize = config.anchorSize;
              }
              if (lineColor !== false) {
                render.lineColor = lineColor;
              }
              if (lineOpacity !== false) {
                render.lineOpacity = lineOpacity;
              }
              if (lineThickness !== false) {
                render.lineThickness = lineThickness;
              }
              if (pinSize !== false) {
                render.pinSize = pinSize;
              }
              if (anchorColor !== false) {
                render.anchorColor = anchorColor;
              }
              if (anchorSize !== false) {
                render.anchorSize = anchorSize;
              }
              return this;
            },
            setEventsProxy: function () {
              var _this = this;
              var engine = this.engine;
              var world = this.localWorld;
              if (this.drawDebug) {
                MatterEvents.on(world, "compositeModified", function (composite) {
                  _this.setCompositeRenderStyle(composite);
                });
                MatterEvents.on(world, "beforeAdd", function (event) {
                  var objects = [].concat(event.object);
                  for (var i = 0; i < objects.length; i++) {
                    var obj = objects[i];
                    var render = obj.render;
                    if (obj.type === "body") {
                      _this.setBodyRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.fillColor, render.fillOpacity);
                    } else if (obj.type === "composite") {
                      _this.setCompositeRenderStyle(obj);
                    } else if (obj.type === "constraint") {
                      _this.setConstraintRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.pinSize, render.anchorColor, render.anchorSize);
                    }
                  }
                });
              }
              MatterEvents.on(world, "beforeAdd", function (event) {
                _this.emit(Events.BEFORE_ADD, event);
              });
              MatterEvents.on(world, "afterAdd", function (event) {
                _this.emit(Events.AFTER_ADD, event);
              });
              MatterEvents.on(world, "beforeRemove", function (event) {
                _this.emit(Events.BEFORE_REMOVE, event);
              });
              MatterEvents.on(world, "afterRemove", function (event) {
                _this.emit(Events.AFTER_REMOVE, event);
              });
              MatterEvents.on(engine, "beforeUpdate", function (event) {
                _this.emit(Events.BEFORE_UPDATE, event);
              });
              MatterEvents.on(engine, "afterUpdate", function (event) {
                _this.emit(Events.AFTER_UPDATE, event);
              });
              MatterEvents.on(engine, "collisionStart", function (event) {
                var pairs = event.pairs;
                var bodyA;
                var bodyB;
                if (pairs.length > 0) {
                  bodyA = pairs[0].bodyA;
                  bodyB = pairs[0].bodyB;
                }
                _this.emit(Events.COLLISION_START, event, bodyA, bodyB);
              });
              MatterEvents.on(engine, "collisionActive", function (event) {
                var pairs = event.pairs;
                var bodyA;
                var bodyB;
                if (pairs.length > 0) {
                  bodyA = pairs[0].bodyA;
                  bodyB = pairs[0].bodyB;
                }
                _this.emit(Events.COLLISION_ACTIVE, event, bodyA, bodyB);
              });
              MatterEvents.on(engine, "collisionEnd", function (event) {
                var pairs = event.pairs;
                var bodyA;
                var bodyB;
                if (pairs.length > 0) {
                  bodyA = pairs[0].bodyA;
                  bodyB = pairs[0].bodyB;
                }
                _this.emit(Events.COLLISION_END, event, bodyA, bodyB);
              });
            },
            setBounds: function (x, y, width, height, thickness, left, right, top, bottom) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 0;
              }
              if (width === void 0) {
                width = this.scene.sys.scale.width;
              }
              if (height === void 0) {
                height = this.scene.sys.scale.height;
              }
              if (thickness === void 0) {
                thickness = 64;
              }
              if (left === void 0) {
                left = true;
              }
              if (right === void 0) {
                right = true;
              }
              if (top === void 0) {
                top = true;
              }
              if (bottom === void 0) {
                bottom = true;
              }
              this.updateWall(left, "left", x - thickness, y - thickness, thickness, height + thickness * 2);
              this.updateWall(right, "right", x + width, y - thickness, thickness, height + thickness * 2);
              this.updateWall(top, "top", x, y - thickness, width, thickness);
              this.updateWall(bottom, "bottom", x, y + height, width, thickness);
              return this;
            },
            updateWall: function (add, position, x, y, width, height) {
              var wall = this.walls[position];
              if (add) {
                if (wall) {
                  MatterWorld.remove(this.localWorld, wall);
                }
                x += width / 2;
                y += height / 2;
                this.walls[position] = this.create(x, y, width, height, {
                  isStatic: true,
                  friction: 0,
                  frictionStatic: 0
                });
              } else {
                if (wall) {
                  MatterWorld.remove(this.localWorld, wall);
                }
                this.walls[position] = null;
              }
            },
            createDebugGraphic: function () {
              var graphic = this.scene.sys.add.graphics({
                x: 0,
                y: 0
              });
              graphic.setDepth(Number.MAX_VALUE);
              this.debugGraphic = graphic;
              this.drawDebug = true;
              return graphic;
            },
            disableGravity: function () {
              this.localWorld.gravity.x = 0;
              this.localWorld.gravity.y = 0;
              this.localWorld.gravity.scale = 0;
              return this;
            },
            setGravity: function (x, y, scale) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = 1;
              }
              this.localWorld.gravity.x = x;
              this.localWorld.gravity.y = y;
              if (scale !== void 0) {
                this.localWorld.gravity.scale = scale;
              }
              return this;
            },
            create: function (x, y, width, height, options) {
              var body = Bodies.rectangle(x, y, width, height, options);
              MatterWorld.add(this.localWorld, body);
              return body;
            },
            add: function (object) {
              MatterWorld.add(this.localWorld, object);
              return this;
            },
            remove: function (object, deep) {
              if (!Array.isArray(object)) {
                object = [object];
              }
              for (var i = 0; i < object.length; i++) {
                var entity = object[i];
                var body = entity.body ? entity.body : entity;
                Composite.remove(this.localWorld, body, deep);
              }
              return this;
            },
            removeConstraint: function (constraint, deep) {
              Composite.remove(this.localWorld, constraint, deep);
              return this;
            },
            convertTilemapLayer: function (tilemapLayer, options) {
              var layerData = tilemapLayer.layer;
              var tiles = tilemapLayer.getTilesWithin(0, 0, layerData.width, layerData.height, {
                isColliding: true
              });
              this.convertTiles(tiles, options);
              return this;
            },
            convertTiles: function (tiles, options) {
              if (tiles.length === 0) {
                return this;
              }
              for (var i = 0; i < tiles.length; i++) {
                new MatterTileBody(this, tiles[i], options);
              }
              return this;
            },
            nextGroup: function (isNonColliding) {
              return MatterBody.nextGroup(isNonColliding);
            },
            nextCategory: function () {
              return MatterBody.nextCategory();
            },
            pause: function () {
              this.enabled = false;
              this.emit(Events.PAUSE);
              return this;
            },
            resume: function () {
              this.enabled = true;
              this.emit(Events.RESUME);
              return this;
            },
            update: function (time, delta) {
              if (!this.enabled || !this.autoUpdate) {
                return;
              }
              var engine = this.engine;
              var runner = this.runner;
              var timing = engine.timing;
              var correction = this.correction;
              if (runner.isFixed) {
                delta = this.getDelta(time, delta);
              } else {
                delta = time - runner.timePrev || runner.delta;
                runner.timePrev = time;
                runner.deltaHistory.push(delta);
                runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);
                delta = Math.min.apply(null, runner.deltaHistory);
                delta = delta < runner.deltaMin ? runner.deltaMin : delta;
                delta = delta > runner.deltaMax ? runner.deltaMax : delta;
                correction = delta / runner.delta;
                runner.delta = delta;
              }
              if (runner.timeScalePrev !== 0) {
                correction *= timing.timeScale / runner.timeScalePrev;
              }
              if (timing.timeScale === 0) {
                correction = 0;
              }
              runner.timeScalePrev = timing.timeScale;
              runner.correction = correction;
              runner.frameCounter += 1;
              if (time - runner.counterTimestamp >= 1e3) {
                runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1e3);
                runner.counterTimestamp = time;
                runner.frameCounter = 0;
              }
              Engine.update(engine, delta, correction);
            },
            step: function (delta, correction) {
              Engine.update(this.engine, delta, correction);
            },
            update60Hz: function () {
              return 1e3 / 60;
            },
            update30Hz: function () {
              return 1e3 / 30;
            },
            has: function (body) {
              var src = body.hasOwnProperty("body") ? body.body : body;
              return Composite.get(this.localWorld, src.id, src.type) !== null;
            },
            getAllBodies: function () {
              return Composite.allBodies(this.localWorld);
            },
            getAllConstraints: function () {
              return Composite.allConstraints(this.localWorld);
            },
            getAllComposites: function () {
              return Composite.allComposites(this.localWorld);
            },
            postUpdate: function () {
              if (!this.drawDebug) {
                return;
              }
              var config = this.debugConfig;
              var engine = this.engine;
              var graphics = this.debugGraphic;
              var bodies = Composite.allBodies(this.localWorld);
              this.debugGraphic.clear();
              if (config.showBroadphase && engine.broadphase.controller) {
                this.renderGrid(engine.broadphase, graphics, config.broadphaseColor, 0.5);
              }
              if (config.showBounds) {
                this.renderBodyBounds(bodies, graphics, config.boundsColor, 0.5);
              }
              if (config.showBody || config.showStaticBody) {
                this.renderBodies(bodies);
              }
              if (config.showJoint) {
                this.renderJoints();
              }
              if (config.showAxes || config.showAngleIndicator) {
                this.renderBodyAxes(bodies, graphics, config.showAxes, config.angleColor, 0.5);
              }
              if (config.showVelocity) {
                this.renderBodyVelocity(bodies, graphics, config.velocityColor, 1, 2);
              }
              if (config.showSeparations) {
                this.renderSeparations(engine.pairs.list, graphics, config.separationColor);
              }
              if (config.showCollisions) {
                this.renderCollisions(engine.pairs.list, graphics, config.collisionColor);
              }
            },
            renderGrid: function (grid, graphics, lineColor, lineOpacity) {
              graphics.lineStyle(1, lineColor, lineOpacity);
              var bucketKeys = Common.keys(grid.buckets);
              for (var i = 0; i < bucketKeys.length; i++) {
                var bucketId = bucketKeys[i];
                if (grid.buckets[bucketId].length < 2) {
                  continue;
                }
                var region = bucketId.split(/C|R/);
                graphics.strokeRect(parseInt(region[1], 10) * grid.bucketWidth, parseInt(region[2], 10) * grid.bucketHeight, grid.bucketWidth, grid.bucketHeight);
              }
              return this;
            },
            renderSeparations: function (pairs, graphics, lineColor) {
              graphics.lineStyle(1, lineColor, 1);
              for (var i = 0; i < pairs.length; i++) {
                var pair = pairs[i];
                if (!pair.isActive) {
                  continue;
                }
                var collision = pair.collision;
                var bodyA = collision.bodyA;
                var bodyB = collision.bodyB;
                var posA = bodyA.position;
                var posB = bodyB.position;
                var penetration = collision.penetration;
                var k = !bodyA.isStatic && !bodyB.isStatic ? 4 : 1;
                if (bodyB.isStatic) {
                  k = 0;
                }
                graphics.lineBetween(posB.x, posB.y, posB.x - penetration.x * k, posB.y - penetration.y * k);
                k = !bodyA.isStatic && !bodyB.isStatic ? 4 : 1;
                if (bodyA.isStatic) {
                  k = 0;
                }
                graphics.lineBetween(posA.x, posA.y, posA.x - penetration.x * k, posA.y - penetration.y * k);
              }
              return this;
            },
            renderCollisions: function (pairs, graphics, lineColor) {
              graphics.lineStyle(1, lineColor, 0.5);
              graphics.fillStyle(lineColor, 1);
              var i;
              var pair;
              for (i = 0; i < pairs.length; i++) {
                pair = pairs[i];
                if (!pair.isActive) {
                  continue;
                }
                for (var j = 0; j < pair.activeContacts.length; j++) {
                  var contact = pair.activeContacts[j];
                  var vertex = contact.vertex;
                  graphics.fillRect(vertex.x - 2, vertex.y - 2, 5, 5);
                }
              }
              for (i = 0; i < pairs.length; i++) {
                pair = pairs[i];
                if (!pair.isActive) {
                  continue;
                }
                var collision = pair.collision;
                var contacts = pair.activeContacts;
                if (contacts.length > 0) {
                  var normalPosX = contacts[0].vertex.x;
                  var normalPosY = contacts[0].vertex.y;
                  if (contacts.length === 2) {
                    normalPosX = (contacts[0].vertex.x + contacts[1].vertex.x) / 2;
                    normalPosY = (contacts[0].vertex.y + contacts[1].vertex.y) / 2;
                  }
                  if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic) {
                    graphics.lineBetween(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8, normalPosX, normalPosY);
                  } else {
                    graphics.lineBetween(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8, normalPosX, normalPosY);
                  }
                }
              }
              return this;
            },
            renderBodyBounds: function (bodies, graphics, lineColor, lineOpacity) {
              graphics.lineStyle(1, lineColor, lineOpacity);
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                if (!body.render.visible) {
                  continue;
                }
                var bounds = body.bounds;
                if (bounds) {
                  graphics.strokeRect(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);
                } else {
                  var parts = body.parts;
                  for (var j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                    var part = parts[j];
                    graphics.strokeRect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);
                  }
                }
              }
              return this;
            },
            renderBodyAxes: function (bodies, graphics, showAxes, lineColor, lineOpacity) {
              graphics.lineStyle(1, lineColor, lineOpacity);
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                var parts = body.parts;
                if (!body.render.visible) {
                  continue;
                }
                var part;
                var j;
                var k;
                if (showAxes) {
                  for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                    part = parts[j];
                    for (k = 0; k < part.axes.length; k++) {
                      var axis = part.axes[k];
                      graphics.lineBetween(part.position.x, part.position.y, part.position.x + axis.x * 20, part.position.y + axis.y * 20);
                    }
                  }
                } else {
                  for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                    part = parts[j];
                    for (k = 0; k < part.axes.length; k++) {
                      graphics.lineBetween(part.position.x, part.position.y, (part.vertices[0].x + part.vertices[part.vertices.length - 1].x) / 2, (part.vertices[0].y + part.vertices[part.vertices.length - 1].y) / 2);
                    }
                  }
                }
              }
              return this;
            },
            renderBodyVelocity: function (bodies, graphics, lineColor, lineOpacity, lineThickness) {
              graphics.lineStyle(lineThickness, lineColor, lineOpacity);
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                if (!body.render.visible) {
                  continue;
                }
                graphics.lineBetween(body.position.x, body.position.y, body.position.x + (body.position.x - body.positionPrev.x) * 2, body.position.y + (body.position.y - body.positionPrev.y) * 2);
              }
              return this;
            },
            renderBodies: function (bodies) {
              var graphics = this.debugGraphic;
              var config = this.debugConfig;
              var showBody = config.showBody;
              var showStaticBody = config.showStaticBody;
              var showSleeping = config.showSleeping;
              var showInternalEdges = config.showInternalEdges;
              var showConvexHulls = config.showConvexHulls;
              var renderFill = config.renderFill;
              var renderLine = config.renderLine;
              var staticBodySleepOpacity = config.staticBodySleepOpacity;
              var sleepFillColor = config.sleepFillColor;
              var sleepLineColor = config.sleepLineColor;
              var hullColor = config.hullColor;
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                if (!body.render.visible) {
                  continue;
                }
                if (!showStaticBody && body.isStatic || !showBody && !body.isStatic) {
                  continue;
                }
                var lineColor = body.render.lineColor;
                var lineOpacity = body.render.lineOpacity;
                var lineThickness = body.render.lineThickness;
                var fillColor = body.render.fillColor;
                var fillOpacity = body.render.fillOpacity;
                if (showSleeping && body.isSleeping) {
                  if (body.isStatic) {
                    lineOpacity *= staticBodySleepOpacity;
                    fillOpacity *= staticBodySleepOpacity;
                  } else {
                    lineColor = sleepLineColor;
                    fillColor = sleepFillColor;
                  }
                }
                if (!renderFill) {
                  fillColor = null;
                }
                if (!renderLine) {
                  lineColor = null;
                }
                this.renderBody(body, graphics, showInternalEdges, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity);
                var partsLength = body.parts.length;
                if (showConvexHulls && partsLength > 1) {
                  this.renderConvexHull(body, graphics, hullColor, lineThickness);
                }
              }
            },
            renderBody: function (body, graphics, showInternalEdges, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity) {
              if (lineColor === void 0) {
                lineColor = null;
              }
              if (lineOpacity === void 0) {
                lineOpacity = null;
              }
              if (lineThickness === void 0) {
                lineThickness = 1;
              }
              if (fillColor === void 0) {
                fillColor = null;
              }
              if (fillOpacity === void 0) {
                fillOpacity = null;
              }
              var config = this.debugConfig;
              var sensorFillColor = config.sensorFillColor;
              var sensorLineColor = config.sensorLineColor;
              var parts = body.parts;
              var partsLength = parts.length;
              for (var k = partsLength > 1 ? 1 : 0; k < partsLength; k++) {
                var part = parts[k];
                var render = part.render;
                var opacity = render.opacity;
                if (!render.visible || opacity === 0 || part.isSensor && !config.showSensors) {
                  continue;
                }
                var circleRadius = part.circleRadius;
                graphics.beginPath();
                if (part.isSensor) {
                  if (fillColor !== null) {
                    graphics.fillStyle(sensorFillColor, fillOpacity * opacity);
                  }
                  if (lineColor !== null) {
                    graphics.lineStyle(lineThickness, sensorLineColor, lineOpacity * opacity);
                  }
                } else {
                  if (fillColor !== null) {
                    graphics.fillStyle(fillColor, fillOpacity * opacity);
                  }
                  if (lineColor !== null) {
                    graphics.lineStyle(lineThickness, lineColor, lineOpacity * opacity);
                  }
                }
                if (circleRadius) {
                  graphics.arc(part.position.x, part.position.y, circleRadius, 0, 2 * Math.PI);
                } else {
                  var vertices = part.vertices;
                  var vertLength = vertices.length;
                  graphics.moveTo(vertices[0].x, vertices[0].y);
                  for (var j = 1; j < vertLength; j++) {
                    var vert = vertices[j];
                    if (!vertices[j - 1].isInternal || showInternalEdges) {
                      graphics.lineTo(vert.x, vert.y);
                    } else {
                      graphics.moveTo(vert.x, vert.y);
                    }
                    if (j < vertLength && vert.isInternal && !showInternalEdges) {
                      var nextIndex = (j + 1) % vertLength;
                      graphics.moveTo(vertices[nextIndex].x, vertices[nextIndex].y);
                    }
                  }
                  graphics.closePath();
                }
                if (fillColor !== null) {
                  graphics.fillPath();
                }
                if (lineColor !== null) {
                  graphics.strokePath();
                }
              }
              if (config.showPositions && !body.isStatic) {
                var px = body.position.x;
                var py = body.position.y;
                var hs = Math.ceil(config.positionSize / 2);
                graphics.fillStyle(config.positionColor, 1);
                graphics.fillRect(px - hs, py - hs, config.positionSize, config.positionSize);
              }
              return this;
            },
            renderConvexHull: function (body, graphics, hullColor, lineThickness) {
              if (lineThickness === void 0) {
                lineThickness = 1;
              }
              var parts = body.parts;
              var partsLength = parts.length;
              if (partsLength > 1) {
                var verts = body.vertices;
                graphics.lineStyle(lineThickness, hullColor);
                graphics.beginPath();
                graphics.moveTo(verts[0].x, verts[0].y);
                for (var v = 1; v < verts.length; v++) {
                  graphics.lineTo(verts[v].x, verts[v].y);
                }
                graphics.lineTo(verts[0].x, verts[0].y);
                graphics.strokePath();
              }
              return this;
            },
            renderJoints: function () {
              var graphics = this.debugGraphic;
              var constraints = Composite.allConstraints(this.localWorld);
              for (var i = 0; i < constraints.length; i++) {
                var config = constraints[i].render;
                var lineColor = config.lineColor;
                var lineOpacity = config.lineOpacity;
                var lineThickness = config.lineThickness;
                var pinSize = config.pinSize;
                var anchorColor = config.anchorColor;
                var anchorSize = config.anchorSize;
                this.renderConstraint(constraints[i], graphics, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize);
              }
            },
            renderConstraint: function (constraint, graphics, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize) {
              var render = constraint.render;
              if (!render.visible || !constraint.pointA || !constraint.pointB) {
                return this;
              }
              graphics.lineStyle(lineThickness, lineColor, lineOpacity);
              var bodyA = constraint.bodyA;
              var bodyB = constraint.bodyB;
              var start;
              var end;
              if (bodyA) {
                start = Vector.add(bodyA.position, constraint.pointA);
              } else {
                start = constraint.pointA;
              }
              if (render.type === "pin") {
                graphics.strokeCircle(start.x, start.y, pinSize);
              } else {
                if (bodyB) {
                  end = Vector.add(bodyB.position, constraint.pointB);
                } else {
                  end = constraint.pointB;
                }
                graphics.beginPath();
                graphics.moveTo(start.x, start.y);
                if (render.type === "spring") {
                  var delta = Vector.sub(end, start);
                  var normal = Vector.perp(Vector.normalise(delta));
                  var coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20));
                  var offset;
                  for (var j = 1; j < coils; j += 1) {
                    offset = j % 2 === 0 ? 1 : -1;
                    graphics.lineTo(start.x + delta.x * (j / coils) + normal.x * offset * 4, start.y + delta.y * (j / coils) + normal.y * offset * 4);
                  }
                }
                graphics.lineTo(end.x, end.y);
              }
              graphics.strokePath();
              if (render.anchors && anchorSize > 0) {
                graphics.fillStyle(anchorColor);
                graphics.fillCircle(start.x, start.y, anchorSize);
                graphics.fillCircle(end.x, end.y, anchorSize);
              }
              return this;
            },
            resetCollisionIDs: function () {
              Body._nextCollidingGroupId = 1;
              Body._nextNonCollidingGroupId = -1;
              Body._nextCategory = 1;
              return this;
            },
            shutdown: function () {
              MatterEvents.off(this.engine);
              this.removeAllListeners();
              MatterWorld.clear(this.localWorld, false);
              Engine.clear(this.engine);
              if (this.drawDebug) {
                this.debugGraphic.destroy();
              }
            },
            destroy: function () {
              this.shutdown();
            }
          });
          module2.exports = World;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            BasePlugin: __webpack_require__(540),
            DefaultPlugins: __webpack_require__(197),
            PluginCache: __webpack_require__(24),
            PluginManager: __webpack_require__(414),
            ScenePlugin: __webpack_require__(1404)
          };
        }, function (module2, exports2, __webpack_require__) {
          var BasePlugin = __webpack_require__(540);
          var Class = __webpack_require__(0);
          var SceneEvents = __webpack_require__(20);
          var ScenePlugin = new Class({
            Extends: BasePlugin,
            initialize: function ScenePlugin2(scene, pluginManager, pluginKey) {
              BasePlugin.call(this, pluginManager);
              this.scene = scene;
              this.systems = scene.sys;
              this.pluginKey = pluginKey;
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
            },
            boot: function () {},
            destroy: function () {
              this.pluginManager = null;
              this.game = null;
              this.scene = null;
              this.systems = null;
            }
          });
          module2.exports = ScenePlugin;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Canvas: __webpack_require__(1406),
            Events: __webpack_require__(91),
            Snapshot: __webpack_require__(1407),
            WebGL: __webpack_require__(1408)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            CanvasRenderer: __webpack_require__(368),
            GetBlendModes: __webpack_require__(370),
            SetTransform: __webpack_require__(30)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Canvas: __webpack_require__(369),
            WebGL: __webpack_require__(383)
          };
        }, function (module2, exports2, __webpack_require__) {
          var WEBGL_CONST = __webpack_require__(107);
          var Extend = __webpack_require__(17);
          var WebGL = {
            PipelineManager: __webpack_require__(372),
            Pipelines: __webpack_require__(1409),
            RenderTarget: __webpack_require__(141),
            Utils: __webpack_require__(12),
            WebGLPipeline: __webpack_require__(58),
            WebGLRenderer: __webpack_require__(371),
            WebGLShader: __webpack_require__(375)
          };
          WebGL = Extend(false, WebGL, WEBGL_CONST);
          module2.exports = WebGL;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(92);
          var Extend = __webpack_require__(17);
          var Pipelines = {
            BitmapMaskPipeline: __webpack_require__(373),
            Events: __webpack_require__(374),
            GraphicsPipeline: __webpack_require__(376),
            LightPipeline: __webpack_require__(377),
            MultiPipeline: __webpack_require__(108),
            PointLightPipeline: __webpack_require__(378),
            PostFXPipeline: __webpack_require__(1410),
            RopePipeline: __webpack_require__(379),
            SinglePipeline: __webpack_require__(380),
            UtilityPipeline: __webpack_require__(381)
          };
          Pipelines = Extend(false, Pipelines, CONST);
          module2.exports = Pipelines;
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var ColorMatrix = __webpack_require__(198);
          var GetFastValue = __webpack_require__(2);
          var ShaderSourceFS = __webpack_require__(1411);
          var ShaderSourceVS = __webpack_require__(382);
          var WebGLPipeline = __webpack_require__(58);
          var PostFXPipeline = new Class({
            Extends: WebGLPipeline,
            initialize: function PostFXPipeline2(config) {
              config.renderTarget = GetFastValue(config, "renderTarget", 1);
              config.fragShader = GetFastValue(config, "fragShader", ShaderSourceFS);
              config.vertShader = GetFastValue(config, "vertShader", ShaderSourceVS);
              config.attributes = GetFastValue(config, "attributes", [{
                name: "inPosition",
                size: 2
              }, {
                name: "inTexCoord",
                size: 2
              }]);
              config.batchSize = 1;
              config.vertices = [-1, -1, 0, 0, -1, 1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, 1, 1, 1, 1, 1, -1, 1, 0];
              WebGLPipeline.call(this, config);
              this.isPostFX = true;
              this.gameObject;
              this.colorMatrix = new ColorMatrix();
              this.fullFrame1;
              this.fullFrame2;
              this.halfFrame1;
              this.halfFrame2;
              if (this.renderer.isBooted) {
                this.manager = this.renderer.pipelines;
                this.boot();
              }
            },
            boot: function () {
              WebGLPipeline.prototype.boot.call(this);
              var utility = this.manager.UTILITY_PIPELINE;
              this.fullFrame1 = utility.fullFrame1;
              this.fullFrame2 = utility.fullFrame2;
              this.halfFrame1 = utility.halfFrame1;
              this.halfFrame2 = utility.halfFrame2;
              this.set1i("uMainSampler", 0);
            },
            onDraw: function (renderTarget) {
              this.bindAndDraw(renderTarget);
            },
            copyFrame: function (source, target, brightness, clear, clearAlpha) {
              this.manager.copyFrame(source, target, brightness, clear, clearAlpha);
            },
            copyToGame: function (source) {
              this.manager.copyToGame(source);
            },
            drawFrame: function (source, target, clearAlpha) {
              this.manager.drawFrame(source, target, clearAlpha, this.colorMatrix);
            },
            blendFrames: function (source1, source2, target, strength, clearAlpha) {
              this.manager.blendFrames(source1, source2, target, strength, clearAlpha);
            },
            blendFramesAdditive: function (source1, source2, target, strength, clearAlpha) {
              this.manager.blendFramesAdditive(source1, source2, target, strength, clearAlpha);
            },
            clearFrame: function (target, clearAlpha) {
              this.manager.clearFrame(target, clearAlpha);
            },
            blitFrame: function (source, target, brightness, clear, clearAlpha, eraseMode) {
              this.manager.blitFrame(source, target, brightness, clear, clearAlpha, eraseMode);
            },
            copyFrameRect: function (source, target, x, y, width, height, clear, clearAlpha) {
              this.manager.copyFrameRect(source, target, x, y, width, height, clear, clearAlpha);
            },
            bindAndDraw: function (source, target, clear, clearAlpha, currentShader) {
              if (clear === void 0) {
                clear = true;
              }
              if (clearAlpha === void 0) {
                clearAlpha = true;
              }
              var gl = this.gl;
              var renderer = this.renderer;
              this.bind(currentShader);
              this.set1i("uMainSampler", 0);
              if (target) {
                gl.viewport(0, 0, target.width, target.height);
                gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
                if (clear) {
                  if (clearAlpha) {
                    gl.clearColor(0, 0, 0, 0);
                  } else {
                    gl.clearColor(0, 0, 0, 1);
                  }
                  gl.clear(gl.COLOR_BUFFER_BIT);
                }
              } else {
                renderer.popFramebuffer(false, false, false);
                if (!renderer.currentFramebuffer) {
                  gl.viewport(0, 0, renderer.width, renderer.height);
                }
              }
              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, source.texture);
              gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
              gl.drawArrays(gl.TRIANGLES, 0, 6);
              if (!target) {
                renderer.resetTextures();
              } else {
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              }
            }
          });
          module2.exports = PostFXPipeline;
        }, function (module2, exports2) {
          module2.exports = ["#define SHADER_NAME PHASER_POSTFX_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler;", "", "varying vec2 outTexCoord;", "", "void main ()", "{", "    gl_FragColor = texture2D(uMainSampler, outTexCoord);", "}", ""].join("\n");
        }, function (module2, exports2, __webpack_require__) {
          var Extend = __webpack_require__(17);
          var CONST = __webpack_require__(201);
          var Scale = {
            Center: __webpack_require__(403),
            Events: __webpack_require__(104),
            Orientation: __webpack_require__(404),
            ScaleManager: __webpack_require__(415),
            ScaleModes: __webpack_require__(405),
            Zoom: __webpack_require__(406)
          };
          Scale = Extend(false, Scale, CONST.CENTER);
          Scale = Extend(false, Scale, CONST.ORIENTATION);
          Scale = Extend(false, Scale, CONST.SCALE_MODE);
          Scale = Extend(false, Scale, CONST.ZOOM);
          module2.exports = Scale;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(144);
          var Extend = __webpack_require__(17);
          var Scene = {
            Events: __webpack_require__(20),
            GetPhysicsPlugins: __webpack_require__(419),
            GetScenePlugins: __webpack_require__(420),
            SceneManager: __webpack_require__(417),
            ScenePlugin: __webpack_require__(1414),
            Settings: __webpack_require__(421),
            Systems: __webpack_require__(204)
          };
          Scene = Extend(false, Scene, CONST);
          module2.exports = Scene;
        }, function (module2, exports2, __webpack_require__) {
          var Clamp = __webpack_require__(18);
          var Class = __webpack_require__(0);
          var Events = __webpack_require__(20);
          var GetFastValue = __webpack_require__(2);
          var PluginCache = __webpack_require__(24);
          var ScenePlugin = new Class({
            initialize: function ScenePlugin2(scene) {
              this.scene = scene;
              this.systems = scene.sys;
              this.settings = scene.sys.settings;
              this.key = scene.sys.settings.key;
              this.manager = scene.sys.game.scene;
              this.transitionProgress = 0;
              this._elapsed = 0;
              this._target = null;
              this._duration = 0;
              this._onUpdate;
              this._onUpdateScope;
              this._willSleep = false;
              this._willRemove = false;
              scene.sys.events.once(Events.BOOT, this.boot, this);
              scene.sys.events.on(Events.START, this.pluginStart, this);
            },
            boot: function () {
              this.systems.events.once(Events.DESTROY, this.destroy, this);
            },
            pluginStart: function () {
              this._target = null;
              this.systems.events.once(Events.SHUTDOWN, this.shutdown, this);
            },
            start: function (key, data) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.queueOp("stop", this.key);
              this.manager.queueOp("start", key, data);
              return this;
            },
            restart: function (data) {
              var key = this.key;
              this.manager.queueOp("stop", key);
              this.manager.queueOp("start", key, data);
              return this;
            },
            transition: function (config) {
              if (config === void 0) {
                config = {};
              }
              var key = GetFastValue(config, "target", false);
              var target = this.manager.getScene(key);
              if (!key || !this.checkValidTransition(target)) {
                return false;
              }
              var duration = GetFastValue(config, "duration", 1e3);
              this._elapsed = 0;
              this._target = target;
              this._duration = duration;
              this._willSleep = GetFastValue(config, "sleep", false);
              this._willRemove = GetFastValue(config, "remove", false);
              var callback = GetFastValue(config, "onUpdate", null);
              if (callback) {
                this._onUpdate = callback;
                this._onUpdateScope = GetFastValue(config, "onUpdateScope", this.scene);
              }
              var allowInput = GetFastValue(config, "allowInput", false);
              this.settings.transitionAllowInput = allowInput;
              var targetSettings = target.sys.settings;
              targetSettings.isTransition = true;
              targetSettings.transitionFrom = this.scene;
              targetSettings.transitionDuration = duration;
              targetSettings.transitionAllowInput = allowInput;
              if (GetFastValue(config, "moveAbove", false)) {
                this.manager.moveAbove(this.key, key);
              } else if (GetFastValue(config, "moveBelow", false)) {
                this.manager.moveBelow(this.key, key);
              }
              if (target.sys.isSleeping()) {
                target.sys.wake(GetFastValue(config, "data"));
              } else {
                this.manager.start(key, GetFastValue(config, "data"));
              }
              this.systems.events.emit(Events.TRANSITION_OUT, target, duration);
              this.systems.events.on(Events.UPDATE, this.step, this);
              return true;
            },
            checkValidTransition: function (target) {
              if (!target || target.sys.isActive() || target.sys.isTransitioning() || target === this.scene || this.systems.isTransitioning()) {
                return false;
              }
              return true;
            },
            step: function (time, delta) {
              this._elapsed += delta;
              this.transitionProgress = Clamp(this._elapsed / this._duration, 0, 1);
              if (this._onUpdate) {
                this._onUpdate.call(this._onUpdateScope, this.transitionProgress);
              }
              if (this._elapsed >= this._duration) {
                this.transitionComplete();
              }
            },
            transitionComplete: function () {
              var targetSys = this._target.sys;
              var targetSettings = this._target.sys.settings;
              this.systems.events.off(Events.UPDATE, this.step, this);
              targetSys.events.emit(Events.TRANSITION_COMPLETE, this.scene);
              targetSettings.isTransition = false;
              targetSettings.transitionFrom = null;
              this._duration = 0;
              this._target = null;
              this._onUpdate = null;
              this._onUpdateScope = null;
              if (this._willRemove) {
                this.manager.remove(this.key);
              } else if (this._willSleep) {
                this.systems.sleep();
              } else {
                this.manager.stop(this.key);
              }
            },
            add: function (key, sceneConfig, autoStart, data) {
              return this.manager.add(key, sceneConfig, autoStart, data);
            },
            launch: function (key, data) {
              if (key && key !== this.key) {
                this.manager.queueOp("start", key, data);
              }
              return this;
            },
            run: function (key, data) {
              if (key && key !== this.key) {
                this.manager.queueOp("run", key, data);
              }
              return this;
            },
            pause: function (key, data) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.queueOp("pause", key, data);
              return this;
            },
            resume: function (key, data) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.queueOp("resume", key, data);
              return this;
            },
            sleep: function (key, data) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.queueOp("sleep", key, data);
              return this;
            },
            wake: function (key, data) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.queueOp("wake", key, data);
              return this;
            },
            switch: function (key) {
              if (key !== this.key) {
                this.manager.queueOp("switch", this.key, key);
              }
              return this;
            },
            stop: function (key, data) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.queueOp("stop", key, data);
              return this;
            },
            setActive: function (value, key, data) {
              if (key === void 0) {
                key = this.key;
              }
              var scene = this.manager.getScene(key);
              if (scene) {
                scene.sys.setActive(value, data);
              }
              return this;
            },
            setVisible: function (value, key) {
              if (key === void 0) {
                key = this.key;
              }
              var scene = this.manager.getScene(key);
              if (scene) {
                scene.sys.setVisible(value);
              }
              return this;
            },
            isSleeping: function (key) {
              if (key === void 0) {
                key = this.key;
              }
              return this.manager.isSleeping(key);
            },
            isActive: function (key) {
              if (key === void 0) {
                key = this.key;
              }
              return this.manager.isActive(key);
            },
            isPaused: function (key) {
              if (key === void 0) {
                key = this.key;
              }
              return this.manager.isPaused(key);
            },
            isVisible: function (key) {
              if (key === void 0) {
                key = this.key;
              }
              return this.manager.isVisible(key);
            },
            swapPosition: function (keyA, keyB) {
              if (keyB === void 0) {
                keyB = this.key;
              }
              if (keyA !== keyB) {
                this.manager.swapPosition(keyA, keyB);
              }
              return this;
            },
            moveAbove: function (keyA, keyB) {
              if (keyB === void 0) {
                keyB = this.key;
              }
              if (keyA !== keyB) {
                this.manager.moveAbove(keyA, keyB);
              }
              return this;
            },
            moveBelow: function (keyA, keyB) {
              if (keyB === void 0) {
                keyB = this.key;
              }
              if (keyA !== keyB) {
                this.manager.moveBelow(keyA, keyB);
              }
              return this;
            },
            remove: function (key) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.remove(key);
              return this;
            },
            moveUp: function (key) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.moveUp(key);
              return this;
            },
            moveDown: function (key) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.moveDown(key);
              return this;
            },
            bringToTop: function (key) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.bringToTop(key);
              return this;
            },
            sendToBack: function (key) {
              if (key === void 0) {
                key = this.key;
              }
              this.manager.sendToBack(key);
              return this;
            },
            get: function (key) {
              return this.manager.getScene(key);
            },
            getIndex: function (key) {
              if (key === void 0) {
                key = this.key;
              }
              return this.manager.getIndex(key);
            },
            shutdown: function () {
              var eventEmitter = this.systems.events;
              eventEmitter.off(Events.SHUTDOWN, this.shutdown, this);
              eventEmitter.off(Events.POST_UPDATE, this.step, this);
              eventEmitter.off(Events.TRANSITION_OUT);
            },
            destroy: function () {
              this.shutdown();
              this.scene.sys.events.off(Events.START, this.start, this);
              this.scene = null;
              this.systems = null;
              this.settings = null;
              this.manager = null;
            }
          });
          PluginCache.register("ScenePlugin", ScenePlugin, "scenePlugin");
          module2.exports = ScenePlugin;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Events: __webpack_require__(438),
            List: __webpack_require__(110),
            Map: __webpack_require__(102),
            ProcessQueue: __webpack_require__(211),
            RTree: __webpack_require__(531),
            Set: __webpack_require__(149),
            Size: __webpack_require__(416)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Extend = __webpack_require__(17);
          var FilterMode = __webpack_require__(1417);
          var Textures = {
            CanvasTexture: __webpack_require__(423),
            Events: __webpack_require__(106),
            FilterMode,
            Frame: __webpack_require__(109),
            Parsers: __webpack_require__(425),
            Texture: __webpack_require__(206),
            TextureManager: __webpack_require__(422),
            TextureSource: __webpack_require__(424)
          };
          Textures = Extend(false, Textures, FilterMode);
          module2.exports = Textures;
        }, function (module2, exports2) {
          var CONST = {
            LINEAR: 0,
            NEAREST: 1
          };
          module2.exports = CONST;
        }, function (module2, exports2, __webpack_require__) {
          var Extend = __webpack_require__(17);
          var CONST = __webpack_require__(1419);
          var Tilemaps = {
            Components: __webpack_require__(251),
            Parsers: __webpack_require__(1452),
            Formats: __webpack_require__(40),
            ImageCollection: __webpack_require__(576),
            ParseToTilemap: __webpack_require__(262),
            Tile: __webpack_require__(85),
            Tilemap: __webpack_require__(580),
            TilemapCreator: __webpack_require__(1459),
            TilemapFactory: __webpack_require__(1460),
            Tileset: __webpack_require__(122),
            TilemapLayer: __webpack_require__(581),
            Orientation: __webpack_require__(29),
            LayerData: __webpack_require__(120),
            MapData: __webpack_require__(121),
            ObjectLayer: __webpack_require__(572)
          };
          Tilemaps = Extend(false, Tilemaps, CONST.ORIENTATION);
          module2.exports = Tilemaps;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = {
            ORIENTATION: __webpack_require__(29)
          };
          module2.exports = CONST;
        }, function (module2, exports2, __webpack_require__) {
          var GetTilesWithin = __webpack_require__(26);
          var CalculateFacesWithin = __webpack_require__(63);
          var Copy = function (srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer) {
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            if (srcTileX < 0) {
              srcTileX = 0;
            }
            if (srcTileY < 0) {
              srcTileY = 0;
            }
            var srcTiles = GetTilesWithin(srcTileX, srcTileY, width, height, null, layer);
            var offsetX = destTileX - srcTileX;
            var offsetY = destTileY - srcTileY;
            for (var i = 0; i < srcTiles.length; i++) {
              var tileX = srcTiles[i].x + offsetX;
              var tileY = srcTiles[i].y + offsetY;
              if (tileX >= 0 && tileX < layer.width && tileY >= 0 && tileY < layer.height) {
                if (layer.data[tileY][tileX]) {
                  layer.data[tileY][tileX].copy(srcTiles[i]);
                }
              }
            }
            if (recalculateFaces) {
              CalculateFacesWithin(destTileX - 1, destTileY - 1, width + 2, height + 2, layer);
            }
          };
          module2.exports = Copy;
        }, function (module2, exports2, __webpack_require__) {
          var GetTilesWithin = __webpack_require__(26);
          var ReplaceByIndex = __webpack_require__(542);
          var CreateFromTiles = function (indexes, replacements, spriteConfig, scene, camera, layer) {
            if (!spriteConfig) {
              spriteConfig = {};
            }
            if (!Array.isArray(indexes)) {
              indexes = [indexes];
            }
            var tilemapLayer = layer.tilemapLayer;
            if (!scene) {
              scene = tilemapLayer.scene;
            }
            if (!camera) {
              camera = scene.cameras.main;
            }
            var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);
            var sprites = [];
            var i;
            for (i = 0; i < tiles.length; i++) {
              var tile = tiles[i];
              if (indexes.indexOf(tile.index) !== -1) {
                var point = tilemapLayer.tileToWorldXY(tile.x, tile.y, void 0, camera, layer);
                spriteConfig.x = point.x;
                spriteConfig.y = point.y;
                sprites.push(scene.make.sprite(spriteConfig));
              }
            }
            if (typeof replacements === "number") {
              for (i = 0; i < indexes.length; i++) {
                ReplaceByIndex(indexes[i], replacements, 0, 0, layer.width, layer.height, layer);
              }
            } else if (Array.isArray(replacements)) {
              for (i = 0; i < indexes.length; i++) {
                ReplaceByIndex(indexes[i], replacements[i], 0, 0, layer.width, layer.height, layer);
              }
            }
            return sprites;
          };
          module2.exports = CreateFromTiles;
        }, function (module2, exports2, __webpack_require__) {
          var GetTilesWithin = __webpack_require__(26);
          var CalculateFacesWithin = __webpack_require__(63);
          var SetTileCollision = __webpack_require__(72);
          var Fill = function (index, tileX, tileY, width, height, recalculateFaces, layer) {
            var doesIndexCollide = layer.collideIndexes.indexOf(index) !== -1;
            var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
            for (var i = 0; i < tiles.length; i++) {
              tiles[i].index = index;
              SetTileCollision(tiles[i], doesIndexCollide);
            }
            if (recalculateFaces) {
              CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);
            }
          };
          module2.exports = Fill;
        }, function (module2, exports2, __webpack_require__) {
          var GetTilesWithin = __webpack_require__(26);
          var FilterTiles = function (callback, context, tileX, tileY, width, height, filteringOptions, layer) {
            var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
            return tiles.filter(callback, context);
          };
          module2.exports = FilterTiles;
        }, function (module2, exports2) {
          var FindByIndex = function (findIndex, skip, reverse, layer) {
            if (skip === void 0) {
              skip = 0;
            }
            if (reverse === void 0) {
              reverse = false;
            }
            var count = 0;
            var tx;
            var ty;
            var tile;
            if (reverse) {
              for (ty = layer.height - 1; ty >= 0; ty--) {
                for (tx = layer.width - 1; tx >= 0; tx--) {
                  tile = layer.data[ty][tx];
                  if (tile && tile.index === findIndex) {
                    if (count === skip) {
                      return tile;
                    } else {
                      count += 1;
                    }
                  }
                }
              }
            } else {
              for (ty = 0; ty < layer.height; ty++) {
                for (tx = 0; tx < layer.width; tx++) {
                  tile = layer.data[ty][tx];
                  if (tile && tile.index === findIndex) {
                    if (count === skip) {
                      return tile;
                    } else {
                      count += 1;
                    }
                  }
                }
              }
            }
            return null;
          };
          module2.exports = FindByIndex;
        }, function (module2, exports2, __webpack_require__) {
          var GetTilesWithin = __webpack_require__(26);
          var FindTile = function (callback, context, tileX, tileY, width, height, filteringOptions, layer) {
            var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
            return tiles.find(callback, context) || null;
          };
          module2.exports = FindTile;
        }, function (module2, exports2, __webpack_require__) {
          var GetTilesWithin = __webpack_require__(26);
          var ForEachTile = function (callback, context, tileX, tileY, width, height, filteringOptions, layer) {
            var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
            tiles.forEach(callback, context);
          };
          module2.exports = ForEachTile;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(29);
          var CullTiles = __webpack_require__(544);
          var HexagonalCullTiles = __webpack_require__(545);
          var IsometricCullTiles = __webpack_require__(547);
          var NOOP = __webpack_require__(1);
          var StaggeredCullTiles = __webpack_require__(548);
          var GetCullTilesFunction = function (orientation) {
            if (orientation === CONST.ORTHOGONAL) {
              return CullTiles;
            } else if (orientation === CONST.HEXAGONAL) {
              return HexagonalCullTiles;
            } else if (orientation === CONST.STAGGERED) {
              return StaggeredCullTiles;
            } else if (orientation === CONST.ISOMETRIC) {
              return IsometricCullTiles;
            } else {
              return NOOP;
            }
          };
          module2.exports = GetCullTilesFunction;
        }, function (module2, exports2, __webpack_require__) {
          var GetTileAt = __webpack_require__(158);
          var Vector2 = __webpack_require__(3);
          var point = new Vector2();
          var GetTileAtWorldXY = function (worldX, worldY, nonNull, camera, layer) {
            layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera);
            return GetTileAt(point.x, point.y, nonNull, layer);
          };
          module2.exports = GetTileAtWorldXY;
        }, function (module2, exports2, __webpack_require__) {
          var Geom = __webpack_require__(483);
          var GetTilesWithin = __webpack_require__(26);
          var Intersects = __webpack_require__(484);
          var NOOP = __webpack_require__(1);
          var Vector2 = __webpack_require__(3);
          var TriangleToRectangle = function (triangle, rect) {
            return Intersects.RectangleToTriangle(rect, triangle);
          };
          var point = new Vector2();
          var pointStart = new Vector2();
          var pointEnd = new Vector2();
          var GetTilesWithinShape = function (shape, filteringOptions, camera, layer) {
            if (shape === void 0) {
              return [];
            }
            var intersectTest = NOOP;
            if (shape instanceof Geom.Circle) {
              intersectTest = Intersects.CircleToRectangle;
            } else if (shape instanceof Geom.Rectangle) {
              intersectTest = Intersects.RectangleToRectangle;
            } else if (shape instanceof Geom.Triangle) {
              intersectTest = TriangleToRectangle;
            } else if (shape instanceof Geom.Line) {
              intersectTest = Intersects.LineToRectangle;
            }
            layer.tilemapLayer.worldToTileXY(shape.left, shape.top, true, pointStart, camera);
            var xStart = pointStart.x;
            var yStart = pointStart.y;
            layer.tilemapLayer.worldToTileXY(shape.right, shape.bottom, true, pointEnd, camera);
            var xEnd = Math.ceil(pointEnd.x);
            var yEnd = Math.ceil(pointEnd.y);
            var width = Math.max(xEnd - xStart, 1);
            var height = Math.max(yEnd - yStart, 1);
            var tiles = GetTilesWithin(xStart, yStart, width, height, filteringOptions, layer);
            var tileWidth = layer.tileWidth;
            var tileHeight = layer.tileHeight;
            if (layer.tilemapLayer) {
              tileWidth *= layer.tilemapLayer.scaleX;
              tileHeight *= layer.tilemapLayer.scaleY;
            }
            var results = [];
            var tileRect = new Geom.Rectangle(0, 0, tileWidth, tileHeight);
            for (var i = 0; i < tiles.length; i++) {
              var tile = tiles[i];
              layer.tilemapLayer.tileToWorldXY(tile.x, tile.y, point, camera);
              tileRect.x = point.x;
              tileRect.y = point.y;
              if (intersectTest(shape, tileRect)) {
                results.push(tile);
              }
            }
            return results;
          };
          module2.exports = GetTilesWithinShape;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(29);
          var NOOP = __webpack_require__(1);
          var TileToWorldX = __webpack_require__(253);
          var GetTileToWorldXFunction = function (orientation) {
            if (orientation === CONST.ORTHOGONAL) {
              return TileToWorldX;
            } else {
              return NOOP;
            }
          };
          module2.exports = GetTileToWorldXFunction;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(29);
          var HexagonalTileToWorldXY = __webpack_require__(550);
          var IsometricTileToWorldXY = __webpack_require__(551);
          var NOOP = __webpack_require__(1);
          var StaggeredTileToWorldXY = __webpack_require__(552);
          var TileToWorldXY = __webpack_require__(553);
          var GetTileToWorldXYFunction = function (orientation) {
            if (orientation === CONST.ORTHOGONAL) {
              return TileToWorldXY;
            } else if (orientation === CONST.ISOMETRIC) {
              return IsometricTileToWorldXY;
            } else if (orientation === CONST.HEXAGONAL) {
              return HexagonalTileToWorldXY;
            } else if (orientation === CONST.STAGGERED) {
              return StaggeredTileToWorldXY;
            } else {
              return NOOP;
            }
          };
          module2.exports = GetTileToWorldXYFunction;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(29);
          var HexagonalTileToWorldY = __webpack_require__(554);
          var NOOP = __webpack_require__(1);
          var StaggeredTileToWorldY = __webpack_require__(555);
          var TileToWorldY = __webpack_require__(254);
          var GetTileToWorldYFunction = function (orientation) {
            if (orientation === CONST.ORTHOGONAL) {
              return TileToWorldY;
            } else if (orientation === CONST.HEXAGONAL) {
              return HexagonalTileToWorldY;
            } else if (orientation === CONST.STAGGERED) {
              return StaggeredTileToWorldY;
            } else {
              return NOOP;
            }
          };
          module2.exports = GetTileToWorldYFunction;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(29);
          var NOOP = __webpack_require__(1);
          var WorldToTileX = __webpack_require__(255);
          var GetWorldToTileXFunction = function (orientation) {
            if (orientation === CONST.ORTHOGONAL) {
              return WorldToTileX;
            } else {
              return NOOP;
            }
          };
          module2.exports = GetWorldToTileXFunction;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(29);
          var HexagonalWorldToTileXY = __webpack_require__(556);
          var IsometricWorldToTileXY = __webpack_require__(557);
          var NOOP = __webpack_require__(1);
          var StaggeredWorldToTileXY = __webpack_require__(558);
          var WorldToTileXY = __webpack_require__(559);
          var GetWorldToTileXYFunction = function (orientation) {
            if (orientation === CONST.ORTHOGONAL) {
              return WorldToTileXY;
            } else if (orientation === CONST.ISOMETRIC) {
              return IsometricWorldToTileXY;
            } else if (orientation === CONST.HEXAGONAL) {
              return HexagonalWorldToTileXY;
            } else if (orientation === CONST.STAGGERED) {
              return StaggeredWorldToTileXY;
            } else {
              return NOOP;
            }
          };
          module2.exports = GetWorldToTileXYFunction;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(29);
          var HexagonalWorldToTileY = __webpack_require__(560);
          var NOOP = __webpack_require__(1);
          var StaggeredWorldToTileY = __webpack_require__(561);
          var WorldToTileY = __webpack_require__(256);
          var GetWorldToTileYFunction = function (orientation) {
            if (orientation === CONST.ORTHOGONAL) {
              return WorldToTileY;
            } else if (orientation === CONST.HEXAGONAL) {
              return HexagonalWorldToTileY;
            } else if (orientation === CONST.STAGGERED) {
              return StaggeredWorldToTileY;
            } else {
              return NOOP;
            }
          };
          module2.exports = GetWorldToTileYFunction;
        }, function (module2, exports2, __webpack_require__) {
          var HasTileAt = __webpack_require__(562);
          var Vector2 = __webpack_require__(3);
          var point = new Vector2();
          var HasTileAtWorldXY = function (worldX, worldY, camera, layer) {
            layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera);
            var tileX = point.x;
            var tileY = point.y;
            return HasTileAt(tileX, tileY, layer);
          };
          module2.exports = HasTileAtWorldXY;
        }, function (module2, exports2, __webpack_require__) {
          var PutTileAt = __webpack_require__(257);
          var Vector2 = __webpack_require__(3);
          var point = new Vector2();
          var PutTileAtWorldXY = function (tile, worldX, worldY, recalculateFaces, camera, layer) {
            layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera, layer);
            return PutTileAt(tile, point.x, point.y, recalculateFaces, layer);
          };
          module2.exports = PutTileAtWorldXY;
        }, function (module2, exports2, __webpack_require__) {
          var CalculateFacesWithin = __webpack_require__(63);
          var PutTileAt = __webpack_require__(257);
          var PutTilesAt = function (tilesArray, tileX, tileY, recalculateFaces, layer) {
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            if (!Array.isArray(tilesArray)) {
              return null;
            }
            if (!Array.isArray(tilesArray[0])) {
              tilesArray = [tilesArray];
            }
            var height = tilesArray.length;
            var width = tilesArray[0].length;
            for (var ty = 0; ty < height; ty++) {
              for (var tx = 0; tx < width; tx++) {
                var tile = tilesArray[ty][tx];
                PutTileAt(tile, tileX + tx, tileY + ty, false, layer);
              }
            }
            if (recalculateFaces) {
              CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);
            }
          };
          module2.exports = PutTilesAt;
        }, function (module2, exports2, __webpack_require__) {
          var GetTilesWithin = __webpack_require__(26);
          var GetRandom = __webpack_require__(210);
          var Randomize = function (tileX, tileY, width, height, indexes, layer) {
            var i;
            var tiles = GetTilesWithin(tileX, tileY, width, height, {}, layer);
            if (!indexes) {
              indexes = [];
              for (i = 0; i < tiles.length; i++) {
                if (indexes.indexOf(tiles[i].index) === -1) {
                  indexes.push(tiles[i].index);
                }
              }
            }
            for (i = 0; i < tiles.length; i++) {
              tiles[i].index = GetRandom(indexes);
            }
          };
          module2.exports = Randomize;
        }, function (module2, exports2, __webpack_require__) {
          var RemoveTileAt = __webpack_require__(563);
          var Vector2 = __webpack_require__(3);
          var point = new Vector2();
          var RemoveTileAtWorldXY = function (worldX, worldY, replaceWithNull, recalculateFaces, camera, layer) {
            layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera, layer);
            return RemoveTileAt(point.x, point.y, replaceWithNull, recalculateFaces, layer);
          };
          module2.exports = RemoveTileAtWorldXY;
        }, function (module2, exports2, __webpack_require__) {
          var GetTilesWithin = __webpack_require__(26);
          var Color = __webpack_require__(397);
          var defaultTileColor = new Color(105, 210, 231, 150);
          var defaultCollidingTileColor = new Color(243, 134, 48, 200);
          var defaultFaceColor = new Color(40, 39, 37, 150);
          var RenderDebug = function (graphics, styleConfig, layer) {
            if (styleConfig === void 0) {
              styleConfig = {};
            }
            var tileColor = styleConfig.tileColor !== void 0 ? styleConfig.tileColor : defaultTileColor;
            var collidingTileColor = styleConfig.collidingTileColor !== void 0 ? styleConfig.collidingTileColor : defaultCollidingTileColor;
            var faceColor = styleConfig.faceColor !== void 0 ? styleConfig.faceColor : defaultFaceColor;
            var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);
            graphics.translateCanvas(layer.tilemapLayer.x, layer.tilemapLayer.y);
            graphics.scaleCanvas(layer.tilemapLayer.scaleX, layer.tilemapLayer.scaleY);
            for (var i = 0; i < tiles.length; i++) {
              var tile = tiles[i];
              var tw = tile.width;
              var th = tile.height;
              var x = tile.pixelX;
              var y = tile.pixelY;
              var color = tile.collides ? collidingTileColor : tileColor;
              if (color !== null) {
                graphics.fillStyle(color.color, color.alpha / 255);
                graphics.fillRect(x, y, tw, th);
              }
              x += 1;
              y += 1;
              tw -= 2;
              th -= 2;
              if (faceColor !== null) {
                graphics.lineStyle(1, faceColor.color, faceColor.alpha / 255);
                if (tile.faceTop) {
                  graphics.lineBetween(x, y, x + tw, y);
                }
                if (tile.faceRight) {
                  graphics.lineBetween(x + tw, y, x + tw, y + th);
                }
                if (tile.faceBottom) {
                  graphics.lineBetween(x, y + th, x + tw, y + th);
                }
                if (tile.faceLeft) {
                  graphics.lineBetween(x, y, x, y + th);
                }
              }
            }
          };
          module2.exports = RenderDebug;
        }, function (module2, exports2, __webpack_require__) {
          var SetTileCollision = __webpack_require__(72);
          var CalculateFacesWithin = __webpack_require__(63);
          var SetLayerCollisionIndex = __webpack_require__(160);
          var SetCollision = function (indexes, collides, recalculateFaces, layer, updateLayer) {
            if (collides === void 0) {
              collides = true;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            if (updateLayer === void 0) {
              updateLayer = true;
            }
            if (!Array.isArray(indexes)) {
              indexes = [indexes];
            }
            for (var i = 0; i < indexes.length; i++) {
              SetLayerCollisionIndex(indexes[i], collides, layer);
            }
            if (updateLayer) {
              for (var ty = 0; ty < layer.height; ty++) {
                for (var tx = 0; tx < layer.width; tx++) {
                  var tile = layer.data[ty][tx];
                  if (tile && indexes.indexOf(tile.index) !== -1) {
                    SetTileCollision(tile, collides);
                  }
                }
              }
            }
            if (recalculateFaces) {
              CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
            }
          };
          module2.exports = SetCollision;
        }, function (module2, exports2, __webpack_require__) {
          var SetTileCollision = __webpack_require__(72);
          var CalculateFacesWithin = __webpack_require__(63);
          var SetLayerCollisionIndex = __webpack_require__(160);
          var SetCollisionBetween = function (start, stop, collides, recalculateFaces, layer, updateLayer) {
            if (collides === void 0) {
              collides = true;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            if (updateLayer === void 0) {
              updateLayer = true;
            }
            if (start > stop) {
              return;
            }
            for (var index = start; index <= stop; index++) {
              SetLayerCollisionIndex(index, collides, layer);
            }
            if (updateLayer) {
              for (var ty = 0; ty < layer.height; ty++) {
                for (var tx = 0; tx < layer.width; tx++) {
                  var tile = layer.data[ty][tx];
                  if (tile) {
                    if (tile.index >= start && tile.index <= stop) {
                      SetTileCollision(tile, collides);
                    }
                  }
                }
              }
            }
            if (recalculateFaces) {
              CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
            }
          };
          module2.exports = SetCollisionBetween;
        }, function (module2, exports2, __webpack_require__) {
          var SetTileCollision = __webpack_require__(72);
          var CalculateFacesWithin = __webpack_require__(63);
          var SetLayerCollisionIndex = __webpack_require__(160);
          var SetCollisionByExclusion = function (indexes, collides, recalculateFaces, layer) {
            if (collides === void 0) {
              collides = true;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            if (!Array.isArray(indexes)) {
              indexes = [indexes];
            }
            for (var ty = 0; ty < layer.height; ty++) {
              for (var tx = 0; tx < layer.width; tx++) {
                var tile = layer.data[ty][tx];
                if (tile && indexes.indexOf(tile.index) === -1) {
                  SetTileCollision(tile, collides);
                  SetLayerCollisionIndex(tile.index, collides, layer);
                }
              }
            }
            if (recalculateFaces) {
              CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
            }
          };
          module2.exports = SetCollisionByExclusion;
        }, function (module2, exports2, __webpack_require__) {
          var SetTileCollision = __webpack_require__(72);
          var CalculateFacesWithin = __webpack_require__(63);
          var HasValue = __webpack_require__(126);
          var SetCollisionByProperty = function (properties, collides, recalculateFaces, layer) {
            if (collides === void 0) {
              collides = true;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            for (var ty = 0; ty < layer.height; ty++) {
              for (var tx = 0; tx < layer.width; tx++) {
                var tile = layer.data[ty][tx];
                if (!tile) {
                  continue;
                }
                for (var property in properties) {
                  if (!HasValue(tile.properties, property)) {
                    continue;
                  }
                  var values = properties[property];
                  if (!Array.isArray(values)) {
                    values = [values];
                  }
                  for (var i = 0; i < values.length; i++) {
                    if (tile.properties[property] === values[i]) {
                      SetTileCollision(tile, collides);
                    }
                  }
                }
              }
            }
            if (recalculateFaces) {
              CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
            }
          };
          module2.exports = SetCollisionByProperty;
        }, function (module2, exports2, __webpack_require__) {
          var SetTileCollision = __webpack_require__(72);
          var CalculateFacesWithin = __webpack_require__(63);
          var SetCollisionFromCollisionGroup = function (collides, recalculateFaces, layer) {
            if (collides === void 0) {
              collides = true;
            }
            if (recalculateFaces === void 0) {
              recalculateFaces = true;
            }
            for (var ty = 0; ty < layer.height; ty++) {
              for (var tx = 0; tx < layer.width; tx++) {
                var tile = layer.data[ty][tx];
                if (!tile) {
                  continue;
                }
                var collisionGroup = tile.getCollisionGroup();
                if (collisionGroup && collisionGroup.objects && collisionGroup.objects.length > 0) {
                  SetTileCollision(tile, collides);
                }
              }
            }
            if (recalculateFaces) {
              CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
            }
          };
          module2.exports = SetCollisionFromCollisionGroup;
        }, function (module2, exports2) {
          var SetTileIndexCallback = function (indexes, callback, callbackContext, layer) {
            if (typeof indexes === "number") {
              layer.callbacks[indexes] = callback !== null ? {
                callback,
                callbackContext
              } : void 0;
            } else {
              for (var i = 0, len = indexes.length; i < len; i++) {
                layer.callbacks[indexes[i]] = callback !== null ? {
                  callback,
                  callbackContext
                } : void 0;
              }
            }
          };
          module2.exports = SetTileIndexCallback;
        }, function (module2, exports2, __webpack_require__) {
          var GetTilesWithin = __webpack_require__(26);
          var SetTileLocationCallback = function (tileX, tileY, width, height, callback, callbackContext, layer) {
            var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
            for (var i = 0; i < tiles.length; i++) {
              tiles[i].setCollisionCallback(callback, callbackContext);
            }
          };
          module2.exports = SetTileLocationCallback;
        }, function (module2, exports2, __webpack_require__) {
          var GetTilesWithin = __webpack_require__(26);
          var ShuffleArray = __webpack_require__(131);
          var Shuffle = function (tileX, tileY, width, height, layer) {
            var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
            var indexes = tiles.map(function (tile) {
              return tile.index;
            });
            ShuffleArray(indexes);
            for (var i = 0; i < tiles.length; i++) {
              tiles[i].index = indexes[i];
            }
          };
          module2.exports = Shuffle;
        }, function (module2, exports2, __webpack_require__) {
          var GetTilesWithin = __webpack_require__(26);
          var SwapByIndex = function (indexA, indexB, tileX, tileY, width, height, layer) {
            var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
            for (var i = 0; i < tiles.length; i++) {
              if (tiles[i]) {
                if (tiles[i].index === indexA) {
                  tiles[i].index = indexB;
                } else if (tiles[i].index === indexB) {
                  tiles[i].index = indexA;
                }
              }
            }
          };
          module2.exports = SwapByIndex;
        }, function (module2, exports2, __webpack_require__) {
          var GetTilesWithin = __webpack_require__(26);
          var WeightedRandomize = function (tileX, tileY, width, height, weightedIndexes, layer) {
            if (!weightedIndexes) {
              return;
            }
            var i;
            var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
            var weightTotal = 0;
            for (i = 0; i < weightedIndexes.length; i++) {
              weightTotal += weightedIndexes[i].weight;
            }
            if (weightTotal <= 0) {
              return;
            }
            for (i = 0; i < tiles.length; i++) {
              var rand = Math.random() * weightTotal;
              var sum = 0;
              var randomIndex = -1;
              for (var j = 0; j < weightedIndexes.length; j++) {
                sum += weightedIndexes[j].weight;
                if (rand <= sum) {
                  var chosen = weightedIndexes[j].index;
                  randomIndex = Array.isArray(chosen) ? chosen[Math.floor(Math.random() * chosen.length)] : chosen;
                  break;
                }
              }
              tiles[i].index = randomIndex;
            }
          };
          module2.exports = WeightedRandomize;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            FromOrientationString: __webpack_require__(258),
            Parse: __webpack_require__(564),
            Parse2DArray: __webpack_require__(259),
            ParseCSV: __webpack_require__(565),
            Impact: __webpack_require__(1454),
            Tiled: __webpack_require__(1455)
          };
        }, function (module2, exports2) {
          var ParseWangsets = function (wangsets, datas) {
            for (var w = 0; w < wangsets.length; w++) {
              var wangset = wangsets[w];
              var identifier = w;
              if (wangset.name && wangset.name !== "") {
                identifier = wangset.name;
              }
              if (Array.isArray(wangset.wangtiles) && wangset.wangtiles.length > 0) {
                var edgeColors = {};
                var cornerColors = {};
                var c;
                var color;
                var colorIndex;
                if (Array.isArray(wangset.edgecolors)) {
                  for (c = 0; c < wangset.edgecolors.length; c++) {
                    colorIndex = 1 + c;
                    color = wangset.edgecolors[c];
                    if (color.name !== "") {
                      edgeColors[colorIndex] = color.name;
                    }
                  }
                }
                if (Array.isArray(wangset.cornercolors)) {
                  for (c = 0; c < wangset.cornercolors.length; c++) {
                    colorIndex = 1 + c;
                    color = wangset.cornercolors[c];
                    if (color.name !== "") {
                      cornerColors[colorIndex] = color.name;
                    }
                  }
                }
                if (Array.isArray(wangset.colors)) {
                  for (c = 0; c < wangset.colors.length; c++) {
                    color = wangset.colors[c];
                    colorIndex = 1 + c;
                    if (color.name !== "") {
                      edgeColors[colorIndex] = cornerColors[colorIndex] = color.name;
                    }
                  }
                }
                var idLayout = [edgeColors, cornerColors, edgeColors, cornerColors, edgeColors, cornerColors, edgeColors, cornerColors];
                for (var t = 0; t < wangset.wangtiles.length; t++) {
                  var wangtile = wangset.wangtiles[t];
                  var obj = datas[wangtile.tileid] || (datas[wangtile.tileid] = {});
                  obj = obj.wangid || (obj.wangid = {});
                  var wangid = [];
                  for (var i = 0; i < Math.min(idLayout.length, wangtile.wangid.length); i++) {
                    color = wangtile.wangid[i];
                    if (color === 0) {
                      wangid.push(void 0);
                      continue;
                    }
                    var renamed = idLayout[i][color];
                    if (renamed !== void 0) {
                      wangid.push(renamed);
                      continue;
                    }
                    wangid.push(color);
                  }
                  obj[identifier] = wangid;
                }
              }
            }
          };
          module2.exports = ParseWangsets;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            ParseTileLayers: __webpack_require__(578),
            ParseTilesets: __webpack_require__(579),
            ParseWeltmeister: __webpack_require__(577)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            AssignTileProperties: __webpack_require__(567),
            Base64Decode: __webpack_require__(574),
            BuildTilesetIndex: __webpack_require__(568),
            CreateGroupLayer: __webpack_require__(161),
            ParseGID: __webpack_require__(261),
            ParseImageLayers: __webpack_require__(569),
            ParseJSONTiled: __webpack_require__(566),
            ParseObject: __webpack_require__(260),
            ParseObjectLayers: __webpack_require__(570),
            ParseTileLayers: __webpack_require__(573),
            ParseTilesets: __webpack_require__(575)
          };
        }, function (module2, exports2, __webpack_require__) {
          var renderWebGL = __webpack_require__(1);
          var renderCanvas = __webpack_require__(1);
          if (true) {
            renderWebGL = __webpack_require__(1457);
          }
          if (true) {
            renderCanvas = __webpack_require__(1458);
          }
          module2.exports = {
            renderWebGL,
            renderCanvas
          };
        }, function (module2, exports2, __webpack_require__) {
          var Utils = __webpack_require__(12);
          var TilemapLayerWebGLRenderer = function (renderer, src, camera) {
            var renderTiles = src.cull(camera);
            var tileCount = renderTiles.length;
            var alpha = camera.alpha * src.alpha;
            if (tileCount === 0 || alpha <= 0) {
              return;
            }
            var gidMap = src.gidMap;
            var pipeline = renderer.pipelines.set(src.pipeline, src);
            var getTint = Utils.getTintAppendFloatAlpha;
            var scrollFactorX = src.scrollFactorX;
            var scrollFactorY = src.scrollFactorY;
            var x = src.x;
            var y = src.y;
            var sx = src.scaleX;
            var sy = src.scaleY;
            renderer.pipelines.preBatch(src);
            for (var i = 0; i < tileCount; i++) {
              var tile = renderTiles[i];
              var tileset = gidMap[tile.index];
              if (!tileset) {
                continue;
              }
              var tileTexCoords = tileset.getTileTextureCoordinates(tile.index);
              if (tileTexCoords === null) {
                continue;
              }
              var texture = tileset.glTexture;
              var textureUnit = pipeline.setTexture2D(texture, src);
              var frameWidth = tileset.tileWidth;
              var frameHeight = tileset.tileHeight;
              var frameX = tileTexCoords.x;
              var frameY = tileTexCoords.y;
              var tw = tileset.tileWidth * 0.5;
              var th = tileset.tileHeight * 0.5;
              var tint = getTint(tile.tint, alpha * tile.alpha);
              pipeline.batchTexture(src, texture, texture.width, texture.height, x + (tw + tile.pixelX) * sx, y + (th + tile.pixelY) * sy, tile.width, tile.height, sx, sy, tile.rotation, tile.flipX, tile.flipY, scrollFactorX, scrollFactorY, tw, th, frameX, frameY, frameWidth, frameHeight, tint, tint, tint, tint, false, 0, 0, camera, null, true, textureUnit);
            }
            renderer.pipelines.postBatch(src);
          };
          module2.exports = TilemapLayerWebGLRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var TransformMatrix = __webpack_require__(25);
          var tempMatrix1 = new TransformMatrix();
          var tempMatrix2 = new TransformMatrix();
          var tempMatrix3 = new TransformMatrix();
          var TilemapLayerCanvasRenderer = function (renderer, src, camera, parentMatrix) {
            var renderTiles = src.cull(camera);
            var tileCount = renderTiles.length;
            var alpha = camera.alpha * src.alpha;
            if (tileCount === 0 || alpha <= 0) {
              return;
            }
            var camMatrix = tempMatrix1;
            var layerMatrix = tempMatrix2;
            var calcMatrix = tempMatrix3;
            layerMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);
            camMatrix.copyFrom(camera.matrix);
            var ctx = renderer.currentContext;
            var gidMap = src.gidMap;
            ctx.save();
            if (parentMatrix) {
              camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);
              layerMatrix.e = src.x;
              layerMatrix.f = src.y;
              camMatrix.multiply(layerMatrix, calcMatrix);
              calcMatrix.copyToContext(ctx);
            } else {
              layerMatrix.e -= camera.scrollX * src.scrollFactorX;
              layerMatrix.f -= camera.scrollY * src.scrollFactorY;
              layerMatrix.copyToContext(ctx);
            }
            if (!renderer.antialias || src.scaleX > 1 || src.scaleY > 1) {
              ctx.imageSmoothingEnabled = false;
            }
            for (var i = 0; i < tileCount; i++) {
              var tile = renderTiles[i];
              var tileset = gidMap[tile.index];
              if (!tileset) {
                continue;
              }
              var image = tileset.image.getSourceImage();
              var tileTexCoords = tileset.getTileTextureCoordinates(tile.index);
              if (tileTexCoords === null) {
                continue;
              }
              var tileWidth = tileset.tileWidth;
              var tileHeight = tileset.tileHeight;
              var halfWidth = tileWidth * 0.5;
              var halfHeight = tileHeight * 0.5;
              ctx.save();
              ctx.translate(tile.pixelX + halfWidth, tile.pixelY + halfHeight);
              if (tile.rotation !== 0) {
                ctx.rotate(tile.rotation);
              }
              if (tile.flipX || tile.flipY) {
                ctx.scale(tile.flipX ? -1 : 1, tile.flipY ? -1 : 1);
              }
              ctx.globalAlpha = alpha * tile.alpha;
              ctx.drawImage(image, tileTexCoords.x, tileTexCoords.y, tileWidth, tileHeight, -halfWidth, -halfHeight, tileWidth, tileHeight);
              ctx.restore();
            }
            ctx.restore();
          };
          module2.exports = TilemapLayerCanvasRenderer;
        }, function (module2, exports2, __webpack_require__) {
          var GameObjectCreator = __webpack_require__(16);
          var ParseToTilemap = __webpack_require__(262);
          GameObjectCreator.register("tilemap", function (config) {
            var c = config !== void 0 ? config : {};
            return ParseToTilemap(this.scene, c.key, c.tileWidth, c.tileHeight, c.width, c.height, c.data, c.insertNull);
          });
        }, function (module2, exports2, __webpack_require__) {
          var GameObjectFactory = __webpack_require__(5);
          var ParseToTilemap = __webpack_require__(262);
          GameObjectFactory.register("tilemap", function (key, tileWidth, tileHeight, width, height, data, insertNull) {
            if (key === null) {
              key = void 0;
            }
            if (tileWidth === null) {
              tileWidth = void 0;
            }
            if (tileHeight === null) {
              tileHeight = void 0;
            }
            if (width === null) {
              width = void 0;
            }
            if (height === null) {
              height = void 0;
            }
            return ParseToTilemap(this.scene, key, tileWidth, tileHeight, width, height, data, insertNull);
          });
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Clock: __webpack_require__(1462),
            TimerEvent: __webpack_require__(582)
          };
        }, function (module2, exports2, __webpack_require__) {
          var Class = __webpack_require__(0);
          var PluginCache = __webpack_require__(24);
          var SceneEvents = __webpack_require__(20);
          var TimerEvent = __webpack_require__(582);
          var Remove = __webpack_require__(93);
          var Clock = new Class({
            initialize: function Clock2(scene) {
              this.scene = scene;
              this.systems = scene.sys;
              this.now = 0;
              this.timeScale = 1;
              this.paused = false;
              this._active = [];
              this._pendingInsertion = [];
              this._pendingRemoval = [];
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              scene.sys.events.on(SceneEvents.START, this.start, this);
            },
            boot: function () {
              this.now = this.systems.game.loop.time;
              this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            start: function () {
              var eventEmitter = this.systems.events;
              eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
              eventEmitter.on(SceneEvents.UPDATE, this.update, this);
              eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            addEvent: function (config) {
              var event;
              if (config instanceof TimerEvent) {
                event = config;
                this.removeEvent(event);
                event.elapsed = event.startAt;
                event.hasDispatched = false;
                event.repeatCount = event.repeat === -1 || event.loop ? 999999999999 : event.repeat;
              } else {
                event = new TimerEvent(config);
              }
              this._pendingInsertion.push(event);
              return event;
            },
            delayedCall: function (delay, callback, args, callbackScope) {
              return this.addEvent({
                delay,
                callback,
                args,
                callbackScope
              });
            },
            clearPendingEvents: function () {
              this._pendingInsertion = [];
              return this;
            },
            removeEvent: function (events) {
              if (!Array.isArray(events)) {
                events = [events];
              }
              for (var i = 0; i < events.length; i++) {
                var event = events[i];
                Remove(this._pendingRemoval, event);
                Remove(this._pendingInsertion, event);
                Remove(this._active, event);
              }
              return this;
            },
            removeAllEvents: function () {
              this._pendingRemoval = this._pendingRemoval.concat(this._active);
              return this;
            },
            preUpdate: function () {
              var toRemove = this._pendingRemoval.length;
              var toInsert = this._pendingInsertion.length;
              if (toRemove === 0 && toInsert === 0) {
                return;
              }
              var i;
              var event;
              for (i = 0; i < toRemove; i++) {
                event = this._pendingRemoval[i];
                var index = this._active.indexOf(event);
                if (index > -1) {
                  this._active.splice(index, 1);
                }
                event.destroy();
              }
              for (i = 0; i < toInsert; i++) {
                event = this._pendingInsertion[i];
                this._active.push(event);
              }
              this._pendingRemoval.length = 0;
              this._pendingInsertion.length = 0;
            },
            update: function (time, delta) {
              this.now = time;
              if (this.paused) {
                return;
              }
              delta *= this.timeScale;
              for (var i = 0; i < this._active.length; i++) {
                var event = this._active[i];
                if (event.paused) {
                  continue;
                }
                event.elapsed += delta * event.timeScale;
                if (event.elapsed >= event.delay) {
                  var remainder = event.elapsed - event.delay;
                  event.elapsed = event.delay;
                  if (!event.hasDispatched && event.callback) {
                    event.hasDispatched = true;
                    event.callback.apply(event.callbackScope, event.args);
                  }
                  if (event.repeatCount > 0) {
                    event.repeatCount--;
                    event.elapsed = remainder;
                    event.hasDispatched = false;
                  } else {
                    this._pendingRemoval.push(event);
                  }
                }
              }
            },
            shutdown: function () {
              var i;
              for (i = 0; i < this._pendingInsertion.length; i++) {
                this._pendingInsertion[i].destroy();
              }
              for (i = 0; i < this._active.length; i++) {
                this._active[i].destroy();
              }
              for (i = 0; i < this._pendingRemoval.length; i++) {
                this._pendingRemoval[i].destroy();
              }
              this._active.length = 0;
              this._pendingRemoval.length = 0;
              this._pendingInsertion.length = 0;
              var eventEmitter = this.systems.events;
              eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
              eventEmitter.off(SceneEvents.UPDATE, this.update, this);
              eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function () {
              this.shutdown();
              this.scene.sys.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
            }
          });
          PluginCache.register("Clock", Clock, "time");
          module2.exports = Clock;
        }, function (module2, exports2, __webpack_require__) {
          var CONST = __webpack_require__(100);
          var Extend = __webpack_require__(17);
          var Tweens = {
            Builders: __webpack_require__(1464),
            Events: __webpack_require__(267),
            TweenManager: __webpack_require__(1480),
            Tween: __webpack_require__(266),
            TweenData: __webpack_require__(268),
            Timeline: __webpack_require__(588)
          };
          Tweens = Extend(false, Tweens, CONST);
          module2.exports = Tweens;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            GetBoolean: __webpack_require__(99),
            GetEaseFunction: __webpack_require__(80),
            GetNewValue: __webpack_require__(162),
            GetProps: __webpack_require__(583),
            GetTargets: __webpack_require__(263),
            GetTweens: __webpack_require__(584),
            GetValueOp: __webpack_require__(264),
            NumberTweenBuilder: __webpack_require__(585),
            StaggerBuilder: __webpack_require__(586),
            TimelineBuilder: __webpack_require__(587),
            TweenBuilder: __webpack_require__(163)
          };
        }, function (module2, exports2) {
          module2.exports = ["callbackScope", "completeDelay", "delay", "duration", "ease", "easeParams", "flipX", "flipY", "hold", "loop", "loopDelay", "offset", "onActive", "onActiveParams", "onActiveScope", "onComplete", "onCompleteParams", "onCompleteScope", "onLoop", "onLoopParams", "onLoopScope", "onRepeat", "onRepeatParams", "onRepeatScope", "onStart", "onStartParams", "onStartScope", "onStop", "onStopParams", "onStopScope", "onUpdate", "onUpdateParams", "onUpdateScope", "onYoyo", "onYoyoParams", "onYoyoScope", "paused", "props", "repeat", "repeatDelay", "targets", "useFrames", "yoyo"];
        }, function (module2, exports2) {
          module2.exports = "complete";
        }, function (module2, exports2) {
          module2.exports = "loop";
        }, function (module2, exports2) {
          module2.exports = "pause";
        }, function (module2, exports2) {
          module2.exports = "resume";
        }, function (module2, exports2) {
          module2.exports = "start";
        }, function (module2, exports2) {
          module2.exports = "update";
        }, function (module2, exports2) {
          module2.exports = "active";
        }, function (module2, exports2) {
          module2.exports = "complete";
        }, function (module2, exports2) {
          module2.exports = "loop";
        }, function (module2, exports2) {
          module2.exports = "repeat";
        }, function (module2, exports2) {
          module2.exports = "start";
        }, function (module2, exports2) {
          module2.exports = "stop";
        }, function (module2, exports2) {
          module2.exports = "update";
        }, function (module2, exports2) {
          module2.exports = "yoyo";
        }, function (module2, exports2, __webpack_require__) {
          var ArrayRemove = __webpack_require__(93);
          var Class = __webpack_require__(0);
          var NumberTweenBuilder = __webpack_require__(585);
          var PluginCache = __webpack_require__(24);
          var SceneEvents = __webpack_require__(20);
          var StaggerBuilder = __webpack_require__(586);
          var TimelineBuilder = __webpack_require__(587);
          var TWEEN_CONST = __webpack_require__(100);
          var TweenBuilder = __webpack_require__(163);
          var TweenManager = new Class({
            initialize: function TweenManager2(scene) {
              this.scene = scene;
              this.systems = scene.sys;
              this.timeScale = 1;
              this._add = [];
              this._pending = [];
              this._active = [];
              this._destroy = [];
              this._toProcess = 0;
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              scene.sys.events.on(SceneEvents.START, this.start, this);
            },
            boot: function () {
              this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            start: function () {
              var eventEmitter = this.systems.events;
              eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
              eventEmitter.on(SceneEvents.UPDATE, this.update, this);
              eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
              this.timeScale = 1;
            },
            createTimeline: function (config) {
              return TimelineBuilder(this, config);
            },
            timeline: function (config) {
              var timeline = TimelineBuilder(this, config);
              if (!timeline.paused) {
                this._add.push(timeline);
                this._toProcess++;
              }
              return timeline;
            },
            create: function (config) {
              return TweenBuilder(this, config);
            },
            add: function (config) {
              var tween = TweenBuilder(this, config);
              this._add.push(tween);
              this._toProcess++;
              return tween;
            },
            existing: function (tween) {
              this._add.push(tween);
              this._toProcess++;
              return this;
            },
            addCounter: function (config) {
              var tween = NumberTweenBuilder(this, config);
              this._add.push(tween);
              this._toProcess++;
              return tween;
            },
            stagger: function (value, options) {
              return StaggerBuilder(value, options);
            },
            preUpdate: function () {
              if (this._toProcess === 0) {
                return;
              }
              var list = this._destroy;
              var active = this._active;
              var pending = this._pending;
              var i;
              var tween;
              for (i = 0; i < list.length; i++) {
                tween = list[i];
                var idx = active.indexOf(tween);
                if (idx === -1) {
                  idx = pending.indexOf(tween);
                  if (idx > -1) {
                    tween.state = TWEEN_CONST.REMOVED;
                    pending.splice(idx, 1);
                  }
                } else {
                  tween.state = TWEEN_CONST.REMOVED;
                  active.splice(idx, 1);
                }
              }
              list.length = 0;
              list = this._add;
              for (i = 0; i < list.length; i++) {
                tween = list[i];
                if (tween.state === TWEEN_CONST.PENDING_ADD) {
                  if (tween.init()) {
                    tween.play();
                    this._active.push(tween);
                  } else {
                    this._pending.push(tween);
                  }
                }
              }
              list.length = 0;
              this._toProcess = 0;
            },
            update: function (timestamp, delta) {
              var list = this._active;
              var tween;
              delta *= this.timeScale;
              for (var i = 0; i < list.length; i++) {
                tween = list[i];
                if (tween.update(timestamp, delta)) {
                  this._destroy.push(tween);
                  this._toProcess++;
                }
              }
            },
            remove: function (tween) {
              ArrayRemove(this._add, tween);
              ArrayRemove(this._pending, tween);
              ArrayRemove(this._active, tween);
              ArrayRemove(this._destroy, tween);
              tween.state = TWEEN_CONST.REMOVED;
              return this;
            },
            makeActive: function (tween) {
              if (this._add.indexOf(tween) !== -1 || this._active.indexOf(tween) !== -1) {
                return this;
              }
              var idx = this._pending.indexOf(tween);
              if (idx !== -1) {
                this._pending.splice(idx, 1);
              }
              this._add.push(tween);
              tween.state = TWEEN_CONST.PENDING_ADD;
              this._toProcess++;
              return this;
            },
            each: function (callback, scope) {
              var args = [null];
              for (var i = 1; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              for (var texture in this.list) {
                args[0] = this.list[texture];
                callback.apply(scope, args);
              }
            },
            getAllTweens: function () {
              var list = this._active;
              var output = [];
              for (var i = 0; i < list.length; i++) {
                output.push(list[i]);
              }
              return output;
            },
            getGlobalTimeScale: function () {
              return this.timeScale;
            },
            getTweensOf: function (target, includePending) {
              if (includePending === void 0) {
                includePending = false;
              }
              var list = this._active;
              var tween;
              var output = [];
              var i;
              var t;
              if (!Array.isArray(target)) {
                target = [target];
              }
              for (i = 0; i < list.length; i++) {
                tween = list[i];
                for (t = 0; t < target.length; t++) {
                  if (tween.hasTarget(target[t])) {
                    output.push(tween);
                  }
                }
              }
              if (includePending) {
                list = this._pending;
                for (i = 0; i < list.length; i++) {
                  tween = list[i];
                  for (t = 0; t < target.length; t++) {
                    if (tween.hasTarget(target[t])) {
                      output.push(tween);
                    }
                  }
                }
              }
              return output;
            },
            isTweening: function (target) {
              var list = this._active;
              var tween;
              for (var i = 0; i < list.length; i++) {
                tween = list[i];
                if (tween.hasTarget(target) && tween.isPlaying()) {
                  return true;
                }
              }
              return false;
            },
            killAll: function () {
              var tweens = this.getAllTweens();
              for (var i = 0; i < tweens.length; i++) {
                tweens[i].stop();
              }
              return this;
            },
            killTweensOf: function (target) {
              var tweens = this.getTweensOf(target);
              for (var i = 0; i < tweens.length; i++) {
                tweens[i].stop();
              }
              return this;
            },
            pauseAll: function () {
              var list = this._active;
              for (var i = 0; i < list.length; i++) {
                list[i].pause();
              }
              return this;
            },
            resumeAll: function () {
              var list = this._active;
              for (var i = 0; i < list.length; i++) {
                list[i].resume();
              }
              return this;
            },
            setGlobalTimeScale: function (value) {
              this.timeScale = value;
              return this;
            },
            shutdown: function () {
              this.killAll();
              this._add = [];
              this._pending = [];
              this._active = [];
              this._destroy = [];
              this._toProcess = 0;
              var eventEmitter = this.systems.events;
              eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
              eventEmitter.off(SceneEvents.UPDATE, this.update, this);
              eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            destroy: function () {
              this.shutdown();
              this.scene.sys.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
            }
          });
          PluginCache.register("TweenManager", TweenManager, "tweens");
          module2.exports = TweenManager;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Array: __webpack_require__(208),
            Base64: __webpack_require__(1482),
            Objects: __webpack_require__(1484),
            String: __webpack_require__(1488),
            NOOP: __webpack_require__(1)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            ArrayBufferToBase64: __webpack_require__(1483),
            Base64ToArrayBuffer: __webpack_require__(433)
          };
        }, function (module2, exports2) {
          var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          var ArrayBufferToBase64 = function (arrayBuffer, mediaType) {
            var bytes = new Uint8Array(arrayBuffer);
            var len = bytes.length;
            var base64 = mediaType ? "data:" + mediaType + ";base64," : "";
            for (var i = 0; i < len; i += 3) {
              base64 += chars[bytes[i] >> 2];
              base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
              base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
              base64 += chars[bytes[i + 2] & 63];
            }
            if (len % 3 === 2) {
              base64 = base64.substring(0, base64.length - 1) + "=";
            } else if (len % 3 === 1) {
              base64 = base64.substring(0, base64.length - 2) + "==";
            }
            return base64;
          };
          module2.exports = ArrayBufferToBase64;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Clone: __webpack_require__(77),
            DeepCopy: __webpack_require__(175),
            Extend: __webpack_require__(17),
            GetAdvancedValue: __webpack_require__(13),
            GetFastValue: __webpack_require__(2),
            GetMinMaxValue: __webpack_require__(1485),
            GetValue: __webpack_require__(6),
            HasAll: __webpack_require__(1486),
            HasAny: __webpack_require__(455),
            HasValue: __webpack_require__(126),
            IsPlainObject: __webpack_require__(7),
            Merge: __webpack_require__(127),
            MergeRight: __webpack_require__(1487),
            Pick: __webpack_require__(571),
            SetValue: __webpack_require__(478)
          };
        }, function (module2, exports2, __webpack_require__) {
          var GetValue = __webpack_require__(6);
          var Clamp = __webpack_require__(18);
          var GetMinMaxValue = function (source, key, min, max, defaultValue) {
            if (defaultValue === void 0) {
              defaultValue = min;
            }
            var value = GetValue(source, key, defaultValue);
            return Clamp(value, min, max);
          };
          module2.exports = GetMinMaxValue;
        }, function (module2, exports2) {
          var HasAll = function (source, keys) {
            for (var i = 0; i < keys.length; i++) {
              if (!source.hasOwnProperty(keys[i])) {
                return false;
              }
            }
            return true;
          };
          module2.exports = HasAll;
        }, function (module2, exports2, __webpack_require__) {
          var Clone = __webpack_require__(77);
          var MergeRight = function (obj1, obj2) {
            var clone = Clone(obj1);
            for (var key in obj2) {
              if (clone.hasOwnProperty(key)) {
                clone[key] = obj2[key];
              }
            }
            return clone;
          };
          module2.exports = MergeRight;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Format: __webpack_require__(1489),
            Pad: __webpack_require__(186),
            RemoveAt: __webpack_require__(1490),
            Reverse: __webpack_require__(1491),
            UppercaseFirst: __webpack_require__(205),
            UUID: __webpack_require__(222)
          };
        }, function (module2, exports2) {
          var Format = function (string, values) {
            return string.replace(/%([0-9]+)/g, function (s, n) {
              return values[Number(n) - 1];
            });
          };
          module2.exports = Format;
        }, function (module2, exports2) {
          var RemoveAt = function (string, index) {
            if (index === 0) {
              return string.slice(1);
            } else {
              return string.slice(0, index - 1) + string.slice(index);
            }
          };
          module2.exports = RemoveAt;
        }, function (module2, exports2) {
          var Reverse = function (string) {
            return string.split("").reverse().join("");
          };
          module2.exports = Reverse;
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            SoundManagerCreator: __webpack_require__(426),
            Events: __webpack_require__(70),
            BaseSound: __webpack_require__(146),
            BaseSoundManager: __webpack_require__(145),
            WebAudioSound: __webpack_require__(434),
            WebAudioSoundManager: __webpack_require__(432),
            HTML5AudioSound: __webpack_require__(429),
            HTML5AudioSoundManager: __webpack_require__(427),
            NoAudioSound: __webpack_require__(431),
            NoAudioSoundManager: __webpack_require__(430)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            Arcade: __webpack_require__(1366),
            Matter: __webpack_require__(1494)
          };
        }, function (module2, exports2, __webpack_require__) {
          module2.exports = {
            BodyBounds: __webpack_require__(1392),
            Components: __webpack_require__(249),
            Events: __webpack_require__(272),
            Factory: __webpack_require__(1394),
            MatterGameObject: __webpack_require__(1395),
            Image: __webpack_require__(1396),
            Matter: __webpack_require__(594),
            MatterPhysics: __webpack_require__(1524),
            PolyDecomp: __webpack_require__(1393),
            Sprite: __webpack_require__(1397),
            TileBody: __webpack_require__(593),
            PhysicsEditorParser: __webpack_require__(589),
            PhysicsJSONParser: __webpack_require__(590),
            PointerConstraint: __webpack_require__(1398),
            World: __webpack_require__(1402)
          };
        }, function (module2, exports2) {
          var Bounce = {
            setBounce: function (value) {
              this.body.restitution = value;
              return this;
            }
          };
          module2.exports = Bounce;
        }, function (module2, exports2) {
          var Collision = {
            setCollisionCategory: function (value) {
              this.body.collisionFilter.category = value;
              return this;
            },
            setCollisionGroup: function (value) {
              this.body.collisionFilter.group = value;
              return this;
            },
            setCollidesWith: function (categories) {
              var flags = 0;
              if (!Array.isArray(categories)) {
                flags = categories;
              } else {
                for (var i = 0; i < categories.length; i++) {
                  flags |= categories[i];
                }
              }
              this.body.collisionFilter.mask = flags;
              return this;
            },
            setOnCollide: function (callback) {
              this.body.onCollideCallback = callback;
              return this;
            },
            setOnCollideEnd: function (callback) {
              this.body.onCollideEndCallback = callback;
              return this;
            },
            setOnCollideActive: function (callback) {
              this.body.onCollideActiveCallback = callback;
              return this;
            },
            setOnCollideWith: function (body, callback) {
              if (!Array.isArray(body)) {
                body = [body];
              }
              for (var i = 0; i < body.length; i++) {
                var src = body[i].hasOwnProperty("body") ? body[i].body : body[i];
                this.body.setOnCollideWith(src, callback);
              }
              return this;
            }
          };
          module2.exports = Collision;
        }, function (module2, exports2, __webpack_require__) {
          var Body = __webpack_require__(41);
          var Force = {
            applyForce: function (force) {
              this._tempVec2.set(this.body.position.x, this.body.position.y);
              Body.applyForce(this.body, this._tempVec2, force);
              return this;
            },
            applyForceFrom: function (position, force) {
              Body.applyForce(this.body, position, force);
              return this;
            },
            thrust: function (speed) {
              var angle = this.body.angle;
              this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
              Body.applyForce(this.body, {
                x: this.body.position.x,
                y: this.body.position.y
              }, this._tempVec2);
              return this;
            },
            thrustLeft: function (speed) {
              var angle = this.body.angle - Math.PI / 2;
              this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
              Body.applyForce(this.body, {
                x: this.body.position.x,
                y: this.body.position.y
              }, this._tempVec2);
              return this;
            },
            thrustRight: function (speed) {
              var angle = this.body.angle + Math.PI / 2;
              this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
              Body.applyForce(this.body, {
                x: this.body.position.x,
                y: this.body.position.y
              }, this._tempVec2);
              return this;
            },
            thrustBack: function (speed) {
              var angle = this.body.angle - Math.PI;
              this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
              Body.applyForce(this.body, {
                x: this.body.position.x,
                y: this.body.position.y
              }, this._tempVec2);
              return this;
            }
          };
          module2.exports = Force;
        }, function (module2, exports2) {
          var Friction = {
            setFriction: function (value, air, fstatic) {
              this.body.friction = value;
              if (air !== void 0) {
                this.body.frictionAir = air;
              }
              if (fstatic !== void 0) {
                this.body.frictionStatic = fstatic;
              }
              return this;
            },
            setFrictionAir: function (value) {
              this.body.frictionAir = value;
              return this;
            },
            setFrictionStatic: function (value) {
              this.body.frictionStatic = value;
              return this;
            }
          };
          module2.exports = Friction;
        }, function (module2, exports2) {
          var Gravity = {
            setIgnoreGravity: function (value) {
              this.body.ignoreGravity = value;
              return this;
            }
          };
          module2.exports = Gravity;
        }, function (module2, exports2, __webpack_require__) {
          var Body = __webpack_require__(41);
          var Vector2 = __webpack_require__(3);
          var Mass = {
            setMass: function (value) {
              Body.setMass(this.body, value);
              return this;
            },
            setDensity: function (value) {
              Body.setDensity(this.body, value);
              return this;
            },
            centerOfMass: {
              get: function () {
                return new Vector2(this.body.centerOfMass.x, this.body.centerOfMass.y);
              }
            }
          };
          module2.exports = Mass;
        }, function (module2, exports2) {
          var Sensor = {
            setSensor: function (value) {
              this.body.isSensor = value;
              return this;
            },
            isSensor: function () {
              return this.body.isSensor;
            }
          };
          module2.exports = Sensor;
        }, function (module2, exports2, __webpack_require__) {
          var Bodies = __webpack_require__(86);
          var Body = __webpack_require__(41);
          var FuzzyEquals = __webpack_require__(124);
          var GetFastValue = __webpack_require__(2);
          var PhysicsEditorParser = __webpack_require__(589);
          var PhysicsJSONParser = __webpack_require__(590);
          var Vertices = __webpack_require__(64);
          var SetBody = {
            setRectangle: function (width, height, options) {
              return this.setBody({
                type: "rectangle",
                width,
                height
              }, options);
            },
            setCircle: function (radius, options) {
              return this.setBody({
                type: "circle",
                radius
              }, options);
            },
            setPolygon: function (radius, sides, options) {
              return this.setBody({
                type: "polygon",
                sides,
                radius
              }, options);
            },
            setTrapezoid: function (width, height, slope, options) {
              return this.setBody({
                type: "trapezoid",
                width,
                height,
                slope
              }, options);
            },
            setExistingBody: function (body, addToWorld) {
              if (addToWorld === void 0) {
                addToWorld = true;
              }
              if (this.body) {
                this.world.remove(this.body, true);
              }
              this.body = body;
              for (var i = 0; i < body.parts.length; i++) {
                body.parts[i].gameObject = this;
              }
              var _this = this;
              body.destroy = function destroy() {
                _this.world.remove(_this.body, true);
                _this.body.gameObject = null;
              };
              if (addToWorld) {
                if (this.world.has(body)) {
                  this.world.remove(body, true);
                }
                this.world.add(body);
              }
              if (this._originComponent) {
                var rx = body.render.sprite.xOffset;
                var ry = body.render.sprite.yOffset;
                var comx = body.centerOfMass.x;
                var comy = body.centerOfMass.y;
                if (FuzzyEquals(comx, 0.5) && FuzzyEquals(comy, 0.5)) {
                  this.setOrigin(rx + 0.5, ry + 0.5);
                } else {
                  var cx = body.centerOffset.x;
                  var cy = body.centerOffset.y;
                  this.setOrigin(rx + cx / this.displayWidth, ry + cy / this.displayHeight);
                }
              }
              return this;
            },
            setBody: function (config, options) {
              if (!config) {
                return this;
              }
              var body;
              if (typeof config === "string") {
                config = {
                  type: config
                };
              }
              var shapeType = GetFastValue(config, "type", "rectangle");
              var bodyX = GetFastValue(config, "x", this._tempVec2.x);
              var bodyY = GetFastValue(config, "y", this._tempVec2.y);
              var bodyWidth = GetFastValue(config, "width", this.width);
              var bodyHeight = GetFastValue(config, "height", this.height);
              switch (shapeType) {
                case "rectangle":
                  body = Bodies.rectangle(bodyX, bodyY, bodyWidth, bodyHeight, options);
                  break;
                case "circle":
                  var radius = GetFastValue(config, "radius", Math.max(bodyWidth, bodyHeight) / 2);
                  var maxSides = GetFastValue(config, "maxSides", 25);
                  body = Bodies.circle(bodyX, bodyY, radius, options, maxSides);
                  break;
                case "trapezoid":
                  var slope = GetFastValue(config, "slope", 0.5);
                  body = Bodies.trapezoid(bodyX, bodyY, bodyWidth, bodyHeight, slope, options);
                  break;
                case "polygon":
                  var sides = GetFastValue(config, "sides", 5);
                  var pRadius = GetFastValue(config, "radius", Math.max(bodyWidth, bodyHeight) / 2);
                  body = Bodies.polygon(bodyX, bodyY, sides, pRadius, options);
                  break;
                case "fromVertices":
                case "fromVerts":
                  var verts = GetFastValue(config, "verts", null);
                  if (verts) {
                    if (typeof verts === "string") {
                      verts = Vertices.fromPath(verts);
                    }
                    if (this.body && !this.body.hasOwnProperty("temp")) {
                      Body.setVertices(this.body, verts);
                      body = this.body;
                    } else {
                      var flagInternal = GetFastValue(config, "flagInternal", false);
                      var removeCollinear = GetFastValue(config, "removeCollinear", 0.01);
                      var minimumArea = GetFastValue(config, "minimumArea", 10);
                      body = Bodies.fromVertices(bodyX, bodyY, verts, options, flagInternal, removeCollinear, minimumArea);
                    }
                  }
                  break;
                case "fromPhysicsEditor":
                  body = PhysicsEditorParser.parseBody(bodyX, bodyY, config, options);
                  break;
                case "fromPhysicsTracer":
                  body = PhysicsJSONParser.parseBody(bodyX, bodyY, config, options);
                  break;
              }
              if (body) {
                this.setExistingBody(body, config.addToWorld);
              }
              return this;
            }
          };
          module2.exports = SetBody;
        }, function (module2, exports2, __webpack_require__) {
          var Events = __webpack_require__(272);
          var Sleeping = __webpack_require__(165);
          var MatterEvents = __webpack_require__(166);
          var Sleep = {
            setToSleep: function () {
              Sleeping.set(this.body, true);
              return this;
            },
            setAwake: function () {
              Sleeping.set(this.body, false);
              return this;
            },
            setSleepThreshold: function (value) {
              if (value === void 0) {
                value = 60;
              }
              this.body.sleepThreshold = value;
              return this;
            },
            setSleepEvents: function (start, end) {
              this.setSleepStartEvent(start);
              this.setSleepEndEvent(end);
              return this;
            },
            setSleepStartEvent: function (value) {
              if (value) {
                var world = this.world;
                MatterEvents.on(this.body, "sleepStart", function (event) {
                  world.emit(Events.SLEEP_START, event, this);
                });
              } else {
                MatterEvents.off(this.body, "sleepStart");
              }
              return this;
            },
            setSleepEndEvent: function (value) {
              if (value) {
                var world = this.world;
                MatterEvents.on(this.body, "sleepEnd", function (event) {
                  world.emit(Events.SLEEP_END, event, this);
                });
              } else {
                MatterEvents.off(this.body, "sleepEnd");
              }
              return this;
            }
          };
          module2.exports = Sleep;
        }, function (module2, exports2) {
          module2.exports = "afteradd";
        }, function (module2, exports2) {
          module2.exports = "afterremove";
        }, function (module2, exports2) {
          module2.exports = "afterupdate";
        }, function (module2, exports2) {
          module2.exports = "beforeadd";
        }, function (module2, exports2) {
          module2.exports = "beforeremove";
        }, function (module2, exports2) {
          module2.exports = "beforeupdate";
        }, function (module2, exports2) {
          module2.exports = "collisionactive";
        }, function (module2, exports2) {
          module2.exports = "collisionend";
        }, function (module2, exports2) {
          module2.exports = "collisionstart";
        }, function (module2, exports2) {
          module2.exports = "dragend";
        }, function (module2, exports2) {
          module2.exports = "drag";
        }, function (module2, exports2) {
          module2.exports = "dragstart";
        }, function (module2, exports2) {
          module2.exports = "pause";
        }, function (module2, exports2) {
          module2.exports = "resume";
        }, function (module2, exports2) {
          module2.exports = "sleepend";
        }, function (module2, exports2) {
          module2.exports = "sleepstart";
        }, function (module2, exports2, __webpack_require__) {
          var Body = __webpack_require__(41);
          var Static = {
            setStatic: function (value) {
              Body.setStatic(this.body, value);
              return this;
            },
            isStatic: function () {
              return this.body.isStatic;
            }
          };
          module2.exports = Static;
        }, function (module2, exports2, __webpack_require__) {
          var Body = __webpack_require__(41);
          var MATH_CONST = __webpack_require__(14);
          var WrapAngle = __webpack_require__(269);
          var WrapAngleDegrees = __webpack_require__(270);
          var _FLAG = 4;
          var Transform = {
            x: {
              get: function () {
                return this.body.position.x;
              },
              set: function (value) {
                this._tempVec2.set(value, this.y);
                Body.setPosition(this.body, this._tempVec2);
              }
            },
            y: {
              get: function () {
                return this.body.position.y;
              },
              set: function (value) {
                this._tempVec2.set(this.x, value);
                Body.setPosition(this.body, this._tempVec2);
              }
            },
            scaleX: {
              get: function () {
                return this._scaleX;
              },
              set: function (value) {
                var factorX = 1 / this._scaleX;
                var factorY = 1 / this._scaleY;
                this._scaleX = value;
                if (this._scaleX === 0) {
                  this.renderFlags &= ~_FLAG;
                } else {
                  this.renderFlags |= _FLAG;
                }
                Body.scale(this.body, factorX, factorY);
                Body.scale(this.body, value, this._scaleY);
              }
            },
            scaleY: {
              get: function () {
                return this._scaleY;
              },
              set: function (value) {
                var factorX = 1 / this._scaleX;
                var factorY = 1 / this._scaleY;
                this._scaleY = value;
                if (this._scaleY === 0) {
                  this.renderFlags &= ~_FLAG;
                } else {
                  this.renderFlags |= _FLAG;
                }
                Body.scale(this.body, factorX, factorY);
                Body.scale(this.body, this._scaleX, value);
              }
            },
            angle: {
              get: function () {
                return WrapAngleDegrees(this.body.angle * MATH_CONST.RAD_TO_DEG);
              },
              set: function (value) {
                this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;
              }
            },
            rotation: {
              get: function () {
                return this.body.angle;
              },
              set: function (value) {
                this._rotation = WrapAngle(value);
                Body.setAngle(this.body, this._rotation);
              }
            },
            setPosition: function (x, y) {
              if (x === void 0) {
                x = 0;
              }
              if (y === void 0) {
                y = x;
              }
              this._tempVec2.set(x, y);
              Body.setPosition(this.body, this._tempVec2);
              return this;
            },
            setRotation: function (radians) {
              if (radians === void 0) {
                radians = 0;
              }
              this._rotation = WrapAngle(radians);
              Body.setAngle(this.body, radians);
              return this;
            },
            setFixedRotation: function () {
              Body.setInertia(this.body, Infinity);
              return this;
            },
            setAngle: function (degrees) {
              if (degrees === void 0) {
                degrees = 0;
              }
              this.angle = degrees;
              Body.setAngle(this.body, this.rotation);
              return this;
            },
            setScale: function (x, y, point) {
              if (x === void 0) {
                x = 1;
              }
              if (y === void 0) {
                y = x;
              }
              var factorX = 1 / this._scaleX;
              var factorY = 1 / this._scaleY;
              this._scaleX = x;
              this._scaleY = y;
              Body.scale(this.body, factorX, factorY, point);
              Body.scale(this.body, x, y, point);
              return this;
            }
          };
          module2.exports = Transform;
        }, function (module2, exports2, __webpack_require__) {
          var Body = __webpack_require__(41);
          var Velocity = {
            setAngularVelocity: function (value) {
              Body.setAngularVelocity(this.body, value);
              return this;
            },
            setVelocityX: function (x) {
              this._tempVec2.set(x, this.body.velocity.y);
              Body.setVelocity(this.body, this._tempVec2);
              return this;
            },
            setVelocityY: function (y) {
              this._tempVec2.set(this.body.velocity.x, y);
              Body.setVelocity(this.body, this._tempVec2);
              return this;
            },
            setVelocity: function (x, y) {
              this._tempVec2.set(x, y);
              Body.setVelocity(this.body, this._tempVec2);
              return this;
            }
          };
          module2.exports = Velocity;
        }, function (module2, exports2, __webpack_require__) {
          var Metrics = {};
          module2.exports = Metrics;
          var Composite = __webpack_require__(118);
          var Common = __webpack_require__(32);
          (function () {
            Metrics.create = function (options) {
              var defaults = {
                extended: false,
                narrowDetections: 0,
                narrowphaseTests: 0,
                narrowReuse: 0,
                narrowReuseCount: 0,
                midphaseTests: 0,
                broadphaseTests: 0,
                narrowEff: 1e-4,
                midEff: 1e-4,
                broadEff: 1e-4,
                collisions: 0,
                buckets: 0,
                bodies: 0,
                pairs: 0
              };
              return Common.extend(defaults, false, options);
            };
            Metrics.reset = function (metrics) {
              if (metrics.extended) {
                metrics.narrowDetections = 0;
                metrics.narrowphaseTests = 0;
                metrics.narrowReuse = 0;
                metrics.narrowReuseCount = 0;
                metrics.midphaseTests = 0;
                metrics.broadphaseTests = 0;
                metrics.narrowEff = 0;
                metrics.midEff = 0;
                metrics.broadEff = 0;
                metrics.collisions = 0;
                metrics.buckets = 0;
                metrics.pairs = 0;
                metrics.bodies = 0;
              }
            };
            Metrics.update = function (metrics, engine) {
              if (metrics.extended) {
                var world = engine.world, bodies = Composite.allBodies(world);
                metrics.collisions = metrics.narrowDetections;
                metrics.pairs = engine.pairs.list.length;
                metrics.bodies = bodies.length;
                metrics.midEff = (metrics.narrowDetections / (metrics.midphaseTests || 1)).toFixed(2);
                metrics.narrowEff = (metrics.narrowDetections / (metrics.narrowphaseTests || 1)).toFixed(2);
                metrics.broadEff = (1 - metrics.broadphaseTests / (bodies.length || 1)).toFixed(2);
                metrics.narrowReuse = (metrics.narrowReuseCount / (metrics.narrowphaseTests || 1)).toFixed(2);
              }
            };
          })();
        }, function (module2, exports2, __webpack_require__) {
          var ALIGN_CONST = __webpack_require__(123);
          var Axes = __webpack_require__(271);
          var Bodies = __webpack_require__(86);
          var Body = __webpack_require__(41);
          var BodyBounds = __webpack_require__(1392);
          var Bounds = __webpack_require__(84);
          var Class = __webpack_require__(0);
          var Composite = __webpack_require__(118);
          var Composites = __webpack_require__(591);
          var Constraint = __webpack_require__(128);
          var Detector = __webpack_require__(273);
          var DistanceBetween = __webpack_require__(50);
          var Factory = __webpack_require__(1394);
          var GetFastValue = __webpack_require__(2);
          var GetValue = __webpack_require__(6);
          var Grid = __webpack_require__(597);
          var MatterAttractors = __webpack_require__(1525);
          var MatterCollisionEvents = __webpack_require__(1526);
          var MatterLib = __webpack_require__(1399);
          var MatterWrap = __webpack_require__(1527);
          var Merge = __webpack_require__(127);
          var Pair = __webpack_require__(250);
          var Pairs = __webpack_require__(598);
          var Plugin = __webpack_require__(595);
          var PluginCache = __webpack_require__(24);
          var Query = __webpack_require__(1400);
          var Resolver = __webpack_require__(599);
          var SAT = __webpack_require__(274);
          var SceneEvents = __webpack_require__(20);
          var Svg = __webpack_require__(592);
          var Vector = __webpack_require__(83);
          var Vertices = __webpack_require__(64);
          var World = __webpack_require__(1402);
          var MatterPhysics = new Class({
            initialize: function MatterPhysics2(scene) {
              this.scene = scene;
              this.systems = scene.sys;
              this.config = this.getConfig();
              this.world;
              this.add;
              this.bodyBounds;
              this.body = Body;
              this.composite = Composite;
              this.detector = Detector;
              this.grid = Grid;
              this.pair = Pair;
              this.pairs = Pairs;
              this.query = Query;
              this.resolver = Resolver;
              this.sat = SAT;
              this.constraint = Constraint;
              this.bodies = Bodies;
              this.composites = Composites;
              this.axes = Axes;
              this.bounds = Bounds;
              this.svg = Svg;
              this.vector = Vector;
              this.vertices = Vertices;
              this.verts = Vertices;
              this._tempVec2 = Vector.create();
              if (GetValue(this.config, "plugins.collisionevents", true)) {
                this.enableCollisionEventsPlugin();
              }
              if (GetValue(this.config, "plugins.attractors", false)) {
                this.enableAttractorPlugin();
              }
              if (GetValue(this.config, "plugins.wrap", false)) {
                this.enableWrapPlugin();
              }
              Resolver._restingThresh = GetValue(this.config, "restingThresh", 4);
              Resolver._restingThreshTangent = GetValue(this.config, "restingThreshTangent", 6);
              Resolver._positionDampen = GetValue(this.config, "positionDampen", 0.9);
              Resolver._positionWarming = GetValue(this.config, "positionWarming", 0.8);
              Resolver._frictionNormalMultiplier = GetValue(this.config, "frictionNormalMultiplier", 5);
              scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
              scene.sys.events.on(SceneEvents.START, this.start, this);
            },
            boot: function () {
              this.world = new World(this.scene, this.config);
              this.add = new Factory(this.world);
              this.bodyBounds = new BodyBounds();
              this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
            },
            start: function () {
              if (!this.world) {
                this.world = new World(this.scene, this.config);
                this.add = new Factory(this.world);
              }
              var eventEmitter = this.systems.events;
              eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world);
              eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
              eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
            },
            getConfig: function () {
              var gameConfig = this.systems.game.config.physics;
              var sceneConfig = this.systems.settings.physics;
              var config = Merge(GetFastValue(sceneConfig, "matter", {}), GetFastValue(gameConfig, "matter", {}));
              return config;
            },
            enableAttractorPlugin: function () {
              Plugin.register(MatterAttractors);
              Plugin.use(MatterLib, MatterAttractors);
              return this;
            },
            enableWrapPlugin: function () {
              Plugin.register(MatterWrap);
              Plugin.use(MatterLib, MatterWrap);
              return this;
            },
            enableCollisionEventsPlugin: function () {
              Plugin.register(MatterCollisionEvents);
              Plugin.use(MatterLib, MatterCollisionEvents);
              return this;
            },
            pause: function () {
              return this.world.pause();
            },
            resume: function () {
              return this.world.resume();
            },
            set60Hz: function () {
              this.world.getDelta = this.world.update60Hz;
              this.world.autoUpdate = true;
              return this;
            },
            set30Hz: function () {
              this.world.getDelta = this.world.update30Hz;
              this.world.autoUpdate = true;
              return this;
            },
            step: function (delta, correction) {
              this.world.step(delta, correction);
            },
            containsPoint: function (body, x, y) {
              body = this.getMatterBodies(body);
              var position = Vector.create(x, y);
              var result = Query.point(body, position);
              return result.length > 0 ? true : false;
            },
            intersectPoint: function (x, y, bodies) {
              bodies = this.getMatterBodies(bodies);
              var position = Vector.create(x, y);
              var output = [];
              var result = Query.point(bodies, position);
              result.forEach(function (body) {
                if (output.indexOf(body) === -1) {
                  output.push(body);
                }
              });
              return output;
            },
            intersectRect: function (x, y, width, height, outside, bodies) {
              if (outside === void 0) {
                outside = false;
              }
              bodies = this.getMatterBodies(bodies);
              var bounds = {
                min: {
                  x,
                  y
                },
                max: {
                  x: x + width,
                  y: y + height
                }
              };
              var output = [];
              var result = Query.region(bodies, bounds, outside);
              result.forEach(function (body) {
                if (output.indexOf(body) === -1) {
                  output.push(body);
                }
              });
              return output;
            },
            intersectRay: function (x1, y1, x2, y2, rayWidth, bodies) {
              if (rayWidth === void 0) {
                rayWidth = 1;
              }
              bodies = this.getMatterBodies(bodies);
              var result = [];
              var collisions = Query.ray(bodies, Vector.create(x1, y1), Vector.create(x2, y2), rayWidth);
              for (var i = 0; i < collisions.length; i++) {
                result.push(collisions[i].body);
              }
              return result;
            },
            intersectBody: function (body, bodies) {
              bodies = this.getMatterBodies(bodies);
              var result = [];
              var collisions = Query.collides(body, bodies);
              for (var i = 0; i < collisions.length; i++) {
                var pair = collisions[i];
                if (pair.bodyA === body) {
                  result.push(pair.bodyB);
                } else {
                  result.push(pair.bodyA);
                }
              }
              return result;
            },
            overlap: function (target, bodies, overlapCallback, processCallback, callbackContext) {
              if (overlapCallback === void 0) {
                overlapCallback = null;
              }
              if (processCallback === void 0) {
                processCallback = null;
              }
              if (callbackContext === void 0) {
                callbackContext = overlapCallback;
              }
              if (!Array.isArray(target)) {
                target = [target];
              }
              target = this.getMatterBodies(target);
              bodies = this.getMatterBodies(bodies);
              var match = false;
              for (var i = 0; i < target.length; i++) {
                var entry = target[i];
                var collisions = Query.collides(entry, bodies);
                for (var c = 0; c < collisions.length; c++) {
                  var info = collisions[c];
                  var bodyB = info.bodyA.id === entry.id ? info.bodyB : info.bodyA;
                  if (!processCallback || processCallback.call(callbackContext, entry, bodyB, info)) {
                    match = true;
                    if (overlapCallback) {
                      overlapCallback.call(callbackContext, entry, bodyB, info);
                    } else if (!processCallback) {
                      return true;
                    }
                  }
                }
              }
              return match;
            },
            setCollisionCategory: function (bodies, value) {
              bodies = this.getMatterBodies(bodies);
              bodies.forEach(function (body) {
                body.collisionFilter.category = value;
              });
              return this;
            },
            setCollisionGroup: function (bodies, value) {
              bodies = this.getMatterBodies(bodies);
              bodies.forEach(function (body) {
                body.collisionFilter.group = value;
              });
              return this;
            },
            setCollidesWith: function (bodies, categories) {
              bodies = this.getMatterBodies(bodies);
              var flags = 0;
              if (!Array.isArray(categories)) {
                flags = categories;
              } else {
                for (var i = 0; i < categories.length; i++) {
                  flags |= categories[i];
                }
              }
              bodies.forEach(function (body) {
                body.collisionFilter.mask = flags;
              });
              return this;
            },
            getMatterBodies: function (bodies) {
              if (!bodies) {
                return this.world.getAllBodies();
              }
              if (!Array.isArray(bodies)) {
                bodies = [bodies];
              }
              var output = [];
              for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i].hasOwnProperty("body") ? bodies[i].body : bodies[i];
                output.push(body);
              }
              return output;
            },
            setVelocity: function (bodies, x, y) {
              bodies = this.getMatterBodies(bodies);
              var vec2 = this._tempVec2;
              vec2.x = x;
              vec2.y = y;
              bodies.forEach(function (body) {
                Body.setVelocity(body, vec2);
              });
              return this;
            },
            setVelocityX: function (bodies, x) {
              bodies = this.getMatterBodies(bodies);
              var vec2 = this._tempVec2;
              vec2.x = x;
              bodies.forEach(function (body) {
                vec2.y = body.velocity.y;
                Body.setVelocity(body, vec2);
              });
              return this;
            },
            setVelocityY: function (bodies, y) {
              bodies = this.getMatterBodies(bodies);
              var vec2 = this._tempVec2;
              vec2.y = y;
              bodies.forEach(function (body) {
                vec2.x = body.velocity.x;
                Body.setVelocity(body, vec2);
              });
              return this;
            },
            setAngularVelocity: function (bodies, value) {
              bodies = this.getMatterBodies(bodies);
              bodies.forEach(function (body) {
                Body.setAngularVelocity(body, value);
              });
              return this;
            },
            applyForce: function (bodies, force) {
              bodies = this.getMatterBodies(bodies);
              var vec2 = this._tempVec2;
              bodies.forEach(function (body) {
                vec2.x = body.position.x;
                vec2.y = body.position.y;
                Body.applyForce(body, vec2, force);
              });
              return this;
            },
            applyForceFromPosition: function (bodies, position, speed, angle) {
              bodies = this.getMatterBodies(bodies);
              var vec2 = this._tempVec2;
              bodies.forEach(function (body) {
                if (angle === void 0) {
                  angle = body.angle;
                }
                vec2.x = speed * Math.cos(angle);
                vec2.y = speed * Math.sin(angle);
                Body.applyForce(body, position, vec2);
              });
              return this;
            },
            applyForceFromAngle: function (bodies, speed, angle) {
              bodies = this.getMatterBodies(bodies);
              var vec2 = this._tempVec2;
              bodies.forEach(function (body) {
                if (angle === void 0) {
                  angle = body.angle;
                }
                vec2.x = speed * Math.cos(angle);
                vec2.y = speed * Math.sin(angle);
                Body.applyForce(body, {
                  x: body.position.x,
                  y: body.position.y
                }, vec2);
              });
              return this;
            },
            getConstraintLength: function (constraint) {
              var aX = constraint.pointA.x;
              var aY = constraint.pointA.y;
              var bX = constraint.pointB.x;
              var bY = constraint.pointB.y;
              if (constraint.bodyA) {
                aX += constraint.bodyA.position.x;
                aY += constraint.bodyA.position.y;
              }
              if (constraint.bodyB) {
                bX += constraint.bodyB.position.x;
                bY += constraint.bodyB.position.y;
              }
              return DistanceBetween(aX, aY, bX, bY);
            },
            alignBody: function (body, x, y, align) {
              body = body.hasOwnProperty("body") ? body.body : body;
              var pos;
              switch (align) {
                case ALIGN_CONST.TOP_LEFT:
                case ALIGN_CONST.LEFT_TOP:
                  pos = this.bodyBounds.getTopLeft(body, x, y);
                  break;
                case ALIGN_CONST.TOP_CENTER:
                  pos = this.bodyBounds.getTopCenter(body, x, y);
                  break;
                case ALIGN_CONST.TOP_RIGHT:
                case ALIGN_CONST.RIGHT_TOP:
                  pos = this.bodyBounds.getTopRight(body, x, y);
                  break;
                case ALIGN_CONST.LEFT_CENTER:
                  pos = this.bodyBounds.getLeftCenter(body, x, y);
                  break;
                case ALIGN_CONST.CENTER:
                  pos = this.bodyBounds.getCenter(body, x, y);
                  break;
                case ALIGN_CONST.RIGHT_CENTER:
                  pos = this.bodyBounds.getRightCenter(body, x, y);
                  break;
                case ALIGN_CONST.LEFT_BOTTOM:
                case ALIGN_CONST.BOTTOM_LEFT:
                  pos = this.bodyBounds.getBottomLeft(body, x, y);
                  break;
                case ALIGN_CONST.BOTTOM_CENTER:
                  pos = this.bodyBounds.getBottomCenter(body, x, y);
                  break;
                case ALIGN_CONST.BOTTOM_RIGHT:
                case ALIGN_CONST.RIGHT_BOTTOM:
                  pos = this.bodyBounds.getBottomRight(body, x, y);
                  break;
              }
              if (pos) {
                Body.setPosition(body, pos);
              }
              return this;
            },
            shutdown: function () {
              var eventEmitter = this.systems.events;
              if (this.world) {
                eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world);
                eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
              }
              eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
              if (this.add) {
                this.add.destroy();
              }
              if (this.world) {
                this.world.destroy();
              }
              this.add = null;
              this.world = null;
            },
            destroy: function () {
              this.shutdown();
              this.scene.sys.events.off(SceneEvents.START, this.start, this);
              this.scene = null;
              this.systems = null;
            }
          });
          PluginCache.register("MatterPhysics", MatterPhysics, "matterPhysics");
          module2.exports = MatterPhysics;
        }, function (module2, exports2, __webpack_require__) {
          var Matter = __webpack_require__(594);
          var MatterAttractors = {
            name: "matter-attractors",
            version: "0.1.7",
            for: "matter-js@^0.14.2",
            silent: true,
            install: function (base) {
              base.after("Body.create", function () {
                MatterAttractors.Body.init(this);
              });
              base.before("Engine.update", function (engine) {
                MatterAttractors.Engine.update(engine);
              });
            },
            Body: {
              init: function (body) {
                body.plugin.attractors = body.plugin.attractors || [];
              }
            },
            Engine: {
              update: function (engine) {
                var bodies = Matter.Composite.allBodies(engine.world);
                for (var i = 0; i < bodies.length; i++) {
                  var bodyA = bodies[i];
                  var attractors = bodyA.plugin.attractors;
                  if (attractors && attractors.length > 0) {
                    for (var j = 0; j < bodies.length; j++) {
                      var bodyB = bodies[j];
                      if (i !== j) {
                        for (var k = 0; k < attractors.length; k++) {
                          var attractor = attractors[k];
                          var forceVector = attractor;
                          if (Matter.Common.isFunction(attractor)) {
                            forceVector = attractor(bodyA, bodyB);
                          }
                          if (forceVector) {
                            Matter.Body.applyForce(bodyB, bodyB.position, forceVector);
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            Attractors: {
              gravityConstant: 1e-3,
              gravity: function (bodyA, bodyB) {
                var bToA = Matter.Vector.sub(bodyB.position, bodyA.position);
                var distanceSq = Matter.Vector.magnitudeSquared(bToA) || 1e-4;
                var normal = Matter.Vector.normalise(bToA);
                var magnitude = -MatterAttractors.Attractors.gravityConstant * (bodyA.mass * bodyB.mass / distanceSq);
                var force = Matter.Vector.mult(normal, magnitude);
                Matter.Body.applyForce(bodyA, bodyA.position, Matter.Vector.neg(force));
                Matter.Body.applyForce(bodyB, bodyB.position, force);
              }
            }
          };
          module2.exports = MatterAttractors;
        }, function (module2, exports2) {
          var MatterCollisionEvents = {
            name: "matter-collision-events",
            version: "0.1.6",
            for: "matter-js@^0.14.2",
            silent: true,
            install: function (matter) {
              matter.after("Engine.create", function () {
                matter.Events.on(this, "collisionStart", function (event) {
                  event.pairs.map(function (pair) {
                    var bodyA = pair.bodyA;
                    var bodyB = pair.bodyB;
                    if (bodyA.gameObject) {
                      bodyA.gameObject.emit("collide", bodyA, bodyB, pair);
                    }
                    if (bodyB.gameObject) {
                      bodyB.gameObject.emit("collide", bodyB, bodyA, pair);
                    }
                    matter.Events.trigger(bodyA, "onCollide", {
                      pair
                    });
                    matter.Events.trigger(bodyB, "onCollide", {
                      pair
                    });
                    if (bodyA.onCollideCallback) {
                      bodyA.onCollideCallback(pair);
                    }
                    if (bodyB.onCollideCallback) {
                      bodyB.onCollideCallback(pair);
                    }
                    if (bodyA.onCollideWith[bodyB.id]) {
                      bodyA.onCollideWith[bodyB.id](bodyB, pair);
                    }
                    if (bodyB.onCollideWith[bodyA.id]) {
                      bodyB.onCollideWith[bodyA.id](bodyA, pair);
                    }
                  });
                });
                matter.Events.on(this, "collisionActive", function (event) {
                  event.pairs.map(function (pair) {
                    var bodyA = pair.bodyA;
                    var bodyB = pair.bodyB;
                    if (bodyA.gameObject) {
                      bodyA.gameObject.emit("collideActive", bodyA, bodyB, pair);
                    }
                    if (bodyB.gameObject) {
                      bodyB.gameObject.emit("collideActive", bodyB, bodyA, pair);
                    }
                    matter.Events.trigger(bodyA, "onCollideActive", {
                      pair
                    });
                    matter.Events.trigger(bodyB, "onCollideActive", {
                      pair
                    });
                    if (bodyA.onCollideActiveCallback) {
                      bodyA.onCollideActiveCallback(pair);
                    }
                    if (bodyB.onCollideActiveCallback) {
                      bodyB.onCollideActiveCallback(pair);
                    }
                  });
                });
                matter.Events.on(this, "collisionEnd", function (event) {
                  event.pairs.map(function (pair) {
                    var bodyA = pair.bodyA;
                    var bodyB = pair.bodyB;
                    if (bodyA.gameObject) {
                      bodyA.gameObject.emit("collideEnd", bodyA, bodyB, pair);
                    }
                    if (bodyB.gameObject) {
                      bodyB.gameObject.emit("collideEnd", bodyB, bodyA, pair);
                    }
                    matter.Events.trigger(bodyA, "onCollideEnd", {
                      pair
                    });
                    matter.Events.trigger(bodyB, "onCollideEnd", {
                      pair
                    });
                    if (bodyA.onCollideEndCallback) {
                      bodyA.onCollideEndCallback(pair);
                    }
                    if (bodyB.onCollideEndCallback) {
                      bodyB.onCollideEndCallback(pair);
                    }
                  });
                });
              });
            }
          };
          module2.exports = MatterCollisionEvents;
        }, function (module2, exports2, __webpack_require__) {
          var Matter = __webpack_require__(594);
          var MatterWrap = {
            name: "matter-wrap",
            version: "0.1.4",
            for: "matter-js@^0.14.2",
            silent: true,
            install: function (base) {
              base.after("Engine.update", function () {
                MatterWrap.Engine.update(this);
              });
            },
            Engine: {
              update: function (engine) {
                var world = engine.world, bodies = Matter.Composite.allBodies(world), composites = Matter.Composite.allComposites(world);
                for (var i = 0; i < bodies.length; i += 1) {
                  var body = bodies[i];
                  if (body.plugin.wrap) {
                    MatterWrap.Body.wrap(body, body.plugin.wrap);
                  }
                }
                for (i = 0; i < composites.length; i += 1) {
                  var composite = composites[i];
                  if (composite.plugin.wrap) {
                    MatterWrap.Composite.wrap(composite, composite.plugin.wrap);
                  }
                }
              }
            },
            Bounds: {
              wrap: function (objectBounds, bounds) {
                var x = null, y = null;
                if (typeof bounds.min.x !== "undefined" && typeof bounds.max.x !== "undefined") {
                  if (objectBounds.min.x > bounds.max.x) {
                    x = bounds.min.x - objectBounds.max.x;
                  } else if (objectBounds.max.x < bounds.min.x) {
                    x = bounds.max.x - objectBounds.min.x;
                  }
                }
                if (typeof bounds.min.y !== "undefined" && typeof bounds.max.y !== "undefined") {
                  if (objectBounds.min.y > bounds.max.y) {
                    y = bounds.min.y - objectBounds.max.y;
                  } else if (objectBounds.max.y < bounds.min.y) {
                    y = bounds.max.y - objectBounds.min.y;
                  }
                }
                if (x !== null || y !== null) {
                  return {
                    x: x || 0,
                    y: y || 0
                  };
                }
              }
            },
            Body: {
              wrap: function (body, bounds) {
                var translation = MatterWrap.Bounds.wrap(body.bounds, bounds);
                if (translation) {
                  Matter.Body.translate(body, translation);
                }
                return translation;
              }
            },
            Composite: {
              bounds: function (composite) {
                var bodies = Matter.Composite.allBodies(composite), vertices = [];
                for (var i = 0; i < bodies.length; i += 1) {
                  var body = bodies[i];
                  vertices.push(body.bounds.min, body.bounds.max);
                }
                return Matter.Bounds.create(vertices);
              },
              wrap: function (composite, bounds) {
                var translation = MatterWrap.Bounds.wrap(MatterWrap.Composite.bounds(composite), bounds);
                if (translation) {
                  Matter.Composite.translate(composite, translation);
                }
                return translation;
              }
            }
          };
          module2.exports = MatterWrap;
        }, function (module2, exports2, __webpack_require__) {
          (function (global) {
            var CONST = __webpack_require__(33);
            var Extend = __webpack_require__(17);
            var Phaser2 = {
              Actions: __webpack_require__(275),
              Animations: __webpack_require__(723),
              BlendModes: __webpack_require__(35),
              Cache: __webpack_require__(735),
              Cameras: __webpack_require__(738),
              Core: __webpack_require__(806),
              Class: __webpack_require__(0),
              Create: __webpack_require__(888),
              Curves: __webpack_require__(894),
              Data: __webpack_require__(896),
              Display: __webpack_require__(898),
              DOM: __webpack_require__(917),
              Events: __webpack_require__(918),
              Game: __webpack_require__(920),
              GameObjects: __webpack_require__(1011),
              Geom: __webpack_require__(483),
              Input: __webpack_require__(1308),
              Loader: __webpack_require__(1338),
              Math: __webpack_require__(193),
              Physics: __webpack_require__(1493),
              Plugins: __webpack_require__(1403),
              Renderer: __webpack_require__(1405),
              Scale: __webpack_require__(1412),
              ScaleModes: __webpack_require__(168),
              Scene: __webpack_require__(418),
              Scenes: __webpack_require__(1413),
              Structs: __webpack_require__(1415),
              Textures: __webpack_require__(1416),
              Tilemaps: __webpack_require__(1418),
              Time: __webpack_require__(1461),
              Tweens: __webpack_require__(1463),
              Utils: __webpack_require__(1481)
            };
            if (true) {
              Phaser2.Sound = __webpack_require__(1492);
            }
            if (false) {}
            if (false) {}
            Phaser2 = Extend(false, Phaser2, CONST);
            module2.exports = Phaser2;
            global.Phaser = Phaser2;
          }).call(this, __webpack_require__(600));
        }]);
      });
    }
  });
  var require_dom4_max = __commonJS({
    "node_modules/dom4/build/dom4.max.js"() {
      init_define_process();
      (function (window2) {
        "use strict";
        function createDocumentFragment() {
          return document2.createDocumentFragment();
        }
        function createElement7(nodeName) {
          return document2.createElement(nodeName);
        }
        function enoughArguments(length, name) {
          if (!length) throw new Error("Failed to construct " + name + ": 1 argument required, but only 0 present.");
        }
        function mutationMacro(nodes) {
          if (nodes.length === 1) {
            return textNodeIfPrimitive(nodes[0]);
          }
          for (var fragment = createDocumentFragment(), list = slice.call(nodes), i2 = 0; i2 < nodes.length; i2++) {
            fragment.appendChild(textNodeIfPrimitive(list[i2]));
          }
          return fragment;
        }
        function textNodeIfPrimitive(node) {
          return typeof node === "object" ? node : document2.createTextNode(node);
        }
        for (var head, property, TemporaryPrototype, TemporaryTokenList, wrapVerifyToken, document2 = window2.document, hOP = Object.prototype.hasOwnProperty, defineProperty = Object.defineProperty || (function (object, property2, descriptor) {
          if (hOP.call(descriptor, "value")) {
            object[property2] = descriptor.value;
          } else {
            if (hOP.call(descriptor, "get")) object.__defineGetter__(property2, descriptor.get);
            if (hOP.call(descriptor, "set")) object.__defineSetter__(property2, descriptor.set);
          }
          return object;
        }), indexOf = [].indexOf || (function indexOf2(value) {
          var length = this.length;
          while (length--) {
            if (this[length] === value) {
              break;
            }
          }
          return length;
        }), verifyToken = function (token) {
          if (!token) {
            throw "SyntaxError";
          } else if (spaces.test(token)) {
            throw "InvalidCharacterError";
          }
          return token;
        }, DOMTokenList = function (node) {
          var noClassName = typeof node.className === "undefined", className = noClassName ? node.getAttribute("class") || "" : node.className, isSVG = noClassName || typeof className === "object", value = (isSVG ? noClassName ? className : className.baseVal : className).replace(trim, "");
          if (value.length) {
            properties.push.apply(this, value.split(spaces));
          }
          this._isSVG = isSVG;
          this._ = node;
        }, classListDescriptor = {
          get: function get() {
            return new DOMTokenList(this);
          },
          set: function () {}
        }, trim = /^\s+|\s+$/g, spaces = /\s+/, SPACE2 = " ", CLASS_LIST = "classList", toggle = function toggle2(token, force) {
          if (this.contains(token)) {
            if (!force) {
              this.remove(token);
            }
          } else if (force === void 0 || force) {
            force = true;
            this.add(token);
          }
          return !!force;
        }, DocumentFragmentPrototype = window2.DocumentFragment && DocumentFragment.prototype, Node = window2.Node, NodePrototype = (Node || Element).prototype, CharacterData = window2.CharacterData || Node, CharacterDataPrototype = CharacterData && CharacterData.prototype, DocumentType = window2.DocumentType, DocumentTypePrototype = DocumentType && DocumentType.prototype, ElementPrototype = (window2.Element || Node || window2.HTMLElement).prototype, HTMLSelectElement = window2.HTMLSelectElement || createElement7("select").constructor, selectRemove = HTMLSelectElement.prototype.remove, SVGElement = window2.SVGElement, properties = ["matches", ElementPrototype.matchesSelector || ElementPrototype.webkitMatchesSelector || ElementPrototype.khtmlMatchesSelector || ElementPrototype.mozMatchesSelector || ElementPrototype.msMatchesSelector || ElementPrototype.oMatchesSelector || (function matches(selector) {
          var parentNode = this.parentNode;
          return !!parentNode && -1 < indexOf.call(parentNode.querySelectorAll(selector), this);
        }), "closest", function closest(selector) {
          var parentNode = this, matches;
          while ((matches = parentNode && parentNode.matches) && !parentNode.matches(selector)) {
            parentNode = parentNode.parentNode;
          }
          return matches ? parentNode : null;
        }, "prepend", function prepend() {
          var firstChild = this.firstChild, node = mutationMacro(arguments);
          if (firstChild) {
            this.insertBefore(node, firstChild);
          } else {
            this.appendChild(node);
          }
        }, "append", function append() {
          this.appendChild(mutationMacro(arguments));
        }, "before", function before() {
          var parentNode = this.parentNode;
          if (parentNode) {
            parentNode.insertBefore(mutationMacro(arguments), this);
          }
        }, "after", function after() {
          var parentNode = this.parentNode, nextSibling = this.nextSibling, node = mutationMacro(arguments);
          if (parentNode) {
            if (nextSibling) {
              parentNode.insertBefore(node, nextSibling);
            } else {
              parentNode.appendChild(node);
            }
          }
        }, "toggleAttribute", function toggleAttribute(name, force) {
          var had = this.hasAttribute(name);
          if (1 < arguments.length) {
            if (had && !force) this.removeAttribute(name); else if (force && !had) this.setAttribute(name, "");
          } else if (had) this.removeAttribute(name); else this.setAttribute(name, "");
          return this.hasAttribute(name);
        }, "replace", function replace2() {
          this.replaceWith.apply(this, arguments);
        }, "replaceWith", function replaceWith() {
          var parentNode = this.parentNode;
          if (parentNode) {
            parentNode.replaceChild(mutationMacro(arguments), this);
          }
        }, "remove", function remove() {
          var parentNode = this.parentNode;
          if (parentNode) {
            parentNode.removeChild(this);
          }
        }], slice = properties.slice, i = properties.length; i; i -= 2) {
          property = properties[i - 2];
          if (!((property in ElementPrototype))) {
            ElementPrototype[property] = properties[i - 1];
          }
          if (property === "remove" && !selectRemove._dom4) {
            (HTMLSelectElement.prototype[property] = function () {
              return 0 < arguments.length ? selectRemove.apply(this, arguments) : ElementPrototype.remove.call(this);
            })._dom4 = true;
          }
          if ((/^(?:before|after|replace|replaceWith|remove)$/).test(property)) {
            if (CharacterData && !((property in CharacterDataPrototype))) {
              CharacterDataPrototype[property] = properties[i - 1];
            }
            if (DocumentType && !((property in DocumentTypePrototype))) {
              DocumentTypePrototype[property] = properties[i - 1];
            }
          }
          if ((/^(?:append|prepend)$/).test(property)) {
            if (DocumentFragmentPrototype) {
              if (!((property in DocumentFragmentPrototype))) {
                DocumentFragmentPrototype[property] = properties[i - 1];
              }
            } else {
              try {
                createDocumentFragment().constructor.prototype[property] = properties[i - 1];
              } catch (o_O) {}
            }
          }
        }
        if (!createElement7("a").matches("a")) {
          ElementPrototype[property] = (function (matches) {
            return function (selector) {
              return matches.call(this.parentNode ? this : createDocumentFragment().appendChild(this), selector);
            };
          })(ElementPrototype[property]);
        }
        DOMTokenList.prototype = {
          length: 0,
          add: function add() {
            for (var j = 0, token; j < arguments.length; j++) {
              token = arguments[j];
              if (!this.contains(token)) {
                properties.push.call(this, property);
              }
            }
            if (this._isSVG) {
              this._.setAttribute("class", "" + this);
            } else {
              this._.className = "" + this;
            }
          },
          contains: (function (indexOf2) {
            return function contains(token) {
              i = indexOf2.call(this, property = verifyToken(token));
              return -1 < i;
            };
          })([].indexOf || (function (token) {
            i = this.length;
            while (i-- && this[i] !== token) {}
            return i;
          })),
          item: function item(i2) {
            return this[i2] || null;
          },
          remove: function remove() {
            for (var j = 0, token; j < arguments.length; j++) {
              token = arguments[j];
              if (this.contains(token)) {
                properties.splice.call(this, i, 1);
              }
            }
            if (this._isSVG) {
              this._.setAttribute("class", "" + this);
            } else {
              this._.className = "" + this;
            }
          },
          toggle,
          toString: function toString() {
            return properties.join.call(this, SPACE2);
          }
        };
        if (SVGElement && !((CLASS_LIST in SVGElement.prototype))) {
          defineProperty(SVGElement.prototype, CLASS_LIST, classListDescriptor);
        }
        if (!((CLASS_LIST in document2.documentElement))) {
          defineProperty(ElementPrototype, CLASS_LIST, classListDescriptor);
        } else {
          TemporaryTokenList = createElement7("div")[CLASS_LIST];
          TemporaryTokenList.add("a", "b", "a");
          if ("a b" != TemporaryTokenList) {
            TemporaryPrototype = TemporaryTokenList.constructor.prototype;
            if (!(("add" in TemporaryPrototype))) {
              TemporaryPrototype = window2.TemporaryTokenList.prototype;
            }
            wrapVerifyToken = function (original) {
              return function () {
                var i2 = 0;
                while (i2 < arguments.length) {
                  original.call(this, arguments[i2++]);
                }
              };
            };
            TemporaryPrototype.add = wrapVerifyToken(TemporaryPrototype.add);
            TemporaryPrototype.remove = wrapVerifyToken(TemporaryPrototype.remove);
            TemporaryPrototype.toggle = toggle;
          }
        }
        if (!(("contains" in NodePrototype))) {
          defineProperty(NodePrototype, "contains", {
            value: function (el) {
              while (el && el !== this) el = el.parentNode;
              return this === el;
            }
          });
        }
        if (!(("head" in document2))) {
          defineProperty(document2, "head", {
            get: function () {
              return head || (head = document2.getElementsByTagName("head")[0]);
            }
          });
        }
        (function () {
          for (var raf, rAF = window2.requestAnimationFrame, cAF = window2.cancelAnimationFrame, prefixes = ["o", "ms", "moz", "webkit"], i2 = prefixes.length; !cAF && i2--; ) {
            rAF = rAF || window2[prefixes[i2] + "RequestAnimationFrame"];
            cAF = window2[prefixes[i2] + "CancelAnimationFrame"] || window2[prefixes[i2] + "CancelRequestAnimationFrame"];
          }
          if (!cAF) {
            if (rAF) {
              raf = rAF;
              rAF = function (callback) {
                var goOn = true;
                raf(function () {
                  if (goOn) callback.apply(this, arguments);
                });
                return function () {
                  goOn = false;
                };
              };
              cAF = function (id) {
                id();
              };
            } else {
              rAF = function (callback) {
                return setTimeout(callback, 15, 15);
              };
              cAF = function (id) {
                clearTimeout(id);
              };
            }
          }
          window2.requestAnimationFrame = rAF;
          window2.cancelAnimationFrame = cAF;
        })();
        try {
          new window2.CustomEvent("?");
        } catch (o_O) {
          window2.CustomEvent = (function (eventName, defaultInitDict) {
            function CustomEvent2(type, eventInitDict) {
              var event = document2.createEvent(eventName);
              if (typeof type != "string") {
                throw new Error("An event name must be provided");
              }
              if (eventName == "Event") {
                event.initCustomEvent = initCustomEvent;
              }
              if (eventInitDict == null) {
                eventInitDict = defaultInitDict;
              }
              event.initCustomEvent(type, eventInitDict.bubbles, eventInitDict.cancelable, eventInitDict.detail);
              return event;
            }
            function initCustomEvent(type, bubbles, cancelable, detail) {
              this.initEvent(type, bubbles, cancelable);
              this.detail = detail;
            }
            return CustomEvent2;
          })(window2.CustomEvent ? "CustomEvent" : "Event", {
            bubbles: false,
            cancelable: false,
            detail: null
          });
        }
        try {
          new Event("_");
        } catch (o_O) {
          o_O = (function ($Event) {
            function Event2(type, init) {
              enoughArguments(arguments.length, "Event");
              var out = document2.createEvent("Event");
              if (!init) init = {};
              out.initEvent(type, !!init.bubbles, !!init.cancelable);
              return out;
            }
            Event2.prototype = $Event.prototype;
            return Event2;
          })(window2.Event || (function Event2() {}));
          defineProperty(window2, "Event", {
            value: o_O
          });
          if (Event !== o_O) Event = o_O;
        }
        try {
          new KeyboardEvent("_", {});
        } catch (o_O) {
          o_O = (function ($KeyboardEvent) {
            var initType = 0, defaults = {
              char: "",
              key: "",
              location: 0,
              ctrlKey: false,
              shiftKey: false,
              altKey: false,
              metaKey: false,
              altGraphKey: false,
              repeat: false,
              locale: navigator.language,
              detail: 0,
              bubbles: false,
              cancelable: false,
              keyCode: 0,
              charCode: 0,
              which: 0
            }, eventType;
            try {
              var e = document2.createEvent("KeyboardEvent");
              e.initKeyboardEvent("keyup", false, false, window2, "+", 3, true, false, true, false, false);
              initType = (e.keyIdentifier || e.key) == "+" && (e.keyLocation || e.location) == 3 && (e.ctrlKey ? e.altKey ? 1 : 3 : e.shiftKey ? 2 : 4) || 9;
            } catch (o_O2) {}
            eventType = 0 < initType ? "KeyboardEvent" : "Event";
            function getModifier(init) {
              for (var out = [], keys = ["ctrlKey", "Control", "shiftKey", "Shift", "altKey", "Alt", "metaKey", "Meta", "altGraphKey", "AltGraph"], i2 = 0; i2 < keys.length; i2 += 2) {
                if (init[keys[i2]]) out.push(keys[i2 + 1]);
              }
              return out.join(" ");
            }
            function withDefaults(target, source) {
              for (var key in source) {
                if (source.hasOwnProperty(key) && !source.hasOwnProperty.call(target, key)) target[key] = source[key];
              }
              return target;
            }
            function withInitValues(key, out, init) {
              try {
                out[key] = init[key];
              } catch (o_O2) {}
            }
            function KeyboardEvent2(type, init) {
              enoughArguments(arguments.length, "KeyboardEvent");
              init = withDefaults(init || ({}), defaults);
              var out = document2.createEvent(eventType), ctrlKey = init.ctrlKey, shiftKey = init.shiftKey, altKey = init.altKey, metaKey = init.metaKey, altGraphKey = init.altGraphKey, modifiers = initType > 3 ? getModifier(init) : null, key = String(init.key), chr = String(init.char), location = init.location, keyCode = init.keyCode || (init.keyCode = key) && key.charCodeAt(0) || 0, charCode = init.charCode || (init.charCode = chr) && chr.charCodeAt(0) || 0, bubbles = init.bubbles, cancelable = init.cancelable, repeat = init.repeat, locale = init.locale, view = init.view || window2, args;
              if (!init.which) init.which = init.keyCode;
              if (("initKeyEvent" in out)) {
                out.initKeyEvent(type, bubbles, cancelable, view, ctrlKey, altKey, shiftKey, metaKey, keyCode, charCode);
              } else if (0 < initType && ("initKeyboardEvent" in out)) {
                args = [type, bubbles, cancelable, view];
                switch (initType) {
                  case 1:
                    args.push(key, location, ctrlKey, shiftKey, altKey, metaKey, altGraphKey);
                    break;
                  case 2:
                    args.push(ctrlKey, altKey, shiftKey, metaKey, keyCode, charCode);
                    break;
                  case 3:
                    args.push(key, location, ctrlKey, altKey, shiftKey, metaKey, altGraphKey);
                    break;
                  case 4:
                    args.push(key, location, modifiers, repeat, locale);
                    break;
                  default:
                    args.push(char, key, location, modifiers, repeat, locale);
                }
                out.initKeyboardEvent.apply(out, args);
              } else {
                out.initEvent(type, bubbles, cancelable);
              }
              for (key in out) {
                if (defaults.hasOwnProperty(key) && out[key] !== init[key]) {
                  withInitValues(key, out, init);
                }
              }
              return out;
            }
            KeyboardEvent2.prototype = $KeyboardEvent.prototype;
            return KeyboardEvent2;
          })(window2.KeyboardEvent || (function KeyboardEvent2() {}));
          defineProperty(window2, "KeyboardEvent", {
            value: o_O
          });
          if (KeyboardEvent !== o_O) KeyboardEvent = o_O;
        }
        try {
          new MouseEvent("_", {});
        } catch (o_O) {
          o_O = (function ($MouseEvent) {
            function MouseEvent2(type, init) {
              enoughArguments(arguments.length, "MouseEvent");
              var out = document2.createEvent("MouseEvent");
              if (!init) init = {};
              out.initMouseEvent(type, !!init.bubbles, !!init.cancelable, init.view || window2, init.detail || 1, init.screenX || 0, init.screenY || 0, init.clientX || 0, init.clientY || 0, !!init.ctrlKey, !!init.altKey, !!init.shiftKey, !!init.metaKey, init.button || 0, init.relatedTarget || null);
              return out;
            }
            MouseEvent2.prototype = $MouseEvent.prototype;
            return MouseEvent2;
          })(window2.MouseEvent || (function MouseEvent2() {}));
          defineProperty(window2, "MouseEvent", {
            value: o_O
          });
          if (MouseEvent !== o_O) MouseEvent = o_O;
        }
        if (!document2.querySelectorAll("*").forEach) {
          (function () {
            function patch(what) {
              var querySelectorAll = what.querySelectorAll;
              what.querySelectorAll = function qSA(css) {
                var result = querySelectorAll.call(this, css);
                result.forEach = Array.prototype.forEach;
                return result;
              };
            }
            patch(document2);
            patch(Element.prototype);
          })();
        }
        try {
          document2.querySelector(":scope *");
        } catch (o_O) {
          (function () {
            var dataScope = "data-scope-" + (Math.random() * 1e9 >>> 0);
            var proto = Element.prototype;
            var querySelector = proto.querySelector;
            var querySelectorAll = proto.querySelectorAll;
            proto.querySelector = function qS(css) {
              return find(this, querySelector, css);
            };
            proto.querySelectorAll = function qSA(css) {
              return find(this, querySelectorAll, css);
            };
            function find(node, method, css) {
              if (node.type != document2.ELEMENT_NODE) return method.call(node, css);
              node.setAttribute(dataScope, null);
              var result = method.call(node, String(css).replace(/(^|,\s*)(:scope([ >]|$))/g, function ($0, $1, $2, $3) {
                return $1 + "[" + dataScope + "]" + ($3 || " ");
              }));
              node.removeAttribute(dataScope);
              return result;
            }
          })();
        }
      })(window);
      (function (global) {
        "use strict";
        var DOMMap = global.WeakMap || (function () {
          var counter2 = 0, dispatched = false, drop = false, value;
          function dispatch(key, ce, shouldDrop) {
            drop = shouldDrop;
            dispatched = false;
            value = void 0;
            key.dispatchEvent(ce);
          }
          function Handler(value2) {
            this.value = value2;
          }
          Handler.prototype.handleEvent = function handleEvent(e) {
            dispatched = true;
            if (drop) {
              e.currentTarget.removeEventListener(e.type, this, false);
            } else {
              value = this.value;
            }
          };
          function DOMMap2() {
            counter2++;
            this.__ce__ = new Event2("@DOMMap:" + counter2 + Math.random());
          }
          DOMMap2.prototype = {
            "constructor": DOMMap2,
            "delete": function del(key) {
              return (dispatch(key, this.__ce__, true), dispatched);
            },
            "get": function get(key) {
              dispatch(key, this.__ce__, false);
              var v = value;
              value = void 0;
              return v;
            },
            "has": function has(key) {
              return (dispatch(key, this.__ce__, false), dispatched);
            },
            "set": function set(key, value2) {
              dispatch(key, this.__ce__, true);
              key.addEventListener(this.__ce__.type, new Handler(value2), false);
              return this;
            }
          };
          return DOMMap2;
        })();
        function Dict() {}
        Dict.prototype = (Object.create || Object)(null);
        function createEventListener(type, callback, options) {
          function eventListener(e) {
            if (eventListener.once) {
              e.currentTarget.removeEventListener(e.type, callback, eventListener);
              eventListener.removed = true;
            }
            if (eventListener.passive) {
              e.preventDefault = createEventListener.preventDefault;
            }
            if (typeof eventListener.callback === "function") {
              eventListener.callback.call(this, e);
            } else if (eventListener.callback) {
              eventListener.callback.handleEvent(e);
            }
            if (eventListener.passive) {
              delete e.preventDefault;
            }
          }
          eventListener.type = type;
          eventListener.callback = callback;
          eventListener.capture = !!options.capture;
          eventListener.passive = !!options.passive;
          eventListener.once = !!options.once;
          eventListener.removed = false;
          return eventListener;
        }
        createEventListener.preventDefault = function preventDefault() {};
        var Event2 = global.CustomEvent, dE = global.dispatchEvent, aEL = global.addEventListener, rEL = global.removeEventListener, counter = 0, increment = function () {
          counter++;
        }, indexOf = [].indexOf || (function indexOf2(value) {
          var length = this.length;
          while (length--) {
            if (this[length] === value) {
              break;
            }
          }
          return length;
        }), getListenerKey = function (options) {
          return ("").concat(options.capture ? "1" : "0", options.passive ? "1" : "0", options.once ? "1" : "0");
        }, augment;
        try {
          aEL("_", increment, {
            once: true
          });
          dE(new Event2("_"));
          dE(new Event2("_"));
          rEL("_", increment, {
            once: true
          });
        } catch (o_O) {}
        if (counter !== 1) {
          (function () {
            var dm = new DOMMap();
            function createAEL(aEL2) {
              return function addEventListener(type, handler, options) {
                if (options && typeof options !== "boolean") {
                  var info = dm.get(this), key = getListenerKey(options), i, tmp, wrap;
                  if (!info) dm.set(this, info = new Dict());
                  if (!((type in info))) info[type] = {
                    handler: [],
                    wrap: []
                  };
                  tmp = info[type];
                  i = indexOf.call(tmp.handler, handler);
                  if (i < 0) {
                    i = tmp.handler.push(handler) - 1;
                    tmp.wrap[i] = wrap = new Dict();
                  } else {
                    wrap = tmp.wrap[i];
                  }
                  if (!((key in wrap))) {
                    wrap[key] = createEventListener(type, handler, options);
                    aEL2.call(this, type, wrap[key], wrap[key].capture);
                  }
                } else {
                  aEL2.call(this, type, handler, options);
                }
              };
            }
            function createREL(rEL2) {
              return function removeEventListener(type, handler, options) {
                if (options && typeof options !== "boolean") {
                  var info = dm.get(this), key, i, tmp, wrap;
                  if (info && (type in info)) {
                    tmp = info[type];
                    i = indexOf.call(tmp.handler, handler);
                    if (-1 < i) {
                      key = getListenerKey(options);
                      wrap = tmp.wrap[i];
                      if ((key in wrap)) {
                        rEL2.call(this, type, wrap[key], wrap[key].capture);
                        delete wrap[key];
                        for (key in wrap) return;
                        tmp.handler.splice(i, 1);
                        tmp.wrap.splice(i, 1);
                        if (tmp.handler.length === 0) delete info[type];
                      }
                    }
                  }
                } else {
                  rEL2.call(this, type, handler, options);
                }
              };
            }
            augment = function (Constructor) {
              if (!Constructor) return;
              var proto = Constructor.prototype;
              proto.addEventListener = createAEL(proto.addEventListener);
              proto.removeEventListener = createREL(proto.removeEventListener);
            };
            if (global.EventTarget) {
              augment(EventTarget);
            } else {
              augment(global.Text);
              augment(global.Element || global.HTMLElement);
              augment(global.HTMLDocument);
              augment(global.Window || ({
                prototype: global
              }));
              augment(global.XMLHttpRequest);
            }
          })();
        }
      })(self);
    }
  });
  var require_colors = __commonJS({
    "node_modules/@blueprintjs/colors/lib/colors.js"(exports) {
      "use strict";
      init_define_process();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Colors = void 0;
      var grayScale = {
        BLACK: "#111418",
        DARK_GRAY1: "#1C2127",
        DARK_GRAY2: "#252A31",
        DARK_GRAY3: "#2F343C",
        DARK_GRAY4: "#383E47",
        DARK_GRAY5: "#404854",
        GRAY1: "#5F6B7C",
        GRAY2: "#738091",
        GRAY3: "#8F99A8",
        GRAY4: "#ABB3BF",
        GRAY5: "#C5CBD3",
        LIGHT_GRAY1: "#D3D8DE",
        LIGHT_GRAY2: "#DCE0E5",
        LIGHT_GRAY3: "#E5E8EB",
        LIGHT_GRAY4: "#EDEFF2",
        LIGHT_GRAY5: "#F6F7F9",
        WHITE: "#FFFFFF"
      };
      var coreColors = {
        BLUE1: "#184A90",
        BLUE2: "#215DB0",
        BLUE3: "#2D72D2",
        BLUE4: "#4C90F0",
        BLUE5: "#8ABBFF",
        GREEN1: "#165A36",
        GREEN2: "#1C6E42",
        GREEN3: "#238551",
        GREEN4: "#32A467",
        GREEN5: "#72CA9B",
        ORANGE1: "#77450D",
        ORANGE2: "#935610",
        ORANGE3: "#C87619",
        ORANGE4: "#EC9A3C",
        ORANGE5: "#FBB360",
        RED1: "#8E292C",
        RED2: "#AC2F33",
        RED3: "#CD4246",
        RED4: "#E76A6E",
        RED5: "#FA999C"
      };
      var extendedColors = {
        CERULEAN1: "#0C5174",
        CERULEAN2: "#0F6894",
        CERULEAN3: "#147EB3",
        CERULEAN4: "#3FA6DA",
        CERULEAN5: "#68C1EE",
        FOREST1: "#1D7324",
        FOREST2: "#238C2C",
        FOREST3: "#29A634",
        FOREST4: "#43BF4D",
        FOREST5: "#62D96B",
        GOLD1: "#5C4405",
        GOLD2: "#866103",
        GOLD3: "#D1980B",
        GOLD4: "#F0B726",
        GOLD5: "#FBD065",
        INDIGO1: "#5642A6",
        INDIGO2: "#634DBF",
        INDIGO3: "#7961DB",
        INDIGO4: "#9881F3",
        INDIGO5: "#BDADFF",
        LIME1: "#43501B",
        LIME2: "#5A701A",
        LIME3: "#8EB125",
        LIME4: "#B6D94C",
        LIME5: "#D4F17E",
        ROSE1: "#A82255",
        ROSE2: "#C22762",
        ROSE3: "#DB2C6F",
        ROSE4: "#F5498B",
        ROSE5: "#FF66A1",
        SEPIA1: "#5E4123",
        SEPIA2: "#7A542E",
        SEPIA3: "#946638",
        SEPIA4: "#AF855A",
        SEPIA5: "#D0B090",
        TURQUOISE1: "#004D46",
        TURQUOISE2: "#007067",
        TURQUOISE3: "#00A396",
        TURQUOISE4: "#13C9BA",
        TURQUOISE5: "#7AE1D8",
        VERMILION1: "#96290D",
        VERMILION2: "#B83211",
        VERMILION3: "#D33D17",
        VERMILION4: "#EB6847",
        VERMILION5: "#FF9980",
        VIOLET1: "#5C255C",
        VIOLET2: "#7C327C",
        VIOLET3: "#9D3F9D",
        VIOLET4: "#BD6BBD",
        VIOLET5: "#D69FD6"
      };
      var legacyColors = {
        COBALT1: extendedColors.CERULEAN1,
        COBALT2: extendedColors.CERULEAN2,
        COBALT3: extendedColors.CERULEAN3,
        COBALT4: extendedColors.CERULEAN4,
        COBALT5: extendedColors.CERULEAN5
      };
      exports.Colors = Object.assign(Object.assign(Object.assign(Object.assign({}, grayScale), coreColors), extendedColors), legacyColors);
    }
  });
  var require_legacyColors = __commonJS({
    "node_modules/@blueprintjs/colors/lib/legacyColors.js"(exports) {
      "use strict";
      init_define_process();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LegacyColors = void 0;
      exports.LegacyColors = {
        BLACK: "#10161A",
        BLUE1: "#0E5A8A",
        BLUE2: "#106BA3",
        BLUE3: "#137CBD",
        BLUE4: "#2B95D6",
        BLUE5: "#48AFF0",
        COBALT1: "#1F4B99",
        COBALT2: "#2458B3",
        COBALT3: "#2965CC",
        COBALT4: "#4580E6",
        COBALT5: "#669EFF",
        DARK_GRAY1: "#182026",
        DARK_GRAY2: "#202B33",
        DARK_GRAY3: "#293742",
        DARK_GRAY4: "#30404D",
        DARK_GRAY5: "#394B59",
        FOREST1: "#1D7324",
        FOREST2: "#238C2C",
        FOREST3: "#29A634",
        FOREST4: "#43BF4D",
        FOREST5: "#62D96B",
        GOLD1: "#A67908",
        GOLD2: "#BF8C0A",
        GOLD3: "#D99E0B",
        GOLD4: "#F2B824",
        GOLD5: "#FFC940",
        GRAY1: "#5C7080",
        GRAY2: "#738694",
        GRAY3: "#8A9BA8",
        GRAY4: "#A7B6C2",
        GRAY5: "#BFCCD6",
        GREEN1: "#0A6640",
        GREEN2: "#0D8050",
        GREEN3: "#0F9960",
        GREEN4: "#15B371",
        GREEN5: "#3DCC91",
        INDIGO1: "#5642A6",
        INDIGO2: "#634DBF",
        INDIGO3: "#7157D9",
        INDIGO4: "#9179F2",
        INDIGO5: "#AD99FF",
        LIGHT_GRAY1: "#CED9E0",
        LIGHT_GRAY2: "#D8E1E8",
        LIGHT_GRAY3: "#E1E8ED",
        LIGHT_GRAY4: "#EBF1F5",
        LIGHT_GRAY5: "#F5F8FA",
        LIME1: "#728C23",
        LIME2: "#87A629",
        LIME3: "#9BBF30",
        LIME4: "#B6D94C",
        LIME5: "#D1F26D",
        ORANGE1: "#A66321",
        ORANGE2: "#BF7326",
        ORANGE3: "#D9822B",
        ORANGE4: "#F29D49",
        ORANGE5: "#FFB366",
        RED1: "#A82A2A",
        RED2: "#C23030",
        RED3: "#DB3737",
        RED4: "#F55656",
        RED5: "#FF7373",
        ROSE1: "#A82255",
        ROSE2: "#C22762",
        ROSE3: "#DB2C6F",
        ROSE4: "#F5498B",
        ROSE5: "#FF66A1",
        SEPIA1: "#63411E",
        SEPIA2: "#7D5125",
        SEPIA3: "#96622D",
        SEPIA4: "#B07B46",
        SEPIA5: "#C99765",
        TURQUOISE1: "#008075",
        TURQUOISE2: "#00998C",
        TURQUOISE3: "#00B3A4",
        TURQUOISE4: "#14CCBD",
        TURQUOISE5: "#2EE6D6",
        VERMILION1: "#9E2B0E",
        VERMILION2: "#B83211",
        VERMILION3: "#D13913",
        VERMILION4: "#EB532D",
        VERMILION5: "#FF6E4A",
        VIOLET1: "#5C255C",
        VIOLET2: "#752F75",
        VIOLET3: "#8F398F",
        VIOLET4: "#A854A8",
        VIOLET5: "#C274C2",
        WHITE: "#FFFFFF"
      };
    }
  });
  var require_lib = __commonJS({
    "node_modules/@blueprintjs/colors/lib/index.js"(exports) {
      "use strict";
      init_define_process();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LegacyColors = exports.Colors = void 0;
      var colors_1 = require_colors();
      Object.defineProperty(exports, "Colors", {
        enumerable: true,
        get: function () {
          return colors_1.Colors;
        }
      });
      var legacyColors_1 = require_legacyColors();
      Object.defineProperty(exports, "LegacyColors", {
        enumerable: true,
        get: function () {
          return legacyColors_1.LegacyColors;
        }
      });
    }
  });
  var require_classnames = __commonJS({
    "node_modules/classnames/index.js"(exports, module) {
      init_define_process();
      (function () {
        "use strict";
        var hasOwn = ({}).hasOwnProperty;
        var nativeCodeString = "[native code]";
        function classNames5() {
          var classes = [];
          for (var i = 0; i < arguments.length; i++) {
            var arg = arguments[i];
            if (!arg) continue;
            var argType = typeof arg;
            if (argType === "string" || argType === "number") {
              classes.push(arg);
            } else if (Array.isArray(arg)) {
              if (arg.length) {
                var inner = classNames5.apply(null, arg);
                if (inner) {
                  classes.push(inner);
                }
              }
            } else if (argType === "object") {
              if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
                classes.push(arg.toString());
                continue;
              }
              for (var key in arg) {
                if (hasOwn.call(arg, key) && arg[key]) {
                  classes.push(key);
                }
              }
            }
          }
          return classes.join(" ");
        }
        if (typeof module !== "undefined" && module.exports) {
          classNames5.default = classNames5;
          module.exports = classNames5;
        } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
          define("classnames", [], function () {
            return classNames5;
          });
        } else {
          window.classNames = classNames5;
        }
      })();
    }
  });
  var ArcadeTwod_exports = {};
  __export(ArcadeTwod_exports, {
    default: () => ArcadeTwod_default
  });
  init_define_process();
  var import_react = __toESM(__require("react"), 1);
  var import_phaser = __toESM(require_phaser(), 1);
  var classes_exports = {};
  __export(classes_exports, {
    ACTIVE: () => ACTIVE,
    ALERT: () => ALERT,
    ALERT_BODY: () => ALERT_BODY,
    ALERT_CONTENTS: () => ALERT_CONTENTS,
    ALERT_FOOTER: () => ALERT_FOOTER,
    ALIGN_LEFT: () => ALIGN_LEFT,
    ALIGN_RIGHT: () => ALIGN_RIGHT,
    BLOCKQUOTE: () => BLOCKQUOTE,
    BREADCRUMB: () => BREADCRUMB,
    BREADCRUMBS: () => BREADCRUMBS,
    BREADCRUMBS_COLLAPSED: () => BREADCRUMBS_COLLAPSED,
    BREADCRUMB_CURRENT: () => BREADCRUMB_CURRENT,
    BUTTON: () => BUTTON,
    BUTTON_GROUP: () => BUTTON_GROUP,
    BUTTON_SPINNER: () => BUTTON_SPINNER,
    BUTTON_TEXT: () => BUTTON_TEXT,
    CALLOUT: () => CALLOUT,
    CALLOUT_ICON: () => CALLOUT_ICON,
    CARD: () => CARD,
    CHECKBOX: () => CHECKBOX,
    CODE: () => CODE,
    CODE_BLOCK: () => CODE_BLOCK,
    COLLAPSE: () => COLLAPSE,
    COLLAPSE_BODY: () => COLLAPSE_BODY,
    COLLAPSIBLE_LIST: () => COLLAPSIBLE_LIST,
    COMPACT: () => COMPACT,
    CONTEXT_MENU: () => CONTEXT_MENU,
    CONTEXT_MENU_POPOVER_TARGET: () => CONTEXT_MENU_POPOVER_TARGET,
    CONTROL: () => CONTROL,
    CONTROL_GROUP: () => CONTROL_GROUP,
    CONTROL_INDICATOR: () => CONTROL_INDICATOR,
    CONTROL_INDICATOR_CHILD: () => CONTROL_INDICATOR_CHILD,
    DARK: () => DARK,
    DIALOG: () => DIALOG,
    DIALOG_BODY: () => DIALOG_BODY,
    DIALOG_BODY_SCROLL_CONTAINER: () => DIALOG_BODY_SCROLL_CONTAINER,
    DIALOG_CLOSE_BUTTON: () => DIALOG_CLOSE_BUTTON,
    DIALOG_CONTAINER: () => DIALOG_CONTAINER,
    DIALOG_FOOTER: () => DIALOG_FOOTER,
    DIALOG_FOOTER_ACTIONS: () => DIALOG_FOOTER_ACTIONS,
    DIALOG_FOOTER_FIXED: () => DIALOG_FOOTER_FIXED,
    DIALOG_FOOTER_MAIN_SECTION: () => DIALOG_FOOTER_MAIN_SECTION,
    DIALOG_HEADER: () => DIALOG_HEADER,
    DIALOG_STEP: () => DIALOG_STEP,
    DIALOG_STEP_CONTAINER: () => DIALOG_STEP_CONTAINER,
    DIALOG_STEP_ICON: () => DIALOG_STEP_ICON,
    DIALOG_STEP_TITLE: () => DIALOG_STEP_TITLE,
    DIALOG_STEP_VIEWED: () => DIALOG_STEP_VIEWED,
    DISABLED: () => DISABLED,
    DIVIDER: () => DIVIDER,
    DRAWER: () => DRAWER,
    DRAWER_BODY: () => DRAWER_BODY,
    DRAWER_FOOTER: () => DRAWER_FOOTER,
    DRAWER_HEADER: () => DRAWER_HEADER,
    EDITABLE_TEXT: () => EDITABLE_TEXT,
    EDITABLE_TEXT_CONTENT: () => EDITABLE_TEXT_CONTENT,
    EDITABLE_TEXT_EDITING: () => EDITABLE_TEXT_EDITING,
    EDITABLE_TEXT_INPUT: () => EDITABLE_TEXT_INPUT,
    EDITABLE_TEXT_PLACEHOLDER: () => EDITABLE_TEXT_PLACEHOLDER,
    ELEVATION_0: () => ELEVATION_0,
    ELEVATION_1: () => ELEVATION_1,
    ELEVATION_2: () => ELEVATION_2,
    ELEVATION_3: () => ELEVATION_3,
    ELEVATION_4: () => ELEVATION_4,
    END: () => END,
    FILE_INPUT: () => FILE_INPUT,
    FILE_INPUT_HAS_SELECTION: () => FILE_INPUT_HAS_SELECTION,
    FILE_UPLOAD_INPUT: () => FILE_UPLOAD_INPUT,
    FILE_UPLOAD_INPUT_CUSTOM_TEXT: () => FILE_UPLOAD_INPUT_CUSTOM_TEXT,
    FILL: () => FILL,
    FIXED: () => FIXED,
    FIXED_TOP: () => FIXED_TOP,
    FLEX_EXPANDER: () => FLEX_EXPANDER,
    FOCUS_DISABLED: () => FOCUS_DISABLED,
    FOCUS_STYLE_MANAGER_IGNORE: () => FOCUS_STYLE_MANAGER_IGNORE,
    FORM_CONTENT: () => FORM_CONTENT,
    FORM_GROUP: () => FORM_GROUP,
    FORM_GROUP_SUB_LABEL: () => FORM_GROUP_SUB_LABEL,
    FORM_HELPER_TEXT: () => FORM_HELPER_TEXT,
    HEADING: () => HEADING,
    HOTKEY: () => HOTKEY,
    HOTKEY_COLUMN: () => HOTKEY_COLUMN,
    HOTKEY_DIALOG: () => HOTKEY_DIALOG,
    HOTKEY_LABEL: () => HOTKEY_LABEL,
    HTML_SELECT: () => HTML_SELECT,
    HTML_TABLE: () => HTML_TABLE,
    HTML_TABLE_BORDERED: () => HTML_TABLE_BORDERED,
    HTML_TABLE_CONDENSED: () => HTML_TABLE_CONDENSED,
    HTML_TABLE_STRIPED: () => HTML_TABLE_STRIPED,
    ICON: () => ICON,
    ICON_LARGE: () => ICON_LARGE,
    ICON_STANDARD: () => ICON_STANDARD,
    INLINE: () => INLINE,
    INPUT: () => INPUT,
    INPUT_ACTION: () => INPUT_ACTION,
    INPUT_GHOST: () => INPUT_GHOST,
    INPUT_GROUP: () => INPUT_GROUP,
    INPUT_LEFT_CONTAINER: () => INPUT_LEFT_CONTAINER,
    INTENT_DANGER: () => INTENT_DANGER,
    INTENT_PRIMARY: () => INTENT_PRIMARY,
    INTENT_SUCCESS: () => INTENT_SUCCESS,
    INTENT_WARNING: () => INTENT_WARNING,
    INTERACTIVE: () => INTERACTIVE,
    KEY: () => KEY,
    KEY_COMBO: () => KEY_COMBO,
    LABEL: () => LABEL,
    LARGE: () => LARGE,
    LIST: () => LIST,
    LIST_UNSTYLED: () => LIST_UNSTYLED,
    LOADING: () => LOADING,
    MENU: () => MENU,
    MENU_DIVIDER: () => MENU_DIVIDER,
    MENU_HEADER: () => MENU_HEADER,
    MENU_ITEM: () => MENU_ITEM,
    MENU_ITEM_ICON: () => MENU_ITEM_ICON,
    MENU_ITEM_LABEL: () => MENU_ITEM_LABEL,
    MENU_SUBMENU: () => MENU_SUBMENU,
    MENU_SUBMENU_ICON: () => MENU_SUBMENU_ICON,
    MINIMAL: () => MINIMAL,
    MODIFIER_KEY: () => MODIFIER_KEY,
    MONOSPACE_TEXT: () => MONOSPACE_TEXT,
    MULTILINE: () => MULTILINE,
    MULTISTEP_DIALOG: () => MULTISTEP_DIALOG,
    MULTISTEP_DIALOG_FOOTER: () => MULTISTEP_DIALOG_FOOTER,
    MULTISTEP_DIALOG_LEFT_PANEL: () => MULTISTEP_DIALOG_LEFT_PANEL,
    MULTISTEP_DIALOG_NAV_RIGHT: () => MULTISTEP_DIALOG_NAV_RIGHT,
    MULTISTEP_DIALOG_NAV_TOP: () => MULTISTEP_DIALOG_NAV_TOP,
    MULTISTEP_DIALOG_PANELS: () => MULTISTEP_DIALOG_PANELS,
    MULTISTEP_DIALOG_RIGHT_PANEL: () => MULTISTEP_DIALOG_RIGHT_PANEL,
    NAVBAR: () => NAVBAR,
    NAVBAR_DIVIDER: () => NAVBAR_DIVIDER,
    NAVBAR_GROUP: () => NAVBAR_GROUP,
    NAVBAR_HEADING: () => NAVBAR_HEADING,
    NON_IDEAL_STATE: () => NON_IDEAL_STATE,
    NON_IDEAL_STATE_TEXT: () => NON_IDEAL_STATE_TEXT,
    NON_IDEAL_STATE_VISUAL: () => NON_IDEAL_STATE_VISUAL,
    NUMERIC_INPUT: () => NUMERIC_INPUT,
    OUTLINED: () => OUTLINED,
    OVERFLOW_LIST: () => OVERFLOW_LIST,
    OVERFLOW_LIST_SPACER: () => OVERFLOW_LIST_SPACER,
    OVERLAY: () => OVERLAY,
    OVERLAY_BACKDROP: () => OVERLAY_BACKDROP,
    OVERLAY_CONTAINER: () => OVERLAY_CONTAINER,
    OVERLAY_CONTENT: () => OVERLAY_CONTENT,
    OVERLAY_END_FOCUS_TRAP: () => OVERLAY_END_FOCUS_TRAP,
    OVERLAY_INLINE: () => OVERLAY_INLINE,
    OVERLAY_OPEN: () => OVERLAY_OPEN,
    OVERLAY_SCROLL_CONTAINER: () => OVERLAY_SCROLL_CONTAINER,
    OVERLAY_START_FOCUS_TRAP: () => OVERLAY_START_FOCUS_TRAP,
    PANEL_STACK: () => PANEL_STACK,
    PANEL_STACK2: () => PANEL_STACK2,
    PANEL_STACK2_HEADER: () => PANEL_STACK2_HEADER,
    PANEL_STACK2_HEADER_BACK: () => PANEL_STACK2_HEADER_BACK,
    PANEL_STACK2_VIEW: () => PANEL_STACK2_VIEW,
    PANEL_STACK_HEADER: () => PANEL_STACK_HEADER,
    PANEL_STACK_HEADER_BACK: () => PANEL_STACK_HEADER_BACK,
    PANEL_STACK_VIEW: () => PANEL_STACK_VIEW,
    POPOVER: () => POPOVER,
    POPOVER_ARROW: () => POPOVER_ARROW,
    POPOVER_BACKDROP: () => POPOVER_BACKDROP,
    POPOVER_CAPTURING_DISMISS: () => POPOVER_CAPTURING_DISMISS,
    POPOVER_CONTENT: () => POPOVER_CONTENT,
    POPOVER_CONTENT_SIZING: () => POPOVER_CONTENT_SIZING,
    POPOVER_DISMISS: () => POPOVER_DISMISS,
    POPOVER_DISMISS_OVERRIDE: () => POPOVER_DISMISS_OVERRIDE,
    POPOVER_OPEN: () => POPOVER_OPEN,
    POPOVER_OUT_OF_BOUNDARIES: () => POPOVER_OUT_OF_BOUNDARIES,
    POPOVER_TARGET: () => POPOVER_TARGET,
    POPOVER_WRAPPER: () => POPOVER_WRAPPER,
    PORTAL: () => PORTAL,
    POSITION_BOTTOM: () => POSITION_BOTTOM,
    POSITION_LEFT: () => POSITION_LEFT,
    POSITION_RIGHT: () => POSITION_RIGHT,
    POSITION_TOP: () => POSITION_TOP,
    PROGRESS_BAR: () => PROGRESS_BAR,
    PROGRESS_METER: () => PROGRESS_METER,
    PROGRESS_NO_ANIMATION: () => PROGRESS_NO_ANIMATION,
    PROGRESS_NO_STRIPES: () => PROGRESS_NO_STRIPES,
    RADIO: () => RADIO,
    READ_ONLY: () => READ_ONLY,
    ROUND: () => ROUND,
    RTL: () => RTL,
    RUNNING_TEXT: () => RUNNING_TEXT,
    SELECT: () => SELECT,
    SELECTED: () => SELECTED,
    SKELETON: () => SKELETON,
    SLIDER: () => SLIDER,
    SLIDER_AXIS: () => SLIDER_AXIS,
    SLIDER_HANDLE: () => SLIDER_HANDLE,
    SLIDER_LABEL: () => SLIDER_LABEL,
    SLIDER_PROGRESS: () => SLIDER_PROGRESS,
    SLIDER_TRACK: () => SLIDER_TRACK,
    SMALL: () => SMALL,
    SPINNER: () => SPINNER,
    SPINNER_ANIMATION: () => SPINNER_ANIMATION,
    SPINNER_HEAD: () => SPINNER_HEAD,
    SPINNER_NO_SPIN: () => SPINNER_NO_SPIN,
    SPINNER_TRACK: () => SPINNER_TRACK,
    START: () => START,
    SWITCH: () => SWITCH,
    SWITCH_INNER_TEXT: () => SWITCH_INNER_TEXT,
    TAB: () => TAB,
    TABS: () => TABS,
    TAB_INDICATOR: () => TAB_INDICATOR,
    TAB_INDICATOR_WRAPPER: () => TAB_INDICATOR_WRAPPER,
    TAB_LIST: () => TAB_LIST,
    TAB_PANEL: () => TAB_PANEL,
    TAG: () => TAG,
    TAG_INPUT: () => TAG_INPUT,
    TAG_INPUT_ICON: () => TAG_INPUT_ICON,
    TAG_INPUT_VALUES: () => TAG_INPUT_VALUES,
    TAG_REMOVE: () => TAG_REMOVE,
    TEXT_DISABLED: () => TEXT_DISABLED,
    TEXT_LARGE: () => TEXT_LARGE,
    TEXT_MUTED: () => TEXT_MUTED,
    TEXT_OVERFLOW_ELLIPSIS: () => TEXT_OVERFLOW_ELLIPSIS,
    TEXT_SMALL: () => TEXT_SMALL,
    TOAST: () => TOAST,
    TOAST_CONTAINER: () => TOAST_CONTAINER,
    TOAST_MESSAGE: () => TOAST_MESSAGE,
    TOOLTIP: () => TOOLTIP,
    TOOLTIP_INDICATOR: () => TOOLTIP_INDICATOR,
    TRANSITION_CONTAINER: () => TRANSITION_CONTAINER,
    TREE: () => TREE,
    TREE_NODE: () => TREE_NODE,
    TREE_NODE_CARET: () => TREE_NODE_CARET,
    TREE_NODE_CARET_CLOSED: () => TREE_NODE_CARET_CLOSED,
    TREE_NODE_CARET_NONE: () => TREE_NODE_CARET_NONE,
    TREE_NODE_CARET_OPEN: () => TREE_NODE_CARET_OPEN,
    TREE_NODE_CONTENT: () => TREE_NODE_CONTENT,
    TREE_NODE_EXPANDED: () => TREE_NODE_EXPANDED,
    TREE_NODE_ICON: () => TREE_NODE_ICON,
    TREE_NODE_LABEL: () => TREE_NODE_LABEL,
    TREE_NODE_LIST: () => TREE_NODE_LIST,
    TREE_NODE_SECONDARY_LABEL: () => TREE_NODE_SECONDARY_LABEL,
    TREE_NODE_SELECTED: () => TREE_NODE_SELECTED,
    TREE_ROOT: () => TREE_ROOT,
    UI_TEXT: () => UI_TEXT,
    VERTICAL: () => VERTICAL,
    alignmentClass: () => alignmentClass,
    elevationClass: () => elevationClass,
    getClassNamespace: () => getClassNamespace,
    iconClass: () => iconClass,
    intentClass: () => intentClass,
    positionClass: () => positionClass
  });
  init_define_process();
  init_define_process();
  var Alignment = {
    CENTER: "center",
    LEFT: "left",
    RIGHT: "right"
  };
  init_define_process();
  var Elevation = {
    ZERO: 0,
    ONE: 1,
    TWO: 2,
    THREE: 3,
    FOUR: 4
  };
  init_define_process();
  var Intent = {
    NONE: "none",
    PRIMARY: "primary",
    SUCCESS: "success",
    WARNING: "warning",
    DANGER: "danger"
  };
  init_define_process();
  var Position = {
    BOTTOM: "bottom",
    BOTTOM_LEFT: "bottom-left",
    BOTTOM_RIGHT: "bottom-right",
    LEFT: "left",
    LEFT_BOTTOM: "left-bottom",
    LEFT_TOP: "left-top",
    RIGHT: "right",
    RIGHT_BOTTOM: "right-bottom",
    RIGHT_TOP: "right-top",
    TOP: "top",
    TOP_LEFT: "top-left",
    TOP_RIGHT: "top-right"
  };
  var _a;
  var _b;
  var _c;
  var _d;
  var NS = "bp4";
  if (typeof define_process_default !== "undefined") {
    NS = (_d = (_b = (_a = define_process_default.env) === null || _a === void 0 ? void 0 : _a.BLUEPRINT_NAMESPACE) !== null && _b !== void 0 ? _b : (_c = define_process_default.env) === null || _c === void 0 ? void 0 : _c.REACT_APP_BLUEPRINT_NAMESPACE) !== null && _d !== void 0 ? _d : NS;
  }
  var ACTIVE = ("").concat(NS, "-active");
  var ALIGN_LEFT = ("").concat(NS, "-align-left");
  var ALIGN_RIGHT = ("").concat(NS, "-align-right");
  var COMPACT = ("").concat(NS, "-compact");
  var DARK = ("").concat(NS, "-dark");
  var DISABLED = ("").concat(NS, "-disabled");
  var FILL = ("").concat(NS, "-fill");
  var FIXED = ("").concat(NS, "-fixed");
  var FIXED_TOP = ("").concat(NS, "-fixed-top");
  var INLINE = ("").concat(NS, "-inline");
  var INTERACTIVE = ("").concat(NS, "-interactive");
  var LARGE = ("").concat(NS, "-large");
  var LOADING = ("").concat(NS, "-loading");
  var MINIMAL = ("").concat(NS, "-minimal");
  var OUTLINED = ("").concat(NS, "-outlined");
  var MULTILINE = ("").concat(NS, "-multiline");
  var READ_ONLY = ("").concat(NS, "-read-only");
  var ROUND = ("").concat(NS, "-round");
  var SELECTED = ("").concat(NS, "-selected");
  var SMALL = ("").concat(NS, "-small");
  var VERTICAL = ("").concat(NS, "-vertical");
  var POSITION_TOP = positionClass(Position.TOP);
  var POSITION_BOTTOM = positionClass(Position.BOTTOM);
  var POSITION_LEFT = positionClass(Position.LEFT);
  var POSITION_RIGHT = positionClass(Position.RIGHT);
  var ELEVATION_0 = elevationClass(Elevation.ZERO);
  var ELEVATION_1 = elevationClass(Elevation.ONE);
  var ELEVATION_2 = elevationClass(Elevation.TWO);
  var ELEVATION_3 = elevationClass(Elevation.THREE);
  var ELEVATION_4 = elevationClass(Elevation.FOUR);
  var INTENT_PRIMARY = intentClass(Intent.PRIMARY);
  var INTENT_SUCCESS = intentClass(Intent.SUCCESS);
  var INTENT_WARNING = intentClass(Intent.WARNING);
  var INTENT_DANGER = intentClass(Intent.DANGER);
  var FOCUS_DISABLED = ("").concat(NS, "-focus-disabled");
  var FOCUS_STYLE_MANAGER_IGNORE = ("").concat(NS, "-focus-style-manager-ignore");
  var UI_TEXT = ("").concat(NS, "-ui-text");
  var RUNNING_TEXT = ("").concat(NS, "-running-text");
  var MONOSPACE_TEXT = ("").concat(NS, "-monospace-text");
  var TEXT_LARGE = ("").concat(NS, "-text-large");
  var TEXT_SMALL = ("").concat(NS, "-text-small");
  var TEXT_MUTED = ("").concat(NS, "-text-muted");
  var TEXT_DISABLED = ("").concat(NS, "-text-disabled");
  var TEXT_OVERFLOW_ELLIPSIS = ("").concat(NS, "-text-overflow-ellipsis");
  var BLOCKQUOTE = ("").concat(NS, "-blockquote");
  var CODE = ("").concat(NS, "-code");
  var CODE_BLOCK = ("").concat(NS, "-code-block");
  var HEADING = ("").concat(NS, "-heading");
  var LIST = ("").concat(NS, "-list");
  var LIST_UNSTYLED = ("").concat(NS, "-list-unstyled");
  var RTL = ("").concat(NS, "-rtl");
  var ALERT = ("").concat(NS, "-alert");
  var ALERT_BODY = ("").concat(ALERT, "-body");
  var ALERT_CONTENTS = ("").concat(ALERT, "-contents");
  var ALERT_FOOTER = ("").concat(ALERT, "-footer");
  var BREADCRUMB = ("").concat(NS, "-breadcrumb");
  var BREADCRUMB_CURRENT = ("").concat(BREADCRUMB, "-current");
  var BREADCRUMBS = ("").concat(BREADCRUMB, "s");
  var BREADCRUMBS_COLLAPSED = ("").concat(BREADCRUMB, "s-collapsed");
  var BUTTON = ("").concat(NS, "-button");
  var BUTTON_GROUP = ("").concat(BUTTON, "-group");
  var BUTTON_SPINNER = ("").concat(BUTTON, "-spinner");
  var BUTTON_TEXT = ("").concat(BUTTON, "-text");
  var CALLOUT = ("").concat(NS, "-callout");
  var CALLOUT_ICON = ("").concat(CALLOUT, "-icon");
  var CARD = ("").concat(NS, "-card");
  var COLLAPSE = ("").concat(NS, "-collapse");
  var COLLAPSE_BODY = ("").concat(COLLAPSE, "-body");
  var COLLAPSIBLE_LIST = ("").concat(NS, "-collapse-list");
  var CONTEXT_MENU = ("").concat(NS, "-context-menu");
  var CONTEXT_MENU_POPOVER_TARGET = ("").concat(CONTEXT_MENU, "-popover-target");
  var CONTROL_GROUP = ("").concat(NS, "-control-group");
  var DIALOG = ("").concat(NS, "-dialog");
  var DIALOG_CONTAINER = ("").concat(DIALOG, "-container");
  var DIALOG_HEADER = ("").concat(DIALOG, "-header");
  var DIALOG_BODY = ("").concat(DIALOG, "-body");
  var DIALOG_BODY_SCROLL_CONTAINER = ("").concat(DIALOG, "-body-scroll-container");
  var DIALOG_CLOSE_BUTTON = ("").concat(DIALOG, "-close-button");
  var DIALOG_FOOTER = ("").concat(DIALOG, "-footer");
  var DIALOG_FOOTER_FIXED = ("").concat(DIALOG, "-footer-fixed");
  var DIALOG_FOOTER_MAIN_SECTION = ("").concat(DIALOG, "-footer-main-section");
  var DIALOG_FOOTER_ACTIONS = ("").concat(DIALOG, "-footer-actions");
  var DIALOG_STEP = ("").concat(NS, "-dialog-step");
  var DIALOG_STEP_CONTAINER = ("").concat(DIALOG_STEP, "-container");
  var DIALOG_STEP_TITLE = ("").concat(DIALOG_STEP, "-title");
  var DIALOG_STEP_ICON = ("").concat(DIALOG_STEP, "-icon");
  var DIALOG_STEP_VIEWED = ("").concat(DIALOG_STEP, "-viewed");
  var DIVIDER = ("").concat(NS, "-divider");
  var DRAWER = ("").concat(NS, "-drawer");
  var DRAWER_BODY = ("").concat(DRAWER, "-body");
  var DRAWER_FOOTER = ("").concat(DRAWER, "-footer");
  var DRAWER_HEADER = ("").concat(DRAWER, "-header");
  var EDITABLE_TEXT = ("").concat(NS, "-editable-text");
  var EDITABLE_TEXT_CONTENT = ("").concat(EDITABLE_TEXT, "-content");
  var EDITABLE_TEXT_EDITING = ("").concat(EDITABLE_TEXT, "-editing");
  var EDITABLE_TEXT_INPUT = ("").concat(EDITABLE_TEXT, "-input");
  var EDITABLE_TEXT_PLACEHOLDER = ("").concat(EDITABLE_TEXT, "-placeholder");
  var FLEX_EXPANDER = ("").concat(NS, "-flex-expander");
  var HTML_SELECT = ("").concat(NS, "-html-select");
  var SELECT = ("").concat(NS, "-select");
  var HTML_TABLE = ("").concat(NS, "-html-table");
  var HTML_TABLE_BORDERED = ("").concat(HTML_TABLE, "-bordered");
  var HTML_TABLE_CONDENSED = ("").concat(HTML_TABLE, "-condensed");
  var HTML_TABLE_STRIPED = ("").concat(HTML_TABLE, "-striped");
  var INPUT = ("").concat(NS, "-input");
  var INPUT_GHOST = ("").concat(INPUT, "-ghost");
  var INPUT_GROUP = ("").concat(INPUT, "-group");
  var INPUT_LEFT_CONTAINER = ("").concat(INPUT, "-left-container");
  var INPUT_ACTION = ("").concat(INPUT, "-action");
  var CONTROL = ("").concat(NS, "-control");
  var CONTROL_INDICATOR = ("").concat(CONTROL, "-indicator");
  var CONTROL_INDICATOR_CHILD = ("").concat(CONTROL_INDICATOR, "-child");
  var CHECKBOX = ("").concat(NS, "-checkbox");
  var RADIO = ("").concat(NS, "-radio");
  var SWITCH = ("").concat(NS, "-switch");
  var SWITCH_INNER_TEXT = ("").concat(SWITCH, "-inner-text");
  var FILE_INPUT = ("").concat(NS, "-file-input");
  var FILE_INPUT_HAS_SELECTION = ("").concat(NS, "-file-input-has-selection");
  var FILE_UPLOAD_INPUT = ("").concat(NS, "-file-upload-input");
  var FILE_UPLOAD_INPUT_CUSTOM_TEXT = ("").concat(NS, "-file-upload-input-custom-text");
  var KEY = ("").concat(NS, "-key");
  var KEY_COMBO = ("").concat(KEY, "-combo");
  var MODIFIER_KEY = ("").concat(NS, "-modifier-key");
  var HOTKEY = ("").concat(NS, "-hotkey");
  var HOTKEY_LABEL = ("").concat(HOTKEY, "-label");
  var HOTKEY_COLUMN = ("").concat(HOTKEY, "-column");
  var HOTKEY_DIALOG = ("").concat(HOTKEY, "-dialog");
  var LABEL = ("").concat(NS, "-label");
  var FORM_GROUP = ("").concat(NS, "-form-group");
  var FORM_CONTENT = ("").concat(NS, "-form-content");
  var FORM_HELPER_TEXT = ("").concat(NS, "-form-helper-text");
  var FORM_GROUP_SUB_LABEL = ("").concat(NS, "-form-group-sub-label");
  var MENU = ("").concat(NS, "-menu");
  var MENU_ITEM = ("").concat(MENU, "-item");
  var MENU_ITEM_ICON = ("").concat(MENU_ITEM, "-icon");
  var MENU_ITEM_LABEL = ("").concat(MENU_ITEM, "-label");
  var MENU_SUBMENU = ("").concat(NS, "-submenu");
  var MENU_SUBMENU_ICON = ("").concat(MENU_SUBMENU, "-icon");
  var MENU_DIVIDER = ("").concat(MENU, "-divider");
  var MENU_HEADER = ("").concat(MENU, "-header");
  var MULTISTEP_DIALOG = ("").concat(NS, "-multistep-dialog");
  var MULTISTEP_DIALOG_PANELS = ("").concat(MULTISTEP_DIALOG, "-panels");
  var MULTISTEP_DIALOG_LEFT_PANEL = ("").concat(MULTISTEP_DIALOG, "-left-panel");
  var MULTISTEP_DIALOG_RIGHT_PANEL = ("").concat(MULTISTEP_DIALOG, "-right-panel");
  var MULTISTEP_DIALOG_FOOTER = ("").concat(MULTISTEP_DIALOG, "-footer");
  var MULTISTEP_DIALOG_NAV_TOP = ("").concat(MULTISTEP_DIALOG, "-nav-top");
  var MULTISTEP_DIALOG_NAV_RIGHT = ("").concat(MULTISTEP_DIALOG, "-nav-right");
  var NAVBAR = ("").concat(NS, "-navbar");
  var NAVBAR_GROUP = ("").concat(NAVBAR, "-group");
  var NAVBAR_HEADING = ("").concat(NAVBAR, "-heading");
  var NAVBAR_DIVIDER = ("").concat(NAVBAR, "-divider");
  var NON_IDEAL_STATE = ("").concat(NS, "-non-ideal-state");
  var NON_IDEAL_STATE_VISUAL = ("").concat(NON_IDEAL_STATE, "-visual");
  var NON_IDEAL_STATE_TEXT = ("").concat(NON_IDEAL_STATE, "-text");
  var NUMERIC_INPUT = ("").concat(NS, "-numeric-input");
  var OVERFLOW_LIST = ("").concat(NS, "-overflow-list");
  var OVERFLOW_LIST_SPACER = ("").concat(OVERFLOW_LIST, "-spacer");
  var OVERLAY = ("").concat(NS, "-overlay");
  var OVERLAY_BACKDROP = ("").concat(OVERLAY, "-backdrop");
  var OVERLAY_CONTAINER = ("").concat(OVERLAY, "-container");
  var OVERLAY_CONTENT = ("").concat(OVERLAY, "-content");
  var OVERLAY_INLINE = ("").concat(OVERLAY, "-inline");
  var OVERLAY_OPEN = ("").concat(OVERLAY, "-open");
  var OVERLAY_SCROLL_CONTAINER = ("").concat(OVERLAY, "-scroll-container");
  var OVERLAY_START_FOCUS_TRAP = ("").concat(OVERLAY, "-start-focus-trap");
  var OVERLAY_END_FOCUS_TRAP = ("").concat(OVERLAY, "-end-focus-trap");
  var PANEL_STACK = ("").concat(NS, "-panel-stack");
  var PANEL_STACK_HEADER = ("").concat(PANEL_STACK, "-header");
  var PANEL_STACK_HEADER_BACK = ("").concat(PANEL_STACK, "-header-back");
  var PANEL_STACK_VIEW = ("").concat(PANEL_STACK, "-view");
  var PANEL_STACK2 = ("").concat(NS, "-panel-stack2");
  var PANEL_STACK2_HEADER = ("").concat(PANEL_STACK, "-header");
  var PANEL_STACK2_HEADER_BACK = ("").concat(PANEL_STACK, "-header-back");
  var PANEL_STACK2_VIEW = ("").concat(PANEL_STACK, "-view");
  var POPOVER = ("").concat(NS, "-popover");
  var POPOVER_ARROW = ("").concat(POPOVER, "-arrow");
  var POPOVER_BACKDROP = ("").concat(POPOVER, "-backdrop");
  var POPOVER_CAPTURING_DISMISS = ("").concat(POPOVER, "-capturing-dismiss");
  var POPOVER_CONTENT = ("").concat(POPOVER, "-content");
  var POPOVER_CONTENT_SIZING = ("").concat(POPOVER_CONTENT, "-sizing");
  var POPOVER_DISMISS = ("").concat(POPOVER, "-dismiss");
  var POPOVER_DISMISS_OVERRIDE = ("").concat(POPOVER_DISMISS, "-override");
  var POPOVER_OPEN = ("").concat(POPOVER, "-open");
  var POPOVER_OUT_OF_BOUNDARIES = ("").concat(POPOVER, "-out-of-boundaries");
  var POPOVER_TARGET = ("").concat(POPOVER, "-target");
  var POPOVER_WRAPPER = ("").concat(POPOVER, "-wrapper");
  var TRANSITION_CONTAINER = ("").concat(NS, "-transition-container");
  var PROGRESS_BAR = ("").concat(NS, "-progress-bar");
  var PROGRESS_METER = ("").concat(NS, "-progress-meter");
  var PROGRESS_NO_STRIPES = ("").concat(NS, "-no-stripes");
  var PROGRESS_NO_ANIMATION = ("").concat(NS, "-no-animation");
  var PORTAL = ("").concat(NS, "-portal");
  var SKELETON = ("").concat(NS, "-skeleton");
  var SLIDER = ("").concat(NS, "-slider");
  var SLIDER_AXIS = ("").concat(SLIDER, "-axis");
  var SLIDER_HANDLE = ("").concat(SLIDER, "-handle");
  var SLIDER_LABEL = ("").concat(SLIDER, "-label");
  var SLIDER_TRACK = ("").concat(SLIDER, "-track");
  var SLIDER_PROGRESS = ("").concat(SLIDER, "-progress");
  var START = ("").concat(NS, "-start");
  var END = ("").concat(NS, "-end");
  var SPINNER = ("").concat(NS, "-spinner");
  var SPINNER_ANIMATION = ("").concat(SPINNER, "-animation");
  var SPINNER_HEAD = ("").concat(SPINNER, "-head");
  var SPINNER_NO_SPIN = ("").concat(NS, "-no-spin");
  var SPINNER_TRACK = ("").concat(SPINNER, "-track");
  var TAB = ("").concat(NS, "-tab");
  var TAB_INDICATOR = ("").concat(TAB, "-indicator");
  var TAB_INDICATOR_WRAPPER = ("").concat(TAB_INDICATOR, "-wrapper");
  var TAB_LIST = ("").concat(TAB, "-list");
  var TAB_PANEL = ("").concat(TAB, "-panel");
  var TABS = ("").concat(TAB, "s");
  var TAG = ("").concat(NS, "-tag");
  var TAG_REMOVE = ("").concat(TAG, "-remove");
  var TAG_INPUT = ("").concat(NS, "-tag-input");
  var TAG_INPUT_ICON = ("").concat(TAG_INPUT, "-icon");
  var TAG_INPUT_VALUES = ("").concat(TAG_INPUT, "-values");
  var TOAST = ("").concat(NS, "-toast");
  var TOAST_CONTAINER = ("").concat(TOAST, "-container");
  var TOAST_MESSAGE = ("").concat(TOAST, "-message");
  var TOOLTIP = ("").concat(NS, "-tooltip");
  var TOOLTIP_INDICATOR = ("").concat(TOOLTIP, "-indicator");
  var TREE = ("").concat(NS, "-tree");
  var TREE_NODE = ("").concat(NS, "-tree-node");
  var TREE_NODE_CARET = ("").concat(TREE_NODE, "-caret");
  var TREE_NODE_CARET_CLOSED = ("").concat(TREE_NODE_CARET, "-closed");
  var TREE_NODE_CARET_NONE = ("").concat(TREE_NODE_CARET, "-none");
  var TREE_NODE_CARET_OPEN = ("").concat(TREE_NODE_CARET, "-open");
  var TREE_NODE_CONTENT = ("").concat(TREE_NODE, "-content");
  var TREE_NODE_EXPANDED = ("").concat(TREE_NODE, "-expanded");
  var TREE_NODE_ICON = ("").concat(TREE_NODE, "-icon");
  var TREE_NODE_LABEL = ("").concat(TREE_NODE, "-label");
  var TREE_NODE_LIST = ("").concat(TREE_NODE, "-list");
  var TREE_NODE_SECONDARY_LABEL = ("").concat(TREE_NODE, "-secondary-label");
  var TREE_NODE_SELECTED = ("").concat(TREE_NODE, "-selected");
  var TREE_ROOT = ("").concat(NS, "-tree-root");
  var ICON = ("").concat(NS, "-icon");
  var ICON_STANDARD = ("").concat(ICON, "-standard");
  var ICON_LARGE = ("").concat(ICON, "-large");
  function getClassNamespace() {
    return NS;
  }
  function alignmentClass(alignment) {
    switch (alignment) {
      case Alignment.LEFT:
        return ALIGN_LEFT;
      case Alignment.RIGHT:
        return ALIGN_RIGHT;
      default:
        return void 0;
    }
  }
  function elevationClass(elevation) {
    if (elevation === void 0) {
      return void 0;
    }
    return ("").concat(NS, "-elevation-").concat(elevation);
  }
  function iconClass(iconName) {
    if (iconName == null) {
      return void 0;
    }
    return iconName.indexOf(("").concat(NS, "-icon-")) === 0 ? iconName : ("").concat(NS, "-icon-").concat(iconName);
  }
  function intentClass(intent) {
    if (intent == null || intent === Intent.NONE) {
      return void 0;
    }
    return ("").concat(NS, "-intent-").concat(intent.toLowerCase());
  }
  function positionClass(position) {
    if (position === void 0) {
      return void 0;
    }
    return ("").concat(NS, "-position-").concat(position);
  }
  init_define_process();
  init_define_process();
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || ({
      __proto__: []
    }) instanceof Array && (function (d2, b2) {
      d2.__proto__ = b2;
    }) || (function (d2, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d2[p3] = b2[p3];
    });
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var __assign = function () {
    __assign = Object.assign || (function __assign4(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p3 in s) if (Object.prototype.hasOwnProperty.call(s, p3)) t[p3] = s[p3];
      }
      return t;
    });
    return __assign.apply(this, arguments);
  };
  function __rest(s, e) {
    var t = {};
    for (var p3 in s) if (Object.prototype.hasOwnProperty.call(s, p3) && e.indexOf(p3) < 0) t[p3] = s[p3];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p3 = Object.getOwnPropertySymbols(s); i < p3.length; i++) {
      if (e.indexOf(p3[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p3[i])) t[p3[i]] = s[p3[i]];
    }
    return t;
  }
  var utils_exports = {};
  __export(utils_exports, {
    approxEqual: () => approxEqual,
    arrayLengthCompare: () => arrayLengthCompare,
    arraysEqual: () => arraysEqual,
    clamp: () => clamp,
    countDecimalPlaces: () => countDecimalPlaces,
    deepCompareKeys: () => deepCompareKeys,
    elementIsOrContains: () => elementIsOrContains,
    elementIsTextInput: () => elementIsTextInput,
    ensureElement: () => ensureElement,
    getActiveElement: () => getActiveElement,
    getDeepUnequalKeyValues: () => getDeepUnequalKeyValues,
    getDisplayName: () => getDisplayName,
    getRef: () => getRef,
    isDarkTheme: () => isDarkTheme,
    isElementOfType: () => isElementOfType,
    isFunction: () => isFunction,
    isNodeEnv: () => isNodeEnv,
    isReactChildrenElementOrElements: () => isReactChildrenElementOrElements,
    isReactNodeEmpty: () => isReactNodeEmpty,
    setRef: () => setRef,
    shallowCompareKeys: () => shallowCompareKeys,
    throttle: () => throttle,
    throttleEvent: () => throttleEvent,
    throttleReactEventCallback: () => throttleReactEventCallback,
    uniqueId: () => uniqueId
  });
  init_define_process();
  init_define_process();
  function arraysEqual(arrA, arrB, compare) {
    if (compare === void 0) {
      compare = function (a, b) {
        return a === b;
      };
    }
    if (arrA == null && arrB == null) {
      return true;
    } else if (arrA == null || arrB == null || arrA.length !== arrB.length) {
      return false;
    } else {
      return arrA.every(function (a, i) {
        return compare(a, arrB[i]);
      });
    }
  }
  function shallowCompareKeys(objA, objB, keys) {
    if (objA == null && objB == null) {
      return true;
    } else if (objA == null || objB == null) {
      return false;
    } else if (Array.isArray(objA) || Array.isArray(objB)) {
      return false;
    } else if (keys != null) {
      return shallowCompareKeysImpl(objA, objB, keys);
    } else {
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      return shallowCompareKeysImpl(objA, objB, {
        include: keysA
      }) && shallowCompareKeysImpl(objA, objB, {
        include: keysB
      });
    }
  }
  function deepCompareKeys(objA, objB, keys) {
    if (objA === objB) {
      return true;
    } else if (objA == null && objB == null) {
      return true;
    } else if (objA == null || objB == null) {
      return false;
    } else if (Array.isArray(objA) || Array.isArray(objB)) {
      return arraysEqual(objA, objB, deepCompareKeys);
    } else if (isSimplePrimitiveType(objA) || isSimplePrimitiveType(objB)) {
      return objA === objB;
    } else if (keys != null) {
      return deepCompareKeysImpl(objA, objB, keys);
    } else if (objA.constructor !== objB.constructor) {
      return false;
    } else {
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA == null || keysB == null) {
        return false;
      }
      if (keysA.length === 0 && keysB.length === 0) {
        return true;
      }
      return arraysEqual(keysA, keysB) && deepCompareKeysImpl(objA, objB, keysA);
    }
  }
  function getDeepUnequalKeyValues(objA, objB, keys) {
    if (objA === void 0) {
      objA = {};
    }
    if (objB === void 0) {
      objB = {};
    }
    var filteredKeys = keys == null ? unionKeys(objA, objB) : keys;
    return getUnequalKeyValues(objA, objB, filteredKeys, function (a, b, key) {
      return deepCompareKeys(a, b, [key]);
    });
  }
  function shallowCompareKeysImpl(objA, objB, keys) {
    return filterKeys(objA, objB, keys).every(function (key) {
      return objA.hasOwnProperty(key) === objB.hasOwnProperty(key) && objA[key] === objB[key];
    });
  }
  function deepCompareKeysImpl(objA, objB, keys) {
    return keys.every(function (key) {
      return objA.hasOwnProperty(key) === objB.hasOwnProperty(key) && deepCompareKeys(objA[key], objB[key]);
    });
  }
  function isSimplePrimitiveType(value) {
    return typeof value === "number" || typeof value === "string" || typeof value === "boolean";
  }
  function filterKeys(objA, objB, keys) {
    if (isAllowlist(keys)) {
      return keys.include;
    } else if (isDenylist(keys)) {
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      var keySet_1 = arrayToObject(keysA.concat(keysB));
      keys.exclude.forEach(function (key) {
        return delete keySet_1[key];
      });
      return Object.keys(keySet_1);
    }
    return [];
  }
  function isAllowlist(keys) {
    return keys != null && keys.include != null;
  }
  function isDenylist(keys) {
    return keys != null && keys.exclude != null;
  }
  function arrayToObject(arr) {
    return arr.reduce(function (obj, element) {
      obj[element] = true;
      return obj;
    }, {});
  }
  function getUnequalKeyValues(objA, objB, keys, compareFn) {
    var unequalKeys = keys.filter(function (key) {
      return !compareFn(objA, objB, key);
    });
    var unequalKeyValues = unequalKeys.map(function (key) {
      return {
        key,
        valueA: objA[key],
        valueB: objB[key]
      };
    });
    return unequalKeyValues;
  }
  function unionKeys(objA, objB) {
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    var concatKeys = keysA.concat(keysB);
    var keySet = arrayToObject(concatKeys);
    return Object.keys(keySet);
  }
  init_define_process();
  function elementIsOrContains(element, testElement) {
    return element === testElement || element.contains(testElement);
  }
  function elementIsTextInput(elem) {
    if (elem == null || elem.closest == null) {
      return false;
    }
    var editable = elem.closest("input, textarea, [contenteditable=true]");
    if (editable == null) {
      return false;
    }
    if (editable.tagName.toLowerCase() === "input") {
      var inputType = editable.type;
      if (inputType === "checkbox" || inputType === "radio") {
        return false;
      }
    }
    if (editable.readOnly) {
      return false;
    }
    return true;
  }
  function getActiveElement(element, options) {
    var _a3;
    if (element == null) {
      return document.activeElement;
    }
    var rootNode = (_a3 = element.getRootNode(options)) !== null && _a3 !== void 0 ? _a3 : document;
    return rootNode.activeElement;
  }
  function throttleEvent(target, eventName, newEventName) {
    var throttledFunc = throttleImpl(function (event) {
      target.dispatchEvent(new CustomEvent(newEventName, event));
    });
    target.addEventListener(eventName, throttledFunc);
    return throttledFunc;
  }
  function throttleReactEventCallback(callback, options) {
    if (options === void 0) {
      options = {};
    }
    var throttledFunc = throttleImpl(callback, function (event2) {
      if (options.preventDefault) {
        event2.preventDefault();
      }
    }, function (event2) {
      return event2.persist();
    });
    return throttledFunc;
  }
  function throttle(method) {
    return throttleImpl(method);
  }
  function throttleImpl(onAnimationFrameRequested, onBeforeIsRunningCheck, onAfterIsRunningCheck) {
    var isRunning = false;
    var func = function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      onBeforeIsRunningCheck === null || onBeforeIsRunningCheck === void 0 ? void 0 : onBeforeIsRunningCheck.apply(void 0, args);
      if (isRunning) {
        return;
      }
      isRunning = true;
      onAfterIsRunningCheck === null || onAfterIsRunningCheck === void 0 ? void 0 : onAfterIsRunningCheck.apply(void 0, args);
      requestAnimationFrame(function () {
        onAnimationFrameRequested.apply(void 0, args);
        isRunning = false;
      });
    };
    return func;
  }
  init_define_process();
  function isFunction(value) {
    return typeof value === "function";
  }
  init_define_process();
  init_define_process();
  var ns = "[Blueprint]";
  var CLAMP_MIN_MAX = ns + " clamp: max cannot be less than min";
  var ALERT_WARN_CANCEL_PROPS = ns + " <Alert> cancelButtonText and onCancel should be set together.";
  var ALERT_WARN_CANCEL_ESCAPE_KEY = ns + " <Alert> canEscapeKeyCancel enabled without onCancel or onClose handler.";
  var ALERT_WARN_CANCEL_OUTSIDE_CLICK = ns + " <Alert> canOutsideClickCancel enabled without onCancel or onClose handler.";
  var COLLAPSIBLE_LIST_INVALID_CHILD = ns + " <CollapsibleList> children must be <MenuItem>s";
  var CONTEXTMENU_WARN_DECORATOR_NO_METHOD = ns + " @ContextMenuTarget-decorated class should implement renderContextMenu.";
  var CONTEXTMENU_WARN_DECORATOR_NEEDS_REACT_ELEMENT = ns + ' "@ContextMenuTarget-decorated components must return a single JSX.Element or an empty render.';
  var HOTKEYS_HOTKEY_CHILDREN = ns + " <Hotkeys> only accepts <Hotkey> children.";
  var HOTKEYS_WARN_DECORATOR_NO_METHOD = ns + " @HotkeysTarget-decorated class should implement renderHotkeys.";
  var HOTKEYS_WARN_DECORATOR_NEEDS_REACT_ELEMENT = ns + ' "@HotkeysTarget-decorated components must return a single JSX.Element or an empty render.';
  var HOTKEYS_PROVIDER_NOT_FOUND = ns + " useHotkeys() was used outside of a <HotkeysProvider> context. These hotkeys will not be shown in the hotkeys help dialog.";
  var HOTKEYS_TARGET2_CHILDREN_LOCAL_HOTKEYS = ns + " <HotkeysTarget2> was configured with local hotkeys, but you did not use the generated event handlers to bind their event handlers. Try using a render function as the child of this component.";
  var INPUT_WARN_LEFT_ELEMENT_LEFT_ICON_MUTEX = ns + " <InputGroup> leftElement and leftIcon prop are mutually exclusive, with leftElement taking priority.";
  var NUMERIC_INPUT_MIN_MAX = ns + " <NumericInput> requires min to be no greater than max if both are defined.";
  var NUMERIC_INPUT_MINOR_STEP_SIZE_BOUND = ns + " <NumericInput> requires minorStepSize to be no greater than stepSize.";
  var NUMERIC_INPUT_MAJOR_STEP_SIZE_BOUND = ns + " <NumericInput> requires stepSize to be no greater than majorStepSize.";
  var NUMERIC_INPUT_MINOR_STEP_SIZE_NON_POSITIVE = ns + " <NumericInput> requires minorStepSize to be strictly greater than zero.";
  var NUMERIC_INPUT_MAJOR_STEP_SIZE_NON_POSITIVE = ns + " <NumericInput> requires majorStepSize to be strictly greater than zero.";
  var NUMERIC_INPUT_STEP_SIZE_NON_POSITIVE = ns + " <NumericInput> requires stepSize to be strictly greater than zero.";
  var NUMERIC_INPUT_CONTROLLED_VALUE_INVALID = ns + " <NumericInput> controlled value prop does not adhere to stepSize, min, and/or max constraints.";
  var PANEL_STACK_INITIAL_PANEL_STACK_MUTEX = ns + " <PanelStack> requires exactly one of initialPanel and stack prop";
  var PANEL_STACK_REQUIRES_PANEL = ns + " <PanelStack> requires at least one panel in the stack";
  var OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED = ns + " <OverflowList> does not support changing observeParents after mounting.";
  var POPOVER_REQUIRES_TARGET = ns + " <Popover> requires target prop or at least one child element.";
  var POPOVER_HAS_BACKDROP_INTERACTION = ns + " <Popover hasBackdrop={true}> requires interactionKind={PopoverInteractionKind.CLICK}.";
  var POPOVER_WARN_TOO_MANY_CHILDREN = ns + " <Popover> supports one or two children; additional children are ignored. First child is the target, second child is the content. You may instead supply these two as props.";
  var POPOVER_WARN_DOUBLE_CONTENT = ns + " <Popover> with two children ignores content prop; use either prop or children.";
  var POPOVER_WARN_DOUBLE_TARGET = ns + " <Popover> with children ignores target prop; use either prop or children.";
  var POPOVER_WARN_EMPTY_CONTENT = ns + " Disabling <Popover> with empty/whitespace content...";
  var POPOVER_WARN_HAS_BACKDROP_INLINE = ns + " <Popover usePortal={false}> ignores hasBackdrop";
  var POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX = ns + " <Popover> supports either placement or position prop, not both.";
  var POPOVER_WARN_UNCONTROLLED_ONINTERACTION = ns + " <Popover> onInteraction is ignored when uncontrolled.";
  var PORTAL_CONTEXT_CLASS_NAME_STRING = ns + " <Portal> context blueprintPortalClassName must be string";
  var PORTAL_LEGACY_CONTEXT_API = ns + " setting blueprintPortalClassName via legacy React context API is deprecated, use <PortalProvider> instead.";
  var RADIOGROUP_WARN_CHILDREN_OPTIONS_MUTEX = ns + " <RadioGroup> children and options prop are mutually exclusive, with options taking priority.";
  var SLIDER_ZERO_STEP = ns + " <Slider> stepSize must be greater than zero.";
  var SLIDER_ZERO_LABEL_STEP = ns + " <Slider> labelStepSize must be greater than zero.";
  var RANGESLIDER_NULL_VALUE = ns + " <RangeSlider> value prop must be an array of two non-null numbers.";
  var MULTISLIDER_INVALID_CHILD = ns + " <MultiSlider> children must be <SliderHandle>s or <SliderTrackStop>s";
  var MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX = ns + " <MultiSlider> labelStepSize and labelValues prop are mutually exclusive, with labelStepSize taking priority.";
  var SPINNER_WARN_CLASSES_SIZE = ns + " <Spinner> Classes.SMALL/LARGE are ignored if size prop is set.";
  var TOASTER_CREATE_NULL = ns + " Toaster.create() is not supported inside React lifecycle methods in React 16. See usage example on the docs site.";
  var TOASTER_WARN_INLINE = ns + " Toaster.create() ignores inline prop as it always creates a new element.";
  var DIALOG_WARN_NO_HEADER_ICON = ns + " <Dialog> iconName is ignored if title is omitted.";
  var DIALOG_WARN_NO_HEADER_CLOSE_BUTTON = ns + " <Dialog> isCloseButtonShown prop is ignored if title is omitted.";
  var DRAWER_ANGLE_POSITIONS_ARE_CASTED = ns + " <Drawer> all angle positions are casted into pure position (TOP, BOTTOM, LEFT or RIGHT)";
  var TOASTER_MAX_TOASTS_INVALID = ns + " <Toaster> maxToasts is set to an invalid number, must be greater than 0";
  function isNodeEnv(env) {
    return typeof define_process_default !== "undefined" && define_process_default.env && define_process_default.env.NODE_ENV === env;
  }
  function arrayLengthCompare(a, b) {
    if (a === void 0) {
      a = [];
    }
    if (b === void 0) {
      b = [];
    }
    return a.length - b.length;
  }
  function approxEqual(a, b, tolerance) {
    if (tolerance === void 0) {
      tolerance = 1e-5;
    }
    return Math.abs(a - b) <= tolerance;
  }
  function clamp(val, min, max) {
    if (val == null) {
      return val;
    }
    if (max < min) {
      throw new Error(CLAMP_MIN_MAX);
    }
    return Math.min(Math.max(val, min), max);
  }
  function countDecimalPlaces(num) {
    if (!isFinite(num)) {
      return 0;
    }
    var e = 1;
    var p3 = 0;
    while (Math.round(num * e) / e !== num) {
      e *= 10;
      p3++;
    }
    return p3;
  }
  var uniqueCountForNamespace = new Map();
  function uniqueId(namespace) {
    var _a3;
    var curCount = (_a3 = uniqueCountForNamespace.get(namespace)) !== null && _a3 !== void 0 ? _a3 : 0;
    uniqueCountForNamespace.set(namespace, curCount + 1);
    return ("").concat(namespace, "-").concat(curCount);
  }
  init_define_process();
  var React = __toESM(__require("react"));
  function isReactNodeEmpty(node, skipArray) {
    if (skipArray === void 0) {
      skipArray = false;
    }
    return node == null || node === "" || node === false || !skipArray && Array.isArray(node) && (node.length === 0 || node.every(function (n) {
      return isReactNodeEmpty(n, true);
    }));
  }
  function isReactChildrenElementOrElements(children) {
    return !isReactNodeEmpty(children, true) && children !== true;
  }
  function ensureElement(child, tagName) {
    if (tagName === void 0) {
      tagName = "span";
    }
    if (child == null || typeof child === "boolean") {
      return void 0;
    } else if (typeof child === "string") {
      return child.trim().length > 0 ? React.createElement(tagName, {}, child) : void 0;
    } else if (typeof child === "number" || typeof child.type === "symbol" || Array.isArray(child)) {
      return React.createElement(tagName, {}, child);
    } else if (isReactElement(child)) {
      return child;
    } else {
      return void 0;
    }
  }
  function isReactElement(child) {
    return typeof child === "object" && typeof child.type !== "undefined" && typeof child.props !== "undefined";
  }
  function getDisplayName(ComponentClass) {
    return ComponentClass.displayName || ComponentClass.name || "Unknown";
  }
  function isElementOfType(element, ComponentType) {
    return element != null && element.type != null && element.type.displayName != null && element.type.displayName === ComponentType.displayName;
  }
  init_define_process();
  init_define_process();
  if (typeof __require !== "undefined" && typeof window !== "undefined" && typeof document !== "undefined") {
    require_dom4_max();
  }
  function isDarkTheme(element) {
    return element != null && element instanceof Element && element.closest((".").concat(DARK)) != null;
  }
  init_define_process();
  function isRefObject(value) {
    return value != null && typeof value !== "function";
  }
  function isRefCallback(value) {
    return typeof value === "function";
  }
  function setRef(refTarget, ref) {
    if (isRefObject(refTarget)) {
      refTarget.current = ref;
    } else if (isRefCallback(refTarget)) {
      refTarget(ref);
    }
  }
  function getRef(ref) {
    var _a3;
    if (ref === null) {
      return null;
    }
    return (_a3 = ref.current) !== null && _a3 !== void 0 ? _a3 : ref;
  }
  function refHandler(refTargetParent, refTargetKey, refProp) {
    return function (ref) {
      refTargetParent[refTargetKey] = ref;
      setRef(refProp, ref);
    };
  }
  init_define_process();
  var React2 = __toESM(__require("react"));
  var AbstractPureComponent2 = (function (_super) {
    __extends(AbstractPureComponent22, _super);
    function AbstractPureComponent22(props, context) {
      var _this = _super.call(this, props, context) || this;
      _this.timeoutIds = [];
      _this.requestIds = [];
      _this.clearTimeouts = function () {
        if (_this.timeoutIds.length > 0) {
          for (var _i = 0, _a3 = _this.timeoutIds; _i < _a3.length; _i++) {
            var timeoutId = _a3[_i];
            window.clearTimeout(timeoutId);
          }
          _this.timeoutIds = [];
        }
      };
      _this.cancelAnimationFrames = function () {
        if (_this.requestIds.length > 0) {
          for (var _i = 0, _a3 = _this.requestIds; _i < _a3.length; _i++) {
            var requestId = _a3[_i];
            window.cancelAnimationFrame(requestId);
          }
          _this.requestIds = [];
        }
      };
      if (!isNodeEnv("production")) {
        _this.validateProps(_this.props);
      }
      return _this;
    }
    AbstractPureComponent22.prototype.componentDidUpdate = function (_prevProps, _prevState, _snapshot) {
      if (!isNodeEnv("production")) {
        this.validateProps(this.props);
      }
    };
    AbstractPureComponent22.prototype.componentWillUnmount = function () {
      this.clearTimeouts();
      this.cancelAnimationFrames();
    };
    AbstractPureComponent22.prototype.requestAnimationFrame = function (callback) {
      var handle = window.requestAnimationFrame(callback);
      this.requestIds.push(handle);
      return function () {
        return window.cancelAnimationFrame(handle);
      };
    };
    AbstractPureComponent22.prototype.setTimeout = function (callback, timeout) {
      var handle = window.setTimeout(callback, timeout);
      this.timeoutIds.push(handle);
      return function () {
        return window.clearTimeout(handle);
      };
    };
    AbstractPureComponent22.prototype.validateProps = function (_props) {};
    return AbstractPureComponent22;
  })(React2.PureComponent);
  init_define_process();
  var DISPLAYNAME_PREFIX = "Blueprint4";
  var INVALID_PROPS = ["active", "alignText", "asyncControl", "containerRef", "current", "elementRef", "fill", "icon", "inputClassName", "inputRef", "intent", "inline", "large", "loading", "leftElement", "leftIcon", "minimal", "onRemove", "outlined", "panel", "panelClassName", "popoverProps", "rightElement", "rightIcon", "round", "small", "tagName", "text"];
  function removeNonHTMLProps(props, invalidProps, shouldMerge) {
    if (invalidProps === void 0) {
      invalidProps = INVALID_PROPS;
    }
    if (shouldMerge === void 0) {
      shouldMerge = false;
    }
    if (shouldMerge) {
      invalidProps = invalidProps.concat(INVALID_PROPS);
    }
    return invalidProps.reduce(function (prev, curr) {
      if (curr.indexOf("-") !== -1) {
        return prev;
      }
      if (prev.hasOwnProperty(curr)) {
        delete prev[curr];
      }
      return prev;
    }, __assign({}, props));
  }
  var import_colors = __toESM(require_lib());
  var keys_exports = {};
  __export(keys_exports, {
    ARROW_DOWN: () => ARROW_DOWN,
    ARROW_LEFT: () => ARROW_LEFT,
    ARROW_RIGHT: () => ARROW_RIGHT,
    ARROW_UP: () => ARROW_UP,
    BACKSPACE: () => BACKSPACE,
    DELETE: () => DELETE,
    ENTER: () => ENTER,
    ESCAPE: () => ESCAPE,
    SHIFT: () => SHIFT,
    SPACE: () => SPACE,
    TAB: () => TAB2,
    isKeyboardClick: () => isKeyboardClick
  });
  init_define_process();
  var BACKSPACE = 8;
  var TAB2 = 9;
  var ENTER = 13;
  var SHIFT = 16;
  var ESCAPE = 27;
  var SPACE = 32;
  var ARROW_LEFT = 37;
  var ARROW_UP = 38;
  var ARROW_RIGHT = 39;
  var ARROW_DOWN = 40;
  var DELETE = 46;
  function isKeyboardClick(keyCode) {
    return keyCode === ENTER || keyCode === SPACE;
  }
  init_define_process();
  var React6 = __toESM(__require("react"));
  init_define_process();
  var import_classnames3 = __toESM(require_classnames());
  var React5 = __toESM(__require("react"));
  init_define_process();
  var import_classnames = __toESM(require_classnames());
  var React3 = __toESM(__require("react"));
  init_define_process();
  init_define_process();
  init_define_process();
  var __assign2 = function () {
    __assign2 = Object.assign || (function __assign4(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p3 in s) if (Object.prototype.hasOwnProperty.call(s, p3)) t[p3] = s[p3];
      }
      return t;
    });
    return __assign2.apply(this, arguments);
  };
  init_define_process();
  init_define_process();
  init_define_process();
  function lowerCase(str) {
    return str.toLowerCase();
  }
  var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
  var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
  function noCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    var _a3 = options.splitRegexp, splitRegexp = _a3 === void 0 ? DEFAULT_SPLIT_REGEXP : _a3, _b2 = options.stripRegexp, stripRegexp = _b2 === void 0 ? DEFAULT_STRIP_REGEXP : _b2, _c2 = options.transform, transform = _c2 === void 0 ? lowerCase : _c2, _d2 = options.delimiter, delimiter = _d2 === void 0 ? " " : _d2;
    var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
    var start = 0;
    var end = result.length;
    while (result.charAt(start) === "\0") start++;
    while (result.charAt(end - 1) === "\0") end--;
    return result.slice(start, end).split("\0").map(transform).join(delimiter);
  }
  function replace(input, re, value) {
    if (re instanceof RegExp) return input.replace(re, value);
    return re.reduce(function (input2, re2) {
      return input2.replace(re2, value);
    }, input);
  }
  function pascalCaseTransform(input, index) {
    var firstChar = input.charAt(0);
    var lowerChars = input.substr(1).toLowerCase();
    if (index > 0 && firstChar >= "0" && firstChar <= "9") {
      return "_" + firstChar + lowerChars;
    }
    return "" + firstChar.toUpperCase() + lowerChars;
  }
  function pascalCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    return noCase(input, __assign2({
      delimiter: "",
      transform: pascalCaseTransform
    }, options));
  }
  init_define_process();
  function dotCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    return noCase(input, __assign2({
      delimiter: "."
    }, options));
  }
  init_define_process();
  function snakeCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    return dotCase(input, __assign2({
      delimiter: "_"
    }, options));
  }
  var paths_exports = {};
  __export(paths_exports, {
    Add: () => add_default,
    AddClip: () => add_clip_default,
    AddColumnLeft: () => add_column_left_default,
    AddColumnRight: () => add_column_right_default,
    AddLocation: () => add_location_default,
    AddRowBottom: () => add_row_bottom_default,
    AddRowTop: () => add_row_top_default,
    AddToArtifact: () => add_to_artifact_default,
    AddToFolder: () => add_to_folder_default,
    AimpointsTarget: () => aimpoints_target_default,
    Airplane: () => airplane_default,
    AlignCenter: () => align_center_default,
    AlignJustify: () => align_justify_default,
    AlignLeft: () => align_left_default,
    AlignRight: () => align_right_default,
    AlignmentBottom: () => alignment_bottom_default,
    AlignmentHorizontalCenter: () => alignment_horizontal_center_default,
    AlignmentLeft: () => alignment_left_default,
    AlignmentRight: () => alignment_right_default,
    AlignmentTop: () => alignment_top_default,
    AlignmentVerticalCenter: () => alignment_vertical_center_default,
    Anchor: () => anchor_default,
    Annotation: () => annotation_default,
    Antenna: () => antenna_default,
    AppHeader: () => app_header_default,
    Application: () => application_default,
    Applications: () => applications_default,
    Archive: () => archive_default,
    AreaOfInterest: () => area_of_interest_default,
    Array: () => array_default,
    ArrayBoolean: () => array_boolean_default,
    ArrayDate: () => array_date_default,
    ArrayFloatingPoint: () => array_floating_point_default,
    ArrayNumeric: () => array_numeric_default,
    ArrayString: () => array_string_default,
    ArrayTimestamp: () => array_timestamp_default,
    ArrowBottomLeft: () => arrow_bottom_left_default,
    ArrowBottomRight: () => arrow_bottom_right_default,
    ArrowDown: () => arrow_down_default,
    ArrowLeft: () => arrow_left_default,
    ArrowRight: () => arrow_right_default,
    ArrowTopLeft: () => arrow_top_left_default,
    ArrowTopRight: () => arrow_top_right_default,
    ArrowUp: () => arrow_up_default,
    ArrowsHorizontal: () => arrows_horizontal_default,
    ArrowsVertical: () => arrows_vertical_default,
    Asterisk: () => asterisk_default,
    At: () => at_default,
    AutomaticUpdates: () => automatic_updates_default,
    Backlink: () => backlink_default,
    Badge: () => badge_default,
    BanCircle: () => ban_circle_default,
    BankAccount: () => bank_account_default,
    Barcode: () => barcode_default,
    Blank: () => blank_default,
    BlockedPerson: () => blocked_person_default,
    Bold: () => bold_default,
    Book: () => book_default,
    Bookmark: () => bookmark_default,
    Box: () => box_default,
    Briefcase: () => briefcase_default,
    BringData: () => bring_data_default,
    Bug: () => bug_default,
    Buggy: () => buggy_default,
    Build: () => build_default,
    Calculator: () => calculator_default,
    Calendar: () => calendar_default,
    Camera: () => camera_default,
    CaretDown: () => caret_down_default,
    CaretLeft: () => caret_left_default,
    CaretRight: () => caret_right_default,
    CaretUp: () => caret_up_default,
    CargoShip: () => cargo_ship_default,
    CellTower: () => cell_tower_default,
    Changes: () => changes_default,
    Chart: () => chart_default,
    Chat: () => chat_default,
    ChevronBackward: () => chevron_backward_default,
    ChevronDown: () => chevron_down_default,
    ChevronForward: () => chevron_forward_default,
    ChevronLeft: () => chevron_left_default,
    ChevronRight: () => chevron_right_default,
    ChevronUp: () => chevron_up_default,
    Circle: () => circle_default,
    CircleArrowDown: () => circle_arrow_down_default,
    CircleArrowLeft: () => circle_arrow_left_default,
    CircleArrowRight: () => circle_arrow_right_default,
    CircleArrowUp: () => circle_arrow_up_default,
    Citation: () => citation_default,
    Clean: () => clean_default,
    Clip: () => clip_default,
    Clipboard: () => clipboard_default,
    Cloud: () => cloud_default,
    CloudDownload: () => cloud_download_default,
    CloudUpload: () => cloud_upload_default,
    Code: () => code_default,
    CodeBlock: () => code_block_default,
    Cog: () => cog_default,
    CollapseAll: () => collapse_all_default,
    ColorFill: () => color_fill_default,
    ColumnLayout: () => column_layout_default,
    Comment: () => comment_default,
    Comparison: () => comparison_default,
    Compass: () => compass_default,
    Compressed: () => compressed_default,
    Confirm: () => confirm_default,
    Console: () => console_default,
    Contrast: () => contrast_default,
    Control: () => control_default,
    CreditCard: () => credit_card_default,
    Cross: () => cross_default,
    CrossCircle: () => cross_circle_default,
    Crown: () => crown_default,
    Cube: () => cube_default,
    CubeAdd: () => cube_add_default,
    CubeRemove: () => cube_remove_default,
    CurvedRangeChart: () => curved_range_chart_default,
    Cut: () => cut_default,
    Cycle: () => cycle_default,
    Dashboard: () => dashboard_default,
    DataConnection: () => data_connection_default,
    DataLineage: () => data_lineage_default,
    Database: () => database_default,
    Delete: () => delete_default,
    Delta: () => delta_default,
    DeriveColumn: () => derive_column_default,
    Desktop: () => desktop_default,
    Diagnosis: () => diagnosis_default,
    DiagramTree: () => diagram_tree_default,
    DirectionLeft: () => direction_left_default,
    DirectionRight: () => direction_right_default,
    Disable: () => disable_default,
    Divide: () => divide_default,
    Document: () => document_default,
    DocumentOpen: () => document_open_default,
    DocumentShare: () => document_share_default,
    Dollar: () => dollar_default,
    Dot: () => dot_default,
    DoubleCaretHorizontal: () => double_caret_horizontal_default,
    DoubleCaretVertical: () => double_caret_vertical_default,
    DoubleChevronDown: () => double_chevron_down_default,
    DoubleChevronLeft: () => double_chevron_left_default,
    DoubleChevronRight: () => double_chevron_right_default,
    DoubleChevronUp: () => double_chevron_up_default,
    DoughnutChart: () => doughnut_chart_default,
    Download: () => download_default,
    DragHandleHorizontal: () => drag_handle_horizontal_default,
    DragHandleVertical: () => drag_handle_vertical_default,
    Draw: () => draw_default,
    DrawerLeft: () => drawer_left_default,
    DrawerLeftFilled: () => drawer_left_filled_default,
    DrawerRight: () => drawer_right_default,
    DrawerRightFilled: () => drawer_right_filled_default,
    DriveTime: () => drive_time_default,
    Duplicate: () => duplicate_default,
    Edit: () => edit_default,
    Eject: () => eject_default,
    Emoji: () => emoji_default,
    Endorsed: () => endorsed_default,
    Envelope: () => envelope_default,
    Equals: () => equals_default,
    Eraser: () => eraser_default,
    Error: () => error_default,
    Euro: () => euro_default,
    Exchange: () => exchange_default,
    ExcludeRow: () => exclude_row_default,
    ExpandAll: () => expand_all_default,
    Export: () => export_default,
    EyeOff: () => eye_off_default,
    EyeOn: () => eye_on_default,
    EyeOpen: () => eye_open_default,
    FastBackward: () => fast_backward_default,
    FastForward: () => fast_forward_default,
    Feed: () => feed_default,
    FeedSubscribed: () => feed_subscribed_default,
    Film: () => film_default,
    Filter: () => filter_default,
    FilterKeep: () => filter_keep_default,
    FilterList: () => filter_list_default,
    FilterOpen: () => filter_open_default,
    FilterRemove: () => filter_remove_default,
    Flag: () => flag_default,
    Flame: () => flame_default,
    Flash: () => flash_default,
    FloatingPoint: () => floating_point_default,
    FloppyDisk: () => floppy_disk_default,
    FlowBranch: () => flow_branch_default,
    FlowEnd: () => flow_end_default,
    FlowLinear: () => flow_linear_default,
    FlowReview: () => flow_review_default,
    FlowReviewBranch: () => flow_review_branch_default,
    Flows: () => flows_default,
    FolderClose: () => folder_close_default,
    FolderNew: () => folder_new_default,
    FolderOpen: () => folder_open_default,
    FolderShared: () => folder_shared_default,
    FolderSharedOpen: () => folder_shared_open_default,
    Follower: () => follower_default,
    Following: () => following_default,
    Font: () => font_default,
    Fork: () => fork_default,
    Form: () => form_default,
    Fuel: () => fuel_default,
    FullCircle: () => full_circle_default,
    FullStackedChart: () => full_stacked_chart_default,
    Fullscreen: () => fullscreen_default,
    Function: () => function_default,
    GanttChart: () => gantt_chart_default,
    Geofence: () => geofence_default,
    Geolocation: () => geolocation_default,
    Geosearch: () => geosearch_default,
    GitBranch: () => git_branch_default,
    GitCommit: () => git_commit_default,
    GitMerge: () => git_merge_default,
    GitNewBranch: () => git_new_branch_default,
    GitPull: () => git_pull_default,
    GitPush: () => git_push_default,
    GitRepo: () => git_repo_default,
    Glass: () => glass_default,
    Globe: () => globe_default,
    GlobeNetwork: () => globe_network_default,
    Graph: () => graph_default,
    GraphRemove: () => graph_remove_default,
    GreaterThan: () => greater_than_default,
    GreaterThanOrEqualTo: () => greater_than_or_equal_to_default,
    Grid: () => grid_default,
    GridView: () => grid_view_default,
    GroupObjects: () => group_objects_default,
    GroupedBarChart: () => grouped_bar_chart_default,
    Hand: () => hand_default,
    HandDown: () => hand_down_default,
    HandLeft: () => hand_left_default,
    HandRight: () => hand_right_default,
    HandUp: () => hand_up_default,
    Hat: () => hat_default,
    Header: () => header_default,
    HeaderOne: () => header_one_default,
    HeaderThree: () => header_three_default,
    HeaderTwo: () => header_two_default,
    Headset: () => headset_default,
    Heart: () => heart_default,
    HeartBroken: () => heart_broken_default,
    HeatGrid: () => heat_grid_default,
    Heatmap: () => heatmap_default,
    Helicopter: () => helicopter_default,
    Help: () => help_default,
    HelperManagement: () => helper_management_default,
    HighPriority: () => high_priority_default,
    HighVoltagePole: () => high_voltage_pole_default,
    Highlight: () => highlight_default,
    History: () => history_default,
    Home: () => home_default,
    HorizontalBarChart: () => horizontal_bar_chart_default,
    HorizontalBarChartAsc: () => horizontal_bar_chart_asc_default,
    HorizontalBarChartDesc: () => horizontal_bar_chart_desc_default,
    HorizontalDistribution: () => horizontal_distribution_default,
    HorizontalInbetween: () => horizontal_inbetween_default,
    Hurricane: () => hurricane_default,
    IdNumber: () => id_number_default,
    ImageRotateLeft: () => image_rotate_left_default,
    ImageRotateRight: () => image_rotate_right_default,
    Import: () => import_default,
    Inbox: () => inbox_default,
    InboxFiltered: () => inbox_filtered_default,
    InboxGeo: () => inbox_geo_default,
    InboxSearch: () => inbox_search_default,
    InboxUpdate: () => inbox_update_default,
    InfoSign: () => info_sign_default,
    Inheritance: () => inheritance_default,
    InheritedGroup: () => inherited_group_default,
    InnerJoin: () => inner_join_default,
    Insert: () => insert_default,
    Intelligence: () => intelligence_default,
    Intersection: () => intersection_default,
    IpAddress: () => ip_address_default,
    Issue: () => issue_default,
    IssueClosed: () => issue_closed_default,
    IssueNew: () => issue_new_default,
    Italic: () => italic_default,
    JoinTable: () => join_table_default,
    Key: () => key_default,
    KeyBackspace: () => key_backspace_default,
    KeyCommand: () => key_command_default,
    KeyControl: () => key_control_default,
    KeyDelete: () => key_delete_default,
    KeyEnter: () => key_enter_default,
    KeyEscape: () => key_escape_default,
    KeyOption: () => key_option_default,
    KeyShift: () => key_shift_default,
    KeyTab: () => key_tab_default,
    KnownVehicle: () => known_vehicle_default,
    LabTest: () => lab_test_default,
    Label: () => label_default,
    Layer: () => layer_default,
    LayerOutline: () => layer_outline_default,
    Layers: () => layers_default,
    Layout: () => layout_default,
    LayoutAuto: () => layout_auto_default,
    LayoutBalloon: () => layout_balloon_default,
    LayoutCircle: () => layout_circle_default,
    LayoutGrid: () => layout_grid_default,
    LayoutGroupBy: () => layout_group_by_default,
    LayoutHierarchy: () => layout_hierarchy_default,
    LayoutLinear: () => layout_linear_default,
    LayoutSkewGrid: () => layout_skew_grid_default,
    LayoutSortedClusters: () => layout_sorted_clusters_default,
    Learning: () => learning_default,
    LeftJoin: () => left_join_default,
    LessThan: () => less_than_default,
    LessThanOrEqualTo: () => less_than_or_equal_to_default,
    Lifesaver: () => lifesaver_default,
    Lightbulb: () => lightbulb_default,
    Lightning: () => lightning_default,
    Link: () => link_default,
    List: () => list_default,
    ListColumns: () => list_columns_default,
    ListDetailView: () => list_detail_view_default,
    Locate: () => locate_default,
    Lock: () => lock_default,
    LogIn: () => log_in_default,
    LogOut: () => log_out_default,
    LowVoltagePole: () => low_voltage_pole_default,
    Manual: () => manual_default,
    ManuallyEnteredData: () => manually_entered_data_default,
    ManyToMany: () => many_to_many_default,
    ManyToOne: () => many_to_one_default,
    Map: () => map_default,
    MapCreate: () => map_create_default,
    MapMarker: () => map_marker_default,
    Maximize: () => maximize_default,
    Media: () => media_default,
    Menu: () => menu_default,
    MenuClosed: () => menu_closed_default,
    MenuOpen: () => menu_open_default,
    MergeColumns: () => merge_columns_default,
    MergeLinks: () => merge_links_default,
    Minimize: () => minimize_default,
    Minus: () => minus_default,
    MobilePhone: () => mobile_phone_default,
    MobileVideo: () => mobile_video_default,
    Modal: () => modal_default,
    ModalFilled: () => modal_filled_default,
    Moon: () => moon_default,
    More: () => more_default,
    Mountain: () => mountain_default,
    Move: () => move_default,
    Mugshot: () => mugshot_default,
    MultiSelect: () => multi_select_default,
    Music: () => music_default,
    Nest: () => nest_default,
    NewDrawing: () => new_drawing_default,
    NewGridItem: () => new_grid_item_default,
    NewLayer: () => new_layer_default,
    NewLayers: () => new_layers_default,
    NewLink: () => new_link_default,
    NewObject: () => new_object_default,
    NewPerson: () => new_person_default,
    NewPrescription: () => new_prescription_default,
    NewTextBox: () => new_text_box_default,
    Ninja: () => ninja_default,
    NotEqualTo: () => not_equal_to_default,
    Notifications: () => notifications_default,
    NotificationsSnooze: () => notifications_snooze_default,
    NotificationsUpdated: () => notifications_updated_default,
    NumberedList: () => numbered_list_default,
    Numerical: () => numerical_default,
    Office: () => office_default,
    Offline: () => offline_default,
    OilField: () => oil_field_default,
    OneColumn: () => one_column_default,
    OneToMany: () => one_to_many_default,
    OneToOne: () => one_to_one_default,
    OpenApplication: () => open_application_default,
    Outdated: () => outdated_default,
    PageLayout: () => page_layout_default,
    PanelStats: () => panel_stats_default,
    PanelTable: () => panel_table_default,
    Paperclip: () => paperclip_default,
    Paragraph: () => paragraph_default,
    Path: () => path_default,
    PathSearch: () => path_search_default,
    Pause: () => pause_default,
    People: () => people_default,
    Percentage: () => percentage_default,
    Person: () => person_default,
    Phone: () => phone_default,
    PieChart: () => pie_chart_default,
    Pin: () => pin_default,
    Pivot: () => pivot_default,
    PivotTable: () => pivot_table_default,
    Play: () => play_default,
    Playbook: () => playbook_default,
    Plus: () => plus_default,
    PolygonFilter: () => polygon_filter_default,
    Power: () => power_default,
    PredictiveAnalysis: () => predictive_analysis_default,
    Prescription: () => prescription_default,
    Presentation: () => presentation_default,
    Print: () => print_default,
    Projects: () => projects_default,
    Properties: () => properties_default,
    Property: () => property_default,
    PublishFunction: () => publish_function_default,
    Pulse: () => pulse_default,
    Rain: () => rain_default,
    Random: () => random_default,
    Record: () => record_default,
    RectHeight: () => rect_height_default,
    RectWidth: () => rect_width_default,
    Rectangle: () => rectangle_default,
    Redo: () => redo_default,
    Refresh: () => refresh_default,
    Regex: () => regex_default,
    RegressionChart: () => regression_chart_default,
    Remove: () => remove_default,
    RemoveColumn: () => remove_column_default,
    RemoveColumnLeft: () => remove_column_left_default,
    RemoveColumnRight: () => remove_column_right_default,
    RemoveRowBottom: () => remove_row_bottom_default,
    RemoveRowTop: () => remove_row_top_default,
    Repeat: () => repeat_default,
    Reset: () => reset_default,
    Resolve: () => resolve_default,
    Rig: () => rig_default,
    RightJoin: () => right_join_default,
    Ring: () => ring_default,
    Rocket: () => rocket_default,
    RocketSlant: () => rocket_slant_default,
    RotateDocument: () => rotate_document_default,
    RotatePage: () => rotate_page_default,
    Route: () => route_default,
    Satellite: () => satellite_default,
    Saved: () => saved_default,
    ScatterPlot: () => scatter_plot_default,
    Search: () => search_default,
    SearchAround: () => search_around_default,
    SearchTemplate: () => search_template_default,
    SearchText: () => search_text_default,
    SegmentedControl: () => segmented_control_default,
    Select: () => select_default,
    Selection: () => selection_default,
    SendMessage: () => send_message_default,
    SendTo: () => send_to_default,
    SendToGraph: () => send_to_graph_default,
    SendToMap: () => send_to_map_default,
    SeriesAdd: () => series_add_default,
    SeriesConfiguration: () => series_configuration_default,
    SeriesDerived: () => series_derived_default,
    SeriesFiltered: () => series_filtered_default,
    SeriesSearch: () => series_search_default,
    Settings: () => settings_default,
    Shapes: () => shapes_default,
    Share: () => share_default,
    SharedFilter: () => shared_filter_default,
    Shield: () => shield_default,
    Ship: () => ship_default,
    Shop: () => shop_default,
    ShoppingCart: () => shopping_cart_default,
    SignalSearch: () => signal_search_default,
    SimCard: () => sim_card_default,
    Slash: () => slash_default,
    SmallCross: () => small_cross_default,
    SmallInfoSign: () => small_info_sign_default,
    SmallMinus: () => small_minus_default,
    SmallPlus: () => small_plus_default,
    SmallSquare: () => small_square_default,
    SmallTick: () => small_tick_default,
    Snowflake: () => snowflake_default,
    SocialMedia: () => social_media_default,
    Sort: () => sort_default,
    SortAlphabetical: () => sort_alphabetical_default,
    SortAlphabeticalDesc: () => sort_alphabetical_desc_default,
    SortAsc: () => sort_asc_default,
    SortDesc: () => sort_desc_default,
    SortNumerical: () => sort_numerical_default,
    SortNumericalDesc: () => sort_numerical_desc_default,
    SplitColumns: () => split_columns_default,
    Square: () => square_default,
    StackedChart: () => stacked_chart_default,
    StadiumGeometry: () => stadium_geometry_default,
    Star: () => star_default,
    StarEmpty: () => star_empty_default,
    StepBackward: () => step_backward_default,
    StepChart: () => step_chart_default,
    StepForward: () => step_forward_default,
    Stop: () => stop_default,
    Stopwatch: () => stopwatch_default,
    Strikethrough: () => strikethrough_default,
    Style: () => style_default,
    SwapHorizontal: () => swap_horizontal_default,
    SwapVertical: () => swap_vertical_default,
    Switch: () => switch_default,
    SymbolCircle: () => symbol_circle_default,
    SymbolCross: () => symbol_cross_default,
    SymbolDiamond: () => symbol_diamond_default,
    SymbolRectangle: () => symbol_rectangle_default,
    SymbolSquare: () => symbol_square_default,
    SymbolTriangleDown: () => symbol_triangle_down_default,
    SymbolTriangleUp: () => symbol_triangle_up_default,
    Syringe: () => syringe_default,
    Tag: () => tag_default,
    TakeAction: () => take_action_default,
    Tank: () => tank_default,
    Target: () => target_default,
    Taxi: () => taxi_default,
    Temperature: () => temperature_default,
    TextHighlight: () => text_highlight_default,
    Th: () => th_default,
    ThDerived: () => th_derived_default,
    ThDisconnect: () => th_disconnect_default,
    ThFiltered: () => th_filtered_default,
    ThList: () => th_list_default,
    ThirdParty: () => third_party_default,
    ThumbsDown: () => thumbs_down_default,
    ThumbsUp: () => thumbs_up_default,
    Tick: () => tick_default,
    TickCircle: () => tick_circle_default,
    Time: () => time_default,
    TimelineAreaChart: () => timeline_area_chart_default,
    TimelineBarChart: () => timeline_bar_chart_default,
    TimelineEvents: () => timeline_events_default,
    TimelineLineChart: () => timeline_line_chart_default,
    Tint: () => tint_default,
    Torch: () => torch_default,
    Tractor: () => tractor_default,
    Train: () => train_default,
    Translate: () => translate_default,
    Trash: () => trash_default,
    Tree: () => tree_default,
    TrendingDown: () => trending_down_default,
    TrendingUp: () => trending_up_default,
    Truck: () => truck_default,
    TwoColumns: () => two_columns_default,
    Unarchive: () => unarchive_default,
    Underline: () => underline_default,
    Undo: () => undo_default,
    UngroupObjects: () => ungroup_objects_default,
    UnknownVehicle: () => unknown_vehicle_default,
    Unlock: () => unlock_default,
    Unpin: () => unpin_default,
    Unresolve: () => unresolve_default,
    Updated: () => updated_default,
    Upload: () => upload_default,
    User: () => user_default,
    Variable: () => variable_default,
    VerticalBarChartAsc: () => vertical_bar_chart_asc_default,
    VerticalBarChartDesc: () => vertical_bar_chart_desc_default,
    VerticalDistribution: () => vertical_distribution_default,
    VerticalInbetween: () => vertical_inbetween_default,
    Video: () => video_default,
    Virus: () => virus_default,
    VolumeDown: () => volume_down_default,
    VolumeOff: () => volume_off_default,
    VolumeUp: () => volume_up_default,
    Walk: () => walk_default,
    WarningSign: () => warning_sign_default,
    WaterfallChart: () => waterfall_chart_default,
    Waves: () => waves_default,
    Widget: () => widget_default,
    WidgetButton: () => widget_button_default,
    WidgetFooter: () => widget_footer_default,
    WidgetHeader: () => widget_header_default,
    Wind: () => wind_default,
    Wrench: () => wrench_default,
    ZoomIn: () => zoom_in_default,
    ZoomOut: () => zoom_out_default,
    ZoomToFit: () => zoom_to_fit_default
  });
  init_define_process();
  init_define_process();
  var add_default = ["M10.99 6.99h-2v-2c0-.55-.45-1-1-1s-1 .45-1 1v2h-2c-.55 0-1 .45-1 1s.45 1 1 1h2v2c0 .55.45 1 1 1s1-.45 1-1v-2h2c.55 0 1-.45 1-1s-.45-1-1-1zm-3-7c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.68 6-6 6z"];
  init_define_process();
  var add_clip_default = ["M12 0a1 1 0 00-1 1v2H9a1 1 0 000 2h2v2a1 1 0 102 0V5h2a1 1 0 100-2h-2V1a1 1 0 00-1-1zM0 4a1 1 0 011-1h3.5a1 1 0 010 2H2v2a1 1 0 01-2 0V4zm1 12a1 1 0 01-1-1v-3a1 1 0 112 0v2h2.5a1 1 0 110 2H1zm11 0a1 1 0 001-1v-3a1 1 0 10-2 0v2H9a1 1 0 100 2h3zm-5.5-4a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"];
  init_define_process();
  var add_column_left_default = ["M15 0H1C.45 0 0 .45 0 1v14c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-5 14H2V2h8v12zm4 0h-3V2h3v12zM4 9h1v1c0 .55.45 1 1 1s1-.45 1-1V9h1c.55 0 1-.45 1-1s-.45-1-1-1H7V6c0-.55-.45-1-1-1s-1 .45-1 1v1H4c-.55 0-1 .45-1 1s.45 1 1 1z"];
  init_define_process();
  var add_column_right_default = ["M8 9h1v1c0 .55.45 1 1 1s1-.45 1-1V9h1c.55 0 1-.45 1-1s-.45-1-1-1h-1V6c0-.55-.45-1-1-1s-1 .45-1 1v1H8c-.55 0-1 .45-1 1s.45 1 1 1zm7-9H1C.45 0 0 .45 0 1v14c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zM5 14H2V2h3v12zm9 0H6V2h8v12z"];
  init_define_process();
  var add_location_default = ["M8 0a1 1 0 110 2 6 6 0 106 6 1 1 0 012 0 8 8 0 11-8-8zm0 5a3 3 0 110 6 3 3 0 010-6zm5-5a1 1 0 011 1v.999L15 2a1 1 0 010 2h-1v1a1 1 0 01-2 0V4h-1a1 1 0 010-2h1V1a1 1 0 011-1z"];
  init_define_process();
  var add_row_bottom_default = ["M6 11h1v1c0 .55.45 1 1 1s1-.45 1-1v-1h1c.55 0 1-.45 1-1s-.45-1-1-1H9V8c0-.55-.45-1-1-1s-1 .45-1 1v1H6c-.55 0-1 .45-1 1s.45 1 1 1zm9-11H1C.45 0 0 .45 0 1v14c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 14H2V6h12v8zm0-9H2V2h12v3z"];
  init_define_process();
  var add_row_top_default = ["M15 0H1C.45 0 0 .45 0 1v14c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 14H2v-3h12v3zm0-4H2V2h12v8zM6 7h1v1c0 .55.45 1 1 1s1-.45 1-1V7h1c.55 0 1-.45 1-1s-.45-1-1-1H9V4c0-.55-.45-1-1-1s-1 .45-1 1v1H6c-.55 0-1 .45-1 1s.45 1 1 1z"];
  init_define_process();
  var add_to_artifact_default = ["M14 4.01h-1v-1c0-.55-.45-1-1-1s-1 .45-1 1v1h-1c-.55 0-1 .45-1 1s.45 1 1 1h1v1c0 .55.45 1 1 1s1-.45 1-1v-1h1c.55 0 1-.45 1-1 0-.56-.45-1-1-1zm-13 2h6c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1zm8 6H1c-.55 0-1 .45-1 1s.45 1 1 1h8c.55 0 1-.45 1-1 0-.56-.45-1-1-1zm0-4H1c-.55 0-1 .45-1 1s.45 1 1 1h8c.55 0 1-.45 1-1 0-.56-.45-1-1-1z"];
  init_define_process();
  var add_to_folder_default = ["M.01 7V5H16v7c0 .55-.45 1-1 1H9.005v-2.99C8.974 8.332 7.644 7 5.996 7H.01zM15 2H7.416L5.706.29a.996.996 0 00-.71-.29H1C.45 0 0 .45 0 1v3h15.99V3c.01-.55-.44-1-.99-1zM5.997 9H2c-.55 0-1 .45-1 1s.45 1 1 1h1.589L.3 14.29a1.003 1.003 0 001.42 1.42l3.287-3.29v1.59c0 .55.45 1 1 1 .549 0 .999-.45.999-1v-4A1.02 1.02 0 005.996 9z"];
  init_define_process();
  var aimpoints_target_default = ["M2.1 9.101a3.99 3.99 0 00-1.828.974A8 8 0 0110.075.272 3.99 3.99 0 009.1 2.1a6 6 0 00-7 7zM14 8a6.03 6.03 0 00-.1-1.101 3.99 3.99 0 001.828-.974 8 8 0 01-9.803 9.803A3.99 3.99 0 006.9 13.9 6 6 0 0014 8z", "M8 3a1 1 0 00-1 1v2a1 1 0 002 0V4a1 1 0 00-1-1zM9 8a1 1 0 011-1h2a1 1 0 010 2h-2a1 1 0 01-1-1zM3 8a1 1 0 011-1h2a1 1 0 010 2H4a1 1 0 01-1-1zM7 10a1 1 0 012 0v2a1 1 0 01-2 0v-2zM5 13a2 2 0 11-4 0 2 2 0 014 0zM13 5a2 2 0 100-4 2 2 0 000 4z"];
  init_define_process();
  var airplane_default = ["M16 1.5A1.498 1.498 0 0013.44.44L9.91 3.97 2 1 1 3l5.93 3.95L3.88 10H1l-1 1 3 2 2 3 1-1v-2.88l3.05-3.05L13 15l2-1-2.97-7.91 3.53-3.53c.27-.27.44-.65.44-1.06z"];
  init_define_process();
  var align_center_default = ["M4 4c-.55 0-1 .45-1 1s.45 1 1 1h8c.55 0 1-.45 1-1s-.45-1-1-1H4zM1 3h14c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1zm13 10H2c-.55 0-1 .45-1 1s.45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1zm1-6H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zm-5 5c.55 0 1-.45 1-1s-.45-1-1-1H6c-.55 0-1 .45-1 1s.45 1 1 1h4z"];
  init_define_process();
  var align_justify_default = ["M15 12.98H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zm-14-10h14c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1 0 .56.45 1 1 1zm14 4H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zm0-3H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zm0 6H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var align_left_default = ["M13 13H1c-.55 0-1 .45-1 1s.45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1zM1 3h14c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1zm0 3h8c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1zm14 1H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zM1 12h4c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1z"];
  init_define_process();
  var align_right_default = ["M15 12.98H3c-.55 0-1 .45-1 1s.45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1zm-14-10h14c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1 0 .56.45 1 1 1zm14 1H7c-.55 0-1 .45-1 1s.45 1 1 1h8c.55 0 1-.45 1-1s-.45-1-1-1zm0 6h-4c-.55 0-1 .45-1 1s.45 1 1 1h4c.55 0 1-.45 1-1s-.45-1-1-1zm0-3H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var alignment_bottom_default = ["M10 12h3c.55 0 1-.45 1-1V7c0-.55-.45-1-1-1h-3c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1zm5 2H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zM3 12h3c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v9c0 .55.45 1 1 1z"];
  init_define_process();
  var alignment_horizontal_center_default = ["M15 7h-1V6c0-.55-.45-1-1-1h-3c-.55 0-1 .45-1 1v1H7V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v4H1c-.55 0-1 .45-1 1s.45 1 1 1h1v4c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V9h2v1c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V9h1c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var alignment_left_default = ["M9 9H5c-.55 0-1 .45-1 1v3c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-3c0-.55-.45-1-1-1zM1 0C.45 0 0 .45 0 1v14c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1zm13 2H5c-.55 0-1 .45-1 1v3c0 .55.45 1 1 1h9c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1z"];
  init_define_process();
  var alignment_right_default = ["M11 9H7c-.55 0-1 .45-1 1v3c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-3c0-.55-.45-1-1-1zm4-9c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1zm-4 2H2c-.55 0-1 .45-1 1v3c0 .55.45 1 1 1h9c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1z"];
  init_define_process();
  var alignment_top_default = ["M15 0H1C.45 0 0 .45 0 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zM6 4H3c-.55 0-1 .45-1 1v9c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zm7 0h-3c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1z"];
  init_define_process();
  var alignment_vertical_center_default = ["M13 2H9V1c0-.55-.45-1-1-1S7 .45 7 1v1H3c-.55 0-1 .45-1 1v3c0 .55.45 1 1 1h4v2H6c-.55 0-1 .45-1 1v3c0 .55.45 1 1 1h1v1c0 .55.45 1 1 1s1-.45 1-1v-1h1c.55 0 1-.45 1-1v-3c0-.55-.45-1-1-1H9V7h4c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1z"];
  init_define_process();
  var anchor_default = ["M10 2a2 2 0 01-1 1.732V5h2v2H9v6.874a4.004 4.004 0 002.976-3.436l-.269.27a1 1 0 01-1.414-1.415l2-2a1 1 0 011.414 0l2 2a1 1 0 01-1.414 1.414l-.306-.306a6 6 0 01-11.974 0l-.306.306A1 1 0 01.293 9.293l2-2a1 1 0 011.414 0l2 2a1 1 0 01-1.414 1.414l-.27-.27A4.003 4.003 0 007 13.875V7H5V5h2V3.732A2 2 0 1110 2z"];
  init_define_process();
  var annotation_default = ["M15.52 2.77c.3-.29.48-.7.48-1.15C16 .73 15.27 0 14.38 0c-.45 0-.85.18-1.15.48l-1.34 1.34 2.3 2.3 1.33-1.35zM7.4 10.9l6.21-6.21-2.3-2.3L5.1 8.6l2.3 2.3zM14 14H2V2h6.34l2-2H1C.45 0 0 .45 0 1v14c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V5.66l-2 2V14zM3 13l3.58-1.29-2.29-2.27L3 13z"];
  init_define_process();
  var antenna_default = ["M2.673 10.758a1.396 1.396 0 01.093.234c.127.442.012.932-.362 1.212-.441.332-1.075.246-1.349-.233a8 8 0 1114.014-.225c-.259.488-.889.594-1.341.277-.382-.269-.513-.755-.4-1.2a1.259 1.259 0 01.085-.238 6 6 0 10-10.74.173zm2.464-1.862a1.783 1.783 0 01.076.404c.03.415-.096.831-.43 1.078-.444.328-1.08.237-1.314-.264a5.003 5.003 0 01-.24-.62l-.004-.011a5 5 0 119.574-.08l-.003.011c-.063.213-.14.422-.23.625-.226.504-.861.606-1.31.285-.338-.241-.47-.654-.448-1.07a1.737 1.737 0 01.07-.405 2.99 2.99 0 00-.216-2.233 3 3 0 00-5.525 2.28zM8 7a1 1 0 011 1v3.586l2.707 2.707a1 1 0 01-1.414 1.414L8 13.414l-2.293 2.293a1 1 0 01-1.414-1.414L7 11.586V8a1 1 0 011-1z"];
  init_define_process();
  var app_header_default = ["M15 0a1 1 0 011 1v14a1 1 0 01-1 1H1a1 1 0 01-1-1V1a1 1 0 011-1h14zM6 4a1 1 0 00-1.993-.117L4 4v8a1 1 0 001.993.117L6 12V9h4v3a1 1 0 001.993.117L12 12V4a1 1 0 00-1.993-.117L10 4v3H6V4z"];
  init_define_process();
  var application_default = ["M3.5 7h7c.28 0 .5-.22.5-.5s-.22-.5-.5-.5h-7c-.28 0-.5.22-.5.5s.22.5.5.5zM15 1H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zm-1 12H2V5h12v8zM3.5 9h4c.28 0 .5-.22.5-.5S7.78 8 7.5 8h-4c-.28 0-.5.22-.5.5s.22.5.5.5zm0 2h5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5h-5c-.28 0-.5.22-.5.5s.22.5.5.5z"];
  init_define_process();
  var applications_default = ["M3.5 11h2c.28 0 .5-.22.5-.5s-.22-.5-.5-.5h-2c-.28 0-.5.22-.5.5s.22.5.5.5zm0-2h5c.28 0 .5-.22.5-.5S8.78 8 8.5 8h-5c-.28 0-.5.22-.5.5s.22.5.5.5zM11 4H1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zm-1 10H2V7h8v7zm5-14H5c-.55 0-1 .45-1 1v2h2V2h8v7h-1v2h2c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zM3.5 13h3c.28 0 .5-.22.5-.5s-.22-.5-.5-.5h-3c-.28 0-.5.22-.5.5s.22.5.5.5z"];
  init_define_process();
  var archive_default = ["M13.382 0a1 1 0 01.894.553L16 4v11a1 1 0 01-1 1H1a1 1 0 01-1-1V4L1.724.553A1 1 0 012.618 0h10.764zM8 6c-.55 0-1 .45-1 1v2.59l-.29-.29-.081-.076A.97.97 0 006 9a1.003 1.003 0 00-.71 1.71l2 2 .096.084c.168.13.38.206.614.206.28 0 .53-.11.71-.29l2-2 .084-.096A1.003 1.003 0 009.29 9.29l-.29.3V7l-.007-.116A1.004 1.004 0 008 6zm5-4H3L2 4h12l-1-2z"];
  init_define_process();
  var area_of_interest_default = ["M4 3.664C4 1.644 5.793 0 8 0s3.993 1.643 4 3.664C12 5.692 8 11 8 11S4 5.692 4 3.664zM6 4a2 2 0 104.001-.001A2 2 0 006 4zm7.504 6.269l-2.68-1.609.021-.033c.34-.538.688-1.115 1-1.687l3.67 2.202a1 1 0 01.266 1.482l-4 5A1 1 0 0111 16H5a1 1 0 01-.78-.376l-4-5a1 1 0 01.266-1.482l3.67-2.202a30.46 30.46 0 00.999 1.687l.021.033-2.68 1.609 2.985 3.73h5.038l2.985-3.73z"];
  init_define_process();
  var array_default = ["M15 0a1 1 0 01.993.883L16 1v14a1 1 0 01-.883.993L15 16h-3a1 1 0 01-.117-1.993L12 14h2V2h-2a1 1 0 01-.993-.883L11 1a1 1 0 01.883-.993L12 0h3zM4 0a1 1 0 01.117 1.993L4 2H2v12h2a1 1 0 01.993.883L5 15a1 1 0 01-.883.993L4 16H1a1 1 0 01-.993-.883L0 15V1A1 1 0 01.883.007L1 0h3zm4 7a1 1 0 110 2 1 1 0 010-2zM5 7a1 1 0 110 2 1 1 0 010-2zm6 0a1 1 0 110 2 1 1 0 010-2z"];
  init_define_process();
  var array_boolean_default = ["M15 0a1 1 0 01.993.883L16 1v14a1 1 0 01-.883.993L15 16h-3a1 1 0 01-.117-1.993L12 14h2V2h-2a1 1 0 01-.993-.883L11 1a1 1 0 01.883-.993L12 0h3zM4 0a1 1 0 01.117 1.993L4 2H2v12h2a1 1 0 01.993.883L5 15a1 1 0 01-.883.993L4 16H1a1 1 0 01-.993-.883L0 15V1A1 1 0 01.883.007L1 0h3zm7 6a1 1 0 01.993.883L12 7v2a1 1 0 01-.883.993L11 10H5a1 1 0 01-.993-.883L4 9V7a1 1 0 01.883-.993L5 6h6zm0 1H8v2h3V7z"];
  init_define_process();
  var array_date_default = ["M15 0a1 1 0 01.993.883L16 1v14a1 1 0 01-.883.993L15 16h-3a1 1 0 01-.117-1.993L12 14h2V2h-2a1 1 0 01-.993-.883L11 1a1 1 0 01.883-.993L12 0h3zM4 0a1 1 0 01.117 1.993L4 2H2v12h2a1 1 0 01.993.883L5 15a1 1 0 01-.883.993L4 16H1a1 1 0 01-.993-.883L0 15V1A1 1 0 01.883.007L1 0h3zm6.5 4a.5.5 0 01.5.5V5a1 1 0 01.993.883L12 6v5a1 1 0 01-.883.993L11 12H5a1 1 0 01-.993-.883L4 11V6a1 1 0 01.883-.993L5 5v-.5a.5.5 0 011 0V5h4v-.5a.5.5 0 01.5-.5zm.5 3H5v4h6V7z"];
  init_define_process();
  var array_floating_point_default = ["M15.993.883A1 1 0 0015 0h-3l-.117.007A1 1 0 0011 1l.007.117A1 1 0 0012 2h2v12h-2l-.117.007A1 1 0 0012 16h3l.117-.007A1 1 0 0016 15V1l-.007-.117zM5 1a1 1 0 00-1-1H1L.883.007A1 1 0 000 1v14l.007.117A1 1 0 001 16h3l.117-.007A1 1 0 005 15l-.007-.117A1 1 0 004 14H2V2h2l.117-.007A1 1 0 005 1z", "M4.347 5.86c-.177.03-.36.047-.547.047v.703h1.344v3.86h.977V5h-.727a.844.844 0 01-.203.422 1.17 1.17 0 01-.367.281c-.14.073-.3.125-.477.157z", "M11.462 5.27c-.236-.176-.542-.264-.918-.264s-.685.088-.925.263a1.79 1.79 0 00-.557.662c-.13.266-.22.56-.27.88-.046.321-.068.632-.068.933 0 .3.022.612.067.933.05.32.14.617.271.887.135.266.321.487.557.662.24.17.549.256.925.256s.682-.085.918-.256c.24-.175.426-.396.556-.662a2.86 2.86 0 00.271-.887c.05-.321.075-.632.075-.933 0-.3-.025-.612-.075-.933a2.775 2.775 0 00-.27-.88 1.702 1.702 0 00-.557-.662zm-.452 4.34a.7.7 0 01-.466.157.711.711 0 01-.474-.158 1.214 1.214 0 01-.293-.436 2.791 2.791 0 01-.15-.647 6.443 6.443 0 01-.046-.782c0-.276.015-.534.045-.775.03-.246.08-.461.15-.647.076-.185.174-.33.294-.436a.69.69 0 01.474-.166.68.68 0 01.466.166c.126.105.223.25.294.436.075.186.128.401.158.647.03.24.045.5.045.775 0 .276-.015.537-.045.782-.03.246-.083.462-.158.647-.07.18-.168.326-.294.436z", "M7.082 9.445H8.17V10.5H7.082V9.445z"];
  init_define_process();
  var array_numeric_default = ["M15 0a1 1 0 01.993.883L16 1v14a1 1 0 01-.883.993L15 16h-3a1 1 0 01-.117-1.993L12 14h2V2h-2a1 1 0 01-.993-.883L11 1a1 1 0 01.883-.993L12 0h3zM4 0a1 1 0 01.117 1.993L4 2H2v12h2a1 1 0 01.993.883L5 15a1 1 0 01-.883.993L4 16H1a1 1 0 01-.993-.883L0 15V1A1 1 0 01.883.007L1 0h3zm6.904 5c.256 0 .483.037.68.112a1.343 1.343 0 01.812.788c.072.184.108.385.108.604 0 .23-.05.441-.152.636a1.314 1.314 0 01-.456.492v.016l.08.04c.055.031.111.072.168.124.085.077.163.172.232.284a1.673 1.673 0 01.24.872c0 .25-.043.477-.128.68a1.518 1.518 0 01-.896.852 1.937 1.937 0 01-.68.116c-.427 0-.792-.101-1.096-.304a1.362 1.362 0 01-.584-.864c-.01-.053.01-.088.064-.104l.696-.16.033-.002c.03.002.051.022.063.058.059.16.155.296.288.408.133.112.312.168.536.168.256 0 .453-.076.592-.228a.827.827 0 00.208-.58c0-.277-.08-.495-.24-.652-.16-.157-.376-.236-.648-.236h-.232l-.035-.005c-.03-.01-.045-.035-.045-.075v-.632l.005-.035c.01-.03.035-.045.075-.045h.216l.138-.009a.734.734 0 00.438-.207c.144-.144.216-.336.216-.576a.745.745 0 00-.192-.532c-.128-.136-.307-.204-.536-.204-.203 0-.363.05-.48.152a.815.815 0 00-.248.408c-.016.048-.048.067-.096.056l-.68-.16-.034-.012c-.028-.016-.038-.044-.03-.084a1.347 1.347 0 01.516-.828c.136-.104.296-.185.48-.244A1.98 1.98 0 0110.904 5zm-6.152.088l.035.005c.03.01.045.035.045.075v5.28l-.005.035c-.01.03-.035.045-.075.045h-.736l-.035-.005c-.03-.01-.045-.035-.045-.075V6.16H3.92l-.832.584-.032.016C3.02 6.773 3 6.751 3 6.696V5.88l.006-.04a.157.157 0 01.05-.072l.872-.632.04-.027a.236.236 0 01.104-.021h.68zM7.344 5c.256 0 .483.04.68.12.197.08.364.188.5.324s.24.296.312.48c.072.184.108.383.108.596 0 .245-.045.47-.136.676-.09.205-.216.404-.376.596l-1.584 1.92v.016h2.016l.035.005c.03.01.045.035.045.075v.64l-.005.035c-.01.03-.035.045-.075.045H5.808l-.035-.005c-.03-.01-.045-.035-.045-.075v-.6l.004-.04a.132.132 0 01.036-.064l1.92-2.392.1-.133a1.95 1.95 0 00.156-.267.985.985 0 00.096-.432.736.736 0 00-.188-.512c-.125-.139-.303-.208-.532-.208-.219 0-.39.061-.512.184a.826.826 0 00-.224.496c-.01.053-.04.075-.088.064L5.792 6.4l-.034-.012c-.028-.016-.038-.044-.03-.084a1.425 1.425 0 01.94-1.192A1.88 1.88 0 017.344 5z"];
  init_define_process();
  var array_string_default = ["M15 0a1 1 0 01.993.883L16 1v14a1 1 0 01-.883.993L15 16h-3a1 1 0 01-.117-1.993L12 14h2V2h-2a1 1 0 01-.993-.883L11 1a1 1 0 01.883-.993L12 0h3zM4 0a1 1 0 01.117 1.993L4 2H2v12h2a1 1 0 01.993.883L5 15a1 1 0 01-.883.993L4 16H1a1 1 0 01-.993-.883L0 15V1A1 1 0 01.883.007L1 0h3zm1.61 5c.514 0 .962.212 1.343.637.382.425.573.997.573 1.716 0 .838-.258 1.588-.773 2.252-.514.663-1.327 1.2-2.437 1.609v-.465l.233-.095a3.09 3.09 0 001.274-1.017c.366-.505.55-1.03.55-1.577a.478.478 0 00-.057-.26c-.018-.037-.043-.056-.074-.056s-.08.025-.149.075c-.198.142-.446.214-.744.214-.36 0-.675-.145-.944-.433A1.453 1.453 0 014 6.572c0-.422.155-.79.465-1.102.31-.313.692-.47 1.144-.47zm4.474 0c.514 0 .963.212 1.344.637.381.425.572.997.572 1.716 0 .838-.257 1.588-.772 2.252-.515.663-1.327 1.2-2.437 1.609v-.465l.233-.095a3.09 3.09 0 001.274-1.017c.366-.505.549-1.03.549-1.577a.478.478 0 00-.056-.26c-.019-.037-.044-.056-.075-.056-.03 0-.08.025-.149.075-.198.142-.446.214-.744.214-.36 0-.674-.145-.944-.433a1.453 1.453 0 01-.405-1.028c0-.422.155-.79.466-1.102.31-.313.691-.47 1.144-.47z"];
  init_define_process();
  var array_timestamp_default = ["M15 0a1 1 0 01.993.883L16 1v14a1 1 0 01-.883.993L15 16h-3a1 1 0 01-.117-1.993L12 14h2V2h-2a1 1 0 01-.993-.883L11 1a1 1 0 01.883-.993L12 0h3zM4 0a1 1 0 01.117 1.993L4 2H2v12h2a1 1 0 01.993.883L5 15a1 1 0 01-.883.993L4 16H1a1 1 0 01-.993-.883L0 15V1A1 1 0 01.883.007L1 0h3zm4 3a5 5 0 110 10A5 5 0 018 3zm0 1a4 4 0 100 8 4 4 0 000-8zm2.354 1.646a.5.5 0 01.057.638l-.057.07-2 2a.5.5 0 01-.638.057l-.07-.057-1-1a.5.5 0 01.638-.765l.07.057.646.647 1.646-1.647a.5.5 0 01.708 0z"];
  init_define_process();
  var arrow_bottom_left_default = ["M14 3a1.003 1.003 0 00-1.71-.71L4 10.59V6c0-.55-.45-1-1-1s-1 .45-1 1v7c0 .55.45 1 1 1h7c.55 0 1-.45 1-1s-.45-1-1-1H5.41l8.29-8.29c.19-.18.3-.43.3-.71z"];
  init_define_process();
  var arrow_bottom_right_default = ["M13 5c-.55 0-1 .45-1 1v4.59l-8.29-8.3a1.003 1.003 0 00-1.42 1.42l8.3 8.29H6c-.55 0-1 .45-1 1s.45 1 1 1h7c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1z"];
  init_define_process();
  var arrow_down_default = ["M13 8c-.3 0-.5.1-.7.3L9 11.6V2c0-.5-.4-1-1-1s-1 .5-1 1v9.6L3.7 8.3C3.5 8.1 3.3 8 3 8c-.5 0-1 .5-1 1 0 .3.1.5.3.7l5 5c.2.2.4.3.7.3s.5-.1.7-.3l5-5c.2-.2.3-.4.3-.7 0-.6-.4-1-1-1z"];
  init_define_process();
  var arrow_left_default = ["M13.99 6.99H4.41L7.7 3.7a1.003 1.003 0 00-1.42-1.42l-5 5a1.014 1.014 0 000 1.42l5 5a1.003 1.003 0 001.42-1.42L4.41 8.99H14c.55 0 1-.45 1-1s-.46-1-1.01-1z"];
  init_define_process();
  var arrow_right_default = ["M14.7 7.29l-5-5a.965.965 0 00-.71-.3 1.003 1.003 0 00-.71 1.71l3.29 3.29H1.99c-.55 0-1 .45-1 1s.45 1 1 1h9.59l-3.29 3.29a1.003 1.003 0 001.42 1.42l5-5c.18-.18.29-.43.29-.71s-.12-.52-.3-.7z"];
  init_define_process();
  var arrow_top_left_default = ["M13.71 12.29L5.41 4H10c.55 0 1-.45 1-1s-.45-1-1-1H3c-.55 0-1 .45-1 1v7c0 .55.45 1 1 1s1-.45 1-1V5.41l8.29 8.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71z"];
  init_define_process();
  var arrow_top_right_default = ["M13 2H6c-.55 0-1 .45-1 1s.45 1 1 1h4.59L2.3 12.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L12 5.41V10c0 .55.45 1 1 1s1-.45 1-1V3c0-.55-.45-1-1-1z"];
  init_define_process();
  var arrow_up_default = ["M13.7 6.3l-5-5C8.5 1.1 8.3 1 8 1s-.5.1-.7.3l-5 5c-.2.2-.3.4-.3.7 0 .6.5 1 1 1 .3 0 .5-.1.7-.3L7 4.4V14c0 .6.4 1 1 1s1-.4 1-1V4.4l3.3 3.3c.2.2.4.3.7.3.6 0 1-.4 1-1 0-.3-.1-.5-.3-.7z"];
  init_define_process();
  var arrows_horizontal_default = ["M15.7 7.3l-4-4c-.2-.2-.4-.3-.7-.3-.6 0-1 .5-1 1 0 .3.1.5.3.7L12.6 7H3.4l2.3-2.3c.2-.2.3-.4.3-.7 0-.5-.4-1-1-1-.3 0-.5.1-.7.3l-4 4c-.2.2-.3.4-.3.7s.1.5.3.7l4 4c.2.2.4.3.7.3.6 0 1-.4 1-1 0-.3-.1-.5-.3-.7L3.4 9h9.2l-2.3 2.3c-.2.2-.3.4-.3.7 0 .6.4 1 1 1 .3 0 .5-.1.7-.3l4-4c.2-.2.3-.4.3-.7s-.1-.5-.3-.7z"];
  init_define_process();
  var arrows_vertical_default = ["M12 10c-.3 0-.5.1-.7.3L9 12.6V3.4l2.3 2.3c.2.2.4.3.7.3.6 0 1-.4 1-1 0-.3-.1-.5-.3-.7l-4-4C8.5.1 8.3 0 8 0s-.5.1-.7.3l-4 4c-.2.2-.3.4-.3.7 0 .6.5 1 1 1 .3 0 .5-.1.7-.3L7 3.4v9.2l-2.3-2.3c-.2-.2-.4-.3-.7-.3-.5 0-1 .4-1 1 0 .3.1.5.3.7l4 4c.2.2.4.3.7.3s.5-.1.7-.3l4-4c.2-.2.3-.4.3-.7 0-.6-.4-1-1-1z"];
  init_define_process();
  var asterisk_default = ["M14.54 11.18l.01-.02L9.8 8l4.75-3.17-.01-.02c.27-.17.46-.46.46-.81 0-.55-.45-1-1-1-.21 0-.39.08-.54.18l-.01-.02L9 6.13V1c0-.55-.45-1-1-1S7 .45 7 1v5.13L2.55 3.17l-.01.01A.969.969 0 002 3c-.55 0-1 .45-1 1 0 .35.19.64.46.82l-.01.01L6.2 8l-4.75 3.17.01.02c-.27.17-.46.46-.46.81 0 .55.45 1 1 1 .21 0 .39-.08.54-.18l.01.02L7 9.87V15c0 .55.45 1 1 1s1-.45 1-1V9.87l4.45 2.96.01-.02c.15.11.33.19.54.19.55 0 1-.45 1-1 0-.35-.19-.64-.46-.82z"];
  init_define_process();
  var at_default = ["M5.816 8.371c0 1.515.603 2.274 1.814 2.274 1.273 0 1.971-.954 2.089-2.86l.12-2.331a5.298 5.298 0 00-1.337-.165c-.848 0-1.507.276-1.979.828-.472.554-.707 1.305-.707 2.254M16 7.133c0 .93-.149 1.78-.446 2.55-.297.77-.714 1.372-1.253 1.802a2.913 2.913 0 01-1.868.642c-.521 0-.975-.137-1.356-.41a1.989 1.989 0 01-.773-1.111h-.12c-.323.506-.723.887-1.198 1.14a3.35 3.35 0 01-1.605.38c-1.076 0-1.924-.34-2.541-1.023-.618-.682-.926-1.607-.926-2.77 0-1.341.41-2.428 1.229-3.264.818-.835 1.918-1.253 3.298-1.253.502 0 1.058.043 1.669.13.61.088 1.155.21 1.63.367l-.218 4.536v.234c0 1.04.344 1.562 1.031 1.562.521 0 .935-.332 1.241-.996.308-.664.463-1.508.463-2.537 0-1.112-.232-2.09-.695-2.931a4.762 4.762 0 00-1.97-1.947c-.851-.456-1.83-.682-2.934-.682-1.405 0-2.628.286-3.67.858a5.736 5.736 0 00-2.382 2.455c-.549 1.062-.822 2.296-.822 3.7 0 1.888.512 3.339 1.535 4.353 1.024 1.015 2.492 1.52 4.409 1.52 1.46 0 2.982-.29 4.567-.877v1.6c-1.386.56-2.896.839-4.527.839-2.446 0-4.35-.65-5.717-1.945C.685 12.757 0 10.947 0 8.625c0-1.698.37-3.209 1.11-4.532a7.556 7.556 0 013.076-3.038C5.497.35 6.982 0 8.64 0c1.433 0 2.71.294 3.827.878a6.294 6.294 0 012.607 2.504c.619 1.082.926 2.332.926 3.75"];
  init_define_process();
  var automatic_updates_default = ["M8 14c-3.31 0-6-2.69-6-6 0-1.77.78-3.36 2-4.46V5c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1H1C.45 0 0 .45 0 1s.45 1 1 1h1.74A7.95 7.95 0 000 8c0 4.42 3.58 8 8 8 .55 0 1-.45 1-1s-.45-1-1-1zM8 2a5.9 5.9 0 012.95.81l1.47-1.47A7.893 7.893 0 008 0c-.55 0-1 .45-1 1s.45 1 1 1zm2.71 6.71l5-5a1.003 1.003 0 00-1.42-1.42L10 6.59l-1.29-1.3a1.003 1.003 0 00-1.42 1.42l2 2c.18.18.43.29.71.29s.53-.11.71-.29zM16 8c0-.55-.06-1.08-.16-1.6l-1.87 1.87A5.966 5.966 0 0112 12.45V11c0-.55-.45-1-1-1s-1 .45-1 1v4c0 .55.45 1 1 1h4c.55 0 1-.45 1-1s-.45-1-1-1h-1.74A7.95 7.95 0 0016 8z"];
  init_define_process();
  var backlink_default = ["M14 10a1 1 0 110 2h-.585l2.292 2.293a1 1 0 01-1.32 1.497l-.094-.083L12 13.415V14a1 1 0 11-2 0l.003-3.075.012-.1.012-.059.033-.108.034-.081.052-.098.067-.096.08-.09a1.01 1.01 0 01.112-.097l.11-.071.143-.065.076-.024.091-.02.116-.014L14 10zM6.036 6.136l-3.45 3.45-.117.127a2 2 0 002.818 2.818l.127-.117 3.45-3.449a4 4 0 01-.885 3.704l-.15.16-1 1A4 4 0 011.02 8.33l.15-.16 1-1a3.998 3.998 0 013.865-1.035zm4.671-1.843a1 1 0 01.083 1.32l-.083.094-5 5a1 1 0 01-1.497-1.32l.083-.094 5-5a1 1 0 011.414 0zm3.121-3.121a4 4 0 01.151 5.497l-.15.16-1 1a3.998 3.998 0 01-3.864 1.036l3.45-3.45.116-.128a2 2 0 00-2.818-2.818l-.127.117-3.45 3.45A4 4 0 017.02 2.33l.15-.16 1-1a4 4 0 015.657 0z"];
  init_define_process();
  var badge_default = ["M13.36 4.59c-.15-1.13.5-2.01 1.1-2.87L13.43.53c-1.72.88-4.12.65-5.63-.53-1.51 1.18-3.91 1.41-5.63.52l-1.03 1.2c.61.86 1.25 1.74 1.1 2.87-.3 2.29-2.45 4.17-1.32 6.68.45 1.14 1.44 1.9 2.72 2.2 1.56.36 3.52.72 4.16 2.53.64-1.81 2.6-2.16 4.16-2.54 1.28-.3 2.27-1.06 2.72-2.2 1.12-2.5-1.03-4.38-1.32-6.67z"];
  init_define_process();
  var ban_circle_default = ["M8 0C3.58 0 0 3.58 0 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm3 9H5c-.55 0-1-.45-1-1s.45-1 1-1h6c.55 0 1 .45 1 1s-.45 1-1 1z"];
  init_define_process();
  var bank_account_default = ["M15.36 6.46l-.62-.14c-.31-1.12-.98-2.15-1.87-2.99l.4-1.77a.438.438 0 00-.49-.56c-.85.09-1.6.42-2.14.98-.84-.32-1.87-.51-2.85-.51-2.49 0-4.63 1.17-5.92 2.89-.18-.04-.36-.09-.53-.09-.76 0-1.34.61-1.34 1.4 0 .56.31 1.03.76 1.26-.05.33-.09.7-.09 1.07 0 1.68.71 3.17 1.83 4.34l-.27 1.59c-.09.56.35 1.07.89 1.07h.58c.45 0 .8-.33.89-.79l.04-.37c.94.42 2 .7 3.16.7 1.11 0 2.23-.23 3.16-.7l.05.37c.09.47.45.79.89.79h.58c.53 0 .98-.51.89-1.07l-.27-1.54c.62-.61 1.07-1.35 1.38-2.15l.8-.19c.4-.09.71-.47.71-.93V7.4c.09-.47-.22-.84-.62-.94zM12 8c-.6 0-1-.7-1-1.5S11.4 5 12 5s1 .7 1 1.5S12.6 8 12 8zM6.21 4.92c-.41.2-.91.04-1.12-.36-.21-.4-.04-.88.37-1.07 1.35-.65 2.73-.65 4.08 0 .41.2.58.68.37 1.07-.21.4-.71.56-1.12.36-.87-.43-1.71-.43-2.58 0z"];
  init_define_process();
  var barcode_default = ["M0 14h2V2H0v12zm6 0h1V2H6v12zm2 0h1V2H8v12zm-5 0h2V2H3v12zM15 2v12h1V2h-1zm-5 12h1V2h-1v12zm2 0h2V2h-2v12z"];
  init_define_process();
  var p = [];
  var blank_default = p;
  init_define_process();
  var blocked_person_default = ["M9.39 12.69c-1.2-.53-1.04-.85-1.08-1.29-.01-.07-.01-.13-.02-.2.41-.37.75-.87.97-1.44 0 0 .01-.03.01-.04.05-.13.09-.26.13-.39.27-.06.43-.36.5-.63.01-.03.03-.08.05-.12C8.18 7.8 6.94 6.04 6.94 4c0-.32.04-.62.09-.92-.17-.03-.35-.08-.51-.08-.65 0-1.37.2-1.88.59-.5.38-.87.92-1.05 1.51-.04.14-.07.27-.09.41-.09.48-.14 1.23-.14 1.74v.06c-.19.08-.36.27-.4.68-.03.31.1.59.16.7.06.28.23.59.51.64.04.14.08.27.13.39 0 .01.01.02.01.02v.01c.22.59.57 1.1.99 1.46 0 .06-.01.12-.01.17-.04.44.08.76-1.12 1.29-1.2.53-3.01 1.1-3.38 1.95C-.12 15.5.03 16 .03 16h12.96s.15-.5-.22-1.36c-.37-.85-2.18-1.42-3.38-1.95zM11.97 0C9.75 0 7.94 1.79 7.94 4s1.8 4 4.03 4S16 6.21 16 4s-1.8-4-4.03-4zM9.96 4c0-1.1.9-2 2.01-2 .37 0 .72.11 1.02.28l-2.75 2.73c-.17-.3-.28-.64-.28-1.01zm2.01 2c-.37 0-.72-.11-1.02-.28l2.75-2.73c.18.3.28.64.28 1.01.01 1.1-.9 2-2.01 2z"];
  init_define_process();
  var bold_default = ["M11.7 7c.2-.4.3-1 .3-1.5v-.4V5c0-.1 0-.2-.1-.3v-.1C11.4 3.1 10.1 2 8.5 2H4c-.5 0-1 .4-1 1v10c0 .5.4 1 1 1h5c2.2 0 4-1.8 4-4 0-1.2-.5-2.3-1.3-3zM6 5h2c.6 0 1 .4 1 1s-.4 1-1 1H6V5zm3 6H6V9h3c.6 0 1 .4 1 1s-.4 1-1 1z"];
  init_define_process();
  var book_default = ["M2 1v14c0 .55.45 1 1 1h1V0H3c-.55 0-1 .45-1 1zm11-1h-1v7l-2-2-2 2V0H5v16h8c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var bookmark_default = ["M11.2.01h-.15C11.03.01 11.02 0 11 0H5c-.02 0-.03.01-.05.01H4.8c-.44 0-.8.37-.8.82v14.75c0 .45.25.56.57.24l2.87-2.94c.31-.32.82-.32 1.13 0l2.87 2.94c.31.32.57.21.57-.24V.83C12 .38 11.64.01 11.2.01z"];
  init_define_process();
  var box_default = ["M6 10h4c.55 0 1-.45 1-1s-.45-1-1-1H6c-.55 0-1 .45-1 1s.45 1 1 1zm9.93-4.37v-.02L13.94.63C13.78.26 13.42 0 13 0H3c-.42 0-.78.26-.93.63L.08 5.61l-.01.02C.03 5.74 0 5.87 0 6v9c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V6c0-.13-.03-.26-.07-.37zM9 2h3.32l1.2 3H9V2zM3.68 2H7v3H2.48l1.2-3zM14 14H2V7h12v7z"];
  init_define_process();
  var briefcase_default = ["M15 3.98h-3v-2c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1v2H1c-.55 0-1 .45-1 1v4h3v-1h2v1h6v-1h2v1h3v-4c0-.55-.45-1-1-1zm-5 0H6v-1h4v1zm3 7h-2v-1H5v1H3v-1H0v4c0 .55.45 1 1 1h14c.55 0 1-.45 1-1v-4h-3v1z"];
  init_define_process();
  var bring_data_default = ["M14 14a1 1 0 010 2H2a1 1 0 010-2h12zM7.995 3.005c.55 0 1 .45 1 .999v5.584l1.29-1.288a1.002 1.002 0 011.42 1.419l-3 2.996a1.015 1.015 0 01-1.42 0l-3-2.997A1.002 1.002 0 015.705 8.3l1.29 1.29V4.013c0-.55.45-1.009 1-1.009zM14 0a1 1 0 110 2 1 1 0 010-2zm-3 0a1 1 0 110 2 1 1 0 010-2zM8 0a1 1 0 110 2 1 1 0 010-2zM5 0a1 1 0 110 2 1 1 0 010-2zM2 0a1 1 0 110 2 1 1 0 010-2z"];
  init_define_process();
  var bug_default = ["M5 3a3 3 0 016 0 5.022 5.022 0 011.425 1.67L13 4.382V3a1 1 0 112 0v2a1 1 0 01-.553.894l-1.46.731c.008.124.013.249.013.375v1h2a1 1 0 110 2h-2a5 5 0 01-.21 1.439l1.581.633A1 1 0 0115 13v2a1 1 0 11-2 0v-1.323l-1.167-.467A4.99 4.99 0 018 15a4.99 4.99 0 01-3.833-1.79L3 13.677V15a1 1 0 11-2 0v-2a1 1 0 01.629-.928l1.581-.633A5 5 0 013 10H1a1 1 0 110-2h2V7c0-.126.005-.251.014-.375l-1.461-.73A1 1 0 011 5V3a1 1 0 012 0v1.382l.575.288A5.023 5.023 0 015 3zm0 6v1a3 3 0 106 0V7a3 3 0 00-6 0v2z"];
  init_define_process();
  var buggy_default = ["M13.928.629A1 1 0 0012.89.006l-9 1a1 1 0 00-.747.48L.431 6.005A.5.5 0 000 6.5v3a.5.5 0 00.5.5h2.798c.341 0 .672.116.938.329l1.952 1.561A.5.5 0 006.5 12H10a.5.5 0 00.4-.2l.9-1.2a1.5 1.5 0 011.2-.6h3a.5.5 0 00.5-.5v-4a.5.5 0 00-.308-.462L13.928.628zM12.36 2.094l-.006-.016-3.166.352 1.121 3.083 2.052-3.419zm.467 1.166l-1.649 2.748 2.51-.594-.861-2.154zM9.603 6.496L8.166 2.543l-3.563.396L2.766 6H3.5a.5.5 0 01.367.16L6.218 8.7h1.914l1.452-2.177a.5.5 0 01.019-.027zM2.5 16a2.5 2.5 0 100-5 2.5 2.5 0 000 5zm11 0a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"];
  init_define_process();
  var build_default = ["M15.39 12.41L7.7 6l1.07-1.1c.34-.34-.12-.63.12-1.26.88-2.17 3.41-2.35 3.41-2.35s.36-.37.71-.72C9.74-.81 7.53.53 6.54 1.4L3.12 4.9l-.71.72c-.39.4-.39 1.05 0 1.45l-.7.72c-.39-.4-1.02-.4-1.41 0s-.39 1.05 0 1.45l1.41 1.45c.39.4 1.02.4 1.41 0s.39-1.05 0-1.45l.71-.72c.39.4 1.02.4 1.41 0l.8-.82 6.39 7.67c.82.82 2.14.82 2.96 0 .81-.82.81-2.15 0-2.96z"];
  init_define_process();
  var calculator_default = ["M13 0H3c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zM6 14H4v-2h2v2zm0-3H4V9h2v2zm0-3H4V6h2v2zm3 6H7v-2h2v2zm0-3H7V9h2v2zm0-3H7V6h2v2zm3 6h-2V9h2v5zm0-6h-2V6h2v2zm0-3H4V2h8v3z"];
  init_define_process();
  var calendar_default = ["M11 3c.6 0 1-.5 1-1V1c0-.6-.4-1-1-1s-1 .4-1 1v1c0 .5.4 1 1 1zm3-2h-1v1c0 1.1-.9 2-2 2s-2-.9-2-2V1H6v1c0 1.1-.9 2-2 2s-2-.9-2-2V1H1c-.6 0-1 .5-1 1v12c0 .6.4 1 1 1h13c.6 0 1-.4 1-1V2c0-.6-.5-1-1-1zM5 13H2v-3h3v3zm0-4H2V6h3v3zm4 4H6v-3h3v3zm0-4H6V6h3v3zm4 4h-3v-3h3v3zm0-4h-3V6h3v3zM4 3c.6 0 1-.5 1-1V1c0-.6-.4-1-1-1S3 .4 3 1v1c0 .5.4 1 1 1z"];
  init_define_process();
  var camera_default = ["M15 3h-2.59L10.7 1.29A.956.956 0 0010 1H6c-.28 0-.53.11-.71.29L3.59 3H1c-.55 0-1 .45-1 1v7c0 .55.45 1 1 1h2.56c1.1 1.22 2.67 2 4.44 2s3.34-.78 4.44-2H15c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1zM3 6H1V5h2v1zm5 6c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"];
  init_define_process();
  var caret_down_default = ["M12 6.5c0-.28-.22-.5-.5-.5h-7a.495.495 0 00-.37.83l3.5 4c.09.1.22.17.37.17s.28-.07.37-.17l3.5-4c.08-.09.13-.2.13-.33z"];
  init_define_process();
  var caret_left_default = ["M9.5 4c-.13 0-.24.05-.33.13l-4 3.5c-.1.09-.17.22-.17.37s.07.28.17.37l4 3.5a.495.495 0 00.83-.37v-7c0-.28-.22-.5-.5-.5z"];
  init_define_process();
  var caret_right_default = ["M11 8c0-.15-.07-.28-.17-.37l-4-3.5A.495.495 0 006 4.5v7a.495.495 0 00.83.37l4-3.5c.1-.09.17-.22.17-.37z"];
  init_define_process();
  var caret_up_default = ["M11.87 9.17s.01 0 0 0l-3.5-4C8.28 5.07 8.15 5 8 5s-.28.07-.37.17l-3.5 4a.495.495 0 00.37.83h7a.495.495 0 00.37-.83z"];
  init_define_process();
  var cargo_ship_default = ["M10 1h3a1 1 0 011 1v2h-4V1zM2.25 4a.25.25 0 00-.25.25V9H.883a.5.5 0 00-.429.757l1.072 1.787c.207.344.477.638.791.87A9.76 9.76 0 011 12.5a.5.5 0 000 1c2.067 0 3.414-.543 4.161-.917.55.373 1.505.917 2.839.917 1.32 0 2.27-.533 2.822-.905l.004.002c.196.105.48.24.856.374.75.268 1.857.529 3.318.529a.5.5 0 000-1c-.326 0-.63-.014-.916-.039.47-.328.848-.79 1.07-1.347l.572-1.428A.5.5 0 0015.26 9H4V4.25A.25.25 0 003.75 4h-1.5zm2.714 9.56a.5.5 0 01.527.033c.455.325 1.277.907 2.509.907s2.054-.582 2.51-.907a.5.5 0 01.579-.001l.006.004.036.023c.034.022.09.055.168.097.154.082.394.197.72.313.649.232 1.642.471 2.981.471a.5.5 0 010 1c-1.46 0-2.568-.261-3.318-.53a6.316 6.316 0 01-.856-.373l-.004-.002c-.552.372-1.502.905-2.822.905-1.334 0-2.289-.544-2.839-.917-.747.374-2.094.917-4.161.917a.5.5 0 010-1c2.129 0 3.384-.63 3.964-.94zM14 5h-4v3h3a1 1 0 001-1V5zM5 2a1 1 0 011-1h3v3H5V2zm4 3H5v2a1 1 0 001 1h3V5z"];
  init_define_process();
  var cell_tower_default = ["M8.97 6.76c-.01-.05-.04-.08-.06-.13-.02-.05-.03-.1-.05-.15.08-.14.14-.3.14-.48 0-.55-.45-1-1-1s-1 .45-1 1c0 .18.06.34.14.48-.03.05-.03.1-.05.15-.02.05-.05.08-.06.13l-2 8c-.13.54.19 1.08.73 1.21a.995.995 0 001.21-.73L7.53 13h.94l.56 2.24a1 1 0 001.94-.48l-2-8zM3.72 1.7C4.1 1.3 4.09.67 3.7.28S2.67-.09 2.28.3c-3.05 3.12-3.05 8.28 0 11.4a.996.996 0 101.43-1.39c-2.28-2.35-2.28-6.27.01-8.61zM11.6 3.2c-.44-.33-1.07-.24-1.4.2-.33.44-.24 1.07.2 1.4.43.32.53 1.96-.04 2.43-.42.35-.48.98-.13 1.41.35.42.98.48 1.41.13 1.59-1.33 1.39-4.5-.04-5.57z", "M13.72.3c-.39-.4-1.02-.4-1.41-.02s-.41 1.02-.03 1.42c2.29 2.34 2.29 6.26 0 8.6-.39.39-.38 1.03.02 1.41s1.03.38 1.41-.02c3.05-3.11 3.05-8.27.01-11.39zM5.4 7.23c-.57-.47-.47-2.11-.04-2.43.44-.33.53-.96.2-1.4s-.96-.53-1.4-.2c-1.44 1.07-1.63 4.24-.04 5.57.42.35 1.05.3 1.41-.13.35-.42.29-1.06-.13-1.41z"];
  init_define_process();
  var changes_default = ["M8.29 7.71l3 3c.18.18.43.29.71.29s.53-.11.71-.29l3-3a1.003 1.003 0 00-1.42-1.42L13 7.59V1c0-.55-.45-1-1-1s-1 .45-1 1v6.59l-1.29-1.3a1.003 1.003 0 00-1.42 1.42zM14.5 13h-13c-.83 0-1.5.67-1.5 1.5S.67 16 1.5 16h13c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5zM1 5c.28 0 .53-.11.71-.29L3 3.41V10c0 .55.45 1 1 1s1-.45 1-1V3.41L6.29 4.7c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-3-3C4.53.11 4.28 0 4 0s-.53.11-.71.29l-3 3A1.003 1.003 0 001 5z"];
  init_define_process();
  var chart_default = ["M0 15c0 .55.45 1 1 1h2c.55 0 1-.45 1-1V9.4L0 11v4zm6-5.5V15c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-5l-1 1-3-1.5zM13 7l-1 1v7c0 .55.45 1 1 1h2c.55 0 1-.45 1-1V7.88c-.26.07-.58.12-1 .12-1.96 0-2-1-2-1zm2-6h-3c-.55 0-1 .45-1 1s.45 1 1 1h.59L8.8 6.78 5.45 5.11v.01C5.31 5.05 5.16 5 5 5s-.31.05-.44.11V5.1l-4 2v.01C.23 7.28 0 7.61 0 8c0 .55.45 1 1 1 .16 0 .31-.05.44-.11v.01L5 7.12 8.55 8.9v-.01c.14.06.29.11.45.11.28 0 .53-.11.71-.29L14 4.41V5c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1z"];
  init_define_process();
  var chat_default = ["M6 10c-1.1 0-2-.9-2-2V3H1c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1v2a1.003 1.003 0 001.71.71L5.41 13H10c.55 0 1-.45 1-1v-1.17l-.83-.83H6zm9-10H6c-.55 0-1 .45-1 1v7c0 .55.45 1 1 1h4.59l2.71 2.71c.17.18.42.29.7.29.55 0 1-.45 1-1V9c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var chevron_backward_default = ["M7.41 8l3.29-3.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L6 6.59V4c0-.55-.45-1-1-1s-1 .45-1 1v8c0 .55.45 1 1 1s1-.45 1-1V9.41l3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L7.41 8z"];
  init_define_process();
  var chevron_down_default = ["M12 5c-.28 0-.53.11-.71.29L8 8.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42l4 4c.18.18.43.29.71.29s.53-.11.71-.29l4-4A1.003 1.003 0 0012 5z"];
  init_define_process();
  var chevron_forward_default = ["M10 3c-.55 0-1 .45-1 1v2.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42L7.59 8 4.3 11.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L9 9.41V12c0 .55.45 1 1 1s1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var chevron_left_default = ["M7.41 8l3.29-3.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-4 4C5.11 7.47 5 7.72 5 8c0 .28.11.53.29.71l4 4a1.003 1.003 0 001.42-1.42L7.41 8z"];
  init_define_process();
  var chevron_right_default = ["M10.71 7.29l-4-4a1.003 1.003 0 00-1.42 1.42L8.59 8 5.3 11.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l4-4c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71z"];
  init_define_process();
  var chevron_up_default = ["M12.71 9.29l-4-4C8.53 5.11 8.28 5 8 5s-.53.11-.71.29l-4 4a1.003 1.003 0 001.42 1.42L8 7.41l3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71z"];
  init_define_process();
  var circle_default = ["M8 0C3.6 0 0 3.6 0 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zm0 14c-3.3 0-6-2.7-6-6s2.7-6 6-6 6 2.7 6 6-2.7 6-6 6z"];
  init_define_process();
  var circle_arrow_down_default = ["M11 7c-.28 0-.53.11-.71.29L9 8.59V5c0-.55-.45-1-1-1s-1 .45-1 1v3.59l-1.29-1.3a1.003 1.003 0 00-1.42 1.42l3 3c.18.18.43.29.71.29s.53-.11.71-.29l3-3A1.003 1.003 0 0011 7zM8 0C3.58 0 0 3.58 0 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"];
  init_define_process();
  var circle_arrow_left_default = ["M11 7H7.41L8.7 5.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-3 3C4.11 7.47 4 7.72 4 8c0 .28.11.53.29.71l3 3a1.003 1.003 0 001.42-1.42L7.41 9H11c.55 0 1-.45 1-1s-.45-1-1-1zM8 0C3.58 0 0 3.58 0 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"];
  init_define_process();
  var circle_arrow_right_default = ["M8.71 4.29a1.003 1.003 0 00-1.42 1.42L8.59 7H5c-.55 0-1 .45-1 1s.45 1 1 1h3.59L7.3 10.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71l-3-3zM8 0C3.58 0 0 3.58 0 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"];
  init_define_process();
  var circle_arrow_up_default = ["M8.71 4.29C8.53 4.11 8.28 4 8 4s-.53.11-.71.29l-3 3a1.003 1.003 0 001.42 1.42L7 7.41V11c0 .55.45 1 1 1s1-.45 1-1V7.41l1.29 1.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-3-3zM8 0C3.58 0 0 3.58 0 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"];
  init_define_process();
  var citation_default = ["M15.02 5c0-1.66-1.34-3-3-3s-3 1.34-3 3a2.996 2.996 0 003.6 2.94C12.1 9.76 11.14 11 10.02 11c-.55 0-1 .45-1 1s.45 1 1 1c2.76 0 5-3.13 5-7 0-.2-.02-.39-.04-.58.01-.14.04-.28.04-.42zm-11-3c-1.66 0-3 1.34-3 3a2.996 2.996 0 003.6 2.94C4.1 9.76 3.14 11 2.02 11c-.55 0-1 .45-1 1s.45 1 1 1c2.76 0 5-3.13 5-7 0-.2-.02-.39-.04-.58.01-.14.04-.28.04-.42 0-1.66-1.35-3-3-3z"];
  init_define_process();
  var clean_default = ["M12 8l-1.2 2.796-2.8 1.2 2.8 1.197L12 16l1.2-2.807L16 12l-2.8-1.204zM5 0L3.5 3.5 0 4.995 3.5 6.5 5 10l1.5-3.5L10 5 6.5 3.5z"];
  init_define_process();
  var clip_default = ["M0 1a1 1 0 011-1h4a1 1 0 010 2H2v3a1 1 0 01-2 0V1zm1 15a1 1 0 01-1-1v-4a1 1 0 112 0v3h3a1 1 0 110 2H1zm14 0a1 1 0 001-1v-4a1 1 0 10-2 0v3h-3a1 1 0 100 2h4zm0-16a1 1 0 011 1v4a1 1 0 11-2 0V2h-3a1 1 0 110-2h4zM8 11a3 3 0 100-6 3 3 0 000 6z"];
  init_define_process();
  var clipboard_default = ["M11 2c0-.55-.45-1-1-1h.22C9.88.4 9.24 0 8.5 0S7.12.4 6.78 1H7c-.55 0-1 .45-1 1v1h5V2zm2 0h-1v2H5V2H4c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h9c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1z"];
  init_define_process();
  var cloud_default = ["M12 6c-.03 0-.07 0-.1.01A5 5 0 002 7c0 .11.01.22.02.33A3.51 3.51 0 000 10.5C0 12.43 1.57 14 3.5 14H12c2.21 0 4-1.79 4-4s-1.79-4-4-4z"];
  init_define_process();
  var cloud_download_default = ["M11 11c-.28 0-.53.11-.71.29L9 12.59V8c0-.55-.45-1-1-1s-1 .45-1 1v4.59L5.71 11.3A.965.965 0 005 11a1.003 1.003 0 00-.71 1.71l3 3c.18.18.43.29.71.29s.53-.11.71-.29l3-3A1.003 1.003 0 0011 11zm1-7c-.03 0-.07 0-.1.01A5 5 0 002 5c0 .11.01.22.02.33A3.51 3.51 0 000 8.5c0 1.41.84 2.61 2.03 3.17C2.2 10.17 3.46 9 5 9c.06 0 .13.02.19.02C5.07 8.7 5 8.36 5 8c0-1.66 1.34-3 3-3s3 1.34 3 3c0 .36-.07.7-.19 1.02.06 0 .13-.02.19-.02 1.48 0 2.7 1.07 2.95 2.47A3.964 3.964 0 0016 8c0-2.21-1.79-4-4-4z"];
  init_define_process();
  var cloud_upload_default = ["M8.71 7.29C8.53 7.11 8.28 7 8 7s-.53.11-.71.29l-3 3a1.003 1.003 0 001.42 1.42L7 10.41V15c0 .55.45 1 1 1s1-.45 1-1v-4.59l1.29 1.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-3-3zM12 4c-.03 0-.07 0-.1.01A5 5 0 002 5c0 .11.01.22.02.33a3.495 3.495 0 00.07 6.37c-.05-.23-.09-.46-.09-.7 0-.83.34-1.58.88-2.12l3-3a2.993 2.993 0 014.24 0l3 3c.54.54.88 1.29.88 2.12 0 .16-.02.32-.05.47C15.17 10.78 16 9.5 16 8c0-2.21-1.79-4-4-4z"];
  init_define_process();
  var code_default = ["M15.71 7.29l-3-3a1.003 1.003 0 00-1.42 1.42L13.59 8l-2.29 2.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71zM5 5a1.003 1.003 0 00-1.71-.71l-3 3C.11 7.47 0 7.72 0 8c0 .28.11.53.29.71l3 3a1.003 1.003 0 001.42-1.42L2.41 8 4.7 5.71c.19-.18.3-.43.3-.71zm4-3c-.48 0-.87.35-.96.81l-2 10c-.01.06-.04.12-.04.19 0 .55.45 1 1 1 .48 0 .87-.35.96-.81l2-10c.01-.06.04-.12.04-.19 0-.55-.45-1-1-1z"];
  init_define_process();
  var code_block_default = ["M15 3h-2V2c0-.55-.45-1-1-1h-2c-.55 0-1 .45-1 1v1H7V2c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v1H1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1zm-8.29 8.29a1.003 1.003 0 01-1.42 1.42l-3-3C2.11 9.53 2 9.28 2 9s.11-.53.29-.71l3-3a1.003 1.003 0 011.42 1.42L4.41 9l2.3 2.29zm7-1.58l-3 3a1.003 1.003 0 01-1.42-1.42L11.59 9l-2.3-2.29a1.003 1.003 0 011.42-1.42l3 3c.18.18.29.43.29.71s-.11.53-.29.71z"];
  init_define_process();
  var cog_default = ["M15.19 6.39h-1.85c-.11-.37-.27-.71-.45-1.04l1.36-1.36c.31-.31.31-.82 0-1.13l-1.13-1.13a.803.803 0 00-1.13 0l-1.36 1.36c-.33-.17-.67-.33-1.04-.44V.79c0-.44-.36-.8-.8-.8h-1.6c-.44 0-.8.36-.8.8v1.86c-.39.12-.75.28-1.1.47l-1.3-1.3c-.3-.3-.79-.3-1.09 0L1.82 2.91c-.3.3-.3.79 0 1.09l1.3 1.3c-.2.34-.36.7-.48 1.09H.79c-.44 0-.8.36-.8.8v1.6c0 .44.36.8.8.8h1.85c.11.37.27.71.45 1.04l-1.36 1.36c-.31.31-.31.82 0 1.13l1.13 1.13c.31.31.82.31 1.13 0l1.36-1.36c.33.18.67.33 1.04.44v1.86c0 .44.36.8.8.8h1.6c.44 0 .8-.36.8-.8v-1.86c.39-.12.75-.28 1.1-.47l1.3 1.3c.3.3.79.3 1.09 0l1.09-1.09c.3-.3.3-.79 0-1.09l-1.3-1.3c.19-.35.36-.71.48-1.1h1.85c.44 0 .8-.36.8-.8v-1.6a.816.816 0 00-.81-.79zm-7.2 4.6c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"];
  init_define_process();
  var collapse_all_default = ["M7.29 6.71c.18.18.43.29.71.29s.53-.11.71-.29l4-4a1.003 1.003 0 00-1.42-1.42L8 4.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42l4 4zm1.42 2.58C8.53 9.11 8.28 9 8 9s-.53.11-.71.29l-4 4a1.003 1.003 0 001.42 1.42L8 11.41l3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-4-4z"];
  init_define_process();
  var color_fill_default = ["M3.093 7c.017-.05.036-.1.058-.15.106-.248.225-.397.263-.436L7 2.828 11.172 7H3.093zM6.5 13c1 0 2.5-1 3-1.5l3.086-3.086L14 7l-1.414-1.414-4.172-4.172L7 0 5.586 1.414 2 5c-.5.5-1 1.5-1 2.5s.5 2 1 2.5l2 2c.5.5 1.5 1 2.5 1zm7-4l1.125 1.667c.238.353.375.666.375 1 0 .666-.375 1.333-1.5 1.333s-1.5-.667-1.5-1.333c0-.334.137-.647.375-1L13.5 9zM0 15a1 1 0 011-1h14a1 1 0 110 2H1a1 1 0 01-1-1z"];
  init_define_process();
  var column_layout_default = ["M15 1H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zM4 13H2V3h2v10zm3 0H5V3h2v10zm7 0H8V3h6v10z"];
  init_define_process();
  var comment_default = ["M14 1H1c-.55 0-1 .45-1 1v9c0 .55.45 1 1 1h2v3a1.003 1.003 0 001.71.71L8.41 12H14c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zM3.5 8C2.67 8 2 7.33 2 6.5S2.67 5 3.5 5 5 5.67 5 6.5 4.33 8 3.5 8zm4 0C6.67 8 6 7.33 6 6.5S6.67 5 7.5 5 9 5.67 9 6.5 8.33 8 7.5 8zm4 0c-.83 0-1.5-.67-1.5-1.5S10.67 5 11.5 5s1.5.67 1.5 1.5S12.33 8 11.5 8z"];
  init_define_process();
  var comparison_default = ["M7.99-.01c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1s1-.45 1-1v-14c0-.55-.45-1-1-1zm-3 3h-4c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-2c0-.55-.45-1-1-1zm10 0h-4c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-2c0-.55-.45-1-1-1zm0 3h-4v-2h4v2zm0 3h-4c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-2c0-.55-.45-1-1-1zm0 3h-4v-2h4v2zm-10-3h-4c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-2c0-.55-.45-1-1-1z"];
  init_define_process();
  var compass_default = ["M12 8c0 .14-.03.27-.08.39l-3 6.99c-.15.37-.51.62-.92.62s-.77-.25-.92-.61l-3-6.99a1.006 1.006 0 010-.79l3-6.99C7.23.25 7.59 0 8 0s.77.25.92.61l3 6.99c.05.13.08.26.08.4zM8 3.54L6.09 8h3.82L8 3.54z"];
  init_define_process();
  var compressed_default = ["M15.93 5.63v-.02L13.94.63C13.78.26 13.42 0 13 0H3c-.42 0-.78.26-.93.63L.08 5.61l-.01.02C.03 5.74 0 5.87 0 6v9c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V6c0-.13-.03-.26-.07-.37zM9 2h3.32l1.2 3H9V2zM3.68 2H7v3H2.48l1.2-3zM14 14H2V7h5v2.59l-1.29-1.3a1.003 1.003 0 00-1.42 1.42l3 3c.18.18.43.29.71.29s.53-.11.71-.29l3-3a1.003 1.003 0 00-1.42-1.42L9 9.59V7h5v7z"];
  init_define_process();
  var confirm_default = ["M8.7 4.29a.965.965 0 00-.71-.3 1.003 1.003 0 00-.71 1.71l2 2c.18.18.43.29.71.29s.53-.11.71-.29l5-5a1.003 1.003 0 00-1.42-1.42l-4.29 4.3L8.7 4.29zm5.22 3.01c.03.23.07.45.07.69 0 3.31-2.69 6-6 6s-6-2.69-6-6 2.69-6 6-6c.81 0 1.59.17 2.3.46l1.5-1.5A7.998 7.998 0 00-.01 7.99c0 4.42 3.58 8 8 8s8-3.58 8-8c0-.83-.13-1.64-.36-2.39l-1.71 1.7z"];
  init_define_process();
  var console_default = ["M15 15H1c-.55 0-1-.45-1-1V2c0-.55.45-1 1-1h14c.55 0 1 .45 1 1v12c0 .55-.45 1-1 1zM14 5H2v8h12V5zM4 6c.28 0 .53.11.71.29l2 2c.18.18.29.43.29.71s-.11.53-.29.71l-2 2a1.003 1.003 0 01-1.42-1.42L4.59 9l-1.3-1.29A1.003 1.003 0 014 6zm5 4h3c.55 0 1 .45 1 1s-.45 1-1 1H9c-.55 0-1-.45-1-1s.45-1 1-1z"];
  init_define_process();
  var contrast_default = ["M15.2 6.4h-1.44c-.13-.47-.32-.92-.56-1.34L14.26 4c.31-.31.31-.82 0-1.13l-1.13-1.13a.803.803 0 00-1.13 0L10.94 2.8c-.42-.24-.86-.42-1.34-.56V.8c0-.44-.36-.8-.8-.8H7.2c-.44 0-.8.36-.8.8v1.44c-.5.14-.96.34-1.4.59l-1-1c-.3-.3-.79-.3-1.09 0L1.83 2.91c-.3.3-.3.79 0 1.09l1 1c-.25.44-.45.9-.59 1.4H.8c-.44 0-.8.36-.8.8v1.6c0 .44.36.8.8.8h1.44c.13.47.32.92.56 1.34L1.74 12c-.31.31-.31.82 0 1.13l1.13 1.13c.31.31.82.31 1.13 0l1.06-1.06c.42.24.86.42 1.34.56v1.44c0 .44.36.8.8.8h1.6c.44 0 .8-.36.8-.8v-1.44c.5-.14.96-.33 1.4-.59l1 1c.3.3.79.3 1.09 0l1.09-1.09c.3-.3.3-.79 0-1.09l-1-1c.25-.43.45-.9.59-1.4h1.44c.44 0 .8-.36.8-.8V7.2a.818.818 0 00-.81-.8zM8 12c-2.21 0-4-1.79-4-4s1.79-4 4-4v8z"];
  init_define_process();
  var control_default = ["M13 8H8v5h5V8zm0-5H8v4h5V3zm2-3H1C.45 0 0 .45 0 1v14c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 14H2V2h12v12zM7 3H3v10h4V3z"];
  init_define_process();
  var credit_card_default = ["M14.99 2.95h-14c-.55 0-1 .45-1 1v1h16v-1c0-.55-.45-1-1-1zm-15 10c0 .55.45 1 1 1h14c.55 0 1-.45 1-1v-6h-16v6zm5.5-2h5c.28 0 .5.22.5.5s-.22.5-.5.5h-5c-.28 0-.5-.22-.5-.5s.23-.5.5-.5zm-3 0h1c.28 0 .5.22.5.5s-.22.5-.5.5h-1c-.28 0-.5-.22-.5-.5s.23-.5.5-.5z"];
  init_define_process();
  var cross_default = ["M9.41 8l3.29-3.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L8 6.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42L6.59 8 3.3 11.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L8 9.41l3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L9.41 8z"];
  init_define_process();
  var cross_circle_default = ["M8 16A8 8 0 108 0a8 8 0 000 16zm3.7-10.29L9.41 8l2.3 2.29A1.003 1.003 0 0111 12c-.28 0-.53-.11-.71-.3L8 9.41l-2.29 2.3A1.003 1.003 0 014 11c0-.28.11-.53.3-.71L6.59 8l-2.3-2.29a1.003 1.003 0 011.42-1.42L8 6.59l2.29-2.3A1.003 1.003 0 0112 5c0 .28-.11.53-.3.71z"];
  init_define_process();
  var crown_default = ["M2 6l3 2 3-4 3 4 3-2-1 6H3L2 6zm6-5a1 1 0 110 2 1 1 0 010-2zM1 3a1 1 0 110 2 1 1 0 010-2zm14 0a1 1 0 110 2 1 1 0 010-2zM3 13h10v2H3v-2z"];
  init_define_process();
  var cube_default = ["M14.194 3.54L8 7.41 1.806 3.54 7.504.283a1 1 0 01.992 0l5.698 3.255zm.75.71a1 1 0 01.056.33v6.84a1 1 0 01-.504.868L8.5 15.714V8.277l6.444-4.027zm-13.888 0L7.5 8.277v7.437l-5.996-3.426A1 1 0 011 11.42V4.58a1 1 0 01.056-.33z"];
  init_define_process();
  var cube_add_default = ["M14 2h1a1 1 0 010 2h-1v1a1 1 0 01-2 0V4h-1a1 1 0 010-2h1V1a1 1 0 012 0v1zM9.136.65a3.001 3.001 0 00.992 5.222c.018.058.038.115.059.172L8 7.41 1.806 3.54 7.504.283a1 1 0 01.992 0l.64.365zM15 7.235v4.184a1 1 0 01-.504.868L8.5 15.714V8.277l2.187-1.367A2.994 2.994 0 0013 8c.768 0 1.47-.289 2-.764zM1.056 4.25L7.5 8.277v7.437l-5.996-3.426A1 1 0 011 11.42V4.58a1 1 0 01.056-.33z"];
  init_define_process();
  var cube_remove_default = ["M10.365 5.933L8 7.41 1.806 3.54 7.504.283a1 1 0 01.992 0l.64.365a3.001 3.001 0 001.228 5.283zM15 6v5.42a1 1 0 01-.504.868L8.5 15.714V8.277L12.143 6H15zM1.056 4.25L7.5 8.277v7.437l-5.996-3.426A1 1 0 011 11.42V4.58a1 1 0 01.056-.33zM11 2h4a1 1 0 010 2h-4a1 1 0 010-2z"];
  init_define_process();
  var curved_range_chart_default = ["M15 12H3.12l1.81-1.39c1.73 1.01 5.53-.03 9.08-2.61l-1.22-1.5C10.3 8.3 7.86 9.37 6.65 9.29L14.3 3.4l-.6-.8-7.83 6.03c-.01-1.07 1.8-3.19 4.47-5.13L9.12 2C5.38 4.7 3.34 8.1 4.25 9.87L2 11.6V3c0-.55-.45-1-1-1s-1 .45-1 1v10c0 .55.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var cut_default = ["M13 2s.71-1.29 0-2L8.66 5.07l1.05 1.32L13 2zm.07 8c-.42 0-.82.09-1.18.26L3.31 0c-.69.71 0 2 0 2l3.68 5.02-2.77 3.24A2.996 2.996 0 000 13c0 1.66 1.34 3 3 3s3-1.34 3-3c0-.46-.11-.89-.29-1.27L8.1 8.54l2.33 3.19c-.18.39-.29.82-.29 1.27 0 1.66 1.31 3 2.93 3S16 14.66 16 13s-1.31-3-2.93-3zM3 14c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm10.07 0c-.54 0-.98-.45-.98-1s.44-1 .98-1 .98.45.98 1-.44 1-.98 1z"];
  init_define_process();
  var cycle_default = ["M13 9a3 3 0 110 6 3 3 0 010-6zM3 9a3 3 0 110 6 3 3 0 010-6zm6.169-5.27l.087.09 1.51 1.746 1.589.549a1 1 0 01.65 1.16l-.032.112a1 1 0 01-1.159.65l-.112-.032-1.843-.636a1 1 0 01-.337-.198l-.092-.093-.959-1.109L7.041 7.5l1.691 1.819a1 1 0 01.26.556L9 10v3a1 1 0 01-1.993.117L7 13l-.001-2.608-2.056-2.211a1 1 0 01-.081-1.264l.082-.1 2.825-3.026a1 1 0 011.4-.061zM13 10.5a1.5 1.5 0 100 3 1.5 1.5 0 000-3zm-10 0a1.5 1.5 0 100 3 1.5 1.5 0 000-3zM11 1a1.5 1.5 0 110 3 1.5 1.5 0 010-3z"];
  init_define_process();
  var dashboard_default = ["M5 4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zM4 7c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm4-2c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm-2 6c0 1.1.9 2 2 2s2-.9 2-2c0-.53-2-5-2-5s-2 4.47-2 5zM8 0C3.58 0 0 3.58 0 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zm4-9c0-.55-.45-1-1-1s-1 .45-1 1 .45 1 1 1 1-.45 1-1zm0 2c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1z"];
  init_define_process();
  var data_connection_default = ["M1 9.52c.889.641 2.308 1.133 4.003 1.354L5 11a5.994 5.994 0 002.664 4.988c-.217.008-.44.012-.664.012-3.215 0-5.846-.85-5.993-1.906L1 14V9.52zM11 6c2.762 0 5 2.238 5 5s-2.238 5-5 5-5-2.238-5-5 2.238-5 5-5zm1 1l-4 5h2.5l-.5 3 4-5h-2.5l.5-3zm1-3.48v1.822a6.002 6.002 0 00-7.9 4.556l-.248-.03c-2.168-.28-3.733-.966-3.845-1.774L1 8V3.52C2.22 4.4 4.44 5 7 5s4.78-.6 6-1.48zM7 0c3.31 0 6 .9 6 2s-2.69 2-6 2c-3.32 0-6-.9-6-2s2.68-2 6-2z"];
  init_define_process();
  var data_lineage_default = ["M1.067 0C.477 0 0 .478 0 1.067V3.2c0 .59.478 1.067 1.067 1.067h2.24a5.342 5.342 0 002.9 3.734 5.337 5.337 0 00-2.9 3.733h-2.24C.477 11.733 0 12.21 0 12.8v2.133C0 15.523.478 16 1.067 16H6.4c.59 0 1.067-.478 1.067-1.067V12.8c0-.59-.478-1.067-1.067-1.067H4.401a4.27 4.27 0 013.92-3.194l.212-.006V9.6c0 .59.478 1.067 1.067 1.067h5.333c.59 0 1.067-.478 1.067-1.067V6.4c0-.59-.478-1.067-1.067-1.067H9.6c-.59 0-1.067.478-1.067 1.067v1.067a4.268 4.268 0 01-4.132-3.2H6.4c.59 0 1.067-.478 1.067-1.067V1.067C7.467.477 6.989 0 6.4 0H1.067z"];
  init_define_process();
  var database_default = ["M8 4c3.31 0 6-.9 6-2s-2.69-2-6-2C4.68 0 2 .9 2 2s2.68 2 6 2zm-6-.48V8c0 1.1 2.69 2 6 2s6-.9 6-2V3.52C12.78 4.4 10.56 5 8 5s-4.78-.6-6-1.48zm0 6V14c0 1.1 2.69 2 6 2s6-.9 6-2V9.52C12.78 10.4 10.56 11 8 11s-4.78-.6-6-1.48z"];
  init_define_process();
  var delete_default = ["M11.99 4.99a1.003 1.003 0 00-1.71-.71l-2.29 2.3L5.7 4.29a.965.965 0 00-.71-.3 1.003 1.003 0 00-.71 1.71l2.29 2.29-2.29 2.29A1.003 1.003 0 005.7 11.7l2.29-2.29 2.29 2.29a1.003 1.003 0 001.42-1.42L9.41 7.99 11.7 5.7c.18-.18.29-.43.29-.71zm-4-5c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.68 6-6 6z"];
  init_define_process();
  var delta_default = ["M8 0L0 16h16L8 0zM7 5l5 10H2L7 5z"];
  init_define_process();
  var derive_column_default = ["M6.08 6.67h-.84c.24-.92.56-1.6.96-2.03.24-.27.48-.4.71-.4.05 0 .08.01.11.04s.04.06.04.1c0 .04-.03.11-.1.21-.06.1-.1.2-.1.29 0 .13.05.24.15.33.1.09.23.14.39.14.17 0 .31-.06.42-.17A.58.58 0 008 4.73c0-.22-.09-.39-.26-.53-.17-.13-.44-.2-.81-.2-.59 0-1.12.16-1.59.48-.48.32-.93.85-1.36 1.59-.15.26-.29.42-.42.49s-.35.11-.64.1l-.19.65h.81l-1.19 4.37c-.2.72-.33 1.16-.4 1.33-.1.24-.26.45-.46.62-.08.07-.18.1-.3.1-.03 0-.06-.01-.08-.03l-.03-.04c0-.02.03-.06.09-.11.06-.06.09-.14.09-.26 0-.13-.05-.23-.14-.32a.6.6 0 00-.4-.13c-.21 0-.38.05-.51.16s-.21.25-.21.4c0 .16.08.3.23.42.16.12.4.18.74.18.53 0 .99-.13 1.4-.39.41-.26.76-.65 1.07-1.19.3-.54.62-1.4.94-2.59l.68-2.53h.82l.2-.63zM15 0H8c-.55 0-1 .45-1 1v2h2V2h5v12H9v-1H7v2c0 .55.45 1 1 1h7c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zM8.3 9.94c.18.52.33.89.46 1.13.13.24.28.4.44.51.17.1.37.16.62.16.24 0 .49-.08.74-.25.33-.21.66-.58 1.01-1.09l-.21-.11c-.23.31-.41.5-.52.57a.44.44 0 01-.26.07c-.12 0-.24-.07-.36-.21-.2-.24-.46-.91-.8-2 .3-.49.55-.81.75-.96.15-.11.3-.16.47-.16.06 0 .17.02.34.06.16.04.31.06.43.06.17 0 .31-.06.43-.17.1-.11.16-.25.16-.43 0-.19-.06-.33-.17-.44-.12-.11-.28-.16-.49-.16-.19 0-.37.04-.54.13-.17.09-.39.27-.65.56-.2.21-.48.58-.87 1.11-.15-.66-.41-1.26-.78-1.81l-2.05.33-.04.21c.15-.03.28-.04.39-.04.2 0 .37.08.5.25.21.26.5 1.03.88 2.33-.29.37-.49.61-.6.72-.18.18-.33.3-.44.36-.09.04-.19.07-.3.07-.09 0-.23-.04-.42-.13a.866.866 0 00-.36-.09c-.2 0-.36.06-.49.18a.59.59 0 00-.19.46c0 .17.06.32.18.43.12.11.28.16.48.16.2 0 .38-.04.55-.11.17-.08.39-.24.65-.49.24-.27.6-.66 1.06-1.21z"];
  init_define_process();
  var desktop_default = ["M15 0H1C.45 0 0 .45 0 1v10c0 .55.45 1 1 1h4.75l-.5 2H4c-.55 0-1 .45-1 1s.45 1 1 1h8c.55 0 1-.45 1-1s-.45-1-1-1h-1.25l-.5-2H15c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 10H2V2h12v8z"];
  init_define_process();
  var diagnosis_default = ["M3.2 1a1 1 0 01.117 1.993L3.2 3H3v3a2 2 0 001.85 1.995L5 8a2 2 0 001.995-1.85L7 6V3h-.2a1 1 0 01-.993-.883L5.8 2a1 1 0 01.883-.993L6.8 1H8a1 1 0 01.993.883L9 2v4a4.002 4.002 0 01-3.007 3.876v.007L6 10a3 3 0 005.995.176L12 10V7.792a2.5 2.5 0 112 0V10a5 5 0 01-10 0c0-.042.003-.084.008-.125A4 4 0 011.005 6.2L1 6V2a1 1 0 01.883-.993L2 1h1.2z"];
  init_define_process();
  var diagram_tree_default = ["M15 8v3h-2V9H9v2H7V9H3v2H1V8a1 1 0 011-1h5V5h2v2h5a1 1 0 011 1zM1 12h2a1 1 0 011 1v2a1 1 0 01-1 1H1a1 1 0 01-1-1v-2a1 1 0 011-1zm12 0h2a1 1 0 011 1v2a1 1 0 01-1 1h-2a1 1 0 01-1-1v-2a1 1 0 011-1zm-6 0h2a1 1 0 011 1v2a1 1 0 01-1 1H7a1 1 0 01-1-1v-2a1 1 0 011-1zM7 0h2a1 1 0 011 1v2a1 1 0 01-1 1H7a1 1 0 01-1-1V1a1 1 0 011-1z"];
  init_define_process();
  var direction_left_default = ["M16 1.99l-16 6 16 6-4-6z"];
  init_define_process();
  var direction_right_default = ["M16 7.99l-16-6 4 6-4 6z"];
  init_define_process();
  var disable_default = ["M7.99-.01c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm-6 8c0-3.31 2.69-6 6-6 1.3 0 2.49.42 3.47 1.12l-8.35 8.35c-.7-.98-1.12-2.17-1.12-3.47zm6 6c-1.3 0-2.49-.42-3.47-1.12l8.35-8.35c.7.98 1.12 2.17 1.12 3.47 0 3.32-2.68 6-6 6z"];
  init_define_process();
  var divide_default = ["M9 5a1 1 0 11-2 0 1 1 0 012 0zM5 7c-.55 0-1 .45-1 1s.45 1 1 1h6c.55 0 1-.45 1-1s-.45-1-1-1H5zm3 5a1 1 0 100-2 1 1 0 000 2z"];
  init_define_process();
  var document_default = ["M9 0H3c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V5L9 0zm3 14H4V2h4v4h4v8z"];
  init_define_process();
  var document_open_default = ["M6 12c0 .55.45 1 1 1s1-.45 1-1V8c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1s.45 1 1 1h1.59L1.3 12.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L6 10.41V12zm4-12H4c-.55 0-1 .45-1 1v4h2V2h4v4h4v8H5.24l-1.8 1.8c.16.12.35.2.56.2h10c.55 0 1-.45 1-1V5l-5-5z"];
  init_define_process();
  var document_share_default = ["M10 14H2V2h4v4h1c0-.83.36-1.55.91-2.09l-.03-.03.9-.9C8.3 2.45 8 1.77 8 1L7 0H1C.45 0 0 .45 0 1v14c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V8.22c-.53.48-1.23.78-2 .78v5zm5-14h-4c-.55 0-1 .45-1 1s.45 1 1 1h1.59l-3.3 3.29a1.003 1.003 0 001.42 1.42L14 3.41V5c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var dollar_default = ["M12.83 9.51c-.1-.3-.25-.58-.45-.84s-.45-.49-.75-.7c-.3-.2-.65-.36-1.05-.48-.16-.04-.43-.11-.8-.2-.35-.09-.73-.18-1.12-.28-.39-.1-.74-.19-1.06-.27-.31-.08-.49-.12-.54-.13-.43-.12-.78-.29-1.05-.52-.27-.23-.4-.55-.4-.95 0-.29.07-.53.21-.72.14-.19.32-.34.54-.46.22-.11.46-.19.72-.24.26-.05.52-.08.77-.08.74 0 1.35.15 1.83.46.48.3.75.83.81 1.56h2.14c0-.6-.13-1.13-.38-1.58-.25-.45-.59-.84-1.02-1.15-.43-.31-.93-.54-1.49-.7-.24-.06-.49-.1-.75-.14V1c0-.55-.45-1-1-1s-1 .45-1 1v1.08c-.23.03-.46.07-.68.13-.54.13-1.02.34-1.44.61-.42.28-.76.63-1.02 1.05-.26.43-.39.93-.39 1.5 0 .3.04.59.13.88.09.29.23.56.44.82.21.26.48.49.83.7.35.21.79.38 1.31.51.85.21 1.56.38 2.14.52.58.13 1.08.28 1.52.42.25.09.48.23.69.44.21.21.32.53.32.97 0 .21-.05.42-.14.63-.09.21-.24.39-.45.55-.21.16-.47.29-.81.39-.33.1-.73.15-1.2.15-.43 0-.84-.05-1.21-.14-.37-.09-.7-.24-.99-.43-.29-.2-.51-.45-.67-.76-.16-.31-.24-.68-.24-1.12H3c.01.71.15 1.32.43 1.84.27.52.64.94 1.1 1.27.46.33.99.58 1.61.74.27.07.56.12.85.16V15c0 .55.45 1 1 1s1-.45 1-1v-1.05c.3-.03.61-.08.9-.15.58-.13 1.1-.34 1.56-.63.46-.29.83-.66 1.11-1.11.28-.45.42-1 .42-1.64 0-.31-.05-.61-.15-.91z"];
  init_define_process();
  var dot_default = ["M8 5a3 3 0 100 6 3 3 0 100-6z"];
  init_define_process();
  var double_caret_horizontal_default = ["M13.71 7.29l-3-3A1.003 1.003 0 009 5v6a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71zM6 4c-.28 0-.53.11-.71.29l-3 3C2.11 7.47 2 7.72 2 8c0 .28.11.53.29.71l3 3A1.003 1.003 0 007 11V5c0-.55-.45-1-1-1z"];
  init_define_process();
  var double_caret_vertical_default = ["M5 7h6a1.003 1.003 0 00.71-1.71l-3-3C8.53 2.11 8.28 2 8 2s-.53.11-.71.29l-3 3A1.003 1.003 0 005 7zm6 2H5a1.003 1.003 0 00-.71 1.71l3 3c.18.18.43.29.71.29s.53-.11.71-.29l3-3A1.003 1.003 0 0011 9z"];
  init_define_process();
  var double_chevron_down_default = ["M7.29 8.71c.18.18.43.29.71.29s.53-.11.71-.29l4-4a1.003 1.003 0 00-1.42-1.42L8 6.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42l4 4zM12 8c-.28 0-.53.11-.71.29L8 11.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42l4 4c.18.18.43.29.71.29s.53-.11.71-.29l4-4A1.003 1.003 0 0012 8z"];
  init_define_process();
  var double_chevron_left_default = ["M4.41 8L7.7 4.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-4 4C2.11 7.47 2 7.72 2 8c0 .28.11.53.29.71l4 4a1.003 1.003 0 001.42-1.42L4.41 8zm5 0l3.29-3.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-4 4C7.11 7.47 7 7.72 7 8c0 .28.11.53.29.71l4 4a1.003 1.003 0 001.42-1.42L9.41 8z"];
  init_define_process();
  var double_chevron_right_default = ["M9 8c0-.28-.11-.53-.29-.71l-4-4a1.003 1.003 0 00-1.42 1.42L6.59 8 3.3 11.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l4-4C8.89 8.53 9 8.28 9 8zm4.71-.71l-4-4a1.003 1.003 0 00-1.42 1.42L11.59 8 8.3 11.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l4-4c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71z"];
  init_define_process();
  var double_chevron_up_default = ["M4 8c.28 0 .53-.11.71-.29L8 4.41l3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-4-4C8.53 2.11 8.28 2 8 2s-.53.11-.71.29l-4 4A1.003 1.003 0 004 8zm4.71-.71C8.53 7.11 8.28 7 8 7s-.53.11-.71.29l-4 4a1.003 1.003 0 001.42 1.42L8 9.41l3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-4-4z"];
  init_define_process();
  var doughnut_chart_default = ["M11.86 7h4.05C15.45 3.39 12.61.52 9 .07v4.07A4 4 0 0111.86 7zM12 8c0 2.21-1.79 4-4 4s-4-1.79-4-4 1.79-4 4-4V0C3.58 0 0 3.58 0 8s3.58 8 8 8 8-3.58 8-8h-4z"];
  init_define_process();
  var download_default = ["M7.99-.01c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zM11.7 9.7l-3 3c-.18.18-.43.29-.71.29s-.53-.11-.71-.29l-3-3A1.003 1.003 0 015.7 8.28l1.29 1.29V3.99c0-.55.45-1 1-1s1 .45 1 1v5.59l1.29-1.29a1.003 1.003 0 011.71.71c0 .27-.11.52-.29.7z"];
  init_define_process();
  var drag_handle_horizontal_default = ["M2 9c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm4 4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm8-2c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0 2c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm-4-4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zM6 5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1z"];
  init_define_process();
  var drag_handle_vertical_default = ["M6 9c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm4-6c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zM6 13c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-8c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm4 8c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 8c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1z"];
  init_define_process();
  var draw_default = ["M14.9 11c-.3 0-.5.1-.7.3l-3 3c-.2.2-.3.4-.3.7 0 .6.5 1 1 1 .3 0 .5-.1.7-.3l3-3c.2-.2.3-.4.3-.7 0-.5-.4-1-1-1zm-1-1v-.2l-1-5c-.1-.3-.3-.6-.6-.7l-11-4-.3.3 5.8 5.8c.2-.1.4-.2.6-.2.8 0 1.5.7 1.5 1.5S8.3 9 7.4 9s-1.5-.7-1.5-1.5c0-.2.1-.4.2-.6L.3 1.1l-.3.3 4 11c.1.3.4.6.7.6l5 1h.2c.3 0 .5-.1.7-.3l3-3c.2-.2.3-.4.3-.7z"];
  init_define_process();
  var drawer_left_default = ["M7 0a1 1 0 011 1v14a1 1 0 01-1 1H1a1 1 0 01-1-1V1a1 1 0 011-1h6zM6 2H2v12h4V2zm2 5h4.59L11.3 5.71A.965.965 0 0111 5a1.003 1.003 0 011.71-.71l3 3c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-3 3a1.003 1.003 0 01-1.42-1.42L12.59 9H8V7z"];
  init_define_process();
  var drawer_left_filled_default = ["M1 0h6a1 1 0 011 1v14a1 1 0 01-1 1H1a1 1 0 01-1-1V1a1 1 0 011-1zm7 7h4.59L11.3 5.71A.965.965 0 0111 5a1.003 1.003 0 011.71-.71l3 3c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-3 3a1.003 1.003 0 01-1.42-1.42L12.59 9H8V7z"];
  init_define_process();
  var drawer_right_default = ["M15 0a1 1 0 011 1v14a1 1 0 01-1 1H9a1 1 0 01-1-1V1a1 1 0 011-1h6zm-1 2h-4v12h4V2zM8 7H3.41L4.7 5.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-3 3C.11 7.47 0 7.72 0 8c0 .28.11.53.29.71l3 3a1.003 1.003 0 001.42-1.42L3.41 9H8V7z"];
  init_define_process();
  var drawer_right_filled_default = ["M9 0h6a1 1 0 011 1v14a1 1 0 01-1 1H9a1 1 0 01-1-1V1a1 1 0 011-1zM8 7H3.41L4.7 5.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-3 3C.11 7.47 0 7.72 0 8c0 .28.11.53.29.71l3 3a1.003 1.003 0 001.42-1.42L3.41 9H8V7z"];
  init_define_process();
  var drive_time_default = ["M15.12 4.76h-1.05l-.76-2.12c-.19-.53-.76-1.08-1.27-1.24 0 0-1.32-.4-4.04-.4-2.72 0-4.04.4-4.04.4-.5.16-1.07.71-1.26 1.24l-.77 2.12H.88c-.48 0-.88.42-.88.94s.4.94.88.94h.38L1 7c-.03.69 0 1.44 0 2v5c0 .66.38 1 1 1s1-.34 1-1v-1h10v1c0 .66.38 1 1 1s1-.34 1-1V9c0-.56-.01-1.37 0-2l-.26-.37h.38c.48 0 .88-.42.88-.93 0-.52-.4-.94-.88-.94zM5 10H3V8h2v2zm8 0h-2V8h2v2zm0-4H3c-.18 0-.06-.82 0-1l.73-1.63C3.79 3.19 3.82 3 4 3h8c.18 0 .21.19.27.37L13 5c.06.18.18 1 0 1z"];
  init_define_process();
  var duplicate_default = ["M15 0H5c-.55 0-1 .45-1 1v2h2V2h8v7h-1v2h2c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-4 4H1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zm-1 10H2V6h8v8z"];
  init_define_process();
  var edit_default = ["M3.25 10.26l2.47 2.47 6.69-6.69-2.46-2.48-6.7 6.7zM.99 14.99l3.86-1.39-2.46-2.44-1.4 3.83zm12.25-14c-.48 0-.92.2-1.24.51l-1.44 1.44 2.47 2.47 1.44-1.44c.32-.32.51-.75.51-1.24.01-.95-.77-1.74-1.74-1.74z"];
  init_define_process();
  var eject_default = ["M4 9h8a1.003 1.003 0 00.71-1.71l-4-4C8.53 3.11 8.28 3 8 3s-.53.11-.71.29l-4 4A1.003 1.003 0 004 9zm8 1H4c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h8c.55 0 1-.45 1-1v-1c0-.55-.45-1-1-1z"];
  init_define_process();
  var emoji_default = ["M8 0a8 8 0 110 16A8 8 0 018 0zm0 1a7 7 0 100 14A7 7 0 008 1zM4 8c.228 2.262 2 4 4 4 1.938 0 3.77-1.738 3.984-3.8L12 8h1c-.128 2.888-2.317 5-5 5a5 5 0 01-4.995-4.783L3 8h1zm2-3a1 1 0 110 2 1 1 0 010-2zm4 0a1 1 0 110 2 1 1 0 010-2z"];
  init_define_process();
  var endorsed_default = ["M15.86 7.5l-.81-1.42V4.5c0-.36-.19-.68-.49-.87l-1.37-.8-.81-1.41c-.19-.31-.51-.49-.86-.49H9.89L8.5.14a.948.948 0 00-1 0l-1.39.8H4.52a1 1 0 00-.86.49l-.8 1.37-1.44.83c-.3.19-.49.51-.49.87v1.65l-.8 1.37c-.08.15-.13.32-.13.49s.05.34.14.49l.8 1.37v1.65c0 .36.19.68.49.87l1.42.81.8 1.37c.19.31.51.49.86.49H6.1l1.39.8c.15.09.32.14.48.14s.34-.05.49-.14l1.39-.8h1.63a1 1 0 00.86-.49l.81-1.41 1.37-.8c.3-.19.49-.51.49-.87V9.93l.81-1.42a.89.89 0 00.04-1.01zm-4.12-.82l-4.01 4.01c-.18.18-.43.29-.71.29s-.53-.11-.71-.29l-2-2c-.18-.19-.3-.44-.3-.71a1.003 1.003 0 011.71-.71l1.3 1.3 3.3-3.3a1.003 1.003 0 011.71.71.95.95 0 01-.29.7z"];
  init_define_process();
  var envelope_default = ["M0 3.06v9.88L4.94 8 0 3.06zM14.94 2H1.06L8 8.94 14.94 2zm-6.41 8.53c-.14.14-.32.22-.53.22s-.39-.08-.53-.22L6 9.06 1.06 14h13.88L10 9.06l-1.47 1.47zM11.06 8L16 12.94V3.06L11.06 8z"];
  init_define_process();
  var equals_default = ["M3 5h10a1 1 0 010 2H3a1 1 0 110-2zm0 4h10a1 1 0 010 2H3a1 1 0 010-2z"];
  init_define_process();
  var eraser_default = ["M8.06 13.91l7.63-7.44c.41-.4.41-1.05 0-1.45L10.86.3c-.41-.4-1.08-.4-1.49 0L.31 9.13c-.41.4-.41 1.05 0 1.45l5.58 5.44h8.12v-.01c.55 0 1-.45 1-1s-.45-1-1-1H7.96l.1-.1zm-2.17.06L1.67 9.85l4.22-4.11 4.22 4.11-4.22 4.12z"];
  init_define_process();
  var error_default = ["M7.99-.01c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm1 13h-2v-2h2v2zm0-3h-2v-7h2v7z"];
  init_define_process();
  var euro_default = ["M6.52 3.18c.51-.27 1.12-.4 1.83-.4.48 0 .91.06 1.27.18.37.12.68.29.96.51.18.14.3.33.44.51l1.53-1.53c-.12-.11-.23-.22-.36-.32a5.61 5.61 0 00-1.74-.83c-.66-.2-1.36-.3-2.1-.3-.99 0-1.88.18-2.66.53-.79.35-1.45.82-2 1.41-.55.58-.96 1.27-1.26 2.06H2c-.55 0-1 .45-1 1s.45 1 1 1h.04c-.01.17-.04.33-.04.5 0 .17.03.33.04.5H2c-.55 0-1 .45-1 1s.45 1 1 1h.43c0 .01 0 .02.01.02a6.2 6.2 0 001.25 2.07 5.77 5.77 0 002 1.4c.78.34 1.67.51 2.66.51.81 0 1.54-.12 2.21-.36.67-.24 1.25-.59 1.75-1.03l.03-.03-1.55-1.33c-.01.01-.02.03-.03.04-.29.3-.63.53-1.02.69-.4.17-.85.25-1.37.25-.71 0-1.32-.13-1.83-.4s-.93-.62-1.25-1.07c-.19-.24-.34-.49-.46-.76H9c.55 0 1-.45 1-1s-.45-1-1-1H4.35c-.01-.17-.03-.33-.03-.5 0-.17.02-.34.03-.5H10c.55 0 1-.45 1-1s-.45-1-1-1H4.83c.13-.27.27-.52.44-.76.32-.44.74-.8 1.25-1.06zM14 8.98v0z"];
  init_define_process();
  var exchange_default = ["M1.99 5.99c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.89-2-2-2zm4.15 1.86a.495.495 0 10.7-.7L5.7 5.99h5.79c.28 0 .5-.22.5-.5s-.22-.5-.5-.5H5.7l1.15-1.15a.495.495 0 10-.7-.7l-2 2c-.1.09-.16.21-.16.35s.06.26.15.35l2 2.01zm7.85-1.86c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.89-2-2-2zM9.85 8.14a.533.533 0 00-.36-.15.495.495 0 00-.35.85l1.15 1.15h-5.8c-.28 0-.5.22-.5.5s.22.5.5.5h5.79l-1.15 1.15a.495.495 0 10.7.7l2-2c.09-.09.15-.22.15-.35s-.06-.26-.15-.35l-1.98-2z"];
  init_define_process();
  var exclude_row_default = ["M0 10a1.003 1.003 0 001.71.71L3 9.41l1.29 1.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L4.41 8 5.7 6.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L3 6.59l-1.29-1.3A1.003 1.003 0 00.29 6.71L1.59 8 .29 9.29C.11 9.47 0 9.72 0 10zm1-7h14c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1zm14 10H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zm-1-7H9c-1.1 0-2 .9-2 2s.9 2 2 2h5c1.1 0 2-.9 2-2s-.9-2-2-2z"];
  init_define_process();
  var expand_all_default = ["M4 7c.28 0 .53-.11.71-.29L8 3.41l3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-4-4C8.53 1.11 8.28 1 8 1s-.53.11-.71.29l-4 4A1.003 1.003 0 004 7zm8 2c-.28 0-.53.11-.71.29L8 12.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42l4 4c.18.18.43.29.71.29s.53-.11.71-.29l4-4A1.003 1.003 0 0012 9z"];
  init_define_process();
  var export_default = ["M4 6c.28 0 .53-.11.71-.29L7 3.41V11c0 .55.45 1 1 1s1-.45 1-1V3.41l2.29 2.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-4-4C8.53.11 8.28 0 8 0s-.53.11-.71.29l-4 4A1.003 1.003 0 004 6zm11 5c-.55 0-1 .45-1 1v2H2v-2c0-.55-.45-1-1-1s-1 .45-1 1v3c0 .55.45 1 1 1h14c.55 0 1-.45 1-1v-3c0-.55-.45-1-1-1z"];
  init_define_process();
  var eye_off_default = ["M16 7.97v-.02-.01-.02-.02a.672.672 0 00-.17-.36c-.49-.63-1.07-1.2-1.65-1.72l-3.16 2.26a2.978 2.978 0 01-2.98 2.9c-.31 0-.6-.06-.88-.15L5.09 12.3c.44.19.9.36 1.37.47.97.23 1.94.24 2.92.05.88-.17 1.74-.54 2.53-.98 1.25-.7 2.39-1.67 3.38-2.75.18-.2.37-.41.53-.62.09-.1.15-.22.17-.36v-.02-.02-.01-.02-.03c.01-.02.01-.03.01-.04zm-.43-4.17c.25-.18.43-.46.43-.8 0-.55-.45-1-1-1-.22 0-.41.08-.57.2l-.01-.01-2.67 1.91c-.69-.38-1.41-.69-2.17-.87a6.8 6.8 0 00-2.91-.05c-.88.18-1.74.54-2.53.99-1.25.7-2.39 1.67-3.38 2.75-.18.2-.37.41-.53.62-.23.29-.23.63-.01.92.51.66 1.11 1.25 1.73 1.79.18.16.38.29.56.44l-2.09 1.5.01.01c-.25.18-.43.46-.43.8 0 .55.45 1 1 1 .22 0 .41-.08.57-.2l.01.01 14-10-.01-.01zm-10.41 5a3.03 3.03 0 01-.11-.8 2.99 2.99 0 012.99-2.98c.62 0 1.19.21 1.66.53L5.16 8.8z"];
  init_define_process();
  var eye_on_default = ["M10.29 6.7c.18.18.43.29.71.29s.53-.11.71-.29l4-4c.17-.18.29-.43.29-.7a1.003 1.003 0 00-1.71-.71L11 4.58 9.71 3.29A.997.997 0 009 3c-.55 0-1 .44-1 1a1 1 0 00.3.7l1.99 2zM16 7.96v-.02-.01-.02-.02a.64.64 0 00-.17-.36c-.3-.4-.65-.76-1-1.12l-1.7 1.7c-.55.55-1.3.88-2.13.88-.06 0-.11-.01-.17-.02C10.42 10.15 9.32 11 8.01 11A3.005 3.005 0 016.4 5.46c-.24-.43-.39-.93-.39-1.46 0-.26.04-.5.1-.74-.7.2-1.37.5-2.01.86-1.26.7-2.4 1.68-3.4 2.77-.18.21-.36.41-.53.63-.22.29-.22.64 0 .93.51.67 1.12 1.27 1.73 1.81 1.33 1.17 2.85 2.15 4.53 2.55.97.23 1.95.24 2.92.05.89-.18 1.74-.54 2.54-.99 1.25-.71 2.4-1.69 3.39-2.78.18-.2.37-.41.54-.63.09-.1.15-.23.17-.37v-.02-.02-.01-.02-.03c.01-.01.01-.02.01-.03zM8.01 9c.48 0 .87-.35.96-.81a.55.55 0 01-.07-.09l-.02.01L7.8 7.03c-.45.1-.79.48-.79.96 0 .56.45 1.01 1 1.01z"];
  init_define_process();
  var eye_open_default = ["M8.002 7.003a1.003 1.003 0 000 2.005 1.003 1.003 0 000-2.005zm7.988.972v-.02-.01-.02-.02a.675.675 0 00-.17-.36c-.509-.673-1.118-1.264-1.737-1.806-1.328-1.173-2.846-2.155-4.523-2.546a6.702 6.702 0 00-2.925-.06c-.889.18-1.738.541-2.546.992C2.84 4.837 1.692 5.81.694 6.902c-.18.211-.36.411-.53.632a.742.742 0 000 .932c.51.672 1.119 1.264 1.738 1.805 1.328 1.173 2.846 2.156 4.523 2.547.968.23 1.947.24 2.925.04.889-.18 1.738-.542 2.546-.993 1.248-.712 2.397-1.684 3.395-2.777.18-.2.37-.411.54-.632.09-.1.149-.23.169-.36v-.02-.02-.01-.02-.03c0-.01-.01-.01-.01-.02zm-7.988 3.038a2.998 2.998 0 01-2.995-3.008 2.998 2.998 0 012.995-3.008 2.998 2.998 0 012.996 3.008 2.998 2.998 0 01-2.996 3.008z"];
  init_define_process();
  var fast_backward_default = ["M14 3c-.24 0-.44.09-.62.23l-.01-.01L9 6.72V4c0-.55-.45-1-1-1-.24 0-.44.09-.62.23v-.01l-5 4 .01.01C2.16 7.41 2 7.68 2 8s.16.59.38.77v.01l5 4 .01-.01c.17.14.37.23.61.23.55 0 1-.45 1-1V9.28l4.38 3.5.01-.01c.17.14.37.23.61.23.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var fast_forward_default = ["M15 8c0-.32-.16-.59-.38-.77l.01-.01-5-4-.01.01A.987.987 0 009 3c-.55 0-1 .45-1 1v2.72l-4.38-3.5v.01A.987.987 0 003 3c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1 .24 0 .44-.09.62-.23l.01.01L8 9.28V12c0 .55.45 1 1 1 .24 0 .44-.09.62-.23l.01.01 5-4-.01-.01c.22-.18.38-.45.38-.77z"];
  init_define_process();
  var feed_default = ["M1.99 11.99c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.89-2-2-2zm1-4c-.55 0-1 .45-1 1s.45 1 1 1c1.66 0 3 1.34 3 3 0 .55.45 1 1 1s1-.45 1-1c0-2.76-2.24-5-5-5zm0-4c-.55 0-1 .45-1 1s.45 1 1 1c3.87 0 7 3.13 7 7 0 .55.45 1 1 1s1-.45 1-1a9 9 0 00-9-9zm0-4c-.55 0-1 .45-1 1s.45 1 1 1c6.08 0 11 4.92 11 11 0 .55.45 1 1 1s1-.45 1-1c0-7.18-5.82-13-13-13z"];
  init_define_process();
  var feed_subscribed_default = ["M3 2c1.06 0 2.08.16 3.06.45.13-.71.52-1.32 1.05-1.76C5.82.25 4.44 0 3 0c-.55 0-1 .45-1 1s.45 1 1 1zM2 12c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm8.32-6.33a.99.99 0 001.4 0l3.98-3.98c.19-.18.3-.42.3-.7 0-.55-.45-.99-1-.99-.28 0-.52.11-.7.29l-3.28 3.28-1.29-1.29a.99.99 0 00-.7-.29 1 1 0 00-1 .99c0 .27.11.52.29.7l2 1.99zm3.73.53l-.93.93-.02-.02c-.17.17-.35.33-.56.45C13.47 9.16 14 11.02 14 13c0 .55.45 1 1 1s1-.45 1-1c0-2.5-.73-4.82-1.95-6.8zM3 8c-.55 0-1 .45-1 1s.45 1 1 1c1.66 0 3 1.34 3 3 0 .55.45 1 1 1s1-.45 1-1c0-2.76-2.24-5-5-5zm5.91-.91l-.03.03-2-2 .03-.03c-.11-.11-.23-.2-.33-.33A8.9 8.9 0 003 4c-.55 0-1 .45-1 1s.45 1 1 1c3.87 0 7 3.13 7 7 0 .55.45 1 1 1s1-.45 1-1c0-1.87-.57-3.61-1.55-5.06-.61-.11-1.13-.42-1.54-.85z"];
  init_define_process();
  var film_default = ["M15 1h-5v2H6V1H1c-.55 0-1 .45-1 1v11c0 .55.45 1 1 1h5v-2h4v2h5c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zM4 13H2v-2h2v2zm0-3H2V8h2v2zm0-3H2V5h2v2zm0-3H2V2h2v2zm6 6H6V5h4v5zm4 3h-2v-2h2v2zm0-3h-2V8h2v2zm0-3h-2V5h2v2zm0-3h-2V2h2v2z"];
  init_define_process();
  var filter_default = ["M13.99.99h-12a1.003 1.003 0 00-.71 1.71l4.71 4.71V14a1.003 1.003 0 001.71.71l2-2c.18-.18.29-.43.29-.71V7.41L14.7 2.7a1.003 1.003 0 00-.71-1.71z"];
  init_define_process();
  var filter_keep_default = ["M15 10c-.28 0-.53.11-.71.29L12 12.59l-1.29-1.29A.965.965 0 0010 11a1.003 1.003 0 00-.71 1.71l2 2c.18.18.43.29.71.29s.53-.11.71-.29l3-3A1.003 1.003 0 0015 10zm-3-8c0-.55-.45-1-1-1H1a1.003 1.003 0 00-.71 1.71L4 6.41V12a1.003 1.003 0 001.71.71l2-2c.18-.18.29-.43.29-.71V6.41l3.71-3.71c.18-.17.29-.42.29-.7z"];
  init_define_process();
  var filter_list_default = ["M9 8c0 .55.45 1 1 1h5c.55 0 1-.45 1-1s-.45-1-1-1h-5c-.55 0-1 .45-1 1zm3-6c0-.55-.45-1-1-1H1a1.003 1.003 0 00-.71 1.71L4 6.41V12a1.003 1.003 0 001.71.71l2-2c.18-.18.29-.43.29-.71V6.41l3.71-3.71c.18-.17.29-.42.29-.7zm3 8h-5c-.55 0-1 .45-1 1s.45 1 1 1h5c.55 0 1-.45 1-1s-.45-1-1-1zm0 3h-5c-.55 0-1 .45-1 1s.45 1 1 1h5c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var filter_open_default = ["M15.707 10.293a1 1 0 010 1.414l-3 3c-.63.63-1.707.184-1.707-.707V8c0-.89 1.077-1.337 1.707-.707l3 3zM12 2c0 .28-.11.53-.29.7L8 6.41V10c0 .28-.11.53-.29.71l-2 2A1.003 1.003 0 014 12V6.41L.29 2.71A1.003 1.003 0 011 1h10c.55 0 1 .45 1 1z"];
  init_define_process();
  var filter_remove_default = ["M12 2c0-.55-.45-1-1-1H1a1.003 1.003 0 00-.71 1.71L4 6.41V12a1.003 1.003 0 001.71.71l2-2c.18-.18.29-.43.29-.71V6.41l3.71-3.71c.18-.17.29-.42.29-.7zm2.41 10l1.29-1.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L13 10.59 11.71 9.3A.965.965 0 0011 9a1.003 1.003 0 00-.71 1.71l1.3 1.29-1.29 1.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l1.29-1.3 1.29 1.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L14.41 12z"];
  init_define_process();
  var flag_default = ["M2.99 2.99c-.55 0-1 .45-1 1v11c0 .55.45 1 1 1s1-.45 1-1v-11c0-.55-.45-1-1-1zm0-3c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm2 3.03v7.23c2.07-2.11 5.92 1.75 9 0V3.02c-3 2.07-6.94-2.03-9 0z"];
  init_define_process();
  var flame_default = ["M9.217 0c0 1.368.368 2.462 1.104 3.282C12.774 5.197 14 7.385 14 9.846c0 2.735-1.472 4.786-4.415 6.154 2.165-2.4 1.84-3.385-.368-6.4-2.342 1.2-1.967 2-1.592 3.6-.786 0-1.5 0-1.875-.4 0 .547.898 2 1.464 3.2-2.943-.82-6.092-5.744-4.988-6.154.736-.273 1.594-.137 2.575.41C3.575 5.333 5.047 1.915 9.217 0z"];
  init_define_process();
  var flash_default = ["M4 8c0-.55-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1h2c.55 0 1-.45 1-1zm4-4c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1S7 .45 7 1v2c0 .55.45 1 1 1zM3.79 5.21a1.003 1.003 0 001.42-1.42l-1.5-1.5a1.003 1.003 0 00-1.42 1.42l1.5 1.5zm.71 5.29c-.28 0-.53.11-.71.29l-1.5 1.5a1.003 1.003 0 001.42 1.42l1.5-1.5a1.003 1.003 0 00-.71-1.71zm7-5c.28 0 .53-.11.71-.29l1.5-1.5a1.003 1.003 0 00-1.42-1.42l-1.5 1.5a1.003 1.003 0 00.71 1.71zm.71 5.29a1.003 1.003 0 00-1.42 1.42l1.5 1.5a1.003 1.003 0 001.42-1.42l-1.5-1.5zM15 7h-2c-.55 0-1 .45-1 1s.45 1 1 1h2c.55 0 1-.45 1-1s-.45-1-1-1zM8 5C6.34 5 5 6.34 5 8s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3zm0 4c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm0 3c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1z"];
  init_define_process();
  var floating_point_default = ["M1 5.326c.274 0 .541-.023.8-.069.259-.046.491-.122.697-.228a1.71 1.71 0 00.537-.412c.153-.167.252-.373.297-.617h1.063v8H2.966V6.354H1V5.326zM12.172 4.01c.55 0 .997.128 1.342.385.352.25.623.572.814.968.198.389.33.818.396 1.287.073.47.11.924.11 1.364 0 .44-.037.895-.11 1.364-.066.47-.198.902-.396 1.298-.19.389-.462.711-.814.968-.345.25-.792.374-1.342.374s-1.001-.125-1.353-.374a2.74 2.74 0 01-.814-.968 4.618 4.618 0 01-.396-1.298 9.795 9.795 0 01-.099-1.364c0-.44.033-.895.099-1.364.073-.47.205-.898.396-1.287.198-.396.47-.719.814-.968.352-.257.803-.385 1.353-.385zm0 6.963c.271 0 .499-.077.682-.231.183-.161.326-.374.429-.638.11-.271.187-.587.231-.946.044-.36.066-.74.066-1.144 0-.403-.022-.781-.066-1.133a3.724 3.724 0 00-.231-.946 1.51 1.51 0 00-.429-.638.995.995 0 00-.682-.242c-.279 0-.51.08-.693.242a1.656 1.656 0 00-.429.638 4.08 4.08 0 00-.22.946c-.044.352-.066.73-.066 1.133s.022.785.066 1.144c.044.36.117.675.22.946.11.264.253.477.429.638.183.154.414.231.693.231zM8.089 10.5H6.5v1.543h1.589V10.5z"];
  init_define_process();
  var floppy_disk_default = ["M15.71 2.29l-2-2A.997.997 0 0013 0h-1v6H4V0H1C.45 0 0 .45 0 1v14c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V3c0-.28-.11-.53-.29-.71zM14 15H2V9c0-.55.45-1 1-1h10c.55 0 1 .45 1 1v6zM11 1H9v4h2V1z"];
  init_define_process();
  var flow_branch_default = ["M10.643 6.595c.22.418.344.894.344 1.399 0 .439-.094.855-.263 1.231l3.265 3.462-.002-1.75a.973.973 0 01.314-.68.99.99 0 011.388.048c.186.2.316.46.3.715l-.009 4.03a.959.959 0 01-.3.68.972.972 0 01-.698.266l-4.053.002a.97.97 0 01-.679-.314 1.031 1.031 0 01.05-1.42.972.972 0 01.698-.266l1.7-.001-3.305-3.35a2.998 2.998 0 01-4.228-1.653H.999a1 1 0 010-2h4.166a2.998 2.998 0 014.06-1.735l3.449-3.268-1.745.002a.979.979 0 01-.631-1.692c.199-.186.459-.316.713-.3l4.025.009c.247.008.493.1.679.3.186.2.274.451.265.7l.002 4.046a.972.972 0 01-.313.68 1.03 1.03 0 01-1.42-.05.973.973 0 01-.266-.7V3.295l-3.34 3.301z"];
  init_define_process();
  var flow_end_default = ["M9.702 7.31c.176.176.293.41.293.684a.976.976 0 01-.283.695c-1.888 1.91-2.892 2.918-3.011 3.027-.179.164-.42.284-.693.284a.995.995 0 01-.997-.985c0-.274.112-.541.292-.72.12-.12.624-.551 1.514-1.293H.98c-.536 0-.975-.47-.975-1.008 0-.537.439-.996.975-.996h5.837c-.895-.752-1.4-1.187-1.514-1.304a1.03 1.03 0 01-.292-.705C5.01 4.45 5.464 4 6 4c.272 0 .52.108.695.294A535.7 535.7 0 009.702 7.31zM13 11.002c-1.657 0-3-1.347-3-3.008a3.004 3.004 0 013-3.007c1.657 0 3 1.346 3 3.007a3.004 3.004 0 01-3 3.008z"];
  init_define_process();
  var flow_linear_default = ["M4.16 9.002H.977C.44 9.002 0 8.532 0 7.994c0-.537.44-.99.978-.99h3.18A3.01 3.01 0 016.995 5a3.01 3.01 0 012.839 2.004h2.98c-.898-.756-1.404-1.193-1.518-1.31a1.03 1.03 0 01-.293-.705c0-.538.454-.989.992-.989.274 0 .521.108.697.294.118.124 1.122 1.13 3.014 3.016a.96.96 0 01.293.684.975.975 0 01-.284.695l-3.018 3.027a.974.974 0 01-.694.284c-.553 0-1-.447-1-.985 0-.274.117-.545.293-.72l1.518-1.293H9.833A3.01 3.01 0 016.996 11 3.01 3.01 0 014.16 9.002z"];
  init_define_process();
  var flow_review_default = ["M5.175 7.004a3.003 3.003 0 012.83-2.001c1.305 0 2.416.835 2.83 2.001h1.985c-.896-.756-1.401-1.193-1.515-1.31a1.03 1.03 0 01-.292-.705c0-.538.453-.989.99-.989a.95.95 0 01.696.294c.117.124 1.12 1.13 3.008 3.016.176.176.293.41.293.684a.976.976 0 01-.283.695l-3.013 3.027a.995.995 0 01-1.691-.702c0-.273.116-.544.292-.72l1.515-1.292h-1.98a3.003 3.003 0 01-2.835 2.016A3.003 3.003 0 015.17 9.002H3.18l1.515 1.292c.176.176.292.447.292.72a.995.995 0 01-1.69.702L.282 8.69A.976.976 0 010 7.994c0-.273.117-.508.293-.684A535.858 535.858 0 003.3 4.294.95.95 0 013.997 4c.537 0 .99.45.99.989 0 .273-.12.528-.292.705-.114.117-.62.554-1.515 1.31h1.995z"];
  init_define_process();
  var flow_review_branch_default = ["M10.392 10.647A3.002 3.002 0 016.16 8.995H3.37l1.338 1.318c.172.178.287.41.282.683-.01.536-.524.995-.99.995-.465 0-.63-.187-.747-.294L.281 8.682A.956.956 0 010 7.994a.971.971 0 01.294-.687l3.01-3.028a.973.973 0 01.697-.27c.536.01.998.485.989 1.021a.971.971 0 01-.295.687L3.37 6.997h2.79a3.002 3.002 0 014.106-1.716l2.416-2.277-1.732.004a.99.99 0 01-.679-.329.978.978 0 01.05-1.378c.199-.186.459-.315.714-.3l4.012.005c.248.009.493.1.68.3.185.2.273.45.264.699L15.99 6.05a.973.973 0 01-.314.679 1.03 1.03 0 01-1.421-.048.971.971 0 01-.265-.699V4.29L11.65 6.602c.219.416.343.89.343 1.394 0 .451-.1.88-.279 1.263L14 11.68l-.004-1.73a.982.982 0 01.323-.68.978.978 0 011.378.049c.187.2.316.46.3.714l-.004 4.011a.983.983 0 01-.3.691.972.972 0 01-.7.265l-4.046-.001a.987.987 0 01-.679-.326 1.017 1.017 0 01.048-1.41.972.972 0 01.699-.265h1.693l-2.315-2.35z"];
  init_define_process();
  var flows_default = ["M13.5 6a2.5 2.5 0 00-2.45 2h-1.3L5.74 4l-.75.75L8.25 8h-3.3a2.5 2.5 0 100 1h3.3l-3.26 3.25.75.75 4.01-4h1.3a2.5 2.5 0 102.45-3z"];
  init_define_process();
  var folder_close_default = ["M-.01 14c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V7h-16v7zm15-10H7.41L5.7 2.3a.965.965 0 00-.71-.3h-4c-.55 0-1 .45-1 1v3h16V5c0-.55-.45-1-1-1z"];
  init_define_process();
  var folder_new_default = ["M10.165 7a3.003 3.003 0 002.827 2 3.003 3.003 0 002.827-2H16v7c0 .55-.45 1-1 1H1.01c-.55 0-1-.45-1-1V7h10.155zM8.76 6H0V3c0-.55.45-1 1-1h1.998c.28 0 .53.11.71.29L5.417 4h2.578c0 .768.29 1.469.765 2zm6.23-3c.55 0 1 .45 1 1s-.45 1-1 1h-.999v1c0 .55-.45 1-1 1-.549 0-.998-.45-.998-1V5h-1c-.55 0-1-.45-1-1s.45-1 1-1h1V2c0-.55.45-1 .999-1 .55 0 1 .45 1 1v1h.999z"];
  init_define_process();
  var folder_open_default = ["M2.06 6.69c.14-.4.5-.69.94-.69h11V5c0-.55-.45-1-1-1H6.41l-1.7-1.71A.997.997 0 004 2H1c-.55 0-1 .45-1 1v9.84l2.05-6.15h.01zM16 8c0-.55-.45-1-1-1H4a.99.99 0 00-.94.69l-2 6c-.04.09-.06.2-.06.31 0 .55.45 1 1 1h11c.44 0 .81-.29.94-.69l2-6c.04-.09.06-.2.06-.31z"];
  init_define_process();
  var folder_shared_default = ["M8.76 5.98c-.47-.53-.77-1.22-.77-1.99h-.58L5.7 2.29a.965.965 0 00-.71-.3h-4c-.55 0-1 .45-1 1v3h8.76l.01-.01zm6.23-2.99h-4c-.55 0-1 .45-1 1s.45 1 1 1h1.59l-3.3 3.3a.99.99 0 00-.29.7 1.003 1.003 0 001.71.71l3.29-3.29V8c0 .55.45 1 1 1s1-.45 1-1V4c0-.56-.45-1.01-1-1.01zm-1.98 7.23l-.9.9-.01-.01c-.54.55-1.28.89-2.11.89-1.66 0-3-1.34-3-3 0-.77.3-1.47.78-2H-.01v7c0 .55.45 1 1 1h14c.55 0 1-.45 1-1v-3.18c-.31.11-.65.18-1 .18-.76-.01-1.45-.31-1.98-.78z"];
  init_define_process();
  var folder_shared_open_default = ["M13.02 10.22l-.9.9-.01-.01c-.54.55-1.28.89-2.11.89-1.66 0-3-1.34-3-3 0-.77.3-1.47.78-2H4a.99.99 0 00-.94.69l-2 6c-.04.09-.06.2-.06.31 0 .55.45 1 1 1h11c.44 0 .81-.29.94-.69l1.11-3.32c-.01 0-.03.01-.05.01-.77 0-1.45-.3-1.98-.78zM2.06 6.69c.14-.4.5-.69.94-.69h5.76l.01-.01C8.3 5.46 8 4.77 8 4H6.41l-1.7-1.71A.997.997 0 004 2H1c-.55 0-1 .45-1 1v9.84l2.05-6.15h.01zM15 3h-4c-.55 0-1 .45-1 1s.45 1 1 1h1.59l-3.3 3.29a1.003 1.003 0 001.42 1.42L14 6.41V8c0 .55.45 1 1 1s1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var follower_default = ["M9.37 12.69c-1.2-.53-1.04-.85-1.08-1.29-.01-.06-.01-.12-.01-.19.41-.37.75-.87.97-1.44 0 0 .01-.03.01-.04.05-.13.09-.26.12-.39.28-.06.44-.36.5-.63.06-.11.19-.39.16-.7-.04-.4-.2-.59-.38-.67v-.07c0-.52-.05-1.26-.14-1.74a2.72 2.72 0 00-.09-.43 3.02 3.02 0 00-1.04-1.51C7.87 3.2 7.15 3 6.5 3c-.64 0-1.36.2-1.87.59-.5.38-.87.92-1.05 1.51-.04.13-.07.27-.09.4-.09.49-.14 1.24-.14 1.75v.06c-.19.07-.36.26-.4.68-.03.31.1.59.16.7.06.28.23.59.51.64.04.14.08.27.13.39 0 .01.01.02.01.02v.01c.22.59.57 1.1.99 1.46 0 .06-.01.12-.01.17-.04.44.08.76-1.12 1.29-1.2.53-3.01 1.1-3.38 1.95C-.13 15.5.02 16 .02 16h12.96s.15-.5-.22-1.36c-.38-.85-2.19-1.42-3.39-1.95zm6.33-10.4l-2-2a1.003 1.003 0 00-1.42 1.42l.3.29H9.99c-.55 0-1 .45-1 1s.45 1 1 1h2.58l-.29.29a1.003 1.003 0 001.42 1.42l2-2c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71z"];
  init_define_process();
  var following_default = ["M9.37 12.69c-1.2-.53-1.04-.85-1.08-1.29-.01-.06-.01-.12-.01-.19.41-.37.75-.87.97-1.44 0 0 .01-.03.01-.04.05-.13.09-.26.12-.39.28-.06.44-.36.5-.63.06-.11.19-.39.16-.7-.04-.4-.2-.59-.38-.67v-.07c0-.52-.05-1.26-.14-1.74a2.72 2.72 0 00-.09-.43 3.02 3.02 0 00-1.04-1.51C7.87 3.2 7.15 3 6.5 3c-.64 0-1.36.2-1.87.59-.5.38-.87.92-1.05 1.51-.04.13-.07.27-.09.4-.09.49-.14 1.24-.14 1.75v.06c-.19.07-.36.26-.4.68-.03.31.1.59.16.7.06.28.23.59.51.64.04.14.08.27.13.39 0 .01.01.02.01.02v.01c.22.59.57 1.1.99 1.46 0 .06-.01.12-.01.17-.04.44.08.76-1.12 1.29-1.2.53-3.01 1.1-3.38 1.95C-.13 15.5.02 16 .02 16h12.96s.15-.5-.22-1.36c-.38-.85-2.19-1.42-3.39-1.95zM14.99 2h-2.58l.29-.29A1.003 1.003 0 0011.28.29l-2 2c-.17.18-.29.43-.29.71 0 .28.11.53.29.71l2 2a1.003 1.003 0 001.42-1.42L12.41 4h2.58c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var font_default = ["M13.93 14.67L8.94.67h-.01C8.79.28 8.43 0 8 0s-.79.28-.93.67h-.01l-5 14h.01c-.04.1-.07.21-.07.33 0 .55.45 1 1 1 .43 0 .79-.28.93-.67h.01L5.49 11h5.02l1.55 4.34h.01c.14.38.5.66.93.66.55 0 1-.45 1-1 0-.12-.03-.23-.07-.33zM6.2 9L8 3.97 9.8 9H6.2z"];
  init_define_process();
  var fork_default = ["M13.7 9.29a1.003 1.003 0 00-1.42 1.42l.29.29H11.4l-5-5h6.17l-.29.29a1.003 1.003 0 001.42 1.42l2-2c.18-.18.29-.43.29-.71s-.11-.53-.29-.71l-2-2a1.003 1.003 0 00-1.42 1.42l.29.29H.99c-.55 0-1 .45-1 1s.45 1 1 1h2.59l6.71 6.71c.18.18.43.29.71.29h1.59l-.29.29a1.003 1.003 0 001.42 1.42l2-2c.18-.18.29-.43.29-.71s-.11-.53-.29-.71l-2.02-2z"];
  init_define_process();
  var form_default = ["M2 11v2h2v-2H2zM1 9h4c.55 0 1 .45 1 1v4c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1v-4c0-.55.45-1 1-1zm9-6h5c.55 0 1 .45 1 1s-.45 1-1 1h-5c-.55 0-1-.45-1-1s.45-1 1-1zM6 1a1.003 1.003 0 01.71 1.71l-3 4C3.53 6.89 3.28 7 3 7s-.53-.11-.71-.29l-2-2a1.003 1.003 0 011.42-1.42L3 4.59l2.29-3.3C5.47 1.11 5.72 1 6 1zm4 10h5c.55 0 1 .45 1 1s-.45 1-1 1h-5c-.55 0-1-.45-1-1s.45-1 1-1z"];
  init_define_process();
  var fuel_default = ["M1.949 1H0v2h2c.31 0 .6.161.762.426l1.965 3.193-1.352 1.08A1 1 0 003 8.482V13.9c0 .607.448 1.1 1 1.1h11c.552 0 1-.492 1-1.1V2s0-1-1-1H9c-.5 0-1 .5-1 1v2L6.388 5.29 4.455 2.35A3 3 0 001.95 1zM14 3v1h-4V3h4z"];
  init_define_process();
  var full_circle_default = ["M8 0a8 8 0 100 16A8 8 0 108 0z"];
  init_define_process();
  var full_stacked_chart_default = ["M13 12h1c.55 0 1-.45 1-1V8h-3v3c0 .55.45 1 1 1zM10 2c0-.55-.45-1-1-1H8c-.55 0-1 .45-1 1v3h3V2zm0 4H7v3h3V6zm5-4c0-.55-.45-1-1-1h-1c-.55 0-1 .45-1 1v2h3V2zm0 3h-3v2h3V5zM5 5H2v3h3V5zm-2 7h1c.55 0 1-.45 1-1V9H2v2c0 .55.45 1 1 1zm12 1H2c-.55 0-1 .45-1 1s.45 1 1 1h13c.55 0 1-.45 1-1s-.45-1-1-1zM5 2c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v2h3V2zm3 10h1c.55 0 1-.45 1-1v-1H7v1c0 .55.45 1 1 1z"];
  init_define_process();
  var fullscreen_default = ["M3.41 2H5c.55 0 1-.45 1-1s-.45-1-1-1H1C.45 0 0 .45 0 1v4c0 .55.45 1 1 1s1-.45 1-1V3.41L5.29 6.7c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L3.41 2zM6 9c-.28 0-.53.11-.71.29L2 12.59V11c0-.55-.45-1-1-1s-1 .45-1 1v4c0 .55.45 1 1 1h4c.55 0 1-.45 1-1s-.45-1-1-1H3.41l3.29-3.29c.19-.18.3-.43.3-.71 0-.55-.45-1-1-1zm9 1c-.55 0-1 .45-1 1v1.59L10.71 9.3A.965.965 0 0010 9a1.003 1.003 0 00-.71 1.71l3.3 3.29H11c-.55 0-1 .45-1 1s.45 1 1 1h4c.55 0 1-.45 1-1v-4c0-.55-.45-1-1-1zm0-10h-4c-.55 0-1 .45-1 1s.45 1 1 1h1.59l-3.3 3.29a1.003 1.003 0 001.42 1.42L14 3.41V5c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var function_default = ["M8.12 4.74H6.98c.33-1.29.75-2.24 1.28-2.84.33-.37.64-.56.95-.56.06 0 .11.02.15.05.04.04.06.09.06.15 0 .05-.04.15-.13.29-.09.14-.13.28-.13.4 0 .18.07.33.2.46.14.13.31.19.52.19.22 0 .41-.08.56-.23.15-.16.23-.37.23-.63 0-.3-.11-.55-.34-.74C10.1 1.09 9.74 1 9.24 1c-.78 0-1.49.22-2.12.67-.64.45-1.24 1.2-1.81 2.23-.2.36-.38.59-.56.69-.18.1-.46.15-.85.15l-.26.9h1.08l-1.59 6.12c-.27 1.01-.44 1.63-.54 1.86-.14.34-.34.63-.62.87-.11.1-.24.15-.4.15a.15.15 0 01-.11-.04l-.04-.05c0-.03.04-.08.12-.16.08-.08.12-.2.12-.36 0-.18-.06-.33-.19-.44-.12-.12-.3-.18-.54-.18-.28 0-.51.08-.68.23-.16.14-.25.32-.25.53 0 .22.1.42.31.59.21.17.53.25.97.25.7 0 1.32-.18 1.87-.54.54-.36 1.02-.92 1.42-1.67.41-.75.82-1.96 1.25-3.63l.91-3.54h1.1l.29-.89zm5.43 1.52c.2-.15.41-.23.62-.23.08 0 .23.03.45.09s.41.09.57.09c.23 0 .42-.08.57-.23.16-.16.24-.36.24-.61 0-.26-.08-.47-.23-.62-.15-.15-.37-.23-.66-.23-.25 0-.5.06-.72.18-.23.12-.51.38-.86.78-.26.3-.64.81-1.15 1.55-.2-.91-.55-1.75-1.05-2.51l-2.72.46-.06.29c.2-.04.37-.06.51-.06.27 0 .49.11.67.34.28.36.67 1.45 1.17 3.26-.39.52-.66.85-.8 1.01-.24.26-.44.42-.59.5-.12.06-.25.09-.41.09-.11 0-.3-.06-.56-.18-.18-.08-.34-.12-.48-.12-.27 0-.48.08-.66.25-.17.17-.26.38-.26.64 0 .25.08.44.24.6.16.15.37.23.64.23.26 0 .5-.05.73-.16.23-.11.52-.34.86-.69.35-.35.82-.9 1.43-1.67.23.73.44 1.25.61 1.58s.37.57.59.71c.22.15.5.22.83.22.32 0 .65-.11.98-.34.44-.3.88-.81 1.34-1.53l-.26-.15c-.31.43-.54.7-.69.8-.1.07-.22.1-.35.1-.16 0-.32-.1-.48-.3-.27-.34-.62-1.27-1.06-2.8.4-.68.73-1.13 1-1.34z"];
  init_define_process();
  var gantt_chart_default = ["M10 10c0 .55.45 1 1 1h4c.55 0 1-.45 1-1s-.45-1-1-1h-4c-.55 0-1 .45-1 1zM6 7c0 .55.45 1 1 1h4c.55 0 1-.45 1-1s-.45-1-1-1H7c-.55 0-1 .45-1 1zm9 5H2V3c0-.55-.45-1-1-1s-1 .45-1 1v10c0 .55.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zM4 5h3c.55 0 1-.45 1-1s-.45-1-1-1H4c-.55 0-1 .45-1 1s.45 1 1 1z"];
  init_define_process();
  var geofence_default = ["M6 9c.55 0 1 .45 1 1v4c0 .55-.45 1-1 1s-1-.45-1-1v-1.59l-3.29 3.3A1.003 1.003 0 010 15c0-.28.11-.53.3-.71L3.59 11H2c-.55 0-1-.45-1-1s.45-1 1-1zM9.088.004l.097.013.097.024.057.018.1.042.054.029.095.061.052.04 6 5 .05.046.076.08.053.07.06.095.051.11c.056.141.079.294.067.446l-.014.105-.037.143-.035.087-.043.083-4 7-.034.056-.059.08-.038.044-.096.092-.114.082-.116.062-.086.034-.109.03-.1.017-.069.006H8.83c.088-.25.144-.515.163-.79L9 13v-3a3 3 0 00-2.824-2.995L6 7H3c-.351 0-.689.06-1.002.171L2 5l.002-.07.013-.1.015-.073.025-.085.043-.104.056-.101.045-.066.079-.093.084-.078.083-.062 6-4 .07-.043.12-.056.111-.036.108-.022.083-.01h.031c.046-.002.083 0 .12.003z"];
  init_define_process();
  var geolocation_default = ["M-.01 6.66l7.34 2 2 7.33 6.66-16z"];
  init_define_process();
  var geosearch_default = ["M8.82 12.4h.66c.23 0 .36-.17.36-.4v-1.48l.19-.18c-.27.03-.55.06-.83.06-.28 0-.56-.03-.84-.07.02.04.05.08.07.13V12c0 .23.15.4.39.4zM6.4 15.1A5.51 5.51 0 01.9 9.6c0-.49.06-.98.18-1.43.03 0 .05-.01.08-.01h.08v.44c0 .19.17.34.36.34.03 0 .07-.01.1-.01l.71.7c.07.07.19.07.26 0s.07-.19 0-.26l-.7-.72c0-.02.03-.03.03-.05v-.11c0-.15.08-.2.23-.33h.42c.08 0 .15-.01.22-.04h.02c.02-.02.03-.02.04-.04.01-.01.01-.01.02-.01l.02-.01.9-.9c-.13-.26-.24-.52-.34-.8h-.5v-.43c0-.01.05.05.04-.08h.31c-.03-.13-.06-.26-.08-.39h-.57c.16-.12.34-.24.51-.36-.02-.23-.04-.46-.04-.7 0-.12.01-.23.02-.34A6.385 6.385 0 000 9.6C0 13.13 2.87 16 6.4 16c3.1 0 5.67-2.22 6.26-5.15l-.78-.88c-.21 2.85-2.58 5.13-5.48 5.13zm-1.7-2.93v-.28h.12c.23 0 .39-.19.39-.42v-.54s.01-.01 0-.01L3.77 9.45h-.62c-.23 0-.38.19-.38.42v1.6c0 .23.14.42.38.42h.26v1.61c0 .23.22.41.45.41s.45-.18.45-.41v-.97H4.3c.24 0 .4-.13.4-.36zm11.07-2.34l-2.94-2.94c.11-.17.21-.34.3-.52.01-.03.03-.06.04-.09.08-.18.16-.36.22-.55v-.01c.06-.19.1-.38.14-.58.01-.05.01-.09.02-.14.03-.2.05-.4.05-.61a4.4 4.4 0 00-4.4-4.4C6.77 0 4.8 1.97 4.8 4.4s1.97 4.4 4.4 4.4c.21 0 .41-.02.61-.05.04 0 .09-.01.14-.02.2-.03.39-.08.58-.14h.01c.19-.06.37-.14.55-.22.03-.01.06-.03.09-.04.18-.09.35-.19.52-.3l2.94 2.94a.8.8 0 00.57.23c.44 0 .8-.36.8-.8a.895.895 0 00-.24-.57zM9.2 7.6C7.43 7.6 6 6.17 6 4.4c0-1.77 1.43-3.2 3.2-3.2s3.2 1.43 3.2 3.2c0 1.77-1.43 3.2-3.2 3.2zm1.54 4.26v-.52c0-.09-.1-.17-.19-.17s-.19.07-.19.17v.52c0 .09.1.17.19.17s.19-.07.19-.17z"];
  init_define_process();
  var git_branch_default = ["M12 1c-1.66 0-3 1.34-3 3 0 1.25.76 2.32 1.85 2.77A2.02 2.02 0 019 8H7c-.73 0-1.41.2-2 .55V5.82C6.16 5.4 7 4.3 7 3c0-1.66-1.34-3-3-3S1 1.34 1 3c0 1.3.84 2.4 2 2.82v4.37c-1.16.4-2 1.51-2 2.81 0 1.66 1.34 3 3 3s3-1.34 3-3c0-1.04-.53-1.95-1.32-2.49.35-.31.81-.51 1.32-.51h2c1.92 0 3.52-1.35 3.91-3.15A2.996 2.996 0 0012 1zM4 2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm0 12c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm8-9c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"];
  init_define_process();
  var git_commit_default = ["M15 7h-3.14c-.45-1.72-2-3-3.86-3S4.59 5.28 4.14 7H1c-.55 0-1 .45-1 1s.45 1 1 1h3.14c.45 1.72 2 3 3.86 3s3.41-1.28 3.86-3H15c.55 0 1-.45 1-1s-.45-1-1-1zm-7 3c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"];
  init_define_process();
  var git_merge_default = ["M12 6c-1.3 0-2.4.84-2.82 2H9c-1.62 0-3-.96-3.63-2.34C6.33 5.16 7 4.16 7 3c0-1.66-1.34-3-3-3S1 1.34 1 3c0 1.3.84 2.4 2 2.81v4.37C1.84 10.6 1 11.7 1 13c0 1.66 1.34 3 3 3s3-1.34 3-3c0-1.3-.84-2.4-2-2.82V8.43A5.89 5.89 0 009 10h.18A2.996 2.996 0 0015 9c0-1.66-1.34-3-3-3zm-8 8c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zM4 4c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm8 6c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"];
  init_define_process();
  var git_new_branch_default = ["M14 2h-1V1c0-.55-.45-1-1-1s-1 .45-1 1v1h-1c-.55 0-1 .45-1 1s.45 1 1 1h1v1c0 .55.45 1 1 1s1-.45 1-1V4h1c.55 0 1-.45 1-1s-.45-1-1-1zm-3.18 4.8C10.51 7.51 9.82 8 9 8H7c-.73 0-1.41.2-2 .55V5.82C6.16 5.4 7 4.3 7 3c0-1.66-1.34-3-3-3S1 1.34 1 3c0 1.3.84 2.4 2 2.82v4.37c-1.16.4-2 1.51-2 2.81 0 1.66 1.34 3 3 3s3-1.34 3-3c0-1.04-.53-1.95-1.32-2.49.35-.31.81-.51 1.32-.51h2c1.9 0 3.49-1.33 3.89-3.11-.29.07-.58.11-.89.11-.41 0-.8-.08-1.18-.2zM4 2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm0 12c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"];
  init_define_process();
  var git_pull_default = ["M3 1C1.34 1 0 2.34 0 4c0 1.3.84 2.4 2 2.82v3.37C.84 10.6 0 11.7 0 13c0 1.66 1.34 3 3 3s3-1.34 3-3c0-1.3-.84-2.4-2-2.82V6.82C5.16 6.4 6 5.3 6 4c0-1.66-1.34-3-3-3zm0 13c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm0-9c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm11 5.18V6c0-1.66-1.34-3-3-3H9.41l1.29-1.29c.19-.18.3-.43.3-.71A1.003 1.003 0 009.29.29l-3 3C6.11 3.47 6 3.72 6 4c0 .28.11.53.29.71l3 3a1.003 1.003 0 001.42-1.42L9.41 5H11c.55 0 1 .45 1 1v4.18A2.996 2.996 0 0013 16c1.66 0 3-1.34 3-3 0-1.3-.84-2.4-2-2.82zM13 14c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"];
  init_define_process();
  var git_push_default = ["M4 6h1V5H4v1zm9 3c0-.28-.11-.53-.29-.71l-3-3C9.53 5.11 9.28 5 9 5s-.53.11-.71.29l-3 3a1.003 1.003 0 001.42 1.42L8 8.41V15c0 .55.45 1 1 1s1-.45 1-1V8.41l1.29 1.29c.18.19.43.3.71.3.55 0 1-.45 1-1zM5 3H4v1h1V3zm10-3H1C.45 0 0 .45 0 1v13c0 .55.45 1 1 1h5v-2H2v-1h4v-1H3V2h11v9h-2v1h2v1h-2v2h3c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var git_repo_default = ["M5 9H4v1h1V9zm10-9H1C.45 0 0 .45 0 1v13c0 .55.45 1 1 1h3v1l2-1 2 1v-1h7c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zM4 13H2v-1h2v1zm10 0H8v-1h6v1zm0-2H3V2h11v9zM5 3H4v1h1V3zm0 4H4v1h1V7zm0-2H4v1h1V5z"];
  init_define_process();
  var glass_default = ["M2 0v4c0 2.97 2.16 5.43 5 5.91V14H5c-.55 0-1 .45-1 1s.45 1 1 1h6c.55 0 1-.45 1-1s-.45-1-1-1H9V9.91c2.84-.48 5-2.94 5-5.91V0H2z"];
  init_define_process();
  var globe_default = ["M4.45 7.83c-.26 0-.41.21-.41.46v1.75c0 .26.16.46.41.46h.29v1.77c0 .25.24.45.49.45s.49-.2.49-.45V11.2h-.01c.26 0 .44-.14.44-.4v-.3h.14c.26 0 .43-.2.43-.46v-.59s.01-.01 0-.01l-1.58-1.6h-.69zM8.51 3.9h.22c.06 0 .12-.01.12-.07 0-.06-.05-.07-.12-.07h-.22c-.06 0-.12.01-.12.07.01.06.06.07.12.07zm-2.33-.05c.07-.07.07-.19 0-.26l-.5-.5a.187.187 0 00-.26 0c-.07.07-.07.19 0 .26l.5.5c.07.07.19.07.26 0zm3.06.89c.07 0 .14-.06.14-.12v-.31c0-.07-.07-.12-.14-.12s-.14.06-.14.12v.31c0 .07.07.12.14.12zM8 0C3.58 0 0 3.58 0 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-.55.1-1.07.23-1.57h.11v.47c0 .2.18.37.39.37.03 0 .08-.01.11-.02l.78.77c.08.08.2.08.28 0 .08-.08.08-.2 0-.28l-.75-.78c0-.02.04-.04.04-.06v-.12c0-.16.09-.22.25-.36h.46c.09 0 .17-.01.24-.05h.02c.02-.01.03-.02.05-.03.01-.01.01-.01.02-.01l.02-.02 1.59-1.58c.18-.18.18-.46 0-.64s-.47-.15-.65.03l-.3.34h-.57v-.48c0-.01.05.05.05-.09h.64c.12 0 .22-.09.22-.21s-.1-.21-.22-.21H4.1c.18-.15.34-.31.54-.44l.01-.01c.21-.14.45-.25.68-.37.15-.07.29-.15.44-.21.17-.07.35-.11.53-.17.18-.05.35-.12.53-.16a6.05 6.05 0 013.47.35c.05.02.1.05.16.08.25.11.48.24.71.39.25.16.49.34.71.55H10.6s0-.03-.01-.03c-.04 0-.09 0-.13.03l-.51.51a.17.17 0 000 .23c.06.06.17.06.23 0l.42-.44.01-.02h.25c0 .14-.07.09-.07.12v.07c0 .22-.15.37-.36.37h-.38c-.19 0-.38.21-.38.4v.17h-.1c-.12 0-.2.06-.2.18v.25h-.23c-.17 0-.3.11-.3.28 0 .17.13.26.3.26.07 0 .14.03.19-.11l.04.01.49-.46h.17l.39.37c.03.03.08.02.12-.01.03-.03.03-.12 0-.15l-.32-.35h.23l.09.12c.18.18.48.17.66-.01l.09-.1h.4c.02 0 .08.05.08.05v.24l-.05-.01h-.36c-.11 0-.21.1-.21.21 0 .11.09.21.21.21h.41v.15c-.14.21-.24.42-.45.42h-.94v-.01l-.44-.44a.47.47 0 00-.66 0l-.42.43v.01H8.6c-.26 0-.49.21-.49.46v.92c0 .26.23.45.49.45h.9c.34.14.57.35.72.69v1.68c0 .26.17.44.42.44h.72c.26 0 .4-.18.4-.44V9l.89-.86.03-.02.02-.01h.03c.07-.08.15-.19.15-.31v-.91c0-.18-.16-.32-.31-.46H13c.01.28.21.42.46.42h.42c.08.37.12.76.12 1.15 0 3.31-2.69 6-6 6zm4.54-4.27c-.1 0-.21.08-.21.18v.57c0 .1.11.18.21.18.1 0 .21-.08.21-.18v-.57c0-.1-.11-.18-.21-.18zM8.37 3.19c0-.25-.2-.42-.46-.42h-.54c-.25 0-.42.18-.42.43 0 .03-.1.04.05.08v.47c0 .15.06.27.21.27s.21-.12.21-.27v-.14h.5c.24 0 .45-.16.45-.42z"];
  init_define_process();
  var globe_network_default = ["M8 0C3.58 0 0 3.58 0 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm5.17 5h-2.44c-.21-1.11-.51-2.03-.91-2.69 1.43.46 2.61 1.43 3.35 2.69zM10 8c0 .73-.05 1.39-.12 2H6.12C6.05 9.39 6 8.73 6 8s.05-1.39.12-2h3.76c.07.61.12 1.27.12 2zM8 2c.67 0 1.36 1.1 1.73 3H6.27C6.64 3.1 7.33 2 8 2zm-1.82.31c-.4.66-.71 1.58-.91 2.69H2.83a6.025 6.025 0 013.35-2.69zM2 8c0-.7.13-1.37.35-2h2.76C5.04 6.62 5 7.28 5 8s.04 1.38.11 2H2.35C2.13 9.37 2 8.7 2 8zm.83 3h2.44c.21 1.11.51 2.03.91 2.69A6.025 6.025 0 012.83 11zM8 14c-.67 0-1.36-1.1-1.73-3h3.46c-.37 1.9-1.06 3-1.73 3zm1.82-.31c.4-.66.7-1.58.91-2.69h2.44a6.025 6.025 0 01-3.35 2.69zM13.65 10h-2.76c.07-.62.11-1.28.11-2s-.04-1.38-.11-2h2.76c.22.63.35 1.3.35 2s-.13 1.37-.35 2z"];
  init_define_process();
  var graph_default = ["M14 3c-1.06 0-1.92.83-1.99 1.88l-1.93.97A2.95 2.95 0 008 5c-.56 0-1.08.16-1.52.43L3.97 3.34C3.98 3.23 4 3.12 4 3c0-1.1-.9-2-2-2s-2 .9-2 2 .9 2 2 2c.24 0 .47-.05.68-.13l2.51 2.09C5.08 7.29 5 7.63 5 8c0 .96.46 1.81 1.16 2.35l-.56 1.69c-.91.19-1.6.99-1.6 1.96 0 1.1.9 2 2 2s2-.9 2-2c0-.51-.2-.97-.51-1.32l.56-1.69A2.99 2.99 0 0011 8c0-.12-.02-.24-.04-.36l1.94-.97c.32.21.69.33 1.1.33 1.1 0 2-.9 2-2s-.9-2-2-2z"];
  init_define_process();
  var graph_remove_default = ["M12.89 8.11l-.01.01-.38-.38-.38.38-.02-.02c-.54.55-1.27.9-2.1.9-1.66 0-3-1.34-3-3 0-.83.35-1.56.9-2.1l-.02-.02.38-.38-.38-.38.01-.01C7.35 2.57 7 1.83 7 1c0-.34.07-.65.17-.96A8.004 8.004 0 000 8c0 4.42 3.58 8 8 8 4.14 0 7.54-3.14 7.96-7.17-.31.1-.62.17-.96.17-.83 0-1.57-.35-2.11-.89zm1.02-4.61l1.79-1.79c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-1.79 1.8L10.71.3A.965.965 0 0010 0a1.003 1.003 0 00-.71 1.71l1.79 1.79-1.79 1.79a1.003 1.003 0 001.42 1.42l1.79-1.79 1.79 1.79a1.003 1.003 0 001.42-1.42l-1.8-1.79z"];
  init_define_process();
  var greater_than_default = ["M2.713 5.958a1 1 0 01.574-1.916l10 3c.95.285.95 1.63 0 1.916l-10 3a1 1 0 01-.574-1.916L9.52 8 2.713 5.958z"];
  init_define_process();
  var greater_than_or_equal_to_default = ["M2.713 3.958a1 1 0 01.574-1.916l10 3c.95.285.95 1.63 0 1.916l-10 3a1 1 0 01-.574-1.916L9.52 6 2.713 3.958zM3 12h10a1 1 0 010 2H3a1 1 0 010-2z"];
  init_define_process();
  var grid_default = ["M15 9c.55 0 1-.45 1-1s-.45-1-1-1h-1V4h1c.55 0 1-.45 1-1s-.45-1-1-1h-1V1c0-.55-.45-1-1-1s-1 .45-1 1v1H9V1c0-.55-.45-1-1-1S7 .45 7 1v1H4V1c0-.55-.45-1-1-1S2 .45 2 1v1H1c-.55 0-1 .45-1 1s.45 1 1 1h1v3H1c-.55 0-1 .45-1 1s.45 1 1 1h1v3H1c-.55 0-1 .45-1 1s.45 1 1 1h1v1c0 .55.45 1 1 1s1-.45 1-1v-1h3v1c0 .55.45 1 1 1s1-.45 1-1v-1h3v1c0 .55.45 1 1 1s1-.45 1-1v-1h1c.55 0 1-.45 1-1s-.45-1-1-1h-1V9h1zm-8 3H4V9h3v3zm0-5H4V4h3v3zm5 5H9V9h3v3zm0-5H9V4h3v3z"];
  init_define_process();
  var grid_view_default = ["M0 1v6h7V0H1C.45 0 0 .45 0 1zm0 14c0 .55.45 1 1 1h6V9H0v6zM15 0H9v7h7V1c0-.55-.45-1-1-1zM9 16h6c.55 0 1-.45 1-1V9H9v7z"];
  init_define_process();
  var group_objects_default = ["M5 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6-3H5C2.24 3 0 5.24 0 8s2.24 5 5 5h6c2.76 0 5-2.24 5-5s-2.24-5-5-5zm0 9H5c-2.21 0-4-1.79-4-4s1.79-4 4-4h6c2.21 0 4 1.79 4 4s-1.79 4-4 4zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"];
  init_define_process();
  var grouped_bar_chart_default = ["M10 12c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1s-1 .45-1 1v8c0 .55.45 1 1 1zm3 0c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1s-1 .45-1 1v5c0 .55.45 1 1 1zm2 1H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zm-9-1c.55 0 1-.45 1-1V8c0-.55-.45-1-1-1s-1 .45-1 1v3c0 .55.45 1 1 1zm-3 0c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1v9c0 .55.45 1 1 1z"];
  init_define_process();
  var hand_default = ["M15 5c0-.55-.45-1-1-1-.41 0-.76.24-.91.59v.01s0 .01-.01.01L11.57 8h-.36l.78-4.84C12 3.11 12 3.05 12 3a1 1 0 00-1.99-.16v.01L9.18 8H9V1c0-.55-.45-1-1-1S7 .45 7 1v7h-.09l-.93-5.18A1 1 0 005 2c-.55 0-1 .45-1 1 0 .05 0 .11.01.16L5.26 11h-.04L2.83 7.44C2.65 7.18 2.35 7 2 7c-.55 0-1 .45-1 1 0 .17.04.33.12.47l3 5.69h.01v.01A5.002 5.002 0 0013 11v-.59l1.93-5.05c.05-.11.07-.23.07-.36z"];
  init_define_process();
  var hand_down_default = ["M14.72 7.87c-1.54-.67-2.99-2.68-3.7-3.95C10.11 1.95 9.93 0 6.14 0 4.05 0 2.71.61 1.92 2.12 1.27 3.36 1 5.21 1 7.83v.79c0 .65.6 1.18 1.35 1.18.34 0 .64-.11.88-.29.17.48.68.84 1.29.84.41 0 .78-.16 1.03-.42.23.37.67.63 1.19.63.57 0 1.05-.31 1.25-.74l.01.63v4.05c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5V7.9c.58.41 1.55 1.21 2.47 1.29 1.57.14 1.82-1.07 1.25-1.32z"];
  init_define_process();
  var hand_left_default = ["M12.08 4.97c-1.26-.71-3.27-2.15-3.95-3.7C7.88.7 6.67.96 6.81 2.52c.09.93.89 1.9 1.3 2.48H1.5C.67 5 0 5.67 0 6.5S.67 8 1.5 8h4.05l.63.01c-.44.2-.75.69-.75 1.25 0 .52.26.96.63 1.19-.26.25-.42.61-.42 1.03 0 .61.35 1.12.84 1.29-.18.24-.29.54-.29.88 0 .75.54 1.35 1.19 1.35h.79c2.62 0 4.47-.28 5.71-.92 1.51-.79 2.12-2.14 2.12-4.22 0-3.79-1.95-3.97-3.92-4.89z"];
  init_define_process();
  var hand_right_default = ["M14.5 5H7.89c.41-.58 1.21-1.55 1.3-2.47C9.34.97 8.12.71 7.87 1.28c-.67 1.54-2.68 2.99-3.95 3.7C1.95 5.89 0 6.07 0 9.86c0 2.09.61 3.43 2.12 4.22 1.24.65 3.09.92 5.71.92h.79c.65 0 1.18-.6 1.18-1.35 0-.34-.11-.64-.29-.88.48-.17.84-.68.84-1.29 0-.41-.16-.78-.42-1.03.37-.23.63-.67.63-1.19 0-.57-.31-1.05-.74-1.25l.63-.01h4.05c.83 0 1.5-.67 1.5-1.5S15.33 5 14.5 5z"];
  init_define_process();
  var hand_up_default = ["M13.65 6.19c-.34 0-.64.11-.88.29-.17-.48-.68-.84-1.29-.84-.41 0-.78.16-1.03.42-.23-.37-.67-.63-1.19-.63-.57 0-1.05.31-1.25.74L8 5.55V1.5C8 .67 7.33 0 6.5 0S5 .67 5 1.5v6.61c-.58-.41-1.55-1.21-2.48-1.3C.96 6.67.7 7.88 1.28 8.13c1.54.67 2.99 2.68 3.7 3.95C5.89 14.05 6.07 16 9.86 16c2.09 0 3.43-.61 4.22-2.12.64-1.24.92-3.09.92-5.71v-.79c0-.65-.6-1.19-1.35-1.19z"];
  init_define_process();
  var hat_default = ["M15 10c.495 0 .933.379.993.882L16 11v.505c0 1.461-3.524 2.45-7.707 2.493L8 14c-4.31 0-8-1-8-2.495V11c0-.561.466-1 1-1 .895 0 3 1 7 1l.381-.003C12.135 10.937 14.134 10 15 10zm-4-8c1.13 0 2.02 2.153 2.671 6.46-1.063.266-2.644.652-4.887.727l-.403.01L8 9.2c-2.664 0-4.488-.444-5.673-.74C2.98 4.153 3.87 2 5 2c2 0 1.329 2 3 2s1-2 3-2z"];
  init_define_process();
  var header_default = ["M13 1c-.55 0-1 .45-1 1v5H4V2c0-.55-.45-1-1-1s-1 .45-1 1v12c0 .55.45 1 1 1s1-.45 1-1V9h8v5c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1z"];
  init_define_process();
  var header_one_default = ["M14.06 8c-.04.23-.12.44-.25.61-.13.17-.29.3-.48.41-.18.11-.39.18-.62.23-.23.04-.46.07-.71.07v1.03h1.74V16H15V8h-.94zM7 0c-.56 0-1 .45-1 1v4H2V1c0-.55-.45-1-1-1-.56 0-1 .45-1 1v10c0 .55.45 1 1 1 .56 0 1-.45 1-1V7h4v4c0 .55.45 1 1 1 .56 0 1-.45 1-1V1c0-.54-.45-1-1-1z"];
  init_define_process();
  var header_three_default = ["M1 0C.44 0 0 .45 0 1v10c0 .54.45 1 1 1 .56 0 1-.45 1-1V7h4v4c0 .54.45 1 1 1 .56 0 1-.45 1-1V1c0-.54-.45-1-1-1-.56 0-1 .45-1 1v4H2V1c0-.54-.45-1-1-1zm13.71 11.72c.41.08.72.3.95.65.23.35.34.77.34 1.27 0 .37-.07.7-.2.97-.14.29-.32.54-.55.74-.23.2-.5.36-.8.47-.3.11-.62.16-.96.16-.41 0-.77-.06-1.08-.19-.31-.12-.56-.31-.77-.54-.21-.24-.36-.52-.47-.85-.11-.33-.16-.7-.17-1.1h1.14c-.01.47.09.86.32 1.17.23.31.57.47 1.02.47.39 0 .71-.12.97-.36s.39-.58.39-1.02c0-.3-.05-.53-.16-.71-.11-.17-.25-.31-.43-.4-.17-.09-.37-.15-.59-.17-.22-.02-.44-.03-.67-.02v-.93c.19.01.38 0 .57-.04.19-.03.36-.1.51-.19.14-.09.26-.22.35-.38.09-.16.14-.36.14-.59 0-.33-.1-.59-.31-.79-.2-.2-.47-.3-.79-.3-.21 0-.38.04-.53.13-.15.09-.27.21-.37.36-.1.15-.17.32-.22.51-.05.19-.07.38-.06.58h-1.15c.01-.38.08-.72.19-1.04.11-.32.27-.6.47-.83.19-.23.44-.42.72-.55.28-.13.6-.2.96-.2.28 0 .55.04.82.13.27.08.51.21.72.38.21.17.38.38.51.64s.19.56.19.9c0 .39-.08.73-.24 1.02-.16.29-.42.5-.76.63v.02z"];
  init_define_process();
  var header_two_default = ["M13.17 13.93c-.17.15-.33.29-.46.44-.13.16-.22.32-.27.49h3.55V16H11c.01-.65.16-1.22.44-1.71s.67-.91 1.17-1.27c.24-.18.49-.36.75-.54.25-.18.49-.36.71-.57.21-.2.39-.42.53-.65.14-.24.21-.51.22-.82 0-.14-.02-.29-.05-.45-.03-.16-.09-.31-.18-.45a1.13 1.13 0 00-.37-.35c-.16-.09-.37-.14-.63-.14-.24 0-.43.05-.59.15-.16.1-.29.24-.38.42-.1.17-.17.38-.21.62-.05.24-.07.5-.08.77h-1.19c0-.43.05-.83.16-1.2s.27-.69.49-.96c.21-.25.48-.46.79-.62.31-.15.67-.23 1.07-.23.45 0 .82.08 1.11.23.3.16.55.36.73.6.19.24.32.5.39.79.08.28.12.54.12.79 0 .31-.04.6-.13.85s-.22.49-.37.7c-.15.21-.32.41-.52.59s-.4.35-.61.51l-.63.45c-.21.14-.39.28-.57.42zM0 1c0-.55.44-1 1-1 .55 0 1 .46 1 1v10c0 .55-.44 1-1 1-.55 0-1-.46-1-1V1zm6 0c0-.55.44-1 1-1 .55 0 1 .46 1 1v10c0 .55-.44 1-1 1-.55 0-1-.46-1-1V1zM2 5h4v2H2V5z"];
  init_define_process();
  var headset_default = ["M14.85 6.34C14.18 2.72 11.37 0 8 0S1.82 2.72 1.15 6.34C.47 6.9 0 8.1 0 9.5 0 11.43.9 13 2 13c0 1.1.9 2 2 2h2c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-1c0-.55-.45-1-1-1H7c-.55 0-1 .45-1 1H4c-.55 0-1-.45-1-1 .55 0 1-.45 1-1V7c0-.45-.3-.81-.71-.94C3.97 3.7 5.81 2 8 2s4.03 1.7 4.71 4.06c-.41.13-.71.49-.71.94v5c0 .55.45 1 1 1h1c1.1 0 2-1.57 2-3.5 0-1.4-.47-2.6-1.15-3.16z"];
  init_define_process();
  var heart_default = ["M16 5.095c0-2.255-1.88-4.083-4.2-4.083-1.682 0-3.13.964-3.8 2.352a4.206 4.206 0 00-3.8-2.352C1.88 1.012 0 2.84 0 5.095c0 .066.007.13.01.194H.004c.001.047.01.096.014.143l.013.142c.07.8.321 1.663.824 2.573C2.073 10.354 4.232 12.018 8 15c3.767-2.982 5.926-4.647 7.144-6.854.501-.905.752-1.766.823-2.562.007-.055.012-.11.016-.164.003-.043.012-.088.013-.13h-.006c.003-.066.01-.13.01-.195z"];
  init_define_process();
  var heart_broken_default = ["M7.71 8.87L6.17 6.55l.02-.01A.906.906 0 016 6c0-.07.03-.13.04-.19h-.02l.78-3.92C6.09 1.34 5.19 1 4.2 1 1.88 1 0 2.83 0 5.09c0 .07.01.13.01.19H0c0 .05.01.1.01.14 0 .05.01.1.01.14.07.8.32 1.66.82 2.57 1.07 1.94 2.88 3.47 5.86 5.84l-.68-2.74h.02C6.03 11.16 6 11.08 6 11c0-.28.11-.53.29-.71l1.42-1.42zM16 5.09C16 2.83 14.12 1 11.8 1c-1.2 0-2.27.5-3.04 1.28l-.7 3.51 1.77 2.66-.01.01c.1.15.18.33.18.54 0 .28-.11.53-.29.71l-1.6 1.6.75 3.01c3.23-2.56 5.16-4.15 6.28-6.18.5-.91.75-1.77.82-2.56.01-.05.01-.11.02-.16 0-.04.01-.09.01-.13h-.01c.01-.07.02-.14.02-.2z"];
  init_define_process();
  var heat_grid_default = ["M0 10h5V7H0v3zm1-2h3v1H1V8zm14-5h-4v3h5V4c0-.55-.45-1-1-1zm0 2h-3V4h3v1zM0 4v2h5V3H1c-.55 0-1 .45-1 1zm0 9c0 .55.45 1 1 1h4v-3H0v2zm6-7h4V3H6v3zm0 8h4v-3H6v3zm1-2h2v1H7v-1zm4 2h4c.55 0 1-.45 1-1v-2h-5v3zm0-4h5V7h-5v3zm-5 0h4V7H6v3z"];
  init_define_process();
  var heatmap_default = ["M2 11c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm11-7c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm3 4.5A2.5 2.5 0 0013.5 6c-.98 0-1.82.57-2.23 1.39-.6-.78-1.51-1.3-2.56-1.36.18-.49.29-.99.29-1.53C9 2.01 6.99 0 4.5 0S0 2.01 0 4.5 2.01 9 4.5 9c.19 0 .37-.03.56-.06-.03.19-.06.37-.06.56C5 11.43 6.57 13 8.5 13c1.63 0 2.98-1.11 3.37-2.62.44.38 1 .62 1.63.62A2.5 2.5 0 0016 8.5zM14.5 13c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"];
  init_define_process();
  var helicopter_default = ["M.5 2a.5.5 0 01.5.5V4h7V3H2.5a.5.5 0 010-1h13a.5.5 0 010 1H10v1h1c2.26 0 4 1.79 4 4 0 1.87-1.247 3.44-3 3.878V13h.382l1.894-.947a.5.5 0 11.448.894L12.618 14H4.5a.5.5 0 010-1H7v-2.306C5.749 9.736 5 8.368 5 7L1 6v1.5a.5.5 0 01-1 0v-5A.5.5 0 01.5 2zM8 11.316V13h3v-1a6.73 6.73 0 01-3-.684zM11 5v3h3a3 3 0 00-3-3z"];
  init_define_process();
  var help_default = ["M8 0C3.58 0 0 3.58 0 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm1 13H7v-2h2v2zm1.93-6.52c-.14.32-.35.64-.62.97L9.25 8.83c-.12.15-.24.29-.28.42-.04.13-.09.3-.09.52V10H7.12V8.88s.05-.51.21-.71L8.4 6.73c.22-.26.35-.49.44-.68.09-.19.12-.38.12-.58 0-.3-.1-.55-.28-.75-.18-.19-.44-.28-.76-.28-.33 0-.59.1-.78.29-.19.19-.33.46-.4.81-.03.11-.1.15-.2.14l-1.7-.25c-.12-.01-.16-.08-.14-.19.12-.82.46-1.47 1.03-1.94.57-.48 1.32-.72 2.25-.72.47 0 .9.07 1.29.22s.72.34 1 .59c.28.25.49.55.65.89.15.35.22.72.22 1.12s-.07.75-.21 1.08z"];
  init_define_process();
  var helper_management_default = ["M13 5h-2v2h2V5zm0 6h-2v2h2v-2zm0-3h-2v2h2V8zm2-8H1C.4 0 0 .4 0 1v14c0 .6.4 1 1 1h14c.6 0 1-.4 1-1V1c0-.6-.4-1-1-1zm-1 14H2V2h12v12zm-7-3H5v2h2v-2zm3 0H8v2h2v-2z"];
  init_define_process();
  var high_priority_default = ["M9 14v2H7v-2h2zm1-14L9 12H7L6 0h4z"];
  init_define_process();
  var high_voltage_pole_default = ["M6 0a1 1 0 00-1 1v3H3V3h.5a.5.5 0 000-1h-2a.5.5 0 000 1H2v1a1 1 0 000 2v1h-.5a.5.5 0 000 1h2a.5.5 0 000-1H3V6h2v9a1 1 0 102 0V6h2v9a1 1 0 102 0V6h2v1h-.5a.5.5 0 000 1h2a.5.5 0 000-1H14V6a1 1 0 100-2V3h.5a.5.5 0 000-1h-2a.5.5 0 000 1h.5v1h-2V1a1 1 0 00-1-1H6zm1 2v2h2V2H7z"];
  init_define_process();
  var highlight_default = ["M9.12 11.07l2-2.02.71.71 4-4.04L10.17 0l-4 4.04.71.71-2 2.02 4.24 4.3zM2 12.97h4c.28 0 .53-.11.71-.3l1-1.01-3.42-3.45-3 3.03c-.18.18-.29.44-.29.72 0 .55.45 1.01 1 1.01zm13 1.01H1c-.55 0-1 .45-1 1.01S.45 16 1 16h14c.55 0 1-.45 1-1.01s-.45-1.01-1-1.01z"];
  init_define_process();
  var history_default = ["M8 3c-.55 0-1 .45-1 1v4c0 .28.11.53.29.71l2 2a1.003 1.003 0 001.42-1.42L9 7.59V4c0-.55-.45-1-1-1zm0-3a7.95 7.95 0 00-6 2.74V1c0-.55-.45-1-1-1S0 .45 0 1v4c0 .55.45 1 1 1h4c.55 0 1-.45 1-1s-.45-1-1-1H3.54C4.64 2.78 6.23 2 8 2c3.31 0 6 2.69 6 6 0 2.61-1.67 4.81-4 5.63v-.01c-.63.23-1.29.38-2 .38-3.31 0-6-2.69-6-6 0-.55-.45-1-1-1s-1 .45-1 1c0 4.42 3.58 8 8 8 .34 0 .67-.03 1-.07.02 0 .04-.01.06-.01C12.98 15.4 16 12.06 16 8c0-4.42-3.58-8-8-8z"];
  init_define_process();
  var home_default = ["M2 10v5c0 .55.45 1 1 1h3v-5h4v5h3c.55 0 1-.45 1-1v-5L8 4l-6 6zm13.71-2.71L14 5.59V2c0-.55-.45-1-1-1s-1 .45-1 1v1.59L8.71.29C8.53.11 8.28 0 8 0s-.53.11-.71.29l-7 7a1.003 1.003 0 001.42 1.42L8 2.41l6.29 6.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71z"];
  init_define_process();
  var horizontal_bar_chart_default = ["M4 5h7c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1zM1 1c-.55 0-1 .45-1 1v13c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1zm14 6H4c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h11c.55 0 1-.45 1-1V8c0-.55-.45-1-1-1zm-6 5H4c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h5c.55 0 1-.45 1-1v-1c0-.55-.45-1-1-1z"];
  init_define_process();
  var horizontal_bar_chart_asc_default = ["M1 3h5c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1zm0 4h7c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1zm14 6H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zM1 11h10c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1z"];
  init_define_process();
  var horizontal_bar_chart_desc_default = ["M15 1H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zM8 9H1c-.55 0-1 .45-1 1s.45 1 1 1h7c.55 0 1-.45 1-1s-.45-1-1-1zm-2 4H1c-.55 0-1 .45-1 1s.45 1 1 1h5c.55 0 1-.45 1-1s-.45-1-1-1zm5-8H1c-.55 0-1 .45-1 1s.45 1 1 1h10c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var horizontal_distribution_default = ["M2 0c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1zm13 0c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1zm-5 2H7c-.55 0-1 .45-1 1v9c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1z"];
  init_define_process();
  var horizontal_inbetween_default = ["M0 16V0h1a1 1 0 011 1v14a1 1 0 01-1 1H0zM15 0h1v16h-1a1 1 0 01-1-1V1a1 1 0 011-1zM6.707 6.707a1 1 0 00-1.414-1.414l-2 2a1 1 0 000 1.414l2 2a1 1 0 001.414-1.414L5.414 8l1.293-1.293zm4-1.414a1 1 0 00-1.414 1.414L10.586 8 9.293 9.293a1 1 0 101.414 1.414l2-2a1 1 0 000-1.414l-2-2z"];
  init_define_process();
  var hurricane_default = ["M3.5 12c-.86 0-2.5-.5-3.5-1 1 3.5 4.506 4 7 4a7 7 0 007-7l-.006-.004a5.974 5.974 0 00-1.29-3.988c.896.066 2.37.53 3.296.992-1-3.5-4.506-4-7-4a6.998 6.998 0 00-6.14 3.635 5.972 5.972 0 00-.859 3.226L2 8l.006.005a5.98 5.98 0 001.771 3.99A7.469 7.469 0 013.5 12zM8 6a2 2 0 100 4 2 2 0 000-4z"];
  init_define_process();
  var id_number_default = ["M2 5v7h12V5H2zm0-2h12c1.1 0 2 .9 2 2v7c0 1.1-.9 2-2 2H2c-1.1 0-2-.9-2-2V5c0-1.1.9-2 2-2z", "M7.9 10.48c-.14-.33-.84-.55-1.3-.75-.46-.2-.4-.33-.42-.5v-.07c.16-.14.29-.33.37-.56 0 0 0-.01.01-.02.02-.05.03-.1.05-.15.1-.01.16-.13.19-.23.03-.04.07-.15.06-.27-.02-.16-.08-.24-.15-.26v-.03c0-.2-.02-.48-.05-.67-.01-.05-.02-.1-.03-.16-.07-.23-.21-.44-.4-.58-.2-.15-.48-.23-.73-.23s-.53.08-.72.23c-.19.14-.33.35-.4.58-.02.05-.03.1-.03.16-.05.18-.06.47-.06.67v.03c-.07.03-.14.1-.15.26-.02.12.03.22.06.27.02.1.09.22.2.24.01.05.03.1.05.15v.01c.08.23.22.42.38.56v.07c-.02.17.03.29-.43.5-.46.2-1.16.42-1.3.75s-.09.52-.09.52H8c-.01 0 .05-.19-.1-.52zM10 6h2c.55 0 1 .45 1 1s-.45 1-1 1h-2c-.55 0-1-.45-1-1s.45-1 1-1zM10 9h2c.55 0 1 .45 1 1s-.45 1-1 1h-2c-.55 0-1-.45-1-1s.45-1 1-1z"];
  init_define_process();
  var image_rotate_left_default = ["M13 2h-1.59l.29-.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-2 2C8.11 2.47 8 2.72 8 3c0 .28.11.53.29.71l2 2a1.003 1.003 0 001.42-1.42l-.3-.29H13c.55 0 1 .45 1 1v3c0 .55.45 1 1 1s1-.45 1-1V5c0-1.66-1.34-3-3-3zm-5.5 9c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM10 7H1c-.55 0-1 .45-1 1v7c0 .55.45 1 1 1h9c.55 0 1-.45 1-1V8c0-.55-.45-1-1-1zm-1 6.33L7 12l-1 1-2-3-2 2.67V9h7v4.33z"];
  init_define_process();
  var image_rotate_right_default = ["M5.71 5.71l2-2C7.89 3.53 8 3.28 8 3c0-.28-.11-.53-.29-.71l-2-2a1.003 1.003 0 00-1.42 1.42l.3.29H3C1.34 2 0 3.34 0 5v3c0 .55.45 1 1 1s1-.45 1-1V5c0-.55.45-1 1-1h1.59l-.3.29a1.003 1.003 0 001.42 1.42zM12.5 11c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM15 7H6c-.55 0-1 .45-1 1v7c0 .55.45 1 1 1h9c.55 0 1-.45 1-1V8c0-.55-.45-1-1-1zm-1 6.33L12 12l-1 1-2-3-2 2.67V9h7v4.33z"];
  init_define_process();
  var import_default = ["M7.29 11.71c.18.18.43.29.71.29s.53-.11.71-.29l4-4a1.003 1.003 0 00-1.42-1.42L9 8.59V1c0-.55-.45-1-1-1S7 .45 7 1v7.59l-2.29-2.3a1.003 1.003 0 00-1.42 1.42l4 4zM15 11c-.55 0-1 .45-1 1v2H2v-2c0-.55-.45-1-1-1s-1 .45-1 1v3c0 .55.45 1 1 1h14c.55 0 1-.45 1-1v-3c0-.55-.45-1-1-1z"];
  init_define_process();
  var inbox_default = ["M13.91 2.6c-.16-.36-.51-.61-.92-.61h-10c-.41 0-.77.25-.92.61L-.01 7.45v5.54c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V7.45L13.91 2.6zm-1.92 5.39c-.55 0-1 .45-1 1v1h-6v-1c0-.55-.45-1-1-1H1.94l1.71-4h8.68l1.71 4h-2.05z"];
  init_define_process();
  var inbox_filtered_default = ["M6.432 2c.094.14.202.273.324.394L8.42 4H3.66L1.95 8H4c.55 0 1 .45 1 1v1h6.557c.693 0 1.363-.262 1.837-.736l.103-.102.85-1.14a2.564 2.564 0 00.623-1.682V5.058L16 7.46V13c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V7.46l2.08-4.85C2.23 2.25 2.59 2 3 2h3.432zm9.048-2c.31 0 .52.26.52.57 0 .16-.06.3-.17.41l-2.86 2.73v2.63c0 .16-.06.3-.17.41l-.82 1.1c-.1.1-.25.17-.41.17-.31 0-.57-.26-.57-.57V3.71L8.17.98A.566.566 0 018 .57c0-.31.26-.57.57-.57h6.91z"];
  init_define_process();
  var inbox_geo_default = ["M6.341 2A5.99 5.99 0 006 4H3.66L1.95 8H4c.55 0 1 .45 1 1v1h7a5.978 5.978 0 004-1.528V13c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V7.46l2.08-4.85C2.23 2.25 2.59 2 3 2h3.341zm3.679 2.145c0-.125.075-.23.205-.225h.345l.79.8c.005 0 0 .005 0 .005v.295c0 .13-.085.23-.215.23h-.07v.15c0 .13-.09.2-.215.2v.535c0 .125-.12.225-.245.225s-.245-.1-.245-.225V5.25h-.145c-.125 0-.205-.1-.205-.23v-.875zm2.235-2.195c-.03 0-.055-.005-.06-.035 0-.03.03-.035.06-.035h.11c.035 0 .06.005.06.035 0 .03-.03.035-.06.035h-.11zm-1.165-.025a.094.094 0 01-.13 0l-.25-.25a.094.094 0 010-.13.094.094 0 01.13 0l.25.25a.094.094 0 010 .13zm1.53.445c-.035 0-.07-.025-.07-.06v-.155c0-.03.035-.06.07-.06s.07.025.07.06v.155c0 .03-.035.06-.07.06zM12 0c2.21 0 4 1.79 4 4s-1.79 4-4 4-4-1.79-4-4 1.79-4 4-4zm0 7c1.655 0 3-1.345 3-3 0-.195-.02-.39-.06-.575h-.21c-.125 0-.225-.07-.23-.21h-.215c.075.07.155.14.155.23V3.9c0 .06-.04.115-.075.155h-.015l-.01.005-.015.01-.445.43v.815c0 .13-.07.22-.2.22h-.36c-.125 0-.21-.09-.21-.22v-.84a.627.627 0 00-.36-.345h-.45c-.13 0-.245-.095-.245-.225v-.46c0-.125.115-.23.245-.23l.13-.005.21-.215c.09-.09.24-.09.33 0l.22.225h.47c.105 0 .155-.105.225-.21v-.075h-.205a.106.106 0 01-.105-.105.11.11 0 01.105-.105h.18l.025.005v-.12s-.03-.025-.04-.025h-.2l-.045.05a.235.235 0 01-.33.005l-.045-.06h-.115l.16.175c.015.015.015.06 0 .075-.02.015-.045.02-.06.005l-.195-.185h-.085l-.245.23-.02-.005c-.025.07-.06.055-.095.055-.085 0-.15-.045-.15-.13s.065-.14.15-.14h.115v-.125c0-.06.04-.09.1-.09h.05V2.36c0-.095.095-.2.19-.2h.19c.105 0 .18-.075.18-.185V1.94c0-.015.035.01.035-.06h-.125l-.005.01-.21.22a.085.085 0 01-.115 0 .085.085 0 010-.115l.255-.255c.02-.015.045-.015.065-.015.005 0 .005.015.005.015h.64a2.327 2.327 0 00-.355-.275 2.452 2.452 0 00-.355-.195c-.03-.015-.055-.03-.08-.04a3.025 3.025 0 00-1.735-.175c-.09.02-.175.055-.265.08-.09.03-.18.05-.265.085-.075.03-.145.07-.22.105-.115.06-.235.115-.34.185l-.005.005c-.1.065-.18.145-.27.22h.455c.06 0 .11.045.11.105s-.05.105-.11.105h-.32c0 .07-.025.04-.025.045v.24h.285l.15-.17c.09-.09.235-.105.325-.015.09.09.09.23 0 .32l-.795.79-.01.01c-.005 0-.005 0-.01.005l-.025.015h-.01a.235.235 0 01-.12.025h-.23c-.08.07-.125.1-.125.18v.06c0 .01-.02.02-.02.03l.375.39c.04.04.04.1 0 .14-.04.04-.1.04-.14 0l-.39-.385a.213.213 0 01-.055.01c-.105 0-.195-.085-.195-.185v-.235h-.055A3.1 3.1 0 009 4c0 1.655 1.345 3 3 3zm2.27-2.135c.05 0 .105.04.105.09v.285c0 .05-.055.09-.105.09-.05 0-.105-.04-.105-.09v-.285c0-.05.055-.09.105-.09zm-2.085-3.27c0 .13-.105.21-.225.21h-.25v.07c0 .075-.03.135-.105.135s-.105-.06-.105-.135V1.64c-.075-.02-.025-.025-.025-.04 0-.125.085-.215.21-.215h.27c.13 0 .23.085.23.21z"];
  init_define_process();
  var inbox_search_default = ["M5.639 2a5.391 5.391 0 00-.144 2H3.66L1.95 8H4c.55 0 1 .45 1 1v1h6V9c0-.088.012-.174.033-.255.12-.007.238-.019.39-.038.154-.008.252-.03.442-.077a5.34 5.34 0 00.24-.05h.05l.122-.04 1.266 1.271c.425.47 1.116.769 1.847.769.21 0 .414-.025.61-.071V13c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V7.46l2.08-4.85C2.23 2.25 2.59 2 3 2h2.639zM15.82 7.53c.1.12.17.27.18.44 0 .34-.27.61-.61.61a.57.57 0 01-.43-.18l-2.24-2.25c-.13.08-.26.16-.4.23-.02.01-.05.02-.07.03-.14.06-.27.12-.42.17h-.01c-.14.05-.29.08-.44.11-.04.01-.08.02-.11.02-.15.02-.3.04-.46.04-1.85 0-3.35-1.51-3.35-3.37S8.96.01 10.81 0c1.85 0 3.35 1.51 3.35 3.37 0 .16-.02.31-.04.47-.01.04-.01.07-.02.11-.02.15-.05.29-.1.44v.01c-.05.15-.11.28-.17.42-.01.02-.02.05-.03.07-.07.14-.14.27-.23.4l2.25 2.24zm-5.01-1.94c1.22 0 2.21-.99 2.21-2.22 0-1.23-.99-2.22-2.21-2.22S8.6 2.14 8.6 3.37c0 1.22.99 2.22 2.21 2.22z"];
  init_define_process();
  var inbox_update_default = ["M8.1 2a5.023 5.023 0 000 2H3.66L1.95 8H4c.55 0 1 .45 1 1v1h6V9c0-.55.45-1 1-1h2.05c.708 0 1.352-.241 1.905-.645L16 7.46V13c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V7.46l2.08-4.85C2.23 2.25 2.59 2 3 2h5.1zM13 6a3 3 0 110-6 3 3 0 010 6z"];
  init_define_process();
  var info_sign_default = ["M8 0C3.58 0 0 3.58 0 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zM7 3h2v2H7V3zm3 10H6v-1h1V7H6V6h3v6h1v1z"];
  init_define_process();
  var inheritance_default = ["M5 8c0 1.66 1.34 3 3 3h4.59L11.3 9.71A.965.965 0 0111 9a1.003 1.003 0 011.71-.71l3 3c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-3 3a1.003 1.003 0 01-1.42-1.42l1.3-1.29H8c-2.76 0-5-2.24-5-5H1a1 1 0 01-1-1V1a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H5zM2 2v4h4V2H2z"];
  init_define_process();
  var inherited_group_default = ["M1 7c.51 0 .935.388.993.884L2 8v3c0 .51.388.935.884.993L3 12h1.59l-.3-.29a1.003 1.003 0 011.324-1.504l.096.084 2 2c.18.18.29.43.29.71 0 .233-.076.446-.206.614l-.084.096-2 2A1.003 1.003 0 014 15c0-.24.08-.458.224-.629l.076-.081.29-.29H3a2.996 2.996 0 01-2.995-2.823L0 11V8c0-.55.45-1 1-1zm5.388-7c.629 0 1.338.21 1.838.6.48.38.85.91 1.019 1.52.04.13.07.27.09.4.09.48.14 1.22.14 1.73v.07c.18.08.34.27.37.67.03.32-.09.59-.16.71-.06.28-.21.58-.48.63-.03.13-.07.26-.12.39 0 .01-.01.04-.01.04-.22.58-.55 1.08-.949 1.45v.18c.04.45-.12.77 1.059 1.3 1.179.53 2.947 1.09 3.307 1.95.37.86.22 1.36.22 1.36H9c0-.539-.21-1.045-.583-1.417l-2-2A1.997 1.997 0 005 9c-.149 0-.296-.015-.442-.045.099-.19.082-.37.101-.575 0-.05.01-.11.01-.17-.41-.35-.75-.86-.969-1.45v-.01s-.01-.01-.01-.02c-.04-.12-.09-.26-.12-.39-.28-.05-.44-.36-.5-.64-.06-.12-.19-.39-.16-.71.04-.41.21-.6.39-.68v-.06c0-.51.05-1.26.14-1.74.02-.13.05-.27.09-.4.17-.6.54-1.13 1.02-1.51C5.048.21 5.757 0 6.387 0zm4.625 2.04c.49 0 1.05.16 1.439.46.38.29.67.7.8 1.17.03.1.05.21.07.31.07.37.11.94.11 1.33v.05c.139.06.269.21.289.51.02.25-.07.45-.13.54-.05.21-.16.44-.38.48a1.711 1.711 0 01-.1.33c-.17.44-.43.83-.749 1.11v.14c.03.35-.09.59.83 1 .929.41 2.317.84 2.597 1.5.29.66.17 1.04.17 1.04H13.66v.01c-.05-.24-.14-.5-.25-.76-.36-.86-1.119-1.33-2.687-2-.14-.06-.59-.25-.6-.25-.21-.09-.36-.15-.5-.22.02-.1.02-.2.03-.31 0-.04.01-.08.01-.13-.07-.06-.13-.12-.19-.19.22-.32.4-.67.54-1.05.02-.06.02-.06.03-.1.29-.23.48-.57.59-.96.16-.33.25-.73.21-1.16-.03-.4-.16-.76-.37-1.03-.02-.53-.07-1.13-.15-1.54-.01-.06-.02-.12-.03-.19.23-.06.48-.09.72-.09z"];
  init_define_process();
  var inner_join_default = ["M6.6 3.3C5.3 4.4 4.5 6.1 4.5 8s.8 3.6 2.1 4.7c-.5.2-1 .3-1.6.3-2.8 0-5-2.2-5-5s2.2-5 5-5c.6 0 1.1.1 1.6.3zm-1.96 8.68C3.92 10.83 3.5 9.46 3.5 8s.42-2.83 1.14-3.98C2.6 4.2 1 5.91 1 8s1.6 3.8 3.64 3.98zM8 4c-1.2.9-2 2.4-2 4s.8 3.1 2 4c1.2-.9 2-2.3 2-4s-.8-3.1-2-4zm3-1c2.8 0 5 2.2 5 5s-2.2 5-5 5c-.6 0-1.1-.1-1.6-.3 1.3-1.1 2.1-2.9 2.1-4.7s-.8-3.5-2.1-4.7c.5-.2 1-.3 1.6-.3zm.35 1.02c.73 1.15 1.14 2.52 1.14 3.98s-.42 2.83-1.14 3.98c2.04-.18 3.64-1.9 3.64-3.98s-1.6-3.8-3.64-3.98z"];
  init_define_process();
  var insert_default = ["M5 9h2v2c0 .6.4 1 1 1s1-.4 1-1V9h2c.6 0 1-.4 1-1s-.4-1-1-1H9V5c0-.6-.4-1-1-1s-1 .4-1 1v2H5c-.6 0-1 .4-1 1s.4 1 1 1zm10-9H1C.4 0 0 .4 0 1v14c0 .6.4 1 1 1h14c.6 0 1-.4 1-1V1c0-.6-.4-1-1-1zm-1 14H2V2h12v12z"];
  init_define_process();
  var intelligence_default = ["M8 7c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.46-1-1-1zm4.988.976v-.042a.398.398 0 00-.107-.216 7.57 7.57 0 00-1.087-1.082c-.83-.703-1.78-1.292-2.824-1.527a4.315 4.315 0 00-1.818-.024 5.578 5.578 0 00-1.593.595c-.781.427-1.5 1.01-2.125 1.665-.112.12-.225.246-.33.379a.43.43 0 000 .558c.318.403.699.758 1.086 1.082.831.703 1.78 1.292 2.824 1.527a4.37 4.37 0 001.831.024c.556-.108 1.087-.325 1.593-.595a8.695 8.695 0 002.118-1.665c.113-.12.232-.246.338-.379A.42.42 0 0013 8.06V8c-.012-.012-.012-.018-.012-.024zM8 10c-1.107 0-2-.893-2-2s.893-2 2-2 2 .893 2 2-.893 2-2 2zM7 1a1 1 0 00-1-1H1a1 1 0 00-1 1v5a1 1 0 002 0V2h4a1 1 0 001-1zm2 0a1 1 0 011-1h5a1 1 0 011 1v5a1 1 0 11-2 0V2h-4a1 1 0 01-1-1zm0 14a1 1 0 001 1h5a1 1 0 001-1v-5a1 1 0 10-2 0v4h-4a1 1 0 00-1 1zm-2 0a1 1 0 01-1 1H1a1 1 0 01-1-1v-5a1 1 0 012 0v4h4a1 1 0 011 1z"];
  init_define_process();
  var intersection_default = ["M10 3c-.92 0-1.76.26-2.5.69C6.76 3.26 5.92 3 5 3 2.24 3 0 5.24 0 8s2.24 5 5 5c.92 0 1.76-.26 2.5-.69.74.43 1.58.69 2.5.69 2.76 0 5-2.24 5-5s-2.24-5-5-5zm-4.1 7.85c-.29.09-.59.15-.9.15-1.66 0-3-1.34-3-3s1.34-3 3-3c.31 0 .61.06.9.15C5.33 5.96 5 6.94 5 8s.33 2.04.9 2.85zM10 11c-.31 0-.61-.06-.9-.15.57-.81.9-1.79.9-2.85s-.33-2.04-.9-2.85c.29-.09.59-.15.9-.15 1.66 0 3 1.34 3 3s-1.34 3-3 3z"];
  init_define_process();
  var ip_address_default = ["M5 2.66C5 4.14 8 8 8 8s3-3.86 3-5.34C10.99 1.2 9.66 0 8 0S5 1.2 5 2.66zM7 3c0-.55.45-1 1-1s1 .45 1 1-.45 1-1 1-1-.45-1-1zM10.5 10H8v5h1v-4h1v1H9v1h2v-3h-.5zM2 9h12c.55 0 1 .45 1 1v5c0 .55-.45 1-1 1H2c-.55 0-1-.45-1-1v-5c0-.55.45-1 1-1zm4 1v5h1v-5H6z"];
  init_define_process();
  var issue_default = ["M8 16A8 8 0 118 0a8 8 0 010 16zm0-2A6 6 0 108 2a6 6 0 000 12zm1-2H7v-2h2v2zm0-3H7V4h2v5z"];
  init_define_process();
  var issue_closed_default = ["M9.296.104a2.99 2.99 0 00-1.003.664 2.987 2.987 0 00-.75 1.25 6 6 0 106.28 4.527c.043-.039.085-.079.127-.12l1.456-1.456A8 8 0 119.296.105zm2.532 5.2a.997.997 0 01-.707-.294L9.707 3.596a1 1 0 011.414-1.414l.707.707 1.768-1.768a1 1 0 111.414 1.415L12.536 5.01a.997.997 0 01-.708.293zM9 12H7v-2h2v2zm0-3H7V4h2v5z"];
  init_define_process();
  var issue_new_default = ["M10.568.421c-.01.04-.018.08-.026.121-.837.156-1.53.73-1.85 1.497a6 6 0 105.27 5.273 2.51 2.51 0 001.496-1.854c.04-.008.081-.016.121-.026A8 8 0 1110.568.421zM9 12H7v-2h2v2zm0-3H7V4h2v5zm1-6c0-.55.45-1 1-1h1V1c0-.55.45-1 1-1s1 .45 1 1v1h1c.55 0 1 .45 1 1s-.45 1-1 1h-1v1.005c0 .55-.45 1-1 1s-1-.45-1-1V4h-1c-.55 0-1-.45-1-1z"];
  init_define_process();
  var italic_default = ["M9.8 4H11c.5 0 1-.4 1-1s-.4-1-1-1H7c-.5 0-1 .4-1 1s.4 1 1 1h.8l-1.6 8H5c-.5 0-1 .4-1 1s.4 1 1 1h4c.5 0 1-.4 1-1s-.4-1-1-1h-.8l1.6-8z"];
  init_define_process();
  var join_table_default = ["M15 5h-3V2c0-.55-.45-1-1-1H1c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1h3v3c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm-5-1v2H6V4h4zm0 6H6V7h4v3zM2 4h3v2H2V4zm0 5V7h3v2H2zm4 4v-2h4v2H6zm8 0h-3v-2h3v2zm0-3h-3V8h3v2z"];
  init_define_process();
  var key_default = ["M11 0C8.24 0 6 2.24 6 5c0 1.02.31 1.96.83 2.75L.29 14.29a1.003 1.003 0 001.42 1.42L3 14.41l1.29 1.29c.18.19.43.3.71.3s.53-.11.71-.29l2-2c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71L6.41 11l1.83-1.83c.8.52 1.74.83 2.76.83 2.76 0 5-2.24 5-5s-2.24-5-5-5zm0 8c-.23 0-.45-.03-.66-.08-.01 0-.02-.01-.03-.01-.21-.05-.41-.12-.6-.21a3.014 3.014 0 01-1.62-2c0-.01-.01-.02-.01-.03C8.03 5.45 8 5.23 8 5c0-1.66 1.34-3 3-3s3 1.34 3 3-1.34 3-3 3z"];
  init_define_process();
  var key_backspace_default = ["M15 2H6c-.28 0-.53.11-.71.29l-5 5C.11 7.47 0 7.72 0 8c0 .28.11.53.29.71l5 5c.18.18.43.29.71.29h9c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1zm-2.29 7.29a1.003 1.003 0 01-1.42 1.42L10 9.41 8.71 10.7c-.18.19-.43.3-.71.3a1.003 1.003 0 01-.71-1.71L8.59 8l-1.3-1.29a1.003 1.003 0 011.42-1.42L10 6.59l1.29-1.29c.18-.19.43-.3.71-.3a1.003 1.003 0 01.71 1.71L11.41 8l1.3 1.29z"];
  init_define_process();
  var key_command_default = ["M12 9h-1V7h1c1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3v1H7V4c0-1.66-1.34-3-3-3S1 2.34 1 4s1.34 3 3 3h1v2H4c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3v-1h2v1c0 1.66 1.34 3 3 3s3-1.34 3-3-1.34-3-3-3zm0-6c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM4 13c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm0-8c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm5 4H7V7h2v2zm3 4c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"];
  init_define_process();
  var key_control_default = ["M12.71 5.29l-4-4C8.53 1.11 8.28 1 8 1s-.53.11-.71.29l-4 4a1.003 1.003 0 001.42 1.42L8 3.41l3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71z"];
  init_define_process();
  var key_delete_default = ["M15.71 7.29l-5-5A.997.997 0 0010 2H1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h9c.28 0 .53-.11.71-.29l5-5c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71zm-7 2a1.003 1.003 0 01-1.42 1.42L6 9.41 4.71 10.7c-.18.19-.43.3-.71.3a1.003 1.003 0 01-.71-1.71L4.59 8l-1.3-1.29a1.003 1.003 0 011.42-1.42L6 6.59 7.29 5.3c.18-.19.43-.3.71-.3a1.003 1.003 0 01.71 1.71L7.41 8l1.3 1.29z"];
  init_define_process();
  var key_enter_default = ["M14 2c-.55 0-1 .45-1 1v3c0 1.66-1.34 3-3 3H4.41L5.7 7.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-3 3c-.18.18-.29.43-.29.71 0 .28.11.53.29.71l3 3a1.003 1.003 0 001.42-1.42L4.41 11H10c2.76 0 5-2.24 5-5V3c0-.55-.45-1-1-1z"];
  init_define_process();
  var key_escape_default = ["M2 7c.55 0 1-.45 1-1V4.41L7.29 8.7c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L4.41 3H6c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1zm7-5.9v2A5 5 0 113.1 9h-2c.49 3.39 3.38 6 6.9 6 3.87 0 7-3.13 7-7 0-3.52-2.61-6.41-6-6.9z"];
  init_define_process();
  var key_option_default = ["M11 4h4c.55 0 1-.45 1-1s-.45-1-1-1h-4c-.55 0-1 .45-1 1s.45 1 1 1zm4 8h-3.43L5.86 2.49h-.02A.975.975 0 005 2H1c-.55 0-1 .45-1 1s.45 1 1 1h3.43l5.71 9.51.01-.01c.18.3.49.5.85.5h4c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var key_shift_default = ["M13.71 7.29l-5-5C8.53 2.11 8.28 2 8 2s-.53.11-.71.29l-5 5A1.003 1.003 0 003 9h2v4c0 .55.45 1 1 1h4c.55 0 1-.45 1-1V9h2a1.003 1.003 0 00.71-1.71z"];
  init_define_process();
  var key_tab_default = ["M15 10H4.41L5.7 8.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L2 9.59V8c0-.55-.45-1-1-1s-1 .45-1 1v6c0 .55.45 1 1 1s1-.45 1-1v-1.59l2.29 2.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L4.41 12H15c.55 0 1-.45 1-1s-.45-1-1-1zm0-9c-.55 0-1 .45-1 1v1.59L11.71 1.3A.965.965 0 0011 1a1.003 1.003 0 00-.71 1.71L11.59 4H1c-.55 0-1 .45-1 1s.45 1 1 1h10.59L10.3 7.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L14 6.41V8c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1z"];
  init_define_process();
  var known_vehicle_default = ["M15 3a.997.997 0 00-.707.293L12 5.586l-1.293-1.293a1 1 0 10-1.414 1.414l2 2a.997.997 0 001.414 0l3-3A1 1 0 0015 3zm-.879 6.121l-.007-.007c-.313.309-.69.552-1.114.702V10h-.998H12h-1v-.184c-.424-.15-.8-.395-1.112-.704l-.01.01-2-2 .012-.012A2.978 2.978 0 017.184 6H3c-.176 0-.06-.824 0-1l.73-1.63C3.79 3.192 3.823 3 4 3H7.78C8.328 2.39 9.115 2 10 2c.768 0 1.461.293 1.987.77l.844-.844c-.238-.244-.524-.442-.794-.524C12.037 1.402 10.72 1 8 1c-2.72 0-4.037.402-4.037.402-.508.155-1.078.711-1.268 1.237l-.763 2.117H.88c-.484 0-.88.423-.88.939s.396.939.88.939h.375L1 7c-.034.685 0 1.436 0 2v5c0 .657.384 1 1 1s1-.343 1-1v-1h10v1c0 .657.384 1 1 1s1-.343 1-1V9l-.003-.754-.876.875zM5.001 10H3V8h2v2z"];
  init_define_process();
  var lab_test_default = ["M11 1a1 1 0 010 2v3l3 7v1.25a.75.75 0 01-.75.75H2.75a.75.75 0 01-.75-.75V13l3-7V3a1 1 0 110-2h6zM9 3H7v3l-1.714 4h5.428L9 6V3z"];
  init_define_process();
  var label_default = ["M11 2H1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V7l-5-5zm3 10H2V4h8v2H3v1h7v1h4v4zm-3-5V4l3 3h-3zm-8 3h10V9H3v1z"];
  init_define_process();
  var layer_default = ["M16 8c0-.37-.21-.68-.51-.85l.01-.01-7-4-.01.01C8.34 3.06 8.18 3 8 3s-.34.06-.49.15l-.01-.02-7 4 .01.01C.21 7.32 0 7.63 0 8s.21.68.51.85l-.01.01 7 4 .01-.01c.15.09.31.15.49.15s.34-.06.49-.15l.01.01 7-4-.01-.01c.3-.17.51-.48.51-.85z"];
  init_define_process();
  var layer_outline_default = ["M7.504 3.132l-7 4a1 1 0 000 1.736l7 4a1 1 0 00.992 0l7-4a1 1 0 000-1.736l-7-4a1 1 0 00-.992 0zM8 5.152L12.983 8 8 10.847 3.016 8 8 5.152z"];
  init_define_process();
  var layers_default = ["M.55 4.89l7 3c.14.07.29.11.45.11.16 0 .31-.04.45-.11l7-3a.998.998 0 00-.06-1.81L8.4.08a1.006 1.006 0 00-.79 0l-6.99 3a.992.992 0 00-.07 1.81zM15 11c-.16 0-.31.04-.45.11L8 14l-6.55-2.9c-.14-.06-.29-.1-.45-.1-.55 0-1 .45-1 1 0 .39.23.73.55.89l7 3c.14.07.29.11.45.11.16 0 .31-.04.45-.11l7-3c.32-.16.55-.5.55-.89 0-.55-.45-1-1-1zm0-4c-.16 0-.31.04-.45.11L8 10 1.45 7.11A.997.997 0 001 7c-.55 0-1 .45-1 1 0 .39.23.73.55.89l7 3c.14.07.29.11.45.11.16 0 .31-.04.45-.11l7-3c.32-.16.55-.5.55-.89 0-.55-.45-1-1-1z"];
  init_define_process();
  var layout_default = ["M14 4c-1.1 0-2 .9-2 2 0 .47.17.9.44 1.24l-.68.91A1.996 1.996 0 009.07 9.5H7.93C7.71 8.64 6.93 8 6 8c-.47 0-.9.17-1.24.44l-.91-.68c.1-.23.15-.49.15-.76 0-.37-.11-.71-.28-1.01l2.27-2.27c.3.17.64.28 1.01.28 1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2c0 .37.11.71.28 1.01L3.01 5.28C2.71 5.11 2.37 5 2 5 .9 5 0 5.9 0 7s.9 2 2 2c.47 0 .9-.17 1.24-.44l.91.68c-.1.23-.15.49-.15.76 0 .37.11.71.28 1.01l-1.27 1.27C2.71 12.11 2.37 12 2 12c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2c0-.37-.11-.71-.28-1.01l1.27-1.27c.3.17.64.28 1.01.28.93 0 1.71-.64 1.93-1.5h1.14c.22.86 1 1.5 1.93 1.5 1.1 0 2-.9 2-2 0-.47-.17-.9-.44-1.24l.68-.91c.23.1.49.15.76.15 1.1 0 2-.9 2-2s-.9-2-2-2z"];
  init_define_process();
  var layout_auto_default = ["M14 9.5c-.56 0-1.06.23-1.42.59L8.99 8l3.59-2.09A2.002 2.002 0 0016 4.5c0-1.1-.9-2-2-2s-2 .9-2 2c0 .19.03.37.08.54L8.5 7.13v-3.2c.86-.22 1.5-1 1.5-1.93 0-1.1-.9-2-2-2S6 .9 6 2c0 .93.64 1.71 1.5 1.93v3.2L3.92 5.04c.05-.17.08-.35.08-.54 0-1.1-.9-2-2-2s-2 .9-2 2 .9 2 2 2c.56 0 1.06-.23 1.42-.59L7.01 8l-3.59 2.09A2.002 2.002 0 000 11.5c0 1.1.9 2 2 2s2-.9 2-2c0-.19-.03-.37-.08-.54L7.5 8.87v3.2c-.86.22-1.5 1-1.5 1.93 0 1.1.9 2 2 2s2-.9 2-2c0-.93-.64-1.71-1.5-1.93v-3.2l3.58 2.09c-.05.17-.08.35-.08.54 0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2z"];
  init_define_process();
  var layout_balloon_default = ["M14 11c-.2 0-.38.04-.56.09L12.42 9.4c.36-.36.58-.85.58-1.4 0-.55-.22-1.04-.58-1.4l1.01-1.69c.19.05.37.09.57.09 1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2c0 .55.22 1.04.58 1.4l-1.01 1.69C11.38 6.04 11.2 6 11 6c-.93 0-1.71.64-1.93 1.5H6.93C6.71 6.64 5.93 6 5 6c-.2 0-.38.04-.56.09L3.42 4.4C3.78 4.04 4 3.55 4 3c0-1.1-.9-2-2-2s-2 .9-2 2 .9 2 2 2c.2 0 .38-.04.56-.09L3.58 6.6C3.22 6.96 3 7.45 3 8c0 .55.22 1.04.58 1.4l-1.01 1.69C2.38 11.04 2.2 11 2 11c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2c0-.55-.22-1.04-.58-1.4l1.01-1.69c.19.05.37.09.57.09.93 0 1.71-.64 1.93-1.5h2.14c.22.86 1 1.5 1.93 1.5.2 0 .38-.04.56-.09l1.01 1.69c-.35.36-.57.85-.57 1.4 0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2z"];
  init_define_process();
  var layout_circle_default = ["M14.16 6.02c-.12-.36-.26-.7-.43-1.03.17-.29.27-.63.27-.99 0-1.1-.9-2-2-2-.36 0-.7.1-.99.27-.33-.17-.67-.31-1.03-.43A1.987 1.987 0 008 0C6.95 0 6.1.81 6.02 1.84c-.36.12-.7.26-1.03.43C4.7 2.1 4.36 2 4 2c-1.1 0-2 .9-2 2 0 .36.1.7.27.99-.17.33-.31.67-.43 1.03C.81 6.1 0 6.95 0 8c0 1.05.81 1.9 1.84 1.98.12.36.26.7.43 1.03-.17.29-.27.63-.27.99 0 1.1.9 2 2 2 .36 0 .7-.1.99-.27.33.17.67.32 1.03.43C6.1 15.19 6.95 16 8 16c1.05 0 1.9-.81 1.98-1.84.36-.12.7-.26 1.03-.43.29.17.63.27.99.27 1.1 0 2-.9 2-2 0-.36-.1-.7-.27-.99.17-.33.31-.67.43-1.03C15.19 9.9 16 9.05 16 8c0-1.05-.81-1.9-1.84-1.98zm-.99 3.79c-.05.16-.11.31-.17.46-.3-.17-.64-.27-1-.27-1.1 0-2 .9-2 2 0 .36.1.7.27 1-.15.07-.3.12-.46.17C9.5 12.48 8.81 12 8 12s-1.5.48-1.81 1.17c-.16-.06-.32-.11-.46-.17.17-.3.27-.64.27-1 0-1.1-.9-2-2-2-.36 0-.7.1-1 .27-.07-.15-.12-.3-.17-.46C3.52 9.5 4 8.81 4 8s-.48-1.5-1.17-1.81c.06-.16.11-.32.17-.46.3.17.64.27 1 .27 1.1 0 2-.9 2-2 0-.36-.1-.7-.27-1 .15-.07.3-.12.46-.17C6.5 3.52 7.19 4 8 4s1.5-.48 1.81-1.17c.16.06.32.11.46.17-.17.3-.27.64-.27 1 0 1.1.9 2 2 2 .36 0 .7-.1 1-.27.07.15.12.3.17.46C12.48 6.5 12 7.19 12 8s.48 1.5 1.17 1.81z"];
  init_define_process();
  var layout_grid_default = ["M2 12c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6C.9 6 0 6.9 0 8s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6C.9 0 0 .9 0 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM8 0C6.9 0 6 .9 6 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 12c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM8 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"];
  init_define_process();
  var layout_group_by_default = ["M2 6C.9 6 0 6.9 0 8s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 5c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12-7c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zM2 1C.9 1 0 1.9 0 3s.9 2 2 2 2-.9 2-2-.9-2-2-2zm7 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm5 3c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"];
  init_define_process();
  var layout_hierarchy_default = ["M14.5 12.07V9.93c.86-.22 1.5-1 1.5-1.93 0-1.1-.9-2-2-2-.93 0-1.71.64-1.93 1.5H9.93c-.18-.7-.73-1.25-1.43-1.43V3.93c.86-.22 1.5-1 1.5-1.93 0-1.1-.9-2-2-2S6 .9 6 2c0 .93.64 1.71 1.5 1.93v2.14c-.7.18-1.25.73-1.43 1.43H3.93C3.71 6.64 2.93 6 2 6 .9 6 0 6.9 0 8c0 .93.64 1.71 1.5 1.93v2.14c-.86.22-1.5 1-1.5 1.93 0 1.1.9 2 2 2s2-.9 2-2c0-.93-.64-1.71-1.5-1.93V9.93c.7-.18 1.25-.73 1.43-1.43h2.14c.18.7.73 1.25 1.43 1.43v2.14c-.86.22-1.5 1-1.5 1.93 0 1.1.9 2 2 2s2-.9 2-2c0-.93-.64-1.71-1.5-1.93V9.93c.7-.18 1.25-.73 1.43-1.43h2.14c.18.7.73 1.25 1.43 1.43v2.14c-.86.22-1.5 1-1.5 1.93 0 1.1.9 2 2 2s2-.9 2-2c0-.93-.64-1.71-1.5-1.93z"];
  init_define_process();
  var layout_linear_default = ["M14 6c-.93 0-1.71.64-1.93 1.5H9.93C9.71 6.64 8.93 6 8 6s-1.71.64-1.93 1.5H3.93C3.71 6.64 2.93 6 2 6 .9 6 0 6.9 0 8s.9 2 2 2c.93 0 1.71-.64 1.93-1.5h2.13C6.29 9.36 7.07 10 8 10s1.71-.64 1.93-1.5h2.13c.22.86 1 1.5 1.93 1.5 1.1 0 2-.9 2-2C16 6.9 15.1 6 14 6z"];
  init_define_process();
  var layout_skew_grid_default = ["M2 6C.9 6 0 6.9 0 8s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12-2c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zM2 12c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM2 0C.9 0 0 .9 0 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 9c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6-3c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM8 3c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 9c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"];
  init_define_process();
  var layout_sorted_clusters_default = ["M2 6C.9 6 0 6.9 0 8s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM2 0C.9 0 0 .9 0 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM8 9c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"];
  init_define_process();
  var learning_default = ["M8.441 1.104a.985.985 0 00-.882 0L.365 5c-.487.253-.487.747 0 1L7.56 9.896a.985.985 0 00.882 0L15.635 6c.487-.253.487-.747 0-1L8.44 1.104z", "M14 5.5l.016 4.514c.002.548.447.99.994.99a.99.99 0 00.99-.99V5.5h-2zM3.371 9.047l4.387 2.432a.5.5 0 00.485 0l4.39-2.432a.25.25 0 01.371.218v2.955a.25.25 0 01-.134.222l-4.635 2.436a.5.5 0 01-.466 0l-4.635-2.436A.25.25 0 013 12.22V9.265a.25.25 0 01.371-.218z"];
  init_define_process();
  var left_join_default = ["M6.6 3.3C6.1 3.1 5.6 3 5 3 2.2 3 0 5.2 0 8s2.2 5 5 5c.6 0 1.1-.1 1.6-.3C5.3 11.6 4.5 9.9 4.5 8s.8-3.6 2.1-4.7zM8 4c-1.2.9-2 2.4-2 4s.8 3.1 2 4c1.2-.9 2-2.3 2-4s-.8-3.1-2-4zm3-1c2.8 0 5 2.2 5 5s-2.2 5-5 5c-.6 0-1.1-.1-1.6-.3 1.3-1.1 2.1-2.9 2.1-4.7s-.8-3.5-2.1-4.7c.5-.2 1-.3 1.6-.3zm.35 1.02c.73 1.15 1.14 2.52 1.14 3.98s-.42 2.83-1.14 3.98c2.04-.18 3.64-1.9 3.64-3.98s-1.6-3.8-3.64-3.98z"];
  init_define_process();
  var less_than_default = ["M13.287 5.958a1 1 0 00-.574-1.916l-10 3c-.95.285-.95 1.631 0 1.916l10 3a1 1 0 00.574-1.916L6.48 8l6.807-2.042z"];
  init_define_process();
  var less_than_or_equal_to_default = ["M13.287 3.958a1 1 0 00-.575-1.916l-10 3c-.95.285-.95 1.63 0 1.916l10 3a1 1 0 00.575-1.916L6.48 6l6.807-2.042zM13 12H3a1 1 0 000 2h10a1 1 0 000-2z"];
  init_define_process();
  var lifesaver_default = ["M9.405 11.746C8.968 11.91 8.495 12 8 12c-.494 0-.968-.09-1.405-.254l-.702 1.873C6.548 13.865 7.258 14 8 14c.742 0 1.452-.135 2.107-.38l-.702-1.874zm2.341-2.341l1.873.702C13.865 9.452 14 8.742 14 8c0-.742-.135-1.452-.38-2.107l-1.874.702c.164.437.254.91.254 1.405 0 .494-.09.968-.254 1.405zM9.405 4.254l.702-1.873A5.987 5.987 0 008 2c-.742 0-1.452.135-2.107.38l.702 1.874C7.032 4.09 7.505 4 8 4c.494 0 .968.09 1.405.254zM4.254 6.595L2.38 5.893A5.987 5.987 0 002 8c0 .742.135 1.452.38 2.107l1.874-.702A3.991 3.991 0 014 8c0-.494.09-.968.254-1.405zM8 16A8 8 0 118 0a8 8 0 010 16zm0-6a2 2 0 100-4 2 2 0 000 4z"];
  init_define_process();
  var lightbulb_default = ["M9.01 14h-2c-.55 0-1 .45-1 1s.45 1 1 1h2c.55 0 1-.45 1-1s-.44-1-1-1zm1-3h-4c-.55 0-1 .45-1 1s.45 1 1 1h4c.55 0 1-.45 1-1s-.44-1-1-1zm-2-11C5.26 0 3.03 1.95 3.03 4.35c0 2.37 1.63 2.64 1.94 5.22 0 .24.22.44.5.44h5.09c.28 0 .5-.19.5-.44C11.37 6.99 13 6.72 13 4.35 13 1.95 10.77 0 8.01 0z"];
  init_define_process();
  var lightning_default = ["M7 9H5a1 1 0 01-1-1L4.89.876A1 1 0 015.884 0h4.27a.847.847 0 01.793 1.144L9.125 6h2.05a.825.825 0 01.754 1.16L8.16 15.64A.606.606 0 017 15.394V9z"];
  init_define_process();
  var link_default = ["M4.99 11.99c.28 0 .53-.11.71-.29l6-6a1.003 1.003 0 00-1.42-1.42l-6 6a1.003 1.003 0 00.71 1.71zm3.85-2.02L6.4 12.41l-1 1-.01-.01c-.36.36-.85.6-1.4.6-1.1 0-2-.9-2-2 0-.55.24-1.04.6-1.4l-.01-.01 1-1 2.44-2.44c-.33-.1-.67-.16-1.03-.16-1.1 0-2.09.46-2.81 1.19l-.02-.02-1 1 .02.02c-.73.72-1.19 1.71-1.19 2.81 0 2.21 1.79 4 4 4 1.1 0 2.09-.46 2.81-1.19l.02.02 1-1-.02-.02c.73-.72 1.19-1.71 1.19-2.81 0-.35-.06-.69-.15-1.02zm7.15-5.98c0-2.21-1.79-4-4-4-1.1 0-2.09.46-2.81 1.19l-.02-.02-1 1 .02.02c-.72.72-1.19 1.71-1.19 2.81 0 .36.06.69.15 1.02l2.44-2.44 1-1 .01.01c.36-.36.85-.6 1.4-.6 1.1 0 2 .9 2 2 0 .55-.24 1.04-.6 1.4l.01.01-1 1-2.43 2.45c.33.09.67.15 1.02.15 1.1 0 2.09-.46 2.81-1.19l.02.02 1-1-.02-.02a3.92 3.92 0 001.19-2.81z"];
  init_define_process();
  var list_default = ["M1 3h14c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1zm14 10H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zm0-4H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zm0-4H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var list_columns_default = ["M6 1c.55 0 1 .45 1 1s-.45 1-1 1H1c-.55 0-1-.45-1-1s.45-1 1-1h5zm0 4c.55 0 1 .45 1 1s-.45 1-1 1H1c-.55 0-1-.45-1-1s.45-1 1-1h5zm0 4c.55 0 1 .45 1 1s-.45 1-1 1H1c-.55 0-1-.45-1-1s.45-1 1-1h5zm0 4c.55 0 1 .45 1 1s-.45 1-1 1H1c-.55 0-1-.45-1-1s.45-1 1-1h5zm9-12c.55 0 1 .45 1 1s-.45 1-1 1h-5c-.55 0-1-.45-1-1s.45-1 1-1h5zm0 4c.55 0 1 .45 1 1s-.45 1-1 1h-5c-.55 0-1-.45-1-1s.45-1 1-1h5zm0 4c.55 0 1 .45 1 1s-.45 1-1 1h-5c-.55 0-1-.45-1-1s.45-1 1-1h5zm0 4c.55 0 1 .45 1 1s-.45 1-1 1h-5c-.55 0-1-.45-1-1s.45-1 1-1h5z"];
  init_define_process();
  var list_detail_view_default = ["M6 9H1c-.55 0-1 .45-1 1s.45 1 1 1h5c.55 0 1-.45 1-1s-.45-1-1-1zm0 4H1c-.55 0-1 .45-1 1s.45 1 1 1h5c.55 0 1-.45 1-1s-.45-1-1-1zm9-12h-5c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h5c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zM6 5H1c-.55 0-1 .45-1 1s.45 1 1 1h5c.55 0 1-.45 1-1s-.45-1-1-1zm0-4H1c-.55 0-1 .45-1 1s.45 1 1 1h5c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var locate_default = ["M15 7h-.09A6.98 6.98 0 009 1.1V1c0-.55-.45-1-1-1S7 .45 7 1v.09A6.98 6.98 0 001.1 7H1c-.55 0-1 .45-1 1s.45 1 1 1h.1A6.969 6.969 0 007 14.91V15c0 .55.45 1 1 1s1-.45 1-1v-.09A6.98 6.98 0 0014.9 9h.1c.55 0 1-.45 1-1s-.45-1-1-1zm-6.02 5.9c-.05-.5-.46-.9-.98-.9s-.93.4-.98.9A5.017 5.017 0 013.1 8.98c.5-.05.9-.46.9-.98s-.4-.93-.9-.98A5.017 5.017 0 017.02 3.1c.05.5.46.9.98.9s.93-.4.98-.9c1.97.39 3.52 1.95 3.92 3.92-.5.05-.9.46-.9.98s.4.93.9.98a5.017 5.017 0 01-3.92 3.92zM8 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"];
  init_define_process();
  var lock_default = ["M13.96 7H12V3.95C12 1.77 10.21 0 8 0S4 1.77 4 3.95V7H1.96c-.55 0-.96.35-.96.9v6.91c0 .54.41 1.19.96 1.19h12c.55 0 1.04-.65 1.04-1.19V7.9c0-.55-.49-.9-1.04-.9zM6 7V3.95c0-1.09.9-1.97 2-1.97s2 .88 2 1.97V7H6z"];
  init_define_process();
  var log_in_default = ["M11 8c0-.28-.11-.53-.29-.71l-3-3a1.003 1.003 0 00-1.42 1.42L7.59 7H1c-.55 0-1 .45-1 1s.45 1 1 1h6.59L6.3 10.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71zm4-8H9c-.55 0-1 .45-1 1s.45 1 1 1h5v12H9c-.55 0-1 .45-1 1s.45 1 1 1h6c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var log_out_default = ["M7 14H2V2h5c.55 0 1-.45 1-1s-.45-1-1-1H1C.45 0 0 .45 0 1v14c0 .55.45 1 1 1h6c.55 0 1-.45 1-1s-.45-1-1-1zm8.71-6.71l-3-3a1.003 1.003 0 00-1.42 1.42L12.59 7H6c-.55 0-1 .45-1 1s.45 1 1 1h6.59l-1.29 1.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71z"];
  init_define_process();
  var low_voltage_pole_default = ["M8 0a1 1 0 00-1 1v1H3v-.5a.5.5 0 00-1 0V2a1 1 0 000 2v1h-.5a.5.5 0 000 1h2a.5.5 0 000-1H3V4h4v11a1 1 0 102 0V4h4v1h-.5a.5.5 0 000 1h2a.5.5 0 000-1H14V4a1 1 0 100-2v-.5a.5.5 0 00-1 0V2H9V1a1 1 0 00-1-1z"];
  init_define_process();
  var manual_default = ["M15.99 1.13c-.02-.41-.33-.77-.78-.87C12.26-.36 9.84.13 8 1.7 6.16.13 3.74-.36.78.26.33.35.03.72.01 1.13H0v12c0 .08 0 .17.02.26.12.51.65.82 1.19.71 2.63-.55 4.59-.04 6.01 1.57.02.03.06.04.08.06.02.02.03.04.05.06.04.03.09.04.13.07.05.03.09.05.14.07.11.04.23.07.35.07h.04c.12 0 .24-.03.35-.07.05-.02.09-.05.14-.07.04-.02.09-.04.13-.07.02-.02.03-.04.05-.06.03-.02.06-.03.08-.06 1.42-1.6 3.39-2.12 6.01-1.57.54.11 1.07-.21 1.19-.71.04-.09.04-.18.04-.26l-.01-12zM7 12.99c-1.4-.83-3.07-1.14-5-.93V1.96c2.11-.28 3.75.2 5 1.46v9.57zm7-.92c-1.93-.21-3.6.1-5 .93V3.42c1.25-1.26 2.89-1.74 5-1.46v10.11z"];
  init_define_process();
  var manually_entered_data_default = ["M1 8h3.76l2-2H1c-.55 0-1 .45-1 1s.45 1 1 1zm14.49-4.01c.31-.32.51-.76.51-1.24C16 1.78 15.22 1 14.25 1c-.48 0-.92.2-1.24.51l-1.44 1.44 2.47 2.47 1.45-1.43zM1 4h7.76l2-2H1c-.55 0-1 .45-1 1s.45 1 1 1zm0 6c-.55 0-1 .45-1 1 0 .48.35.86.8.96L2.76 10H1zm9.95-6.43l-6.69 6.69 2.47 2.47 6.69-6.69-2.47-2.47zm4.25 2.47L13.24 8H15c.55 0 1-.45 1-1 0-.48-.35-.86-.8-.96zM2 15l3.86-1.39-2.46-2.44L2 15zm13-5h-3.76l-2 2H15c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var many_to_many_default = ["M3 3a1 1 0 100 2 1 1 0 000-2zm3 1c0 .047-.001.094-.003.14.255.081.538.209.832.41.406.28.8.676 1.171 1.225.37-.549.765-.945 1.171-1.224a3.14 3.14 0 01.832-.411 3 3 0 11.77 1.87 1.038 1.038 0 00-.47.19c-.291.2-.752.672-1.227 1.8.475 1.128.936 1.6 1.227 1.8.183.126.336.173.47.19a3 3 0 11-.77 1.87 3.141 3.141 0 01-.832-.41c-.406-.28-.8-.676-1.171-1.225-.37.549-.765.945-1.171 1.224-.294.202-.577.33-.832.411a3 3 0 11-.77-1.87c.134-.017.287-.064.47-.19.291-.2.752-.672 1.227-1.8-.475-1.128-.936-1.6-1.227-1.8a1.038 1.038 0 00-.47-.19A3 3 0 116 4zm6 0a1 1 0 112 0 1 1 0 01-2 0zm-9 7a1 1 0 100 2 1 1 0 000-2zm9 1a1 1 0 112 0 1 1 0 01-2 0z"];
  init_define_process();
  var many_to_one_default = ["M3 2a1 1 0 100 2 1 1 0 000-2zm0-2c1.385 0 2.551.94 2.896 2.215.168.044.34.096.51.158 1.076.394 2.237 1.242 2.575 2.93.161.809.664 1.211 1.293 1.443a3 3 0 110 2.508c-.629.232-1.132.634-1.293 1.442-.338 1.69-1.499 2.537-2.575 2.93a5.436 5.436 0 01-.51.159A3.001 3.001 0 010 13a3 3 0 015.726-1.254c.629-.232 1.132-.634 1.293-1.442.216-1.076.765-1.81 1.413-2.304-.648-.493-1.197-1.228-1.413-2.304-.161-.808-.664-1.21-1.293-1.442A3 3 0 113 0zm1 13a1 1 0 10-2 0 1 1 0 002 0zm8-5a1 1 0 102 0 1 1 0 00-2 0z"];
  init_define_process();
  var map_default = ["M15.55 3.17l-4.49-3A.975.975 0 009.99.15L5.53 2.82 1.56.17A1.003 1.003 0 000 1v11c0 .35.18.65.45.83l4.49 3a.975.975 0 001.07.02l4.46-2.67 3.97 2.65A1.003 1.003 0 0016 15V4c0-.35-.18-.65-.45-.83zM5 13.46l-3-2v-8.6l2.94 1.96c.02.02.04.03.06.04v8.6zm5-2.32s-.01 0-.01.01L6 13.53V4.86s.01 0 .01-.01L10 2.47v8.67zm4 1.99l-2.94-1.96c-.02-.01-.04-.02-.05-.03v-8.6l3 2v8.59z"];
  init_define_process();
  var map_create_default = ["M14 6.82v6.32l-2.94-1.96c-.02-.01-.04-.02-.05-.03V6.22c-.08-.07-.15-.16-.22-.24-.28-.02-.54-.08-.79-.16v5.32s-.01 0-.01.01L6 13.53V4.86s.01 0 .01-.01l2.05-1.23C8.02 3.42 8 3.21 8 3c0-.98.47-1.84 1.2-2.39l-3.67 2.2L1.56.17A1.003 1.003 0 000 1v11c0 .35.18.65.45.83l4.49 3a.975.975 0 001.07.02l4.46-2.67 3.97 2.65A1.003 1.003 0 0016 15V5.82c-.25.09-.52.14-.8.16-.33.36-.73.67-1.2.84zm-9 6.64l-3-2v-8.6l2.94 1.96c.02.02.04.03.06.04v8.6zM11 4h1v1c0 .55.45 1 1 1s1-.45 1-1V4h1c.55 0 1-.45 1-1s-.45-1-1-1h-1V1c0-.55-.45-1-1-1s-1 .45-1 1v1h-1c-.55 0-1 .45-1 1s.45 1 1 1z"];
  init_define_process();
  var map_marker_default = ["M8.46 0C5.42 0 2.95 2.39 2.95 5.33 2.95 8.28 8.46 16 8.46 16s5.51-7.72 5.51-10.67C13.96 2.39 11.5 0 8.46 0zm0 8a2.5 2.5 0 010-5 2.5 2.5 0 010 5z"];
  init_define_process();
  var maximize_default = ["M5.99 8.99c-.28 0-.53.11-.71.29l-3.29 3.29v-1.59c0-.55-.45-1-1-1s-1 .45-1 1v4c0 .55.45 1 1 1h4c.55 0 1-.45 1-1s-.45-1-1-1H3.41L6.7 10.7a1.003 1.003 0 00-.71-1.71zm9-9h-4c-.55 0-1 .45-1 1s.45 1 1 1h1.59l-3.3 3.3a.99.99 0 00-.29.7 1.003 1.003 0 001.71.71l3.29-3.29V5c0 .55.45 1 1 1s1-.45 1-1V1c0-.56-.45-1.01-1-1.01z"];
  init_define_process();
  var media_default = ["M11.99 6.99c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm3-5h-14c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h14c.55 0 1-.45 1-1v-10c0-.55-.45-1-1-1zm-1 9l-5-3-1 2-3-4-3 5v-7h12v7z"];
  init_define_process();
  var menu_default = ["M1 4h14c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1zm14 8H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zm0-5H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var menu_closed_default = ["M14.99 6.99h-9c-.55 0-1 .45-1 1s.45 1 1 1h9c.55 0 1-.45 1-1s-.45-1-1-1zm-12-2c-.28 0-.53.11-.71.29l-2 2a1.014 1.014 0 000 1.42l2 2a1.003 1.003 0 001.71-.71v-4c0-.55-.45-1-1-1zm3-1h9c.55 0 1-.45 1-1s-.45-1-1-1h-9c-.55 0-1 .45-1 1s.45 1 1 1zm9 8h-9c-.55 0-1 .45-1 1s.45 1 1 1h9c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var menu_open_default = ["M9.99 11.99h-9c-.55 0-1 .45-1 1s.45 1 1 1h9c.55 0 1-.45 1-1s-.45-1-1-1zm0-5h-9c-.55 0-1 .45-1 1s.45 1 1 1h9c.55 0 1-.45 1-1s-.45-1-1-1zm0-5h-9c-.55 0-1 .45-1 1s.45 1 1 1h9c.55 0 1-.45 1-1s-.45-1-1-1zm5.71 5.3l-2-2a1.003 1.003 0 00-1.71.71v4a1.003 1.003 0 001.71.71l2-2c.18-.18.29-.43.29-.71s-.11-.53-.29-.71z"];
  init_define_process();
  var merge_columns_default = ["M5.71 5.29a1.003 1.003 0 00-1.42 1.42l.3.29H2V2h3v1.51c.52.06.99.29 1.34.65l.66.66V1c0-.55-.45-1-1-1H1C.45 0 0 .45 0 1v14c0 .55.45 1 1 1h5c.55 0 1-.45 1-1v-3.82l-.66.66c-.35.35-.82.59-1.34.65V14H2V9h2.59l-.3.29a1.003 1.003 0 001.42 1.42l2-2C7.89 8.53 8 8.28 8 8c0-.28-.11-.53-.29-.71l-2-2zM15 0h-5c-.55 0-1 .45-1 1v3.82l.66-.66c.35-.35.82-.59 1.34-.65V2h3v5h-2.59l.29-.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-2 2C8.11 7.47 8 7.72 8 8c0 .28.11.53.29.71l2 2a1.003 1.003 0 001.42-1.42l-.3-.29H14v5h-3v-1.51c-.52-.06-.99-.29-1.34-.65L9 11.18V15c0 .55.45 1 1 1h5c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var merge_links_default = ["M8 7c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-8c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm6 3c-.93 0-1.71.64-1.93 1.5H11V3c0-1.66-1.34-3-3-3S5 1.34 5 3v4.5H3.93C3.71 6.64 2.93 6 2 6 .9 6 0 6.9 0 8s.9 2 2 2c.93 0 1.71-.64 1.93-1.5H5V13c0 1.66 1.34 3 3 3s3-1.34 3-3V8.5h1.07c.22.86 1 1.5 1.93 1.5 1.1 0 2-.9 2-2s-.9-2-2-2zm-4 7c0 1.1-.9 2-2 2s-2-.9-2-2V3c0-1.1.9-2 2-2s2 .9 2 2v10z"];
  init_define_process();
  var minimize_default = ["M15.99.99a1.003 1.003 0 00-1.71-.71l-3.29 3.29V1.99c0-.55-.45-1-1-1s-1 .45-1 1v4c0 .55.45 1 1 1h4c.55 0 1-.45 1-1s-.45-1-1-1H12.4l3.3-3.29c.18-.18.29-.43.29-.71zm-10 8h-4c-.55 0-1 .45-1 1s.45 1 1 1h1.59L.29 14.28a1.003 1.003 0 001.42 1.42L5 12.41V14c0 .55.45 1 1 1s1-.45 1-1v-4a1.02 1.02 0 00-1.01-1.01z"];
  init_define_process();
  var minus_default = ["M13 7H3c-.55 0-1 .45-1 1s.45 1 1 1h10c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var mobile_phone_default = ["M12 0H4c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h8c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zM8 15c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm3-3H5V3h6v9z"];
  init_define_process();
  var mobile_video_default = ["M15 4c-.28 0-.53.11-.71.29L12 6.59V4c0-.55-.45-1-1-1H1c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V9.41l2.29 2.29c.18.19.43.3.71.3.55 0 1-.45 1-1V5c0-.55-.45-1-1-1z"];
  init_define_process();
  var modal_default = ["M15 1a1 1 0 011 1v12a1 1 0 01-1 1H1a1 1 0 01-1-1V2a1 1 0 011-1h14zm-1 4H2v8h12V5zm-3-3H9v2h2V2zm3 0h-2v2h2V2z"];
  init_define_process();
  var modal_filled_default = ["M15 1H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zm1 4H0V3h16v2zm-3-2h-2V1h2v2z"];
  init_define_process();
  var moon_default = ["M15 11.38A7.835 7.835 0 017.85 16C3.51 16 0 12.49 0 8.15 0 4.97 1.89 2.23 4.62 1c-.45.99-.7 2.08-.7 3.23a7.85 7.85 0 007.85 7.85c1.15 0 2.24-.25 3.23-.7z"];
  init_define_process();
  var more_default = ["M2 6.03a2 2 0 100 4 2 2 0 100-4zM14 6.03a2 2 0 100 4 2 2 0 100-4zM8 6.03a2 2 0 100 4 2 2 0 100-4z"];
  init_define_process();
  var mountain_default = ["M16 13H3l6-9h1l2 2h1l3 7zm-2.5-3.5l-1-2.5h-1l-2-2-3 4.5L9 8l1 1 1-1 2.5 1.5zM5.94 7l-4.122 6H0l5-6h.94z"];
  init_define_process();
  var move_default = ["M15.71 7.29l-2-2a1.003 1.003 0 00-1.42 1.42l.3.29H9V3.41l.29.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-2-2C8.53.11 8.28 0 8 0s-.53.11-.71.29l-2 2a1.003 1.003 0 001.42 1.42l.29-.3V7H3.41l.29-.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-2 2C.11 7.47 0 7.72 0 8c0 .28.11.53.29.71l2 2a1.003 1.003 0 001.42-1.42L3.41 9H7v3.59l-.29-.29A.965.965 0 006 12a1.003 1.003 0 00-.71 1.71l2 2c.18.18.43.29.71.29s.53-.11.71-.29l2-2a1.003 1.003 0 00-1.42-1.42l-.29.3V9h3.59l-.29.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l2-2c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71z"];
  init_define_process();
  var mugshot_default = ["M15 0H1C.45 0 0 .45 0 1v14c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 14h-.15c-.03-.09-.04-.16-.08-.25-.34-.79-2.01-1.31-3.12-1.8-1.11-.49-.96-.79-1-1.2-.01-.06-.01-.12-.01-.18.38-.34.69-.8.89-1.33 0 0 .01-.03.01-.04.04-.12.08-.24.11-.36.25-.05.4-.33.46-.59.06-.1.18-.36.15-.65-.04-.37-.19-.55-.35-.62v-.06c0-.48-.04-1.16-.13-1.61-.02-.12-.05-.25-.08-.37-.16-.55-.51-1.05-.96-1.39C9.26 3.19 8.6 3 8 3c-.59 0-1.26.19-1.73.55-.45.35-.8.84-.96 1.39-.04.13-.06.25-.08.38-.09.45-.13 1.13-.13 1.61v.06c-.18.06-.33.24-.37.62-.03.29.09.54.15.65.06.26.21.54.47.59.03.12.07.25.11.36 0 .01.01.02.01.02v.01c.21.54.53 1.01.92 1.35 0 .05-.01.11-.01.16-.04.41.08.7-1.03 1.2-1.11.49-2.77 1.01-3.12 1.8-.04.09-.05.16-.08.25H2V2h12v12z"];
  init_define_process();
  var multi_select_default = ["M12 3.98H4c-.55 0-1 .45-1 1v1h8v5h1c.55 0 1-.45 1-1v-5c0-.55-.45-1-1-1zm3-3H7c-.55 0-1 .45-1 1v1h8v5h1c.55 0 1-.45 1-1v-5c0-.55-.45-1-1-1zm-6 6H1c-.55 0-1 .45-1 1v5c0 .55.45 1 1 1h8c.55 0 1-.45 1-1v-5c0-.55-.45-1-1-1zm-1 5H2v-3h6v3z"];
  init_define_process();
  var music_default = ["M15 0c-.07 0-.13.03-.19.04V.02l-10 2v.02C4.35 2.13 4 2.52 4 3v9.12c-.31-.07-.65-.12-1-.12-1.66 0-3 .9-3 2s1.34 2 3 2 3-.9 3-2V6.32l8-1.6v5.4c-.31-.07-.65-.12-1-.12-1.66 0-3 .9-3 2s1.34 2 3 2 3-.9 3-2V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var nest_default = ["M2 2c.55 0 1 .45 1 1v3c0 1.66 1.34 3 3 3h5.59L10.3 7.71A.965.965 0 0110 7a1.003 1.003 0 011.71-.71l3 3c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-3 3a1.003 1.003 0 01-1.42-1.42l1.3-1.29H6c-2.76 0-5-2.24-5-5V3c0-.55.45-1 1-1z"];
  init_define_process();
  var new_drawing_default = ["M14.9 11c.6 0 1 .5 1 1 0 .257-.073.44-.22.614l-.08.086-3 3c-.2.2-.4.3-.7.3-.5 0-1-.4-1-1 0-.257.073-.44.22-.614l.08-.086 3-3c.2-.2.4-.3.7-.3zM1.3.1l6.734 2.45a3.005 3.005 0 002.095 3.322 3.005 3.005 0 003.401 2.081L13.9 9.8v.2c0 .257-.073.44-.22.614l-.08.086-3 3c-.171.171-.343.27-.577.294L9.9 14h-.2l-5-1-.1-.01c-.231-.05-.45-.26-.56-.49L4 12.4l-4-11 .3-.3 5.8 5.8c-.1.2-.2.4-.2.6 0 .8.6 1.5 1.5 1.5s1.5-.7 1.5-1.5S8.2 6 7.4 6c-.16 0-.32.064-.48.14l-.12.06L1 .4l.3-.3zM13 0c.55 0 1 .45 1 1v1h1c.55 0 1 .45 1 1s-.45 1-1 1h-1v1c0 .503-.376.922-.861.99l-.013.002A.999.999 0 0113 6l.097-.006-.027.004a1 1 0 01-.037.001L13 6c-.55 0-1-.45-1-1V4h-1a.993.993 0 01-.855-.482A1 1 0 0110 3c0-.55.45-1 1-1h1V1c0-.55.45-1 1-1z"];
  init_define_process();
  var new_grid_item_default = ["M6 0H1C.45 0 0 .45 0 1v5c0 .55.45 1 1 1h5c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm5 14c0-.55-.45-1-1-1s-1 .45-1 1v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1s-.45-1-1-1zM6 9H1c-.55 0-1 .45-1 1v5c0 .55.45 1 1 1h5c.55 0 1-.45 1-1v-5c0-.55-.45-1-1-1zm9 4c-.55 0-1 .45-1 1-.55 0-1 .45-1 1s.45 1 1 1h1c.55 0 1-.45 1-1v-1c0-.55-.45-1-1-1zm-4-4h-1c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1s1-.45 1-1c.55 0 1-.45 1-1s-.45-1-1-1zm4-9h-5c-.55 0-1 .45-1 1v5c0 .55.45 1 1 1h5c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm0 9h-1c-.55 0-1 .45-1 1s.45 1 1 1c0 .55.45 1 1 1s1-.45 1-1v-1c0-.55-.45-1-1-1z"];
  init_define_process();
  var new_layer_default = ["M13.982 6.272l1.518.868-.01.01c.3.17.51.48.51.85s-.21.68-.51.85l.01.01-7 4-.01-.01A.94.94 0 018 13a.94.94 0 01-.49-.15l-.01.01-7-4 .01-.01A.977.977 0 010 8c0-.37.21-.68.51-.86L.5 7.13l7-4 .01.02A.94.94 0 018 3c.086 0 .168.014.246.038a2 2 0 105.736 3.234zM14 3c.55 0 1 .45 1 1s-.45 1-1 1h-1v1c0 .55-.45 1-1 1s-1-.45-1-1V5h-1c-.55 0-1-.45-1-1s.45-1 1-1h1V2c0-.55.45-1 1-1s1 .45 1 1v1h1z"];
  init_define_process();
  var new_layers_default = ["M13 3h2a1 1 0 010 2h-2v2a1 1 0 01-2 0V5H9a1 1 0 110-2h2V1a1 1 0 012 0v2zm-3-1.983V2H9a2 2 0 100 4h1v1c0 .279.057.544.16.785l-1.71.855c-.14.07-.29.11-.45.11-.16 0-.31-.04-.45-.11l-7-3.5a.992.992 0 01.07-1.81l6.99-3a1.006 1.006 0 01.79 0l1.6.687zm.91 7.66a2 2 0 003.085-1.54l.555-.277c.14-.07.29-.11.45-.11.55 0 1 .45 1 1 0 .39-.23.73-.55.89l-7 3.5c-.14.07-.29.11-.45.11-.16 0-.31-.04-.45-.11l-7-3.5C.23 8.48 0 8.14 0 7.75c0-.55.45-1 1-1 .16 0 .31.04.45.11L8 10.13l2.91-1.453zM15 10.25c.55 0 1 .45 1 1 0 .39-.23.73-.55.89l-7 3.5c-.14.07-.29.11-.45.11-.16 0-.31-.04-.45-.11l-7-3.5c-.32-.16-.55-.5-.55-.89 0-.55.45-1 1-1 .16 0 .31.04.45.1L8 13.63l6.55-3.27c.14-.07.29-.11.45-.11z"];
  init_define_process();
  var new_link_default = ["M15 3h-1V2c0-.55-.45-1-1-1s-1 .45-1 1v1h-1c-.55 0-1 .45-1 1s.45 1 1 1h1v1c0 .55.45 1 1 1s1-.45 1-1V5h1c.55 0 1-.45 1-1s-.45-1-1-1zm-3.5 6a2.5 2.5 0 00-2.45 2h-4.1a2.5 2.5 0 100 1h4.1a2.5 2.5 0 102.45-3z"];
  init_define_process();
  var new_object_default = ["M8 4c0 .6.4 1 1 1h2v2c0 .6.4 1 1 1s1-.4 1-1V5h2c.6 0 1-.4 1-1s-.4-1-1-1h-2V1c0-.6-.4-1-1-1s-1 .4-1 1v2H9c-.6 0-1 .5-1 1zm6.5 2.5V7c0 1.4-1.1 2.5-2.5 2.5S9.5 8.4 9.5 7v-.5H9C7.6 6.5 6.5 5.4 6.5 4S7.6 1.5 9 1.5h.5V1c0-.3.1-.6.1-.8C9.1.1 8.6 0 8 0 3.6 0 0 3.6 0 8s3.6 8 8 8 8-3.6 8-8c0-.6-.1-1.3-.2-1.9-.4.3-.8.4-1.3.4z"];
  init_define_process();
  var new_person_default = ["M9.12 12.69c-1.17-.53-1.01-.85-1.05-1.29-.01-.06-.01-.12-.01-.19.4-.37.73-.87.94-1.44 0 0 .01-.03.01-.04.05-.14.09-.27.12-.4.27-.06.43-.36.49-.63.06-.11.19-.39.16-.7-.04-.41-.2-.6-.38-.68v-.07c0-.51-.05-1.25-.14-1.74-.02-.13-.05-.27-.09-.4-.17-.6-.53-1.14-1.01-1.52C7.66 3.2 6.96 3 6.33 3c-.62 0-1.33.2-1.82.59-.49.38-.85.92-1.02 1.52-.04.13-.07.26-.09.4-.09.49-.13 1.23-.13 1.74v.06c-.19.08-.35.27-.39.68-.03.31.1.59.16.7.06.28.22.59.5.64.03.14.07.27.11.4 0 .01.01.02.01.02v.01c.22.59.55 1.1.96 1.46 0 .06-.01.12-.01.17-.04.44.08.76-1.09 1.29-1.17.53-2.93 1.1-3.29 1.95-.35.87-.2 1.37-.2 1.37h12.6s.15-.5-.22-1.36c-.36-.85-2.12-1.42-3.29-1.95zM14.89 2h-1V1c0-.55-.45-1-1-1s-1 .45-1 1v1h-1c-.55 0-1 .45-1 1s.45 1 1 1h1v1c0 .55.45 1 1 1s1-.45 1-1V4h1c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var new_prescription_default = ["M9.82 11.66l2.48-2.87c.12-.2.13-.37.04-.53-.11-.19-.3-.26-.52-.26h-1.29c-.27 0-.49.13-.63.34L8.44 9.9 6.95 8a.482.482 0 00-.08-.1L5.82 6.55c.57-.24 1.04-.57 1.42-1.01.49-.57.74-1.27.74-2.08 0-.51-.1-.99-.32-1.42-.21-.43-.51-.8-.89-1.11A4.1 4.1 0 005.42.24C4.91.08 4.34 0 3.72 0H.61C.26 0 0 .23 0 .56v9.89c0 .33.26.55.61.55h.8c.36 0 .61-.23.61-.56V6.99H3.3l3.73 4.74-2.71 3.48c-.12.2-.13.37-.04.53.11.19.3.26.52.26h1.27c.27 0 .51-.12.64-.34l1.69-2.15 1.66 2.14c.12.21.34.35.62.35h1.43c.2 0 .39-.08.5-.25.12-.18.09-.38-.02-.55l-2.77-3.54zM4.18 5H1.99V2.02h2.19c.62 0 1.08.13 1.38.37.29.22.44.62.44 1.08 0 .45-.15.94-.44 1.17-.31.23-.76.36-1.38.36zM15 2h-1V1c0-.55-.45-1-1-1s-1 .45-1 1v1h-1c-.55 0-1 .45-1 1s.45 1 1 1h1v1c0 .55.45 1 1 1s1-.45 1-1V4h1c.55 0 1-.45 1-1s-.45-1-1-1zM9.99 3.01c0 .02.01.04.01.06V2.95c0 .02-.01.04-.01.06z"];
  init_define_process();
  var new_text_box_default = ["M5 6.5c0 .28.22.5.5.5H7v3.5c0 .28.22.5.5.5s.5-.22.5-.5V7h1.5c.28 0 .5-.22.5-.5S9.78 6 9.5 6h-4c-.28 0-.5.22-.5.5zM15 2h-1V1c0-.55-.45-1-1-1s-1 .45-1 1v1h-1c-.55 0-1 .45-1 1s.45 1 1 1h1v1c0 .55.45 1 1 1s1-.45 1-1V4h1c.55 0 1-.45 1-1s-.45-1-1-1zm-2 5c-.55 0-1 .45-1 1v5H3V4h5c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1v11c0 .55.45 1 1 1h11c.55 0 1-.45 1-1V8c0-.55-.45-1-1-1z"];
  init_define_process();
  var ninja_default = ["M16 5s-2.52 2.11-4.96 1.99C11.03 4.89 10.39.23 5 0c0 0 2.11 2.54 1.96 4.99C4.86 5.01.23 5.65 0 11c0 0 2.56-2.12 5.02-1.95.02 2.11.67 6.72 5.98 6.95 0 0-2.09-2.54-1.94-4.99 2.11-.02 6.71-.68 6.94-6.01zM8 9.5c-.83 0-1.5-.67-1.5-1.5S7.17 6.5 8 6.5s1.5.67 1.5 1.5S8.83 9.5 8 9.5z"];
  init_define_process();
  var not_equal_to_default = ["M7.58 5l.44-2.196a1 1 0 011.96.392L9.62 5H13a1 1 0 010 2H9.22l-.4 2H13a1 1 0 010 2H8.42l-.44 2.196a1 1 0 01-1.96-.392L6.38 11H3a1 1 0 010-2h3.78l.4-2H3a1 1 0 110-2h4.58z"];
  init_define_process();
  var notifications_default = ["M8 16c1.1 0 2-.9 2-2H6c0 1.1.9 2 2 2zm6-5c-.55 0-1-.45-1-1V6c0-2.43-1.73-4.45-4.02-4.9 0-.04.02-.06.02-.1 0-.55-.45-1-1-1S7 .45 7 1c0 .04.02.06.02.1A4.992 4.992 0 003 6v4c0 .55-.45 1-1 1s-1 .45-1 1 .45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var notifications_snooze_default = ["M9 14c0 1.1-.9 2-2 2s-2-.9-2-2zM7 0c.404 0 .755.243.912.59L7.9.6c-.7.6-.9 1.36-.9 1.9 0 .8.267 1.433.8 1.9-.533.6-.795 1.222-.784 1.867l.004.358A2.8 2.8 0 009.82 9.4L12 9.399V10c0 .51.388.935.884.993L13 11c.55 0 1 .45 1 1s-.45 1-1 1H1c-.55 0-1-.45-1-1s.45-1 1-1 1-.45 1-1V6c0-2.43 1.73-4.45 4.02-4.9L6 1c0-.55.45-1 1-1z", "M13 6.702a.632.632 0 00-.632-.632h-1.743l2.208-2.734A.75.75 0 0013 2.864v-.3A.565.565 0 0012.435 2H9.561a.561.561 0 100 1.123h1.814L9.221 5.795A1 1 0 009 6.423v.279c0 .349.283.631.632.631h2.736A.632.632 0 0013 6.702z"];
  init_define_process();
  var notifications_updated_default = ["M8 16c1.1 0 2-.9 2-2H6c0 1.1.9 2 2 2zm3.399-13.667l-.413.412A2.99 2.99 0 009 1.99a3 3 0 00-3 2.99c0 .8.32 1.558.876 2.114l2.002 1.992A2.99 2.99 0 0013 9.184V10c0 .55.45 1 1 1s1 .45 1 1-.45 1-1 1H2c-.55 0-1-.45-1-1s.45-1 1-1 1-.45 1-1V6c0-2.43 1.73-4.45 4.02-4.9 0-.04-.02-.06-.02-.1 0-.55.45-1 1-1s1 .45 1 1c0 .04-.02.06-.02.1a4.97 4.97 0 012.419 1.233zM10.29 7.67l-2-1.99a.99.99 0 01-.29-.7 1 1 0 011-.99c.27 0 .52.11.7.29l1.29 1.29 3.28-3.28c.18-.18.42-.29.7-.29.55 0 1 .44 1 .99 0 .28-.11.52-.3.7l-3.98 3.98a.99.99 0 01-1.4 0z"];
  init_define_process();
  var numbered_list_default = ["M2.76 7h1.26V0h-.94c-.04.21-.12.39-.25.54-.13.15-.29.27-.48.36-.18.09-.39.16-.62.2-.23.04-.46.06-.71.06v.9h1.74V7zm-.59 7.17c.18-.12.37-.25.58-.37a10.763 10.763 0 001.24-.83c.2-.16.37-.33.52-.51.15-.19.28-.39.37-.61.09-.22.14-.47.14-.74 0-.22-.04-.45-.12-.7-.08-.26-.21-.49-.4-.69-.18-.21-.43-.39-.72-.52-.3-.14-.68-.21-1.12-.21-.41 0-.77.07-1.08.2-.32.14-.58.32-.8.56-.22.23-.38.51-.49.84-.11.32-.16.67-.16 1.05h1.19c.01-.24.03-.47.08-.67.05-.21.11-.39.21-.54.09-.15.22-.27.38-.36.16-.09.35-.13.59-.13.26 0 .47.04.63.12.16.08.29.18.38.3.09.12.15.25.18.39s.05.27.05.4c-.01.27-.08.5-.22.71-.14.21-.32.4-.53.57-.22.18-.45.34-.71.49-.26.15-.51.31-.74.47-.5.31-.89.68-1.17 1.11-.3.41-.44.91-.45 1.48h5v-1H1.43c.05-.15.14-.29.27-.43.14-.13.29-.26.47-.38zM15.01 1.99h-7c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h7c.55 0 1-.45 1-1v-1c0-.55-.44-1-1-1zm0 9h-7c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h7c.55 0 1-.45 1-1v-1c0-.55-.44-1-1-1z"];
  init_define_process();
  var numerical_default = ["M2.79 4.61c-.13.17-.29.3-.48.41-.18.11-.39.18-.62.23-.23.04-.46.07-.71.07v1.03h1.74V12h1.26V4h-.94c-.04.23-.12.44-.25.61zm4.37 5.31c.18-.14.37-.28.58-.42l.63-.45c.21-.16.41-.33.61-.51s.37-.38.52-.59c.15-.21.28-.45.37-.7.09-.25.13-.54.13-.85 0-.25-.04-.52-.12-.8-.07-.29-.2-.55-.39-.79a2.18 2.18 0 00-.73-.6c-.29-.15-.66-.23-1.11-.23-.41 0-.77.08-1.08.23-.31.16-.58.37-.79.64-.22.27-.38.59-.49.96-.11.37-.16.77-.16 1.2h1.19c.01-.27.03-.53.08-.77.04-.24.11-.45.21-.62.09-.18.22-.32.38-.42.16-.1.35-.15.59-.15.26 0 .47.05.63.14.15.09.28.21.37.35.09.14.15.29.18.45.03.16.05.31.05.45-.01.31-.08.58-.22.82-.14.23-.32.45-.53.65-.22.21-.46.39-.71.57-.26.18-.51.36-.75.54-.5.36-.89.78-1.17 1.27-.28.49-.43 1.06-.44 1.71h5v-1.15H6.43c.05-.17.14-.33.27-.49.13-.15.29-.29.46-.44zm8.5-1.56c-.23-.35-.54-.57-.95-.65v-.02c.34-.13.6-.34.76-.63.16-.29.24-.63.24-1.02 0-.34-.06-.64-.19-.9s-.3-.47-.51-.64c-.21-.17-.45-.3-.72-.38-.27-.09-.54-.13-.82-.13-.36 0-.68.07-.96.2-.28.13-.53.32-.72.55-.2.23-.36.51-.47.83-.11.32-.18.66-.19 1.04h1.15c-.01-.2.01-.39.06-.58.05-.19.12-.36.22-.51.1-.15.22-.27.37-.36.15-.09.32-.13.53-.13.32 0 .59.1.79.3.21.2.31.46.31.79 0 .23-.05.43-.14.59-.09.16-.21.29-.35.38-.15.09-.32.16-.51.19-.19.04-.38.05-.57.04v.93c.23-.01.45 0 .67.02.22.02.42.08.59.17.18.09.32.23.43.4.11.18.16.41.16.71 0 .44-.13.78-.39 1.02s-.58.36-.97.36c-.45 0-.79-.16-1.02-.47-.23-.31-.33-.7-.32-1.17H11c.01.4.06.77.17 1.1.11.33.26.61.47.85.21.23.46.42.77.54.31.13.67.19 1.08.19.34 0 .66-.05.96-.16.3-.11.57-.27.8-.47.23-.2.41-.45.55-.74.13-.27.2-.6.2-.97 0-.5-.11-.92-.34-1.27z"];
  init_define_process();
  var office_default = ["M15 5h-3V1c0-.55-.45-1-1-1H1C.45 0 0 .45 0 1v14c0 .55.45 1 1 1h3v-4h4v4h7c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zM5 10H2V7h3v3zm0-5H2V2h3v3zm5 5H7V7h3v3zm0-5H7V2h3v3zm4 9h-2v-2h2v2zm0-4h-2V7h2v3z"];
  init_define_process();
  var offline_default = ["M8 0C3.58 0 0 3.58 0 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zM6 14l1-5H4l6-7-1 5h3l-6 7z"];
  init_define_process();
  var oil_field_default = ["M15 14h-1.35l-3.34-7.51 2.46-.95 1.45 3.21c.09.2.36.3.6.23.1-.03.18-.08.24-.15.05-.08 1.23-1.56.87-4.2-.11-.79-.52-4.62-3.26-4.62-.93 0-1.68.62-1.67 1.37 0 .14.03.28.09.42l.87 1.92L.64 8.07v.01A.98.98 0 000 9c0 .55.45 1 1 1 .13 0 .25-.03.36-.07v.01l1.04-.4L3.67 14H2c-.55 0-1 .45-1 1s.45 1 1 1h13c.55 0 1-.45 1-1s-.45-1-1-1zM4.27 8.81L7.14 7.7 5.2 12.08l-.93-3.27zM6.54 14L9 8.46 11.46 14H6.54z"];
  init_define_process();
  var one_column_default = ["M11.99-.01h-3c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-14c0-.55-.45-1-1-1zm-6 5c-.28 0-.53.11-.71.29l-2 2a1.014 1.014 0 000 1.42l2 2a1.003 1.003 0 001.71-.71v-4c0-.55-.45-1-1-1z"];
  init_define_process();
  var one_to_many_default = ["M14 3a1 1 0 11-2 0 1 1 0 012 0zm-3.726 1.254a3 3 0 10-.17-2.039 5.467 5.467 0 00-.51.158c-1.076.394-2.237 1.242-2.575 2.93-.161.809-.664 1.211-1.293 1.443a3 3 0 100 2.508c.629.232 1.132.634 1.293 1.442.338 1.69 1.499 2.537 2.575 2.93.17.063.342.115.51.159a3.001 3.001 0 10.17-2.04c-.629-.231-1.132-.633-1.293-1.441C8.765 9.228 8.216 8.494 7.568 8c.648-.493 1.197-1.228 1.413-2.304.161-.808.664-1.21 1.293-1.442zM13 14a1 1 0 110-2 1 1 0 010 2zM4 8a1 1 0 10-2 0 1 1 0 002 0z"];
  init_define_process();
  var one_to_one_default = ["M2 8a1 1 0 112 0 1 1 0 01-2 0zm3.83-1a3.001 3.001 0 100 2h4.34a3.001 3.001 0 100-2H5.83zM13 7a1 1 0 100 2 1 1 0 000-2z"];
  init_define_process();
  var open_application_default = ["M5 0h10c.55 0 1 .45 1 1v10c0 .55-.45 1-1 1H8v-2h6V3H6v5H4V1c0-.55.45-1 1-1zm2.5 5h5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5h-5c-.28 0-.5.22-.5.5s.22.5.5.5zm0 2h2c.28 0 .5-.22.5-.5S9.78 6 9.5 6h-2c-.28 0-.5.22-.5.5s.22.5.5.5zM11 8.5c0 .28-.165.5-.375.5h-2.25C8.165 9 8 8.78 8 8.5s.165-.5.375-.5h2.25c.21 0 .375.22.375.5zM5 14c0 .55.45 1 1 1s1-.45 1-1v-4c0-.55-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1h1.59L.3 14.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L5 12.41V14z"];
  init_define_process();
  var outdated_default = ["M8 0c4.42 0 8 3.58 8 8 0 4.06-3.02 7.4-6.94 7.92-.02 0-.04.01-.06.01-.33.04-.66.07-1 .07-4.42 0-8-3.58-8-8 0-.55.45-1 1-1s1 .45 1 1c0 3.31 2.69 6 6 6 .71 0 1.37-.15 2-.38v.01c2.33-.82 4-3.02 4-5.63 0-3.31-2.69-6-6-6-1.78 0-3.36.78-4.46 2H5c.55 0 1 .45 1 1s-.45 1-1 1H1c-.55 0-1-.45-1-1V1c0-.55.45-1 1-1s1 .45 1 1v1.74A7.95 7.95 0 018 0zm1 12H7v-2h2v2zm0-3H7V4h2v5z"];
  init_define_process();
  var page_layout_default = ["M15 .95H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h14c.55 0 1-.45 1-1v-12c0-.55-.45-1-1-1zm-9 12H2v-6h4v6zm8 0H7v-6h7v6zm0-7H2v-3h12v3z"];
  init_define_process();
  var panel_stats_default = ["M10 4h3v1h-3zM10 6h3v1h-3zM10 8h3v1h-3zM10 10h3v1h-3z", "M15 1H1c-.6 0-1 .4-1 1v11c0 .6.4 1 1 1h14c.6 0 1-.4 1-1V2c0-.6-.4-1-1-1zM8 12H2V3h6v9zm6 0H9V3h5v9z"];
  init_define_process();
  var panel_table_default = ["M15 1H1c-.6 0-1 .4-1 1v11c0 .6.4 1 1 1h14c.6 0 1-.4 1-1V2c0-.6-.4-1-1-1zM8 9H6V7h2v2zm0-3H6V4h2v2zm-6 6V3h3v9H2zm4 0v-2h2v2H6zm8 0H9v-2h5v2zm0-3H9V7h5v2zm0-3H9V4h5v2z"];
  init_define_process();
  var paperclip_default = ["M14.68 2.31A4.54 4.54 0 0011.46.99c-1.15 0-2.31.44-3.19 1.32L.95 9.63c-.63.63-.95 1.46-.95 2.28a3.21 3.21 0 003.23 3.22c.83 0 1.66-.31 2.3-.95l7.31-7.32c.76-.77.76-1.98.01-2.73s-1.99-.76-2.75 0l-6.07 6.08c-.24.25-.24.65.01.9s.65.25.91.01l6.07-6.08c.25-.25.67-.25.91-.01.25.25.25.67 0 .92l-7.31 7.32c-.75.75-2.04.74-2.76.01-.75-.75-.73-2.02.01-2.76L9.2 3.21c1.24-1.24 3.35-1.26 4.58-.03 1.24 1.24 1.24 3.36 0 4.6l-7.12 7.13c-.24.25-.24.64.01.88.24.24.63.24.88.01v.01l7.13-7.13A4.41 4.41 0 0016 5.51c0-1.16-.44-2.32-1.32-3.2z"];
  init_define_process();
  var paragraph_default = ["M13 1H6C3.8 1 2 2.8 2 5s1.8 4 4 4v5c0 .6.4 1 1 1s1-.5 1-1V3h2v11c0 .6.4 1 1 1s1-.5 1-1V3h1c.5 0 1-.4 1-1s-.4-1-1-1z"];
  init_define_process();
  var path_default = ["M14.5 0h-13C.67 0 0 .67 0 1.5S.67 3 1.5 3H7v3H3.5C2.67 6 2 6.67 2 7.5S2.67 9 3.5 9H7v3H5.5c-.83 0-1.5.67-1.5 1.5S4.67 15 5.5 15h5c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5H9V9h3.5c.83 0 1.5-.67 1.5-1.5S13.33 6 12.5 6H9V3h5.5c.83 0 1.5-.67 1.5-1.5S15.33 0 14.5 0z"];
  init_define_process();
  var path_search_default = ["M15 14.62l-4-2.4V9.77c-.32.09-.66.15-1 .18v2.27l-4 2.4V8.71c-.38-.31-.72-.66-1-1.06v6.97l-4-2.4V8c.55 0 1-.45 1-1s-.45-1-1-1V1.38l3.15 1.89c.08-.34.18-.66.32-.97L.76.07v.01A.496.496 0 00.5 0C.22 0 0 .22 0 .5v12c0 .18.1.33.25.42v.01l5 3v-.01c.07.05.16.08.25.08s.18-.03.25-.08v.01l4.74-2.85 4.74 2.85v-.01c.09.05.18.08.27.08.28 0 .5-.22.5-.5v-3.78c-.3.17-.63.28-1 .28v2.62zM2 5c0 .55.45 1 1 1s1-.45 1-1-.45-1-1-1-1 .45-1 1zm6-1c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm7.75-.92l-1.19-.72c.18.43.29.9.36 1.38l.08.04v3.39l1 1V3.5c0-.18-.1-.33-.25-.42zM10 2c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm3.3 4.89c.44-.7.7-1.51.7-2.39C14 2.01 11.99 0 9.5 0S5 2.01 5 4.5 7.01 9 9.5 9c.88 0 1.69-.26 2.39-.7l2.41 2.41c.17.18.42.29.7.29a1.003 1.003 0 00.71-1.71l-2.41-2.4zM9.5 8C7.57 8 6 6.43 6 4.5S7.57 1 9.5 1 13 2.57 13 4.5 11.43 8 9.5 8z"];
  init_define_process();
  var pause_default = ["M6 3H4c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1h2c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1zm6 0h-2c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1h2c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var people_default = ["M13.69 13.98c-.05-.24-.14-.5-.25-.76-.36-.86-1.12-1.33-2.69-2-.14-.06-.59-.25-.6-.25-.21-.09-.36-.15-.5-.22.02-.1.02-.2.03-.31 0-.04.01-.08.01-.13-.07-.06-.13-.12-.19-.19.22-.32.4-.67.54-1.05.02-.06.02-.06.03-.1.29-.23.48-.57.59-.96.16-.33.25-.73.21-1.16-.03-.4-.16-.76-.37-1.03-.02-.53-.07-1.13-.15-1.54-.01-.06-.02-.12-.03-.19.23-.06.48-.09.72-.09.49 0 1.05.16 1.44.46.38.29.67.7.8 1.17.03.1.05.21.07.31.07.37.11.94.11 1.33v.05c.14.06.27.21.29.51.02.25-.07.45-.13.54-.05.21-.16.44-.38.48-.02.1-.05.2-.09.3 0 .01-.01.03-.01.03-.17.44-.43.83-.75 1.11v.14c.03.35-.09.59.83 1 .93.41 2.32.84 2.6 1.5.29.66.17 1.04.17 1.04h-2.3zm-1.17-.38c.37.86.22 1.36.22 1.36H.06s-.14-.5.22-1.36 2.13-1.43 3.31-1.96c1.17-.54 1.05-.86 1.09-1.3 0-.05.01-.11.01-.17-.41-.35-.75-.86-.97-1.45v-.01s-.01-.01-.01-.02c-.04-.12-.09-.26-.12-.39-.28-.05-.44-.36-.5-.64-.06-.12-.19-.39-.16-.71.04-.41.21-.6.39-.68v-.06c0-.51.05-1.26.14-1.74.02-.13.05-.27.09-.4.17-.6.54-1.13 1.02-1.51.5-.39 1.21-.6 1.84-.6s1.34.21 1.84.6c.48.38.85.91 1.02 1.52.04.13.07.27.09.4.09.48.14 1.22.14 1.73v.07c.18.08.34.27.37.67.03.32-.09.59-.16.71-.06.28-.21.58-.48.63-.03.13-.07.26-.12.39 0 .01-.01.04-.01.04-.22.58-.55 1.08-.95 1.45v.18c.04.45-.12.77 1.06 1.3 1.18.53 2.95 1.09 3.31 1.95z"];
  init_define_process();
  var percentage_default = ["M6 6V4c0-1.1-.9-2-2-2H3c-1.1 0-2 .9-2 2v2c0 1.1.9 2 2 2h1c1.1 0 2-.9 2-2zM3.5 6c-.28 0-.5-.22-.5-.5v-1c0-.28.22-.5.5-.5s.5.22.5.5v1c0 .28-.22.5-.5.5zM13 8h-1c-1.1 0-2 .9-2 2v2c0 1.1.9 2 2 2h1c1.1 0 2-.9 2-2v-2c0-1.1-.9-2-2-2zm0 3.5c0 .28-.22.5-.5.5s-.5-.22-.5-.5v-1c0-.28.22-.5.5-.5s.5.22.5.5v1zM12 3a1.003 1.003 0 00-1.87-.5l-5.99 9.98c-.09.15-.14.33-.14.52a1.003 1.003 0 001.87.5l5.99-9.98c.09-.15.14-.33.14-.52z"];
  init_define_process();
  var person_default = ["M15.68 14.32c-.46-1.05-2.68-1.75-4.16-2.4-1.48-.65-1.28-1.05-1.33-1.59-.01-.07-.01-.15-.01-.23.51-.45.92-1.07 1.19-1.78 0 0 .01-.04.02-.05.06-.15.11-.32.15-.48.34-.07.54-.44.61-.78.08-.14.23-.48.2-.87-.05-.5-.25-.73-.47-.82v-.09c0-.63-.06-1.55-.17-2.15A3.671 3.671 0 0010.32.72C9.68.25 8.79-.01 8-.01c-.79 0-1.68.25-2.31.73-.61.47-1.06 1.13-1.28 1.86-.05.17-.09.33-.11.5-.12.6-.17 1.51-.17 2.15v.08c-.24.09-.45.32-.5.83-.03.38.13.72.2.86.08.35.28.72.63.78.04.17.09.33.15.49 0 .01.01.02.01.03l.01.01c.27.72.7 1.35 1.22 1.8 0 .07-.01.14-.01.21-.05.54.1.94-1.37 1.59-1.48.65-3.7 1.35-4.16 2.4-.46 1.05-.27 1.67-.27 1.67h15.92c-.01.01.18-.61-.28-1.66z"];
  init_define_process();
  var phone_default = ["M15.9 12.41c-.06-.06-3.37-2-3.48-2.05a.794.794 0 00-.32-.08c-.15 0-.34.11-.57.32-.23.22-.94 1.19-1.15 1.4-.21.22-.38.32-.52.32-.07 0-.15-.02-.25-.06-.1-.04-1.16-.58-3.36-2.52-2.2-1.93-2.49-3.2-2.5-3.55 0-.14.11-.31.32-.52.22-.21.45-.41.7-.6.25-.19.49-.4.7-.62.22-.23.32-.42.32-.57 0-.11-.03-.21-.08-.32C5.66 3.46 3.66.15 3.59.08 3.44-.07 2.85 0 2.55.16.16 1.46-.03 3.2 0 3.89c.04.71.49 4.46 4.16 7.95C8.72 16.17 11.89 16 12.1 16c.69 0 2.82-.38 3.72-2.55.13-.32.25-.87.08-1.04z"];
  init_define_process();
  var pie_chart_default = ["M7 1.08c-3.37.5-5.97 3.4-5.97 6.92 0 3.87 3.13 7 6.98 7 3.52 0 6.42-2.61 6.91-6H7V1.08z", "M8 0v8h8c0-4.42-3.58-8-8-8z"];
  init_define_process();
  var pin_default = ["M9.41.92c-.51.51-.41 1.5.15 2.56L4.34 7.54C2.8 6.48 1.45 6.05.92 6.58l3.54 3.54-3.54 4.95 4.95-3.54 3.54 3.54c.53-.53.1-1.88-.96-3.42l4.06-5.22c1.06.56 2.04.66 2.55.15L9.41.92z"];
  init_define_process();
  var pivot_default = ["M4.57 7.02L.3 11.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l4.27-4.27c-.58-.35-1.07-.84-1.41-1.42zM15 8c-.55 0-1 .45-1 1v.59l-2.57-2.57c-.34.58-.83 1.07-1.41 1.41L12.59 11H12c-.55 0-1 .45-1 1s.45 1 1 1h3c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1zm-4-3c0-1.66-1.34-3-3-3S5 3.34 5 5s1.34 3 3 3 3-1.34 3-3zM8 6c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"];
  init_define_process();
  var pivot_table_default = ["M2 4H1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h1c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zm0-4H1C.45 0 0 .45 0 1v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm11.71 4.29C13.53 4.11 13.28 4 13 4s-.53.11-.71.29l-2 2a1.003 1.003 0 001.42 1.42l.29-.3V9c0 1.66-1.34 3-3 3H7.41l.29-.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-2 2c-.18.18-.29.43-.29.71 0 .28.11.53.29.71l2 2a1.003 1.003 0 001.42-1.42l-.3-.29H9c2.76 0 5-2.24 5-5V7.41l.29.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-2-2zM15 0H5c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var play_default = ["M12 8c0-.35-.19-.64-.46-.82l.01-.02-6-4-.01.02A.969.969 0 005 3c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1 .21 0 .39-.08.54-.18l.01.02 6-4-.01-.02c.27-.18.46-.47.46-.82z"];
  init_define_process();
  var playbook_default = ["M4.293.293a1 1 0 011.414 1.414L4.414 3l1.293 1.293a1 1 0 01-1.414 1.414L3 4.414 1.707 5.707A1 1 0 01.293 4.293L1.586 3 .293 1.707A1 1 0 011.707.293L3 1.586 4.293.293z", "M14.29 4.71L13 3.41V6a3 3 0 01-3 3H4a1 1 0 00-1 1v5a1 1 0 11-2 0v-5a3 3 0 013-3h6a1 1 0 001-1V3.41L9.71 4.7c-.18.19-.43.3-.71.3a1.003 1.003 0 01-.71-1.71l3-3c.18-.18.43-.29.71-.29.28 0 .53.11.71.29l3 3a1.003 1.003 0 01-1.42 1.42z", "M16 13a3 3 0 11-6 0 3 3 0 016 0zm-2 0a1 1 0 11-2 0 1 1 0 012 0z"];
  init_define_process();
  var plus_default = ["M13 7H9V3c0-.55-.45-1-1-1s-1 .45-1 1v4H3c-.55 0-1 .45-1 1s.45 1 1 1h4v4c0 .55.45 1 1 1s1-.45 1-1V9h4c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var polygon_filter_default = ["M14 5c-.24 0-.47.05-.68.13L9.97 2.34c.01-.11.03-.22.03-.34 0-1.1-.9-2-2-2S6 .9 6 2c0 .04.01.08.01.12L2.88 4.21C2.61 4.08 2.32 4 2 4 .9 4 0 4.9 0 6c0 .74.4 1.38 1 1.72v4.55c-.6.35-1 .99-1 1.73 0 1.1.9 2 2 2 .74 0 1.38-.4 1.72-1h4.55c.35.6.98 1 1.72 1 1.1 0 2-.9 2-2 0-.37-.11-.7-.28-1L14 9c1.11-.01 2-.9 2-2s-.9-2-2-2zm-4.01 7c-.73 0-1.37.41-1.71 1H3.73c-.18-.3-.43-.55-.73-.72V7.72c.6-.34 1-.98 1-1.72 0-.04-.01-.08-.01-.12l3.13-2.09c.27.13.56.21.88.21.24 0 .47-.05.68-.13l3.35 2.79c-.01.11-.03.22-.03.34 0 .37.11.7.28 1l-2.29 4z"];
  init_define_process();
  var power_default = ["M8 8c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1S7 .45 7 1v6c0 .55.45 1 1 1zm3-5.32v2.34c1.21.91 2 2.35 2 3.98 0 2.76-2.24 5-5 5s-5-2.24-5-5c0-1.63.79-3.06 2-3.98V2.68C2.64 3.81 1 6.21 1 9c0 3.87 3.13 7 7 7s7-3.13 7-7c0-2.79-1.64-5.19-4-6.32z"];
  init_define_process();
  var predictive_analysis_default = ["M16 6.41c0-1.01-.49-1.94-1.29-2.49-.43-1.92-2.07-3.28-4-3.28-.46 0-.92.08-1.35.24C8.83.31 8.11 0 7.34 0c-.9 0-1.74.44-2.28 1.16-.12-.01-.24-.02-.36-.02-1.31 0-2.42.89-2.77 2.17C.78 3.72 0 4.84 0 6.13c0 .38.07.76.21 1.12C.07 7.6 0 7.98 0 8.36c0 1.11.58 2.11 1.51 2.63.54.56 1.27.87 2.03.87.49 0 .95-.12 1.37-.36a2.85 2.85 0 002.18 1.04c.52 0 1.03-.14 1.47-.42.49.39 1.07.65 1.69.73 1.04 1.15 1.84 2.63 1.84 2.64 0 0 .28.49.26.49.77 0 1.41-.16 1.32-1.04 0 .02-.73-2.31-.73-2.31.41-.21.75-.55.97-.98.9-.52 1.47-1.53 1.47-2.61 0-.24-.03-.48-.08-.71.45-.52.7-1.21.7-1.92zm-1.23 1.02l-.15-.16-.61-.67c-.27-.29-.54-.94-.58-1.39l-.1-1.01c-.05-.59-.94-.58-.91.11 0 .02.1 1.01.1 1.01.03.29.12.62.24.93-.06-.01-.12-.02-.18-.02 0 0-2.06-.1-2.05-.11-.58-.02-.71.97-.04 1l2.05.11c.42.02 1.04.3 1.29.58l.49.54.02.05c.08.21.12.44.12.66 0 .74-.41 1.41-1.07 1.75l-.16.08-.07.18c-.15.38-.48.66-.88.74l-.54.11.7 2.2c-.38-.61-.95-1.43-1.62-2.14l-.12-.13-.17-.01c-.41-.03-.8-.17-1.14-.38l1.36-1.18c.35-.31.83-.44.99-.39 0 0 .63.17.62.18.63.16.83-.74.23-.97l-.62-.18c-.55-.16-1.33.18-1.79.58l-1.53 1.33-.31.26c-.35.29-.75.44-1.2.44-.64 0-1.23-.33-1.58-.86V9.15c0-.4.17-.79.27-.85 0 0 .52-.34.51-.35.71-.53.18-1.23-.49-.89 0-.01-.52.35-.52.35-.26.15-.45.44-.58.77-.11-.11-.22-.2-.34-.28 0 0-1.53-1.01-1.53-1.02-.65-.45-1.2.51-.49.89 0-.01 1.51 1.02 1.51 1.02.37.24.62.78.62 1.09v.67c-.34.19-.63.29-.99.29-.54 0-1.05-.23-1.41-.63l-.05-.06-.07-.04c-.65-.34-1.05-1-1.05-1.73 0-.3.07-.6.2-.87l.12-.25L1.15 7c-.13-.27-.2-.56-.2-.87 0-.9.61-1.68 1.48-1.89l.31-.08.05-.34a1.926 1.926 0 012.38-1.58l.32.08.18-.31c.35-.6.99-.97 1.67-.97.44 0 .86.15 1.2.42l-.36.36v-.01l-.25.26c-.33.27-.74.42-.89.4 0 0-.67-.1-.67-.11-.67-.13-.87.86-.14 1.02.01 0 .67.11.67.11.02 0 .05 0 .07.01-.11.37-.15.77-.1 1.12 0 0 .17.99.15.99.11.52 1.06.36.93-.18 0-.01-.15-.99-.15-.99-.05-.37.12-.94.36-1.19l.39-.4c.05-.05.1-.09.15-.14l.74-.76c.4-.18.83-.27 1.27-.27 1.55 0 2.86 1.12 3.11 2.67l.04.25.21.12c.61.35.98 1 .98 1.7 0 .36-.1.7-.28 1.01z"];
  init_define_process();
  var prescription_default = ["M10.91 8.34c.14-.21.36-.34.63-.34h1.29c.22 0 .41.07.52.26.09.16.08.33-.04.53l-2.49 2.87 2.77 3.54c.12.17.14.37.02.55-.11.17-.3.25-.5.25h-1.44a.69.69 0 01-.61-.35L9.4 13.51l-1.69 2.15c-.13.21-.36.34-.63.34H5.8c-.22 0-.41-.07-.52-.26-.09-.16-.08-.33.04-.53l2.71-3.48L4.3 6.99H3.03v3.47c0 .33-.26.56-.62.56h-.8c-.35-.01-.61-.23-.61-.56V.56c0-.33.26-.56.62-.56h3.11c.62 0 1.19.08 1.7.24.51.16.96.39 1.34.69a3.194 3.194 0 011.21 2.53c0 .81-.25 1.5-.74 2.08-.37.44-.84.77-1.42 1.01L7.88 7.9c.04.04.07.08.08.1l1.49 1.9 1.46-1.56zM5.18 5c.62 0 1.08-.13 1.39-.37.29-.23.44-.71.44-1.16s-.15-.87-.44-1.1C6.26 2.12 5.8 2 5.18 2H2.99v3h2.19z"];
  init_define_process();
  var presentation_default = ["M15 1H9c0-.55-.45-1-1-1S7 .45 7 1H1c-.55 0-1 .45-1 1s.45 1 1 1v8c0 .55.45 1 1 1h3.59L3.3 14.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L7 13.41V15c0 .55.45 1 1 1s1-.45 1-1v-1.59l2.29 2.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L10.41 12H14c.55 0 1-.45 1-1V3c.55 0 1-.45 1-1s-.45-1-1-1zm-2 9H3V3h10v7z"];
  init_define_process();
  var print_default = ["M12 2.02c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1v1h8v-1zm3 2H1c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h1v-3h12v3h1c.55 0 1-.45 1-1v-6c0-.56-.45-1-1-1zm-1 3h-2v-1h2v1zm-3 6H5v-3H3v4c0 .55.45 1 1 1h8c.55 0 1-.45 1-1v-4h-2v3z"];
  init_define_process();
  var projects_default = ["M14 3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v1h12V3zm-2-3H4c-.55 0-1 .45-1 1h10c0-.55-.45-1-1-1zm3 5H1c-.55 0-1 .45-1 1v9c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm-3 6c0 .55-.45 1-1 1H5c-.55 0-1-.45-1-1V9h1v2h6V9h1v2z"];
  init_define_process();
  var properties_default = ["M2 6C.9 6 0 6.9 0 8s.9 2 2 2 2-.9 2-2-.9-2-2-2zm4-3h9c.55 0 1-.45 1-1s-.45-1-1-1H6c-.55 0-1 .45-1 1s.45 1 1 1zm-4 9c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm13-5H6c-.55 0-1 .45-1 1s.45 1 1 1h9c.55 0 1-.45 1-1s-.45-1-1-1zm0 6H6c-.55 0-1 .45-1 1s.45 1 1 1h9c.55 0 1-.45 1-1s-.45-1-1-1zM2 0C.9 0 0 .9 0 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"];
  init_define_process();
  var property_default = ["M3 12c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-.5-6.5a2.5 2.5 0 000 5 2.5 2.5 0 000-5zM7 3h8c.55 0 1-.45 1-1s-.45-1-1-1H7c-.55 0-1 .45-1 1s.45 1 1 1zm8 10H7c-.55 0-1 .45-1 1s.45 1 1 1h8c.55 0 1-.45 1-1s-.45-1-1-1zM3 0C1.9 0 1 .9 1 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 6H7c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h8c.55 0 1-.45 1-1V7c0-.55-.45-1-1-1z"];
  init_define_process();
  var publish_function_default = ["M12.16 3.76c.15-.11.3-.16.47-.16.06 0 .17.02.34.06.16.04.31.06.43.06a.58.58 0 00.6-.6c0-.19-.06-.33-.17-.44-.11-.11-.28-.16-.49-.16-.19 0-.37.04-.54.13-.17.09-.39.27-.65.55-.2.21-.48.58-.87 1.11a5.22 5.22 0 00-.78-1.79l-2.05.32-.04.21c.15-.03.28-.04.39-.04.2 0 .37.08.5.25.21.26.5 1.03.88 2.33-.29.36-.49.6-.6.71-.18.19-.33.31-.45.36-.09.04-.19.07-.3.07-.09 0-.23-.04-.42-.13a.904.904 0 00-.36-.09c-.2 0-.36.06-.49.18a.59.59 0 00-.19.46c0 .18.06.32.18.43.12.11.28.16.48.16.2 0 .38-.04.55-.12.17-.08.39-.24.65-.49s.62-.65 1.07-1.19c.18.52.33.89.46 1.13.13.24.28.4.44.51.17.1.37.16.62.16.24 0 .49-.08.74-.25.33-.21.66-.58 1.01-1.09l-.21-.11c-.23.31-.41.5-.52.57a.44.44 0 01-.26.07c-.12 0-.24-.07-.36-.21-.2-.24-.46-.91-.8-2 .29-.49.54-.81.74-.96zM6.37 5.83l.68-2.53h.83l.2-.64h-.84c.24-.91.56-1.59.96-2.01.24-.27.48-.4.71-.4.05 0 .08.01.11.04s.04.06.04.1c0 .04-.03.11-.1.21-.06.1-.1.2-.1.29 0 .13.05.24.15.33.1.09.23.14.39.14.17 0 .31-.06.42-.17.12-.12.18-.27.18-.46 0-.21-.08-.39-.25-.52C9.57.07 9.3 0 8.93 0c-.59 0-1.12.16-1.59.48-.48.32-.93.85-1.36 1.59-.15.26-.29.42-.42.49s-.35.11-.64.1l-.19.65h.81L4.35 7.68c-.2.72-.33 1.16-.4 1.33-.1.24-.26.45-.46.62a.48.48 0 01-.31.1c-.03 0-.06-.01-.08-.03l-.03-.03c0-.02.03-.06.09-.11.06-.06.09-.15.09-.26 0-.13-.05-.23-.14-.32-.1-.09-.23-.13-.41-.13-.21 0-.38.05-.51.16A.52.52 0 002 9.4c0 .16.08.3.23.42.16.12.4.18.74.18.53 0 .99-.13 1.4-.39.41-.26.76-.65 1.07-1.19.3-.53.61-1.39.93-2.59zm2.34 3.46A.997.997 0 008 9c-.28 0-.53.11-.71.29l-2 2a1.003 1.003 0 001.42 1.42l.29-.3V15c0 .55.45 1 1 1s1-.45 1-1v-2.59l.29.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-2-2z"];
  init_define_process();
  var pulse_default = ["M15 8h-1.46l-1.7-2.55-.02.01A.984.984 0 0011 5c-.43 0-.79.27-.93.65h-.01l-1.69 4.51-1.38-8.32h-.02A.989.989 0 006 1c-.41 0-.77.25-.92.61L2.34 8H1c-.55 0-1 .45-1 1s.45 1 1 1h2c.41 0 .77-.25.92-.61l1.65-3.86 1.44 8.63h.02c.08.47.47.84.97.84.43 0 .79-.27.93-.65h.01l2.31-6.17.92 1.38.02-.01c.17.26.46.45.81.45h2c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var rain_default = ["M3.5 8a2.5 2.5 0 11.608-4.926 4.002 4.002 0 017.381-1.03A3 3 0 1112 8H3.501zM3 10a1 1 0 012 0v4a1 1 0 11-2 0v-4zm7-1a1 1 0 00-1 1v5a1 1 0 102 0v-5a1 1 0 00-1-1zm2 1a1 1 0 112 0v2a1 1 0 11-2 0v-2zM7 9a1 1 0 00-1 1v2a1 1 0 102 0v-2a1 1 0 00-1-1z"];
  init_define_process();
  var random_default = ["M11.48 4h1.11l-.29.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l2-2c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71l-2-2a1.003 1.003 0 00-1.42 1.42l.3.29H11c-.32 0-.59.16-.77.38l-.01-.01L8.28 4.8l1.28 1.6L11.48 4zm2.23 6.29a1.003 1.003 0 00-1.42 1.42l.3.29h-1.11l-7.7-9.62h-.01A.996.996 0 003 2H1c-.55 0-1 .45-1 1s.45 1 1 1h1.52l7.7 9.62.01-.01c.18.23.45.39.77.39h1.59l-.29.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l2-2c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71l-2-2zM2.52 12H1c-.55 0-1 .45-1 1s.45 1 1 1h2c.32 0 .59-.16.77-.38l.01.01 1.94-2.42L4.44 9.6 2.52 12z"];
  init_define_process();
  var record_default = ["M8 3a5 5 0 100 10A5 5 0 108 3z"];
  init_define_process();
  var rect_height_default = ["M3 15V1h10v14H3zm0 1a1 1 0 01-1-1V1a1 1 0 011-1h10a1 1 0 011 1v14a1 1 0 01-1 1H3zM8.707 3.293a1 1 0 00-1.414 0l-2 2a1 1 0 001.414 1.414L8 5.414l1.293 1.293a1 1 0 001.414-1.414l-2-2zm-2 6a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l2-2a1 1 0 00-1.414-1.414L8 10.586 6.707 9.293z"];
  init_define_process();
  var rect_width_default = ["M1 3h14v10H1V3zM0 3a1 1 0 011-1h14a1 1 0 011 1v10a1 1 0 01-1 1H1a1 1 0 01-1-1V3zm10.707 2.293a1 1 0 00-1.414 1.414L10.586 8 9.293 9.293a1 1 0 001.414 1.414l2-2a1 1 0 000-1.414l-2-2zm-4 1.414a1 1 0 00-1.414-1.414l-2 2a1 1 0 000 1.414l2 2a1 1 0 001.414-1.414L5.414 8l1.293-1.293z"];
  init_define_process();
  var rectangle_default = ["M1 3h14c.55 0 1 .45 1 1v8c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1zm1 2v6h12V5H2z"];
  init_define_process();
  var redo_default = ["M12 11c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm3.71-6.71l-3-3a1.003 1.003 0 00-1.42 1.42L12.59 4H5C2.24 4 0 6.24 0 9s2.24 5 5 5h4v-2H5c-1.66 0-3-1.34-3-3s1.34-3 3-3h7.59L11.3 7.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71z"];
  init_define_process();
  var refresh_default = ["M14.99 6.99c-.55 0-1 .45-1 1 0 3.31-2.69 6-6 6-1.77 0-3.36-.78-4.46-2h1.46c.55 0 1-.45 1-1s-.45-1-1-1h-4c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1s1-.45 1-1v-1.74a7.95 7.95 0 006 2.74c4.42 0 8-3.58 8-8 0-.55-.45-1-1-1zm0-7c-.55 0-1 .45-1 1v1.74a7.95 7.95 0 00-6-2.74c-4.42 0-8 3.58-8 8 0 .55.45 1 1 1s1-.45 1-1c0-3.31 2.69-6 6-6 1.77 0 3.36.78 4.46 2h-1.46c-.55 0-1 .45-1 1s.45 1 1 1h4c.55 0 1-.45 1-1v-4c0-.55-.45-1-1-1z"];
  init_define_process();
  var regex_default = ["M0 14a2 2 0 114 0 2 2 0 01-4 0zM11 0a1 1 0 00-1 1v2.768L7.603 2.384a1 1 0 10-1 1.732L9 5.5 6.603 6.884a1 1 0 001 1.732L10 7.232V10a1 1 0 102 0V7.232l2.397 1.384a1 1 0 101-1.732L13 5.5l2.397-1.384a1 1 0 10-1-1.732L12 3.768V1a1 1 0 00-1-1z"];
  init_define_process();
  var regression_chart_default = ["M13 6.5c0 .83.67 1.5 1.5 1.5S16 7.33 16 6.5 15.33 5 14.5 5 13 5.67 13 6.5zM8.5 5c.83 0 1.5-.67 1.5-1.5S9.33 2 8.5 2 7 2.67 7 3.5 7.67 5 8.5 5zM9 9.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5S11.33 8 10.5 8 9 8.67 9 9.5zM4.5 8C5.33 8 6 7.33 6 6.5S5.33 5 4.5 5 3 5.67 3 6.5 3.67 8 4.5 8zM15 12H3.26l12.03-8.59-.58-.81L2 11.67V3c0-.55-.45-1-1-1s-1 .45-1 1v10c0 .55.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var remove_default = ["M10.99 6.99h-6c-.55 0-1 .45-1 1s.45 1 1 1h6c.55 0 1-.45 1-1s-.45-1-1-1zm-3-7c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.68 6-6 6z"];
  init_define_process();
  var remove_column_default = ["M14 0H4c-.55 0-1 .45-1 1v3h2V2h3v12H5v-2H3v3c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 14h-3V2h3v12zm-8.71-3.29a1.003 1.003 0 001.42-1.42L4.41 8 5.7 6.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L3 6.59l-1.29-1.3A1.003 1.003 0 00.29 6.71L1.59 8 .29 9.29a1.003 1.003 0 001.42 1.42L3 9.41l1.29 1.3z"];
  init_define_process();
  var remove_column_left_default = ["M4 9h4c.55 0 1-.45 1-1s-.45-1-1-1H4c-.55 0-1 .45-1 1s.45 1 1 1zm11-9H1C.45 0 0 .45 0 1v14c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-5 14H2V2h8v12zm4 0h-3V2h3v12z"];
  init_define_process();
  var remove_column_right_default = ["M15 0H1C.45 0 0 .45 0 1v14c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zM5 14H2V2h3v12zm9 0H6V2h8v12zM8 9h4c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1s.45 1 1 1z"];
  init_define_process();
  var remove_row_bottom_default = ["M15 0H1C.45 0 0 .45 0 1v14c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 14H2V6h12v8zm0-9H2V2h12v3zm-8 6h4c.55 0 1-.45 1-1s-.45-1-1-1H6c-.55 0-1 .45-1 1s.45 1 1 1z"];
  init_define_process();
  var remove_row_top_default = ["M15 0H1C.45 0 0 .45 0 1v14c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 14H2v-3h12v3zm0-4H2V2h12v8zM6 7h4c.55 0 1-.45 1-1s-.45-1-1-1H6c-.55 0-1 .45-1 1s.45 1 1 1z"];
  init_define_process();
  var repeat_default = ["M10 5c0 .55.45 1 1 1h4c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1s-1 .45-1 1v1.74A7.95 7.95 0 008 0C3.58 0 0 3.58 0 8c0 4.06 3.02 7.4 6.94 7.92.02 0 .04.01.06.01.33.04.66.07 1 .07 4.42 0 8-3.58 8-8 0-.55-.45-1-1-1s-1 .45-1 1c0 3.31-2.69 6-6 6-.71 0-1.37-.15-2-.38v.01C3.67 12.81 2 10.61 2 8c0-3.31 2.69-6 6-6 1.77 0 3.36.78 4.46 2H11c-.55 0-1 .45-1 1z"];
  init_define_process();
  var reset_default = ["M6 5c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V1c0-.55.45-1 1-1s1 .45 1 1v1.74A7.95 7.95 0 018 0c4.42 0 8 3.58 8 8 0 4.06-3.02 7.4-6.94 7.92-.02 0-.04.01-.06.01-.33.04-.66.07-1 .07-4.42 0-8-3.58-8-8 0-.55.45-1 1-1s1 .45 1 1c0 3.31 2.69 6 6 6 .71 0 1.37-.15 2-.38v.01c2.33-.82 4-3.02 4-5.63 0-3.31-2.69-6-6-6-1.77 0-3.36.78-4.46 2H5c.55 0 1 .45 1 1z"];
  init_define_process();
  var resolve_default = ["M6.6 3.3C6.1 3.1 5.6 3 5 3 2.2 3 0 5.2 0 8s2.2 5 5 5c.6 0 1.1-.1 1.6-.3C5.3 11.6 4.5 9.9 4.5 8s.8-3.6 2.1-4.7zM8 4c-1.2.9-2 2.4-2 4s.8 3.1 2 4c1.2-.9 2-2.3 2-4s-.8-3.1-2-4zm3-1c-.6 0-1.1.1-1.6.3 1.3 1.2 2.1 2.9 2.1 4.7s-.8 3.6-2.1 4.7c.5.2 1 .3 1.6.3 2.8 0 5-2.2 5-5s-2.2-5-5-5z"];
  init_define_process();
  var rig_default = ["M5.71 3c0 1.1.96 2 2.14 2C9.04 5 10 3.96 10 3c0-1.96-1.47-3-2.14-3H5c0 1.96 2.68 1.4.71 3zm2.5 3l.01.01s0-.01-.01-.01zm6.5 8.29L10 9.59V7c0-.55-.45-1-1-1H7c-.55 0-1 .45-1 1v2.58l-4.71 4.7c-.18.19-.29.44-.29.72a1.003 1.003 0 001.71.71L6 12.42V15c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-2.58l3.29 3.29a1.003 1.003 0 001.42-1.42z"];
  init_define_process();
  var right_join_default = ["M6.6 3.3C5.3 4.4 4.5 6.1 4.5 8s.8 3.6 2.1 4.7c-.5.2-1 .3-1.6.3-2.8 0-5-2.2-5-5s2.2-5 5-5c.6 0 1.1.1 1.6.3zm-1.96 8.68C3.92 10.83 3.5 9.46 3.5 8s.42-2.83 1.14-3.98C2.6 4.2 1 5.91 1 8s1.6 3.8 3.64 3.98zM8 4c-1.2.9-2 2.4-2 4s.8 3.1 2 4c1.2-.9 2-2.3 2-4s-.8-3.1-2-4zm3-1c2.8 0 5 2.2 5 5s-2.2 5-5 5c-.6 0-1.1-.1-1.6-.3 1.3-1.1 2.1-2.9 2.1-4.7s-.8-3.5-2.1-4.7c.5-.2 1-.3 1.6-.3z"];
  init_define_process();
  var ring_default = ["M8 0C3.58 0 0 3.58 0 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 12c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"];
  init_define_process();
  var rocket_default = ["M6 12C4.397 7.46 4.415 4.465 8 0c3.585 4.485 3.602 7.48 2 12H6zm3-7a1 1 0 11-2 0 1 1 0 012 0zm-7 8.022l3-1-.054-.158C4.636 10.954 4.076 9.317 4 8L3 9l-1 4.022zm9-1l3 1L13 9l-1-1c-.076 1.317-.635 2.954-.946 3.864l-.054.158zM7 13h2c0 1.5-.5 2.5-1 3-.5-.5-1-1.5-1-3z"];
  init_define_process();
  var rocket_slant_default = ["M3.992 10c2-5 5-9 11-9 0 6-4 9-9 11l-2-2zm7.714-4.285a1 1 0 11-1.414-1.414 1 1 0 011.414 1.414zm-6.555-.218L2.992 6l-3 2L3.24 9.195c.542-1.301 1.166-2.556 1.911-3.698zM7.992 16l-1.236-3.232c1.3-.539 2.552-1.158 3.694-1.898L9.992 13l-2 3zm-4.931-4.94L5 13c-.992.991-2.186 1.154-3.001 1-.154-.815.07-1.948 1.06-2.94z"];
  init_define_process();
  var rotate_document_default = ["M12 2h-1.59l.29-.29c.19-.18.3-.43.3-.71A1.003 1.003 0 009.29.29l-2 2C7.11 2.47 7 2.72 7 3c0 .28.11.53.29.71l2 2a1.003 1.003 0 001.42-1.42l-.3-.29H12c.55 0 1 .45 1 1v3c0 .55.45 1 1 1s1-.45 1-1V5c0-1.66-1.34-3-3-3zM5.71 5.29A.997.997 0 005 5H1c-.55 0-1 .45-1 1v9c0 .55.45 1 1 1h7c.55 0 1-.45 1-1V9c0-.28-.11-.53-.29-.71l-3-3zM7 14H2V7h2v2c0 .55.45 1 1 1h2v4z"];
  init_define_process();
  var rotate_page_default = ["M8 6H2c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1h6c.55 0 1-.45 1-1V7c0-.55-.45-1-1-1zm-1 8H3V8h4v6zm5-12h-1.59l.29-.29c.19-.18.3-.43.3-.71A1.003 1.003 0 009.29.29l-2 2C7.11 2.47 7 2.72 7 3c0 .28.11.53.29.71l2 2a1.003 1.003 0 001.42-1.42l-.3-.29H12c.55 0 1 .45 1 1v3c0 .55.45 1 1 1s1-.45 1-1V5c0-1.66-1.34-3-3-3z"];
  init_define_process();
  var route_default = ["M11.669 5.066l.099.189c.113.213.236.434.367.661.226.39.468.78.709 1.151l-.198-.004-.48-.004c-1.745.003-2.369.233-2.369.688 0 .053.226.19 1.038.436l.84.24C13.9 9.064 15 9.83 15 11.63c0 2.123-1.607 3.122-4.027 3.366-.651.065-1.266.075-2.043.05l-.958-.035H5.196l.268-.406c.336-.517.672-1.052.998-1.593h1.636l.572.023c.857.036 1.475.034 2.103-.03 1.526-.153 2.227-.59 2.227-1.375 0-.531-.402-.84-1.66-1.22l-.691-.198c-1.04-.293-1.764-.562-2.222-.946C8.8 8.366 9 7.612 9 6.997a5.03 5.03 0 00-.184-1.334c.645-.395 1.598-.562 2.853-.597zM4 3a4.007 4.007 0 014 3.997C8 9.21 4 15 4 15l-.416-.62C2.56 12.827 0 8.767 0 6.997A4.002 4.002 0 014 3zm0 2a2 2 0 10.001 4.001A2 2 0 004 5zm10-4c1.103 0 1.996.896 2 1.999C16 4.105 14 7 14 7l-.293-.44C13.15 5.707 12 3.838 12 2.999 12 1.896 12.897 1 14 1z"];
  init_define_process();
  var satellite_default = ["M3 9c0-.6.4-1 1-1s1 .4 1 1c0 1.1.9 2 2 2 .6 0 1 .4 1 1s-.4 1-1 1c-2.2 0-4-1.8-4-4zM0 9c0-.6.4-1 1-1s1 .4 1 1c0 2.8 2.2 5 5 5 .6 0 1 .4 1 1s-.4 1-1 1c-3.9 0-7-3.1-7-7zm7 1c-.6 0-1-.4-1-1s.4-1 1-1 1 .4 1 1-.4 1-1 1zm1.3-2.8c-.4-.4-.4-1 0-1.4l4.5-4.5c.4-.4 1-.4 1.4 0l.5.5c.4.4.4 1 0 1.4l-4.5 4.5c-.4.4-1 .4-1.4 0l-.5-.5zM5.2.3c.4-.4 1-.4 1.4 0l2.1 2.1c.4.4.4 1 0 1.4l-.9.9c-.4.4-1 .4-1.4 0L4.3 2.6c-.4-.4-.4-1 0-1.4l.9-.9zm7 7c.4-.4 1-.4 1.4 0l2.1 2.1c.4.4.4 1 0 1.4l-.9.9c-.4.4-1 .4-1.4 0l-2.1-2.1c-.4-.4-.4-1 0-1.4l.9-.9z"];
  init_define_process();
  var saved_default = ["M6.71 9.29a1.003 1.003 0 00-1.42 1.42l2 2a.997.997 0 001.6-.27h.01l2-4h-.01c.06-.13.11-.28.11-.44 0-.55-.45-1-1-1-.39 0-.72.23-.89.56H9.1l-1.38 2.76-1.01-1.03zM9 0H3c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V5L9 0zm3 14H4V2h4v4h4v8z"];
  init_define_process();
  var scatter_plot_default = ["M15 12H2V3c0-.55-.45-1-1-1s-1 .45-1 1v10c0 .55.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zm-.5-7c.83 0 1.5-.67 1.5-1.5S15.33 2 14.5 2 13 2.67 13 3.5 13.67 5 14.5 5zm-3 4c.83 0 1.5-.67 1.5-1.5S12.33 6 11.5 6 10 6.67 10 7.5 10.67 9 11.5 9zm-4-2C8.33 7 9 6.33 9 5.5S8.33 4 7.5 4 6 4.67 6 5.5 6.67 7 7.5 7zm-3 4c.83 0 1.5-.67 1.5-1.5S5.33 8 4.5 8 3 8.67 3 9.5 3.67 11 4.5 11z"];
  init_define_process();
  var search_default = ["M15.55 13.43l-2.67-2.68a6.94 6.94 0 001.11-3.76c0-3.87-3.13-7-7-7s-7 3.13-7 7 3.13 7 7 7c1.39 0 2.68-.42 3.76-1.11l2.68 2.67a1.498 1.498 0 102.12-2.12zm-8.56-1.44c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"];
  init_define_process();
  var search_around_default = ["M13.5 11c-.51 0-.98.15-1.38.42l-2.4-2.41c.17-.3.28-.64.28-1.01s-.11-.71-.28-1.01l2.41-2.41c.39.27.86.42 1.37.42a2.5 2.5 0 000-5A2.5 2.5 0 0011 2.5c0 .51.15.98.42 1.38l-2.41 2.4C8.71 6.11 8.37 6 8 6s-.71.11-1.01.28l-2.41-2.4c.27-.4.42-.87.42-1.38a2.5 2.5 0 00-5 0A2.5 2.5 0 002.5 5c.51 0 .98-.15 1.38-.42l2.41 2.41C6.11 7.29 6 7.63 6 8s.11.71.28 1.01l-2.41 2.41c-.39-.27-.86-.42-1.37-.42a2.5 2.5 0 000 5A2.5 2.5 0 005 13.5c0-.51-.15-.98-.42-1.38l2.41-2.41c.3.18.64.29 1.01.29s.71-.11 1.01-.28l2.41 2.41c-.27.39-.42.86-.42 1.37a2.5 2.5 0 005 0 2.5 2.5 0 00-2.5-2.5zm0-10c.83 0 1.5.67 1.5 1.5S14.33 4 13.5 4 12 3.33 12 2.5 12.67 1 13.5 1zm-11 3C1.67 4 1 3.33 1 2.5S1.67 1 2.5 1 4 1.67 4 2.5 3.33 4 2.5 4zm0 11c-.83 0-1.5-.67-1.5-1.5S1.67 12 2.5 12s1.5.67 1.5 1.5S3.33 15 2.5 15zm11 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"];
  init_define_process();
  var search_template_default = ["M15.55 13.43l-2.67-2.67c.7-1.09 1.11-2.38 1.11-3.77 0-3.87-3.13-7-7-7s-7 3.13-7 7 3.13 7 7 7c1.39 0 2.68-.41 3.77-1.11l2.67 2.67a1.498 1.498 0 102.12-2.12zm-8.56-1.44c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm2.5-6h-5c-.28 0-.5.22-.5.5s.22.5.5.5h5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5zm0-2h-5c-.28 0-.5.22-.5.5s.22.5.5.5h5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5zm0 4h-5c-.28 0-.5.22-.5.5s.22.5.5.5h5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5z"];
  init_define_process();
  var search_text_default = ["M9 4H5c-.55 0-1 .45-1 1s.45 1 1 1h1v3c0 .55.45 1 1 1s1-.45 1-1V6h1c.55 0 1-.45 1-1s-.45-1-1-1zm6.56 9.44l-2.67-2.67C13.59 9.68 14 8.39 14 7c0-3.87-3.13-7-7-7S0 3.13 0 7s3.13 7 7 7c1.39 0 2.68-.41 3.77-1.11l2.67 2.67a1.498 1.498 0 102.12-2.12zM7 12c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"];
  init_define_process();
  var segmented_control_default = ["M15 4H1c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zm-1 6H8V6h6v4z"];
  init_define_process();
  var select_default = ["M16 15c0-.28-.12-.52-.31-.69l.02-.02-3.12-3.12 3.41-.84-8.05-2.86c.03-.09.05-.17.05-.27V2c0-.55-.45-1-1-1H3c0-.55-.45-1-1-1S1 .45 1 1c-.55 0-1 .45-1 1s.45 1 1 1v4c0 .55.45 1 1 1h5.2c.1 0 .18-.02.27-.05L10.33 16l.85-3.41 3.12 3.12.02-.02c.16.19.4.31.68.31.04 0 .07-.02.1-.02s.06.02.1.02c.44 0 .8-.36.8-.8 0-.04-.02-.07-.02-.1s.02-.06.02-.1zM6 6H3V3h3v3z"];
  init_define_process();
  var selection_default = ["M8 0C3.58 0 0 3.58 0 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zm0-9C6.34 5 5 6.34 5 8s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"];
  init_define_process();
  var send_message_default = ["M15.399 9.01L1.527 15.875c-.535.267-1.175.081-1.421-.427A.953.953 0 010 15V10l8-2-8-2V1c0-.528.407-1 1.004-1 .169 0 .416.04.567.116L15.403 7.07a1.084 1.084 0 01-.005 1.939z"];
  init_define_process();
  var send_to_default = ["M15 7.5c-.8 0-1.5-.4-2-1l-1.2 1.2c-.4.5-1.1.7-1.8.7-1.4.1-2.5-1-2.5-2.4 0-.7.3-1.3.7-1.8L9.5 3c-.6-.5-1-1.2-1-2 0-.3.1-.7.2-1H8C3.6 0 0 3.6 0 8s3.6 8 8 8 8-3.6 8-8v-.7c-.3.1-.6.2-1 .2zM15 0h-4c-.6 0-1 .5-1 1s.4 1 1 1h1.6L9.3 5.3c-.2.2-.3.4-.3.7 0 .5.4 1 1 1 .3 0 .5-.1.7-.3L14 3.4V5c0 .6.4 1 1 1 .5 0 1-.4 1-1V1c0-.5-.4-1-1-1z"];
  init_define_process();
  var send_to_graph_default = ["M6 9H2c-.55 0-1 .45-1 1s.45 1 1 1h1.59L.3 14.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L5 12.41V14c0 .55.45 1 1 1s1-.45 1-1v-4c0-.55-.45-1-1-1zm8 .5c-.56 0-1.06.23-1.42.59l-2.13-1.24L8.99 8l3.59-2.09A2.002 2.002 0 0016 4.5c0-1.1-.9-2-2-2s-2 .9-2 2c0 .19.03.37.08.54L8.5 7.13v-3.2c.86-.22 1.5-1 1.5-1.93 0-1.1-.9-2-2-2S6 .9 6 2c0 .93.64 1.71 1.5 1.93v3.2l-.88-.52-2.7-1.57c.05-.17.08-.35.08-.54 0-1.1-.9-2-2-2s-2 .9-2 2 .9 2 2 2c.56 0 1.06-.23 1.42-.59l2.13 1.24 3.84 2.24 2.7 1.57c-.06.17-.09.35-.09.54 0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2z"];
  init_define_process();
  var send_to_map_default = ["M6 9H2c-.55 0-1 .45-1 1s.45 1 1 1h1.59L.3 14.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L5 12.41V14c0 .55.45 1 1 1s1-.45 1-1v-4c0-.55-.45-1-1-1zm9.55-5.83l-4.49-3A.975.975 0 009.99.15L5.53 2.82 1.56.17A1.003 1.003 0 000 1v6h2V2.87l2.94 1.96.06.03V7h1V4.86s.01 0 .01-.01L10 2.47v8.67s-.01 0-.01.01l-.99.58v2.33l1.47-.88 3.97 2.65A1.003 1.003 0 0016 15V4c0-.35-.18-.65-.45-.83zM14 13.13l-2.94-1.96c-.02-.01-.04-.02-.05-.03v-8.6l3 2v8.59z"];
  init_define_process();
  var series_add_default = ["M10.68 7.9c.44.54 1.07.92 1.79 1.05l-2.76 2.76c-.18.18-.43.29-.71.29s-.53-.11-.71-.3L5 8.41l-3 3V13h13c.55 0 1 .45 1 1s-.45 1-1 1H1c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1s1 .45 1 1v4.59l2.29-2.3C4.47 6.11 4.72 6 5 6s.53.11.71.29L9 9.59l1.68-1.69zM15 3c.55 0 1 .45 1 1s-.45 1-1 1h-1v1c0 .55-.45 1-1 1s-1-.45-1-1V5h-1c-.55 0-1-.45-1-1s.45-1 1-1h1V2c0-.55.45-1 1-1s1 .45 1 1v1h1z"];
  init_define_process();
  var series_configuration_default = ["M9.94 9.64c.65.23 1.34.36 2.06.36.14 0 .29-.01.43-.01L9.7 12.71c-.18.18-.43.29-.71.29-.28 0-.53-.11-.71-.3L5 9.41l-3 3V14h12.99c.55 0 1 .45 1 1s-.45 1-1 1H1c-.55 0-1-.45-1-1V5c0-.55.45-1 1-1s1 .45 1 1v4.59l2.29-2.3C4.47 7.11 4.72 7 5 7c.28 0 .53.11.71.29L9 10.59l.94-.95zm4.73-6.44h.92c.22 0 .4.18.4.4v.8c0 .22-.18.4-.4.4h-.93c-.06.2-.14.38-.24.55l.66.65c.15.15.15.4 0 .55l-.54.55c-.15.15-.4.15-.55 0l-.65-.65c-.17.1-.36.18-.55.24v.91c0 .22-.18.4-.4.4h-.8c-.22 0-.4-.18-.4-.4v-.93c-.18-.06-.36-.13-.52-.22l-.68.68c-.15.16-.41.16-.57 0l-.56-.56a.417.417 0 010-.57l.68-.68c-.08-.16-.16-.33-.22-.52h-.93c-.22 0-.4-.18-.4-.4v-.8c0-.22.18-.4.4-.4h.93c.06-.2.14-.38.24-.55l-.65-.64a.392.392 0 010-.55l.54-.55a.38.38 0 01.54 0l.65.65c.18-.1.36-.18.55-.24V.4c0-.22.18-.4.4-.4h.8c.22 0 .4.18.4.4v.93c.18.06.35.14.52.22l.68-.68c.15-.16.41-.16.57 0l.57.57c.15.16.15.41 0 .57l-.68.68c.09.16.16.33.22.51zm-4.18.8c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5c-.82 0-1.5.67-1.5 1.5z"];
  init_define_process();
  var series_derived_default = ["M10.66 7.92c.44.54 1.07.91 1.8 1.03L9.71 11.7c-.18.19-.43.3-.71.3s-.53-.11-.71-.3L5 8.41l-3 3V13h13c.55 0 1 .45 1 1s-.45 1-1 1H1c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1s1 .45 1 1v4.59l2.29-2.3C4.47 6.11 4.72 6 5 6s.53.11.71.29L9 9.59l1.66-1.67zM12.3 5.3l.3-.3H8c-.6 0-1-.4-1-1s.4-1 1-1h4.6l-.3-.3c-.2-.2-.3-.4-.3-.7 0-.6.5-1 1-1 .3 0 .5.1.7.3l2 2c.2.2.3.4.3.7s-.1.5-.3.7l-2 2c-.2.2-.4.3-.7.3-.6 0-1-.4-1-1 0-.3.1-.5.3-.7z"];
  init_define_process();
  var series_filtered_default = ["M9.29 9.3c.3.62.8 1.12 1.42 1.41l-1 1c-.18.18-.43.29-.71.29s-.53-.11-.71-.3L5 8.41l-3 3V13h13c.55 0 1 .45 1 1s-.45 1-1 1H1c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1s1 .45 1 1v4.59l2.29-2.3C4.47 6.11 4.72 6 5 6s.53.11.71.29L9 9.59l.29-.29zM15.48 1c.31 0 .52.26.52.57 0 .16-.06.3-.17.41l-2.86 2.73v2.63c0 .16-.06.3-.17.41l-.82 1.1c-.1.1-.25.17-.41.17-.31 0-.57-.26-.57-.57V4.71L8.17 1.98A.566.566 0 018 1.57c0-.31.26-.57.57-.57h6.91z"];
  init_define_process();
  var series_search_default = ["M9.6 8.94a4.937 4.937 0 001.82.01c.1-.01.22-.04.39-.08l.23-.07c.04-.01.08-.02.11-.04l.22.22-2.7 2.72c-.18.19-.43.3-.71.3s-.53-.11-.71-.3L4.98 8.41l-2.99 3V13h12.94c.55 0 1 .45 1 1s-.45 1-1 1H1c-.55 0-1-.45-1-1V3.99c0-.55.45-1 1-1s1 .45 1 1v4.59l2.28-2.3c.17-.18.42-.29.7-.29s.53.11.7.29l3.28 3.3.64-.64zm6.22-.41c.1.12.17.27.18.44 0 .34-.27.61-.61.61a.57.57 0 01-.43-.18l-2.24-2.25c-.13.08-.26.16-.4.23-.02.01-.05.02-.07.03-.14.06-.27.12-.42.17h-.01c-.14.05-.29.08-.44.11-.04.01-.08.02-.11.02-.15.02-.3.04-.46.04-1.85 0-3.35-1.51-3.35-3.37S8.96 1.01 10.81 1c1.85 0 3.35 1.51 3.35 3.37 0 .16-.02.31-.04.47-.01.04-.01.07-.02.11-.02.15-.05.29-.1.44v.01c-.05.15-.11.28-.17.42-.01.02-.02.05-.03.07-.07.14-.14.27-.23.4l2.25 2.24zm-5.01-1.94c1.22 0 2.21-.99 2.21-2.22 0-1.23-.99-2.22-2.21-2.22S8.6 3.14 8.6 4.37c0 1.22.99 2.22 2.21 2.22z"];
  init_define_process();
  var settings_default = ["M3 1c0-.55-.45-1-1-1S1 .45 1 1v3h2V1zm0 4H1c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h2c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm12-4c0-.55-.45-1-1-1s-1 .45-1 1v2h2V1zM9 1c0-.55-.45-1-1-1S7 .45 7 1v6h2V1zM1 15c0 .55.45 1 1 1s1-.45 1-1v-5H1v5zM15 4h-2c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h2c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zm-2 11c0 .55.45 1 1 1s1-.45 1-1V9h-2v6zM9 8H7c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h2c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1zm-2 7c0 .55.45 1 1 1s1-.45 1-1v-2H7v2z"];
  init_define_process();
  var shapes_default = ["M5.92 8.139c.44-.282 1.006-.121 1.264.358l2.689 4.988c.083.155.127.33.127.51C10 14.55 9.587 15 9.077 15H3.924a.864.864 0 01-.438-.12c-.449-.263-.617-.873-.376-1.362l2.465-4.989c.08-.162.2-.297.346-.39zM12 4a3 3 0 110 6 3 3 0 010-6zM6 1a1 1 0 011 1v4a1 1 0 01-1 1H2a1 1 0 01-1-1V2a1 1 0 011-1h4z"];
  init_define_process();
  var share_default = ["M10.99 13.99h-9v-9h4.76l2-2H.99c-.55 0-1 .45-1 1v11c0 .55.45 1 1 1h11c.55 0 1-.45 1-1V7.24l-2 2v4.75zm4-14h-5c-.55 0-1 .45-1 1s.45 1 1 1h2.59L7.29 7.28a1 1 0 00-.3.71 1.003 1.003 0 001.71.71l5.29-5.29V6c0 .55.45 1 1 1s1-.45 1-1V1c0-.56-.45-1.01-1-1.01z"];
  init_define_process();
  var shared_filter_default = ["M13.843 15.163c.232.53.138.837.138.837H6.017s-.088-.308.138-.837c.226-.53 1.338-.88 2.079-1.206.735-.332.66-.53.685-.8 0-.03.006-.068.006-.105a2.171 2.171 0 01-.61-.892v-.006s-.006-.006-.006-.012c-.025-.074-.056-.16-.075-.24-.176-.031-.276-.222-.314-.394a.8.8 0 01-.1-.437c.025-.253.131-.37.244-.419v-.037c0-.313.032-.775.088-1.07A1.835 1.835 0 018.85 8.37c.315-.24.76-.37 1.156-.37.396 0 .842.13 1.156.37.301.233.534.56.64.935.026.08.045.166.057.246.057.295.088.75.088 1.064v.043c.113.05.214.167.232.413a.75.75 0 01-.1.437c-.038.172-.132.357-.301.387a1.77 1.77 0 01-.076.24.136.136 0 01-.006.025 2.346 2.346 0 01-.597.892v.111c.025.277-.075.474.666.8.741.326 1.853.67 2.079 1.2z", "M14.852 15h1.131s.083-.27-.12-.732c-.16-.373-.82-.641-1.411-.88a15.328 15.328 0 01-.409-.17c-.565-.25-.57-.412-.577-.61-.001-.03-.002-.06-.005-.09v-.097c.22-.2.401-.469.522-.781 0 0 .005-.016.005-.022.028-.07.05-.14.066-.21.149-.026.231-.188.264-.339a.655.655 0 00.088-.382c-.016-.215-.104-.318-.203-.36v-.039c0-.274-.028-.673-.077-.931a1.598 1.598 0 00-.61-1.034 1.736 1.736 0 00-1.285-.3c.236.285.42.622.529.996.038.124.065.248.083.36.048.257.079.578.093.867a1.736 1.736 0 01.08 1.624 1.65 1.65 0 01-.217.453 1.42 1.42 0 01-.176.209c-.08.204-.178.4-.292.585l.202.083c.285.117.64.261.9.387.226.11.475.245.698.414.213.161.476.408.63.764.034.08.065.159.091.235zM12.14 14.12l.09.037zM11 1c.55 0 1 .45 1 1 0 .28-.11.53-.29.7L8 6.41v1.374a2.813 2.813 0 00-.833 1.589 6.925 6.925 0 00-.092.86 1.64 1.64 0 00-.25.739l-.001.004c-.02.217.006.413.046.573L5.71 12.71A1.003 1.003 0 014 12V6.41L.29 2.71A1.003 1.003 0 011 1h10z"];
  init_define_process();
  var shield_default = ["M8 16c4.667-3.048 7-7.238 7-12.571-1.556 0-3.889-1.143-7-3.429-3.111 2.286-5.444 3.429-7 3.429C1 8.762 3.333 12.952 8 16zM8 2.121c2.005 1.388 3.715 2.304 5.186 2.735-.342 3.702-2.05 6.683-5.186 9.038V2.121z"];
  init_define_process();
  var ship_default = ["M5.44.804L5.2 2H3a1 1 0 00-1 1v3.714l-1.08.309a.988.988 0 00-.69 1.192c.366 1.432.897 3.324 1.309 4.26a.644.644 0 00.005.01c-.175.01-.356.015-.544.015a.5.5 0 000 1c2.067 0 3.414-.543 4.161-.917.55.373 1.505.917 2.839.917 1.32 0 2.27-.533 2.822-.905l.004.002c.196.105.48.24.856.374.75.268 1.857.529 3.318.529a.5.5 0 000-1c-.295 0-.572-.012-.834-.032a.995.995 0 00.308-.458l1.208-3.74a1 1 0 00-.677-1.269L14 6.714V3a1 1 0 00-1-1h-2.2L10.56.804A1 1 0 009.58 0H6.42a1 1 0 00-.98.804zM4 6.143l3-.857V4H4v2.143zm5-.857l3 .857V4H9v1.286zm-4.036 8.273a.5.5 0 01.527.034c.455.325 1.277.907 2.509.907s2.054-.582 2.51-.907a.5.5 0 01.579-.001l.006.004.036.023c.034.022.09.055.168.097.154.082.394.197.72.313.649.232 1.642.471 2.981.471a.5.5 0 010 1c-1.46 0-2.568-.261-3.318-.53a6.316 6.316 0 01-.856-.373l-.004-.002c-.552.372-1.502.905-2.822.905-1.334 0-2.289-.544-2.839-.917-.747.374-2.094.917-4.161.917a.5.5 0 010-1c2.129 0 3.384-.63 3.964-.94z"];
  init_define_process();
  var shop_default = ["M3 2h10c.55 0 1-.45 1-1s-.45-1-1-1H3c-.55 0-1 .45-1 1s.45 1 1 1zm9 11H4v-3H2v5c0 .55.45 1 1 1h10c.55 0 1-.45 1-1v-5h-2v3zm4-6l-1.01-3.17C14.9 3.36 14.49 3 14 3H2c-.49 0-.9.36-.98.83L.01 7H0c0 1.1.9 2 2 2s2-.9 2-2c0 1.1.9 2 2 2s2-.9 2-2c0 1.1.9 2 2 2s2-.9 2-2c0 1.1.9 2 2 2s2-.9 2-2z"];
  init_define_process();
  var shopping_cart_default = ["M14 10H7.72l-.33-1H13c.39 0 .72-.23.89-.56h.01l2-4h-.01c.06-.13.11-.28.11-.44 0-.55-.45-1-1-1H5.39l-.44-1.32h-.01C4.8 1.29 4.44 1 4 1H1c-.55 0-1 .45-1 1s.45 1 1 1h2.28l2.33 7H4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2h6c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2zM6.05 5h7.33l-1 2H6.72l-.67-2z"];
  init_define_process();
  var signal_search_default = ["M5.474 7.971A5.31 5.31 0 006.66 8.9l.007.019.018.056c.015.038.038.06.045.098l1.5 5.999a.75.75 0 01-1.455.36l-.42-1.68h-.704l-.42 1.68a.746.746 0 01-.907.547.746.746 0 01-.547-.907l1.5-6c.007-.037.03-.06.044-.097.015-.037.015-.075.038-.112a.722.722 0 01-.105-.36c0-.207.084-.394.22-.53zM2.795 5.277a.763.763 0 00-.015-1.065.756.756 0 00-1.065.015c-2.286 2.34-2.286 6.21 0 8.549a.747.747 0 101.072-1.042c-1.709-1.763-1.709-4.702.008-6.457zM7.808 9.388a5.318 5.318 0 001.58.211 2.236 2.236 0 01-.656.98.756.756 0 01-1.057-.098.756.756 0 01.097-1.057l.036-.036zM11.544 9.105l.378.378a6.02 6.02 0 01-1.638 3.285c-.285.3-.757.3-1.057.015a.74.74 0 01-.015-1.057 4.52 4.52 0 001.185-2.24c.4-.083.785-.212 1.147-.381z", "M4.054 9.424c-.427-.352-.352-1.582-.03-1.822a.752.752 0 00.15-1.05.752.752 0 00-1.05-.15c-1.079.802-1.221 3.18-.03 4.177a.75.75 0 10.96-1.155zM9.318 0a4.318 4.318 0 014.317 4.318c0 .206-.02.402-.049.598-.01.05-.01.088-.02.138-.039.196-.078.382-.137.569v.01c-.059.186-.137.363-.216.54l-.039.087a5.285 5.285 0 01-.294.51l2.884 2.886a.878.878 0 01.236.559.787.787 0 01-.785.785.785.785 0 01-.56-.226L11.772 7.89a5.285 5.285 0 01-.51.295l-.089.039c-.176.079-.353.157-.54.216h-.01a3.701 3.701 0 01-.568.137c-.05.01-.099.02-.138.02-.196.03-.392.049-.598.049A4.318 4.318 0 015 4.327 4.332 4.332 0 019.318 0zm-.02 1.1A3.195 3.195 0 006.1 4.298a3.195 3.195 0 003.198 3.198 3.195 3.195 0 003.198-3.198A3.195 3.195 0 009.298 1.1z"];
  init_define_process();
  var sim_card_default = ["M13.71 4.29l-4-4A.997.997 0 009 0H3c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V5c0-.28-.11-.53-.29-.71zM7 6h2v2H7V6zM4 6h2v2H4V6zm2 8H4v-2h2v2zm3 0H7v-2h2v2zm3 0h-2v-2h2v2zm0-3H4V9h8v2zm0-3h-2V6h2v2z"];
  init_define_process();
  var slash_default = ["M10 2a.99.99 0 00-.96.73l-2.99 9.96A1.003 1.003 0 007 14c.46 0 .85-.31.96-.73l2.99-9.96A1.003 1.003 0 0010 2z"];
  init_define_process();
  var small_cross_default = ["M9.41 8l2.29-2.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L8 6.59l-2.29-2.3a1.003 1.003 0 00-1.42 1.42L6.59 8 4.3 10.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L8 9.41l2.29 2.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L9.41 8z"];
  init_define_process();
  var small_info_sign_default = ["M14 8A6 6 0 112 8a6 6 0 0112 0zM9 4v2H7V4h2zm0 3v4h1v1H6v-1h1V8H6V7h3z"];
  init_define_process();
  var small_minus_default = ["M11 7H5c-.55 0-1 .45-1 1s.45 1 1 1h6c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var small_plus_default = ["M11 7H9V5c0-.55-.45-1-1-1s-1 .45-1 1v2H5c-.55 0-1 .45-1 1s.45 1 1 1h2v2c0 .55.45 1 1 1s1-.45 1-1V9h2c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var small_square_default = ["M5 5v6h6V5H5zM4 3a1 1 0 00-1 1v8a1 1 0 001 1h8a1 1 0 001-1V4a1 1 0 00-1-1H4z"];
  init_define_process();
  var small_tick_default = ["M12 5c-.28 0-.53.11-.71.29L7 9.59l-2.29-2.3a1.003 1.003 0 00-1.42 1.42l3 3c.18.18.43.29.71.29s.53-.11.71-.29l5-5A1.003 1.003 0 0012 5z"];
  init_define_process();
  var snowflake_default = ["M13.364 9l.879.879a1 1 0 11-1.415 1.414l-2.12-2.121A1.003 1.003 0 0110.568 9H9v1.604c.042.03.083.065.121.103l2.122 2.121a1 1 0 01-1.415 1.415L9 13.414V15a1 1 0 01-2 0v-1.636l-.879.879a1 1 0 11-1.414-1.415l2.121-2.12c.054-.054.111-.1.172-.139V9H5.38c-.038.06-.084.118-.137.172l-2.122 2.12A1 1 0 111.707 9.88L2.586 9H1a1 1 0 110-2h1.536l-.829-.828a1 1 0 011.414-1.415L5.243 6.88c.038.038.072.079.103.121H7V5.38a1.003 1.003 0 01-.172-.137L4.708 3.12A1 1 0 016.12 1.707L7 2.586V1a1 1 0 112 0v1.536l.828-.829a1 1 0 011.415 1.414L9.12 5.243A1.007 1.007 0 019 5.346V7h1.604c.03-.042.065-.083.103-.121l2.121-2.122a1 1 0 011.415 1.415L13.414 7H15a1 1 0 010 2h-1.636z"];
  init_define_process();
  var social_media_default = ["M9.5 4c.4 0 .8-.1 1.1-.3C12 4.5 12.9 6 13 7.6c0 .5.5.9 1 .9.6 0 1-.4 1-1v-.2c-.2-2.4-1.5-4.4-3.5-5.5-.1-1-.9-1.8-2-1.8s-2 .9-2 2 .9 2 2 2zM4 8.5c0-.7-.4-1.3-.9-1.7.3-1.4 1.2-2.6 2.5-3.3.3-.1.6-.4.6-.9s-.4-1-1-1c-.2 0-.3 0-.5.1-1.9 1-3.2 2.8-3.6 5C.4 7.1 0 7.8 0 8.5c0 1.1.9 2 2 2s2-.9 2-2zm8.8 1.2c-1.1 0-2 .9-2 2v.3c-.8.6-1.8.9-2.8.9-1.2 0-2.3-.4-3.2-1.1-.2-.2-.4-.3-.7-.3-.6 0-1 .4-1 1 0 .3.1.6.3.8C4.6 14.4 6.2 15 8 15c1.5 0 3-.5 4.1-1.3.2.1.5.1.7.1 1.1 0 2-.9 2-2s-.9-2.1-2-2.1z"];
  init_define_process();
  var sort_default = ["M5 12c-.28 0-.53.11-.71.29l-.29.3V9c0-.55-.45-1-1-1s-1 .45-1 1v3.59l-.29-.29A.965.965 0 001 12a1.003 1.003 0 00-.71 1.71l2 2c.18.18.43.29.71.29s.53-.11.71-.29l2-2A1.003 1.003 0 005 12zm3-9h7c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1s.45 1 1 1zm7 2H8c-.55 0-1 .45-1 1s.45 1 1 1h7c.55 0 1-.45 1-1s-.45-1-1-1zm0 8H8c-.55 0-1 .45-1 1s.45 1 1 1h7c.55 0 1-.45 1-1s-.45-1-1-1zm0-4H8c-.55 0-1 .45-1 1s.45 1 1 1h7c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var sort_alphabetical_default = ["M6 12c-.28 0-.53.11-.71.29l-.29.3V9c0-.55-.45-1-1-1s-1 .45-1 1v3.59l-.29-.29A.965.965 0 002 12a1.003 1.003 0 00-.71 1.71l2 2c.19.18.44.29.71.29.28 0 .53-.11.71-.29l2-2c.18-.18.29-.43.29-.71a.99.99 0 00-1-1zm7.93-.95v-1.04H9.25v1.11h2.94L9 14.96V16h5.02v-1.11h-3.27l3.18-3.84zm-1.42-4.84l.62 1.78H15L11.94.01H10.1L7 7.99h1.81l.64-1.78h3.06zm-1.52-4.24h.02l1.03 2.93H9.92l1.07-2.93z"];
  init_define_process();
  var sort_alphabetical_desc_default = ["M5.99 11.99c-.28 0-.53.11-.71.29l-.29.29V8.99c0-.55-.45-1-1-1s-1 .45-1 1v3.59l-.29-.29a1.003 1.003 0 00-1.42 1.42l2 2c.18.18.43.29.71.29.28 0 .53-.11.71-.29l2-2c.18-.18.29-.43.29-.71 0-.56-.45-1.01-1-1.01zM12.7 10h-1.38L9 15.99h1.36l.48-1.33h2.3l.46 1.33H15L12.7 10zm-1.51 3.67l.8-2.2h.02l.77 2.2h-1.59zm3.8-7.17h-4.57l4.45-5.12V0H8.34v1.48h4.1L7.99 6.59v1.39h7V6.5z"];
  init_define_process();
  var sort_asc_default = ["M8 7h3c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1s.45 1 1 1zm0-4h1c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1s.45 1 1 1zm0 8h5c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1s.45 1 1 1zm-3 1c-.28 0-.53.11-.71.29l-.29.3V9c0-.55-.45-1-1-1s-1 .45-1 1v3.59l-.29-.29A.965.965 0 001 12a1.003 1.003 0 00-.71 1.71l2 2c.18.18.43.29.71.29s.53-.11.71-.29l2-2A1.003 1.003 0 005 12zm10 1H8c-.55 0-1 .45-1 1s.45 1 1 1h7c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var sort_desc_default = ["M5 12c-.28 0-.53.11-.71.29l-.29.3V9c0-.55-.45-1-1-1s-1 .45-1 1v3.59l-.29-.29A.965.965 0 001 12a1.003 1.003 0 00-.71 1.71l2 2c.18.18.43.29.71.29s.53-.11.71-.29l2-2A1.003 1.003 0 005 12zm4 1H8c-.55 0-1 .45-1 1s.45 1 1 1h1c.55 0 1-.45 1-1s-.45-1-1-1zm4-8H8c-.55 0-1 .45-1 1s.45 1 1 1h5c.55 0 1-.45 1-1s-.45-1-1-1zm-2 4H8c-.55 0-1 .45-1 1s.45 1 1 1h3c.55 0 1-.45 1-1s-.45-1-1-1zm4-8H8c-.55 0-1 .45-1 1s.45 1 1 1h7c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var sort_numerical_default = ["M6 11.99c-.28 0-.53.11-.71.29l-.29.3V8.99c0-.55-.45-1-1-1s-1 .45-1 1v3.59l-.29-.29c-.18-.18-.43-.3-.71-.3a1.003 1.003 0 00-.71 1.71l2 2c.18.18.43.29.71.29.28 0 .53-.11.71-.29l2-2A1.003 1.003 0 006 11.99zm7.91-.08c-.06-.36-.17-.68-.33-.96-.16-.28-.37-.51-.64-.69-.27-.17-.61-.26-1.03-.26-.28 0-.54.06-.78.17-.23.11-.43.26-.6.45-.17.19-.3.41-.39.67a2.492 2.492 0 00-.04 1.52 1.623 1.623 0 00.89 1.03c.22.11.45.16.68.16.26 0 .5-.05.7-.15s.38-.26.53-.5l.02.02c-.01.16-.03.34-.07.54-.03.2-.09.4-.17.57-.08.18-.18.33-.31.45s-.29.19-.5.19a.63.63 0 01-.48-.21c-.13-.14-.21-.31-.25-.5H10.1c.03.25.1.48.19.68.1.2.22.37.38.5.16.14.33.24.54.31s.42.1.65.1c.39 0 .72-.09.99-.27.27-.18.49-.41.66-.7.17-.29.29-.61.37-.97.08-.36.12-.72.12-1.07 0-.36-.03-.72-.09-1.08zm-1.14.54c-.04.13-.09.24-.16.34a.78.78 0 01-.27.24c-.11.06-.24.09-.39.09a.75.75 0 01-.37-.09.777.777 0 01-.26-.25c-.07-.1-.12-.22-.15-.35-.03-.13-.05-.26-.05-.4 0-.13.02-.26.05-.39.04-.13.09-.24.16-.34.07-.1.16-.18.26-.24s.22-.09.35-.09c.14 0 .26.03.37.09.11.06.2.14.28.24a1.32 1.32 0 01.23.74c0 .15-.02.28-.05.41zm-1.56-4.47H13V0h-1.42c-.05.3-.16.56-.31.76-.16.21-.35.37-.58.5-.23.13-.49.21-.78.26-.3.05-.6.07-.91.06V2.8h2.21v5.18z"];
  init_define_process();
  var sort_numerical_desc_default = ["M6 11.99c-.28 0-.53.11-.71.29l-.29.3V8.99c0-.55-.45-1-1-1s-1 .45-1 1v3.59l-.29-.29a.982.982 0 00-.71-.3 1.003 1.003 0 00-.71 1.71l2 2c.18.18.43.29.71.29s.53-.11.71-.29l2-2A1.003 1.003 0 006 11.99zm7.86-9.45c-.09-.48-.26-.9-.5-1.28S12.8.58 12.4.35C12 .12 11.49 0 10.86 0c-.43 0-.82.07-1.17.22s-.65.35-.9.6-.44.55-.58.89c-.14.34-.2.71-.2 1.11 0 .31.05.61.15.91.1.3.26.57.48.8.23.24.52.43.85.58.33.14.68.21 1.03.21.4 0 .75-.07 1.05-.2.3-.13.57-.35.79-.66l.02.02c-.02.21-.05.45-.1.73-.05.27-.13.53-.25.76-.12.24-.27.44-.47.6-.19.16-.44.25-.75.25a.98.98 0 01-.72-.29c-.19-.18-.31-.4-.37-.66H8.15c.05.34.14.64.29.9.15.26.34.49.57.67.23.18.5.32.8.41.31.1.63.15.98.15.58 0 1.08-.12 1.48-.36.4-.24.73-.55.99-.93.26-.39.44-.82.56-1.29.12-.48.18-.96.18-1.44s-.05-.96-.14-1.44zm-1.71.72c-.05.17-.14.32-.24.46-.11.13-.24.24-.41.31-.16.08-.36.12-.58.12-.21 0-.39-.04-.55-.13-.16-.08-.29-.19-.39-.33-.12-.14-.19-.29-.24-.46-.05-.17-.08-.35-.08-.54 0-.18.03-.35.08-.52.06-.16.14-.31.25-.44.11-.13.24-.24.4-.32.16-.08.33-.12.52-.12.21 0 .4.04.56.12.16.08.3.19.41.32.11.14.2.29.26.46.06.17.09.35.09.52 0 .2-.03.38-.08.55zm-.46 7.31c-.12.15-.26.28-.44.37-.17.09-.37.16-.58.2-.22.04-.44.05-.67.05v.92h1.65v3.88h1.33V10h-1.06c-.03.23-.11.42-.23.57z"];
  init_define_process();
  var split_columns_default = ["M12 10a1.003 1.003 0 001.71.71l2-2c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71l-2-2a1.003 1.003 0 00-1.42 1.42l.3.29H9V2h3v1.71c.31-.13.64-.21 1-.21s.69.08 1 .21V1c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v2.71c.31-.13.64-.21 1-.21s.69.08 1 .21V2h3v5H3.41l.29-.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-2 2C.11 7.47 0 7.72 0 8c0 .28.11.53.29.71l2 2a1.003 1.003 0 001.42-1.42L3.41 9H7v5H4v-1.71c-.31.13-.64.21-1 .21s-.69-.08-1-.21V15c0 .55.45 1 1 1h10c.55 0 1-.45 1-1v-2.71c-.31.13-.64.21-1 .21s-.69-.08-1-.21V14H9V9h3.59l-.29.29c-.19.18-.3.43-.3.71z"];
  init_define_process();
  var square_default = ["M15 0H1C.45 0 0 .45 0 1v14c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 14H2V2h12v12z"];
  init_define_process();
  var stacked_chart_default = ["M10 2c0-.55-.45-1-1-1H8c-.55 0-1 .45-1 1v3h3V2zm3 10h1c.55 0 1-.45 1-1V8h-3v3c0 .55.45 1 1 1zm2-7c0-.55-.45-1-1-1h-1c-.55 0-1 .45-1 1v2h3V5zm-5 1H7v3h3V6zM5 7c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v1h3V7zm3 5h1c.55 0 1-.45 1-1v-1H7v1c0 .55.45 1 1 1zm7 1H2c-.55 0-1 .45-1 1s.45 1 1 1h13c.55 0 1-.45 1-1s-.45-1-1-1zM3 12h1c.55 0 1-.45 1-1V9H2v2c0 .55.45 1 1 1z"];
  init_define_process();
  var stadium_geometry_default = ["M12 6H4a2 2 0 100 4h8a2 2 0 100-4zM4 4a4 4 0 100 8h8a4 4 0 000-8H4z"];
  init_define_process();
  var star_default = ["M8 0l2.5 5.3 5.5.8-4 4.1.9 5.8L8 13.3 3.1 16l.9-5.8-4-4.1 5.5-.8z"];
  init_define_process();
  var star_empty_default = ["M16 6.11l-5.53-.84L8 0 5.53 5.27 0 6.11l4 4.1L3.06 16 8 13.27 12.94 16 12 10.21l4-4.1zM4.91 13.2l.59-3.62L3 7.02l3.45-.53L8 3.2l1.55 3.29 3.45.53-2.5 2.56.59 3.62L8 11.49 4.91 13.2z"];
  init_define_process();
  var step_backward_default = ["M12 3c-.24 0-.44.09-.62.23l-.01-.01L7 6.72V4c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1V9.28l4.38 3.5.01-.01c.17.14.37.23.61.23.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var step_chart_default = ["M15 12H2v-2h3c.55 0 1-.45 1-1V7h2v1c0 .55.45 1 1 1h4c.55 0 1-.45 1-1V5h1c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1v3h-2V6c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1v2H2V3c0-.55-.45-1-1-1s-1 .45-1 1v10c0 .55.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var step_forward_default = ["M12 3h-1c-.55 0-1 .45-1 1v2.72l-4.38-3.5v.01A.987.987 0 005 3c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1 .24 0 .44-.09.62-.23l.01.01L10 9.28V12c0 .55.45 1 1 1h1c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var stop_default = ["M12 3H4c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1h8c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var stopwatch_default = ["M9 2v1.083A6.002 6.002 0 018 15 6 6 0 017 3.083V2H6a1 1 0 110-2h4a1 1 0 010 2H9zM8 5a4 4 0 104 4H8V5z"];
  init_define_process();
  var strikethrough_default = ["M14 7H8.65c-.38-.09-.73-.18-1.04-.26-.31-.08-.49-.13-.54-.14-.43-.11-.79-.29-1.05-.52-.27-.23-.4-.55-.4-.95 0-.29.07-.53.21-.72s.32-.34.54-.46c.22-.11.46-.19.72-.24.26-.05.52-.07.77-.07.74 0 1.36.15 1.84.46.32.2.55.5.68.9h2.22c-.06-.33-.17-.64-.32-.92-.25-.45-.59-.84-1.02-1.15-.43-.31-.93-.54-1.49-.7S8.59 2 7.95 2c-.55 0-1.1.07-1.63.2-.54.13-1.02.34-1.45.62-.42.28-.76.63-1.02 1.05-.26.42-.39.92-.39 1.5 0 .3.04.59.13.88.08.26.21.51.39.75H2c-.55 0-1 .45-1 1s.45 1 1 1h7.13c.25.07.49.14.71.22.25.09.48.23.7.44.21.21.32.53.32.97 0 .21-.05.43-.14.63-.09.21-.24.39-.45.55-.21.16-.48.29-.81.39-.33.1-.73.15-1.2.15-.44 0-.84-.05-1.21-.14-.37-.09-.7-.24-.99-.43-.29-.2-.51-.45-.67-.76-.01 0-.01-.01-.02-.02H3.14a3.68 3.68 0 001.39 2.03c.46.34 1 .58 1.62.74.61.15 1.27.23 1.97.23.61 0 1.2-.07 1.79-.2.58-.13 1.11-.34 1.56-.63.46-.29.83-.66 1.11-1.11.28-.45.42-1 .42-1.64 0-.3-.05-.6-.15-.9-.05-.19-.13-.36-.22-.52H14c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var style_default = ["M14 14H2V2h8.76l2-2H1C.45 0 0 .45 0 1v14c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V6.24l-2 2V14zm1.4-14L9.7 5.7l2.1 2.1L16 3.6V0h-.6zM4 11.92c2.33.15 4.42.15 6.15-1.5.82-.83.82-2.25 0-3.08-.45-.38-.98-.6-1.5-.6-.53 0-1.05.22-1.43.6-.82.91-1.27 3.38-3.22 4.58z"];
  init_define_process();
  var swap_horizontal_default = ["M0 7.02L.05 7H0v.02zm2-2.03h9.57l-1.29 1.29A1.003 1.003 0 0011.7 7.7l2.99-3c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71l-2.99-3a1.07 1.07 0 00-.71-.28 1.003 1.003 0 00-.71 1.71L11.57 3H2c-.55 0-1 .45-1 1a1 1 0 001 .99zM15.96 9H16v-.02l-.04.02zM14 11.01H4.43l1.29-1.29A1.003 1.003 0 004.3 8.3l-2.99 3a.99.99 0 00-.29.7c0 .28.11.53.29.71l2.99 3a1.003 1.003 0 001.42-1.42L4.43 13H14c.55 0 1-.45 1-1s-.45-.99-1-.99z"];
  init_define_process();
  var swap_vertical_default = ["M9 0h-.02L9 .04V0zM7 16h.02L7 15.95V16zM4.7 1.31c-.18-.18-.43-.29-.7-.29s-.53.11-.71.29l-3 2.99a1.003 1.003 0 001.42 1.42L3 4.43V14c0 .55.45 1 1 1s1-.45 1-1V4.43l1.29 1.29c.18.18.43.29.7.29A1.003 1.003 0 007.7 4.3l-3-2.99zM15 9.99c-.28 0-.53.11-.71.29L13 11.57V2c0-.55-.45-1-1-1s-1 .45-1 1v9.57l-1.29-1.29a.99.99 0 00-.7-.29 1.003 1.003 0 00-.71 1.71l3 2.99c.18.18.43.29.71.29.28 0 .53-.11.71-.29l3-2.99c.18-.18.29-.43.29-.71-.01-.55-.46-1-1.01-1z"];
  init_define_process();
  var switch_default = ["M9.293 2.293l1.414 1.414-4.999 5a3 3 0 11-1.415-1.415l5-5zM13 7a3 3 0 110 6 3 3 0 010-6zM3 9a1 1 0 100 2 1 1 0 000-2zm10 0a1 1 0 100 2 1 1 0 000-2z"];
  init_define_process();
  var symbol_circle_default = ["M8 3.01a5 5 0 100 10 5 5 0 100-10z"];
  init_define_process();
  var symbol_cross_default = ["M12 6.01h-2v-2c0-.55-.45-1-1-1H7c-.55 0-1 .45-1 1v2H4c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h2v2c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-2h2c.55 0 1-.45 1-1v-2c0-.56-.45-1-1-1z"];
  init_define_process();
  var symbol_diamond_default = ["M12 8.01c0-.19-.07-.36-.16-.51l.01-.01-3-5-.01.01c-.17-.29-.48-.49-.84-.49s-.67.2-.84.49l-.02-.01-3 5 .02.01c-.09.15-.16.32-.16.51s.07.36.16.51h-.02l3 5 .01-.01c.18.29.49.5.85.5s.67-.2.84-.49l.01.01 3-5-.01-.01c.09-.16.16-.32.16-.51z"];
  init_define_process();
  var symbol_rectangle_default = ["M13 4H3c-.5 0-1 .5-1 1v6c0 .5.5 1 1 1h10c.5 0 1-.5 1-1V5c0-.5-.5-1-1-1z"];
  init_define_process();
  var symbol_square_default = ["M12 3.01H4c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1h8c.55 0 1-.45 1-1v-8c0-.56-.45-1-1-1z"];
  init_define_process();
  var symbol_triangle_down_default = ["M13 4.01c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1 0 .16.05.31.11.44H3.1l4 8h.01c.16.33.49.56.89.56s.72-.23.89-.56h.01l4-8h-.01c.06-.14.11-.28.11-.44z"];
  init_define_process();
  var symbol_triangle_up_default = ["M12.89 11.56l-3.99-8h-.01c-.17-.32-.5-.55-.89-.55s-.72.23-.89.55H7.1l-4 8h.01c-.06.14-.11.29-.11.45 0 .55.45 1 1 1h8c.55 0 1-.45 1-1 0-.16-.05-.31-.11-.45z"];
  init_define_process();
  var syringe_default = ["M11.146.146a.5.5 0 000 .708l.647.646L10.5 2.793 8.854 1.146a.5.5 0 10-.708.708l.647.646-1.146 1.146-5.5 5.5a.5.5 0 000 .708l.646.646-1.647 1.646a.5.5 0 000 .708l.647.646-1.647 1.646a.5.5 0 00.708.708L2.5 14.207l.646.647a.5.5 0 00.708 0L5.5 13.207l.646.647a.5.5 0 00.708 0l5.5-5.5L13.5 7.207l.646.647a.5.5 0 00.708-.708L13.207 5.5 14.5 4.207l.646.647a.5.5 0 00.708-.708l-4-4a.5.5 0 00-.708 0zM11.293 8l-.793.793-1.646-1.647a.5.5 0 10-.708.708L9.793 9.5 8.5 10.793 6.854 9.146a.5.5 0 10-.708.708L7.793 11.5 6.5 12.793 3.207 9.5 8 4.707 11.293 8zM8.707 4L12 7.293l.793-.793L9.5 3.207 8.707 4zm-6.5 8.5L3.5 13.793 4.793 12.5 3.5 11.207 2.207 12.5zm11.586-9L12.5 2.207 11.207 3.5 12.5 4.793 13.793 3.5z"];
  init_define_process();
  var tag_default = ["M1 3a2 2 0 012-2h4.584a2 2 0 011.414.586l5.413 5.412a2 2 0 010 2.829L9.827 14.41a2 2 0 01-2.829 0L1.586 8.998A2 2 0 011 7.584V3zm3.487-.007a1.494 1.494 0 100 2.988 1.494 1.494 0 000-2.988z"];
  init_define_process();
  var take_action_default = ["M9 11a1.003 1.003 0 001.71.71l4-4a1.003 1.003 0 00-1.42-1.42l-4 4c-.18.18-.29.43-.29.71zM4 6c.28 0 .53-.11.71-.29l4-4A1.003 1.003 0 007.29.29l-4 4A1.003 1.003 0 004 6zm4 4l5-5-.79-.79.5-.5a1.003 1.003 0 00-1.42-1.42l-.5.5L10 2 5 7l.79.79-5.5 5.5a1.003 1.003 0 001.42 1.42l5.5-5.5L8 10zm7 4H7c-.55 0-1 .45-1 1s.45 1 1 1h8c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var tank_default = ["M3.7 3.4a1 1 0 01.8-.4h5.086a1 1 0 01.707.293L11 4h3a1 1 0 110 2h-3v1h2.5a2.5 2.5 0 010 5h-11a2.5 2.5 0 010-5H3V4.667a1 1 0 01.2-.6l.5-.667zM2.5 9h11a.5.5 0 010 1h-11a.5.5 0 110-1z"];
  init_define_process();
  var target_default = ["M7 4a1 1 0 012 0v2a1 1 0 01-2 0V4zM10 7a1 1 0 000 2h2a1 1 0 000-2h-2zM3 8a1 1 0 011-1h2a1 1 0 010 2H4a1 1 0 01-1-1zM8 9a1 1 0 00-1 1v2a1 1 0 002 0v-2a1 1 0 00-1-1z", "M8 16A8 8 0 108 0a8 8 0 000 16zm0-2A6 6 0 108 2a6 6 0 000 12z"];
  init_define_process();
  var taxi_default = ["M15.12 6.63h-.38L15 7c-.01.3-.01.64 0 .98V8c0 .07-.03.13-.04.19h.02L14 13.1v.9c0 .55-.45 1-1 1s-1-.45-1-1v-1H4v1c0 .55-.45 1-1 1s-1-.45-1-1v-.9l-.98-4.9h.02C1.03 8.13 1 8.07 1 8H.99c0-.33 0-.67.01-1l.26-.37H.88C.4 6.63 0 6.21 0 5.69s.4-.94.88-.94h1.05l.77-2.11c.19-.53.76-1.08 1.26-1.24 0 0 .68-.2 2.05-.32C6.01 1.05 6 1.03 6 1c0-.55.45-1 1-1h2c.55 0 1 .45 1 1 0 .03-.01.05-.02.08 1.37.12 2.05.32 2.05.32.51.15 1.08.71 1.27 1.24l.76 2.12h1.05c.49 0 .89.42.89.93 0 .52-.4.94-.88.94zM11 10h2V8h-2v2zm-8 0h2V8H3v2zm10-5l-.73-1.63C12.21 3.19 12.18 3 12 3H4c-.18 0-.21.19-.27.37L3 5c-.06.18-.18 1 0 1h10c.18 0 .06-.82 0-1z"];
  init_define_process();
  var temperature_default = ["M8.5 0A1.5 1.5 0 007 1.5v7.837a3.5 3.5 0 103 0V1.5A1.5 1.5 0 008.5 0zM2 5.5a.5.5 0 01.5-.5h3a.5.5 0 010 1h-3a.5.5 0 01-.5-.5zM2.5 1a.5.5 0 000 1h3a.5.5 0 000-1h-3zM4 3.5a.5.5 0 01.5-.5h1a.5.5 0 010 1h-1a.5.5 0 01-.5-.5zM4.5 7a.5.5 0 000 1h1a.5.5 0 000-1h-1z"];
  init_define_process();
  var text_highlight_default = ["M9 10H2V6h7V4H1c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h8v-2zm4 3h-1V3h1c.55 0 1-.45 1-1s-.45-1-1-1h-1c-.37 0-.7.11-1 .28-.3-.17-.63-.28-1-.28H9c-.55 0-1 .45-1 1s.45 1 1 1h1v10H9c-.55 0-1 .45-1 1s.45 1 1 1h1c.37 0 .7-.11 1-.28.3.17.63.28 1 .28h1c.55 0 1-.45 1-1s-.45-1-1-1zm2-9h-2v2h1v4h-1v2h2c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1z"];
  init_define_process();
  var th_default = ["M15 1H1c-.6 0-1 .5-1 1v12c0 .6.4 1 1 1h14c.6 0 1-.4 1-1V2c0-.5-.4-1-1-1zM6 13H2v-2h4v2zm0-3H2V8h4v2zm0-3H2V5h4v2zm8 6H7v-2h7v2zm0-3H7V8h7v2zm0-3H7V5h7v2z"];
  init_define_process();
  var th_derived_default = ["M5.6 10l-.3.3c-.2.2-.3.4-.3.7 0 .6.4 1 1 1 .3 0 .5-.1.7-.3l2-2c.2-.2.3-.4.3-.7s-.1-.5-.3-.7l-2-2C6.5 6.1 6.3 6 6 6c-.5 0-1 .4-1 1 0 .3.1.5.3.7l.3.3H1c-.6 0-1 .4-1 1s.4 1 1 1h4.6zM15 1H2c-.5 0-1 .5-1 1v5h2V5h11v2H8.8l.6.6c.1.1.2.3.3.4H14v2H9.7c-.1.1-.2.3-.3.4l-.6.6H14v2H3v-2H1v3c0 .5.5 1 1 1h13c.6 0 1-.5 1-1V2c0-.5-.4-1-1-1z"];
  init_define_process();
  var th_disconnect_default = ["M12 1h3c.6 0 1 .5 1 1v12c0 .6-.4 1-1 1h-4.97l.286-2H14v-2h-3.398l.143-1H14V8h-2.97l.143-1H14V5h-2.541l.51-3.576C11.99 1.282 12 1.14 12 1zM5.97 1l-.572 4H2v2h3.112L4.97 8H2v2h2.684l-.143 1H2v2h2.255l-.225 1.576c-.02.142-.03.284-.03.424H1c-.6 0-1-.4-1-1V2c0-.5.4-1 1-1h4.97zM8.01.859a1 1 0 111.98.282l-2 14a1 1 0 11-1.98-.282l2-14z"];
  init_define_process();
  var th_filtered_default = ["M10 10h3l1.78-2.226a1 1 0 00.22-.625V4.3l1-.9V14c0 .6-.4 1-1 1H1c-.6 0-1-.4-1-1V2c0-.5.4-1 1-1h4.333L9 4.3V5H7v2h2v1H7v2h3zm-4 3v-2H2v2h4zm0-3V8H2v2h4zm0-3V5H2v2h4zm8 6v-2H7v2h7z", "M15.48 0c.31 0 .52.26.52.57 0 .16-.06.3-.17.41l-2.86 2.73v2.63c0 .16-.06.3-.17.41l-.82 1.1c-.1.1-.25.17-.41.17-.31 0-.57-.26-.57-.57V3.71L8.17.98A.566.566 0 018 .57c0-.31.26-.57.57-.57h6.91z"];
  init_define_process();
  var th_list_default = ["M15 1H1c-.6 0-1 .5-1 1v12c0 .6.4 1 1 1h14c.6 0 1-.4 1-1V2c0-.5-.4-1-1-1zm-1 12H2v-2h12v2zm0-3H2V8h12v2zm0-3H2V5h12v2z"];
  init_define_process();
  var third_party_default = ["M4.448 9h.573c.025-.044.051-.088.079-.13A9.43 9.43 0 015.183 8h-.995A10.424 10.424 0 014 6c0-.717.068-1.391.188-2h3.624c.065.33.114.678.146 1.042A3.42 3.42 0 018.46 5c.168 0 .336.013.502.037A11.089 11.089 0 008.829 4h1.755c.148.338.26.696.33 1.068l.176-.028a2.74 2.74 0 01.5 0c.113 0 .225.006.336.018A6.001 6.001 0 000 6a6 6 0 005.672 5.991 4 4 0 01-.202-.441 1.842 1.842 0 01-.24-.26 1.82 1.82 0 01-.26-.55 2 2 0 01-.185-.92l-.012-.025A6.036 6.036 0 014.448 9zM3.171 8H1.416A4.983 4.983 0 011 6c0-.711.148-1.388.416-2h1.755C3.06 4.626 3 5.299 3 6c0 .701.06 1.374.17 2zM2 9H3.4c.18.618.412 1.167.685 1.62A5.015 5.015 0 012 9zm2.448-6h3.104a6.036 6.036 0 00-.325-.795C6.737 1.225 6.246 1 6 1c-.246 0-.737.225-1.227 1.205-.119.238-.228.504-.325.795zm4.15 0H10a5.016 5.016 0 00-2.086-1.62c.273.453.506 1.002.685 1.62zM4.087 1.38A6.834 6.834 0 003.401 3H2a5.015 5.015 0 012.086-1.62zM13.476 16s.118-.385-.172-1.046c-.228-.533-1.172-.915-2.015-1.257a22.113 22.113 0 01-.584-.243c-.808-.356-.816-.588-.825-.872-.002-.041-.003-.084-.007-.128v-.139c.314-.284.573-.669.745-1.115 0 0 .008-.023.008-.03.04-.1.071-.2.095-.3.212-.04.33-.27.377-.485.054-.093.149-.3.125-.547-.024-.307-.15-.453-.29-.515v-.054c0-.392-.04-.961-.11-1.33a2.16 2.16 0 00-.071-.308 2.283 2.283 0 00-.8-1.17C9.558 6.162 9.001 6 8.506 6c-.495 0-1.052.162-1.445.462A2.294 2.294 0 006.19 7.93c-.07.369-.11.946-.11 1.338v.046c-.14.062-.274.208-.306.523a1 1 0 00.126.547c.047.215.173.453.393.492.02.083.05.172.078.253l.016.047c0 .008.008.015.008.015v.008c.172.454.44.846.761 1.115a.804.804 0 01-.004.072c-.002.02-.004.04-.004.06l-.007.105c-.016.287-.028.523-.848.894-.176.078-.37.156-.568.237-.847.345-1.802.735-2.031 1.27C3.41 15.616 3.52 16 3.52 16h9.955zm2.503-1.25h-1.413a4.05 4.05 0 00-.116-.294c-.192-.445-.52-.753-.787-.955-.278-.21-.59-.38-.873-.517a21.373 21.373 0 00-1.122-.483l-.02-.008-.235-.097c.144-.23.266-.476.366-.731.089-.087.162-.177.22-.26.132-.192.217-.391.271-.568.117-.251.24-.64.199-1.105a2.025 2.025 0 00-.299-.925 8.626 8.626 0 00-.116-1.083 3.426 3.426 0 00-.104-.45 3.476 3.476 0 00-.661-1.246A2.18 2.18 0 0111.63 6c.432 0 .92.141 1.264.404.33.256.584.612.7 1.023.028.087.049.182.062.27.062.322.097.82.097 1.163v.048c.123.053.233.181.254.45a.82.82 0 01-.11.478c-.041.189-.144.391-.33.425a1.92 1.92 0 01-.082.262c0 .007-.007.027-.007.027-.151.39-.378.727-.653.976v.121c.004.038.005.075.006.111v.002c.008.247.015.451.722.762.158.07.332.14.51.213.739.299 1.565.634 1.764 1.1.254.579.151.915.151.915z"];
  init_define_process();
  var thumbs_down_default = ["M2 2H0v7h2c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1zm13.99 4.38c.08-.58-.44-1.02-1.15-1.05-.25-.01-.52-.03-.81-.05.02 0 .05-.01.07-.01.7-.1 1.34-.49 1.41-1.07.06-.58-.46-.97-1.17-1.04-.25-.02-.52-.04-.79-.06.47-.15.84-.42.87-.93.04-.58-.79-1.03-1.5-1.09-.27-.02-.51-.04-.73-.05h-.09c-.23-.02-.43-.02-.62-.03C8.35.95 5.66 1.47 4 2.51v6c2.14 1.29 4.76 3.59 4.21 5.51-.18.59.31 1.05.98.98.81-.09 1.37-.91 1.4-1.78.04-1-.15-2.01-.5-2.91-.04-.25.01-.5.37-.53.49-.03 1.11-.06 1.59-.08.26 0 .51-.01.75-.02h.01c.41-.02.8-.05 1.13-.09.7-.09 1.35-.47 1.43-1.05.08-.58-.44-.97-1.15-1.05-.05-.01-.11-.01-.16-.02.17-.01.33-.03.49-.05.72-.08 1.37-.46 1.44-1.04z"];
  init_define_process();
  var thumbs_up_default = ["M15.99 9.62c-.08-.58-.73-.96-1.43-1.05-.15-.02-.32-.04-.49-.05.06-.01.11-.01.16-.02.71-.08 1.23-.47 1.15-1.05-.08-.58-.73-.96-1.43-1.05-.34-.04-.72-.07-1.13-.09h-.01c-.24-.01-.49-.02-.75-.02-.48-.02-1.11-.04-1.59-.08-.36-.03-.41-.28-.37-.53.35-.9.54-1.91.5-2.91-.04-.85-.6-1.68-1.41-1.77-.67-.07-1.16.39-.99.98C8.76 3.91 6.13 6.2 4 7.49v6c1.66 1.03 4.35 1.56 7.48 1.5.19 0 .39-.01.62-.02h.09c.22-.01.46-.03.73-.05.71-.06 1.54-.51 1.5-1.09-.03-.51-.4-.79-.87-.93.27-.02.54-.04.79-.06.71-.06 1.24-.45 1.17-1.04-.06-.58-.7-.97-1.41-1.07-.02 0-.05-.01-.07-.01.29-.02.57-.03.81-.05.71-.03 1.23-.47 1.15-1.05zM2 7H0v7h2c.55 0 1-.45 1-1V8c0-.56-.45-1-1-1z"];
  init_define_process();
  var tick_default = ["M14 3c-.28 0-.53.11-.71.29L6 10.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42l4 4c.18.18.43.29.71.29s.53-.11.71-.29l8-8A1.003 1.003 0 0014 3z"];
  init_define_process();
  var tick_circle_default = ["M8 16c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm4-11c-.28 0-.53.11-.71.29L7 9.59l-2.29-2.3a1.003 1.003 0 00-1.42 1.42l3 3c.18.18.43.29.71.29s.53-.11.71-.29l5-5A1.003 1.003 0 0012 5z"];
  init_define_process();
  var time_default = ["M8 0C3.58 0 0 3.58 0 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zm1-6.41V4c0-.55-.45-1-1-1s-1 .45-1 1v4c0 .28.11.53.29.71l2 2a1.003 1.003 0 001.42-1.42L9 7.59z"];
  init_define_process();
  var timeline_area_chart_default = ["M15 2.59L9.91 7.68 6.6 5.2l-.01.01C6.42 5.09 6.23 5 6 5c-.24 0-.44.09-.62.23v-.01L3 7.12V11h12V2.59zM15 12H2V3c0-.55-.45-1-1-1s-1 .45-1 1v10c0 .55.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var timeline_bar_chart_default = ["M8 12h1c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1H8c-.55 0-1 .45-1 1v9c0 .55.45 1 1 1zm5 0h1c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1h-1c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1zm2 1H2c-.55 0-1 .45-1 1s.45 1 1 1h13c.55 0 1-.45 1-1s-.45-1-1-1zM3 12h1c.55 0 1-.45 1-1V7c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1z"];
  init_define_process();
  var timeline_events_default = ["M8 11H7v1h1v-1zm-4 0H3v1h1v-1zm7-8c.6 0 1-.5 1-1V1c0-.5-.4-1-1-1s-1 .5-1 1v1c0 .5.5 1 1 1zM4 3c.5 0 1-.5 1-1V1c0-.5-.5-1-1-1S3 .5 3 1v1c0 .5.5 1 1 1zm10-2h-1v1c0 1.1-.9 2-2 2s-2-.9-2-2V1H6v1c0 1.1-.9 2-2 2s-2-.9-2-2V1H1c-.5 0-1 .5-1 1v12c0 .5.5 1 1 1h13c.6 0 1-.5 1-1V2c0-.5-.4-1-1-1zM5 13H2v-3h3v3zm0-4H2V6h3v3zm4 4H6v-3h3v3zm0-4H6V6h3v3zm4 4h-3v-3h3v3zm0-4h-3V6h3v3zm-1-2h-1v1h1V7z"];
  init_define_process();
  var timeline_line_chart_default = ["M15 12H2V9.41l3-3L8.29 9.7c.18.19.43.3.71.3s.53-.11.71-.29l6-6a1.003 1.003 0 00-1.42-1.42L9 7.59l-3.29-3.3C5.53 4.11 5.28 4 5 4s-.53.11-.71.29L2 6.59V3c0-.55-.45-1-1-1s-1 .45-1 1v10c0 .55.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var tint_default = ["M7.88 1s-4.9 6.28-4.9 8.9c.01 2.82 2.34 5.1 4.99 5.1 2.65-.01 5.03-2.3 5.03-5.13C12.99 7.17 7.88 1 7.88 1z"];
  init_define_process();
  var torch_default = ["M5 15c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H5v1zm7-15H4c-.55 0-1 .45-1 1v1h10V1c0-.55-.45-1-1-1zM5 7v6h6V7l2-4H3l2 4zm2 0c0-.55.45-1 1-1s1 .45 1 1v2c0 .55-.45 1-1 1s-1-.45-1-1V7z"];
  init_define_process();
  var tractor_default = ["M3.5 9a3.5 3.5 0 110 7 3.5 3.5 0 010-7zm9.5 1a3 3 0 110 6 3 3 0 010-6zm-9.5 1a1.5 1.5 0 100 3 1.5 1.5 0 000-3zm9.5 1a1 1 0 100 2 1 1 0 000-2zM5 0c1.46 0 2.527.668 3 2l.815 3.255a78.9 78.9 0 012.186.195L11 2h2l.001 3.688c.698.095 1.37.198 2.013.312.623.11.986.479.986 1v3.354a4.001 4.001 0 00-6.873 1.645H7.999l-.026-.002A4.5 4.5 0 00.659 9.01l-.654.001v-.829C.003 7.386.002 6.423 0 6.022 0 5.5.376 4.99 1 4.99V1a1 1 0 011-1h3zm1 2H3v2.99c1.29.024 2.554.069 3.781.135L6 2z"];
  init_define_process();
  var train_default = ["M13 14h-1l1 2H3l1-2H3c-1.1 0-2-.9-2-2V2C1 .9 4.13 0 8 0s7 .9 7 2v10c0 1.1-.9 2-2 2zm-2-2h2v-2h-2v2zM9 7h4V3H9v4zm-6 5h2v-2H3v2zm0-5h4V3H3v4z"];
  init_define_process();
  var translate_default = ["M15.89 14.56l-3.99-8h-.01c-.17-.33-.5-.56-.89-.56s-.72.23-.89.56h-.01L9 8.76 7.17 7.38l.23-.18C8.37 6.47 9 5.31 9 4V3h1c.55 0 1-.45 1-1s-.45-1-1-1H7c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1H1c-.55 0-1 .45-1 1s.45 1 1 1h6v1c0 .66-.32 1.25-.82 1.61l-.68.51-.68-.5C4.32 5.25 4 4.66 4 4H2c0 1.31.63 2.47 1.6 3.2l.23.17L1.4 9.2l.01.01C1.17 9.4 1 9.67 1 10c0 .55.45 1 1 1 .23 0 .42-.09.59-.21l.01.01 2.9-2.17 2.6 1.95-1.99 3.98h.01c-.07.13-.12.28-.12.44 0 .55.45 1 1 1 .39 0 .72-.23.89-.56h.01L8.62 14h4.76l.72 1.45h.01c.17.32.5.55.89.55.55 0 1-.45 1-1 0-.16-.05-.31-.11-.44zM9.62 12L11 9.24 12.38 12H9.62z"];
  init_define_process();
  var trash_default = ["M14.49 3.99h-13c-.28 0-.5.22-.5.5s.22.5.5.5h.5v10c0 .55.45 1 1 1h10c.55 0 1-.45 1-1v-10h.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5zm-8.5 9c0 .55-.45 1-1 1s-1-.45-1-1v-6c0-.55.45-1 1-1s1 .45 1 1v6zm3 0c0 .55-.45 1-1 1s-1-.45-1-1v-6c0-.55.45-1 1-1s1 .45 1 1v6zm3 0c0 .55-.45 1-1 1s-1-.45-1-1v-6c0-.55.45-1 1-1s1 .45 1 1v6zm2-12h-4c0-.55-.45-1-1-1h-2c-.55 0-1 .45-1 1h-4c-.55 0-1 .45-1 1v1h14v-1c0-.55-.45-1-1-1z"];
  init_define_process();
  var tree_default = ["M9 11.857V16H7v-4.143L1 13l3.885-4.44L3 9l3.07-4.297L5 5l3-5 3 5-1.07-.297L13 9l-1.885-.44L15 13l-6-1.143z"];
  init_define_process();
  var trending_down_default = ["M15 7c-.55 0-1 .45-1 1v.59l-4.29-4.3A.997.997 0 009 4c-.16 0-.31.05-.44.11V4.1L5 5.88 1.45 4.11v.01C1.31 4.05 1.16 4 1 4c-.55 0-1 .45-1 1 0 .39.23.72.56.89v.01l4 2v-.01c.13.06.28.11.44.11s.31-.05.44-.11v.01L8.8 6.22 12.59 10H12c-.55 0-1 .45-1 1s.45 1 1 1h3c.55 0 1-.45 1-1V8c0-.55-.45-1-1-1z"];
  init_define_process();
  var trending_up_default = ["M15 4h-3c-.55 0-1 .45-1 1s.45 1 1 1h.59L8.8 9.78 5.45 8.11v.01C5.31 8.05 5.16 8 5 8s-.31.05-.44.11V8.1l-4 2v.01c-.33.17-.56.5-.56.89 0 .55.45 1 1 1 .16 0 .31-.05.44-.11v.01L5 10.12l3.55 1.78v-.01c.14.06.29.11.45.11.28 0 .53-.11.71-.29L14 7.41V8c0 .55.45 1 1 1s1-.45 1-1V5c0-.55-.45-1-1-1z"];
  init_define_process();
  var truck_default = ["M12.5 0a.5.5 0 01.5.5V9a1 1 0 011 1v2h.5a.5.5 0 01.5.5v1a.5.5 0 01-.5.5H13v1a1 1 0 01-2 0v-1H5v1a1 1 0 01-2 0v-1H1.5a.5.5 0 01-.5-.5v-1a.5.5 0 01.5-.5H2v-2a1 1 0 011-1V.5a.5.5 0 011 0V3a2 2 0 012-2h4a2 2 0 012 2V.5a.5.5 0 01.5-.5zM9 8H7a1 1 0 00-1 1v2a1 1 0 001 1h2a1 1 0 001-1V9a1 1 0 00-1-1zm3.5 3h-1a.5.5 0 100 1h1a.5.5 0 100-1zm-8 0h-1a.5.5 0 100 1h1a.5.5 0 100-1zM9 9a.5.5 0 01.5.5v1l-.008.09A.5.5 0 019 11H7l-.09-.008a.5.5 0 01-.41-.492v-1l.008-.09A.5.5 0 017 9zm2-5H5v2h6V4z"];
  init_define_process();
  var two_columns_default = ["M3.99-.01h-3c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-14c0-.55-.45-1-1-1zm11.71 7.3l-2-2a1.003 1.003 0 00-1.71.71v4a1.003 1.003 0 001.71.71l2-2c.18-.18.29-.43.29-.71s-.11-.53-.29-.71zM9.99-.01h-3c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-14c0-.55-.45-1-1-1z"];
  init_define_process();
  var unarchive_default = ["M13.382 0a1 1 0 01.894.553L16 4v11a1 1 0 01-1 1H1a1 1 0 01-1-1V4L1.724.553A1 1 0 012.618 0h10.764zM8 6c-.28 0-.53.11-.71.29l-2 2-.084.096A1.003 1.003 0 006.71 9.71l.29-.3V12l.007.116c.058.496.482.884.993.884.55 0 1-.45 1-1V9.41l.29.29.081.076A.97.97 0 0010 10a1.003 1.003 0 00.71-1.71l-2-2-.096-.084A1.002 1.002 0 008 6zm5-4H3L2 4h12l-1-2z"];
  init_define_process();
  var underline_default = ["M8 14c2.8 0 5-2.2 5-5V3c0-.6-.4-1-1-1s-1 .4-1 1v6c0 1.7-1.3 3-3 3s-3-1.3-3-3V3c0-.6-.4-1-1-1s-1 .4-1 1v6c0 2.8 2.2 5 5 5zM13.5 15h-11c-.3 0-.5.2-.5.5s.2.5.5.5h11c.3 0 .5-.2.5-.5s-.2-.5-.5-.5z"];
  init_define_process();
  var undo_default = ["M4 11c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm7-7H3.41L4.7 2.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-3 3C.11 4.47 0 4.72 0 5c0 .28.11.53.29.71l3 3a1.003 1.003 0 001.42-1.42L3.41 6H11c1.66 0 3 1.34 3 3s-1.34 3-3 3H7v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"];
  init_define_process();
  var ungroup_objects_default = ["M3.5 5C1.57 5 0 6.57 0 8.5S1.57 12 3.5 12 7 10.43 7 8.5 5.43 5 3.5 5zm9 0C10.57 5 9 6.57 9 8.5s1.57 3.5 3.5 3.5S16 10.43 16 8.5 14.43 5 12.5 5z"];
  init_define_process();
  var unknown_vehicle_default = ["M10.507 9.75v-3.5c0-.089.023-.171.051-.25h-7.55c-.176 0-.061-.824 0-1l.729-1.63c.06-.177.095-.37.27-.37h4.5V1.01c-.166-.003-.32-.01-.5-.01-2.72 0-4.036.402-4.036.402-.508.155-1.079.711-1.268 1.237L1.94 4.756H.887c-.483 0-.88.423-.88.939s.397.939.88.939h.376L1.008 7c-.034.685 0 1.436 0 2v5c0 .657.384 1 1 1s1-.343 1-1v-1h10v1c0 .657.383 1 1 1s1-.343 1-1v-3.5h-3.75a.75.75 0 01-.75-.75zm-5.5.25h-2V8h2v2zm11-4.305zM15.34.826a2.807 2.807 0 00-.932-.598c-.386-.16-.868-.241-1.445-.241-.447 0-.851.076-1.213.228-.362.153-.67.364-.926.636s-.456.592-.598.963a3.535 3.535 0 00-.218 1.144V3h1.789c.003-.208.023-.405.069-.588.049-.193.124-.362.225-.506.102-.144.232-.259.39-.345.159-.087.348-.13.567-.13.325 0 .58.09.762.272.183.18.275.46.275.839.008.222-.031.407-.116.555a1.654 1.654 0 01-.335.408 7.4 7.4 0 01-.452.37c-.162.123-.316.27-.463.438a2.556 2.556 0 00-.384.611c-.11.239-.177.535-.2.889V6h1.645v-.1c.032-.248.111-.453.237-.618.126-.164.27-.31.433-.438.163-.128.335-.255.518-.383a2.413 2.413 0 00.878-1.117c.102-.255.152-.58.152-.975A2.241 2.241 0 0015.34.826zM12.007 7v2h2V7h-2z"];
  init_define_process();
  var unlock_default = ["M11.99-.01c-2.21 0-4 1.79-4 4v3h-7c-.55 0-1 .45-1 1v7c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-7c0-.55-.45-1-1-1h-3v-3c0-1.1.9-2 2-2s2 .9 2 2v1c0 .55.45 1 1 1s1-.45 1-1v-1c0-2.21-1.79-4-4-4z"];
  init_define_process();
  var unpin_default = ["M9.39 1c-.5.5-.4 1.48.15 2.53L4.38 7.54C2.85 6.5 1.52 6.07 1 6.59l3.5 3.5c-.02.02-1.4 2.8-1.4 2.8l2.8-1.4 3.5 3.5c.53-.53.1-1.86-.95-3.38l4.02-5.16c1.04.55 2.01.65 2.51.14L9.39 1z"];
  init_define_process();
  var unresolve_default = ["M11 3c-.55 0-1.07.09-1.57.26a6.46 6.46 0 010 9.48c.5.17 1.02.26 1.57.26 2.76 0 5-2.24 5-5s-2.24-5-5-5zM9.78 9.38l.09-.27c.08-.36.13-.73.13-1.11s-.05-.75-.13-1.11l-.09-.27a5.32 5.32 0 00-.29-.79l-.12-.21c-.14-.27-.31-.52-.51-.76a.7.7 0 00-.08-.1c-.24-.27-.49-.52-.78-.74-.43-.32-.92-.58-1.45-.75l.01-.01c-.1-.03-.2-.05-.3-.08-.12-.03-.23-.07-.36-.09A5.28 5.28 0 005 3C2.24 3 0 5.24 0 8s2.24 5 5 5c.31 0 .61-.04.9-.09.12-.02.24-.06.36-.09.1-.03.21-.04.3-.08l-.01-.01c.88-.29 1.64-.8 2.22-1.49.03-.03.06-.07.09-.1.19-.24.36-.49.51-.76.04-.07.08-.14.11-.21.13-.25.23-.52.3-.79z"];
  init_define_process();
  var updated_default = ["M8 0a7.95 7.95 0 00-6 2.74V1c0-.55-.45-1-1-1S0 .45 0 1v4c0 .55.45 1 1 1h4c.55 0 1-.45 1-1s-.45-1-1-1H3.54C4.64 2.78 6.22 2 8 2c3.31 0 6 2.69 6 6 0 2.61-1.67 4.81-4 5.63-.63.22-1.29.37-2 .37-3.31 0-6-2.69-6-6 0-.55-.45-1-1-1s-1 .45-1 1c0 4.42 3.58 8 8 8 .34 0 .67-.03 1-.07.02 0 .04-.01.06-.01C12.98 15.4 16 12.06 16 8c0-4.42-3.58-8-8-8zm3 5c-.28 0-.53.11-.71.29L7 8.58 5.71 7.29a1.003 1.003 0 00-1.42 1.42l2 2c.18.18.43.29.71.29.28 0 .53-.11.71-.29l4-4A1.003 1.003 0 0011 5z"];
  init_define_process();
  var upload_default = ["M8 0C3.58 0 0 3.58 0 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm3 8c-.28 0-.53-.11-.71-.29L9 6.41V12c0 .55-.45 1-1 1s-1-.45-1-1V6.41l-1.29 1.3a1.003 1.003 0 01-1.42-1.42l3-3C7.47 3.11 7.72 3 8 3s.53.11.71.29l3 3A1.003 1.003 0 0111 8z"];
  init_define_process();
  var user_default = ["M7.99-.01A7.998 7.998 0 00.03 8.77c.01.09.03.18.04.28.02.15.04.31.07.47.02.11.05.22.08.34.03.13.06.26.1.38.04.12.08.25.12.37.04.11.08.21.12.32a6.583 6.583 0 00.3.65c.07.14.14.27.22.4.04.07.08.13.12.2l.27.42.1.13a7.973 7.973 0 003.83 2.82c.03.01.05.02.07.03.37.12.75.22 1.14.29l.2.03c.39.06.79.1 1.2.1s.81-.04 1.2-.1l.2-.03c.39-.07.77-.16 1.14-.29.03-.01.05-.02.07-.03a8.037 8.037 0 003.83-2.82c.03-.04.06-.08.09-.13.1-.14.19-.28.28-.42.04-.07.08-.13.12-.2.08-.13.15-.27.22-.41.04-.08.08-.17.12-.26.06-.13.11-.26.17-.39.04-.1.08-.21.12-.32.04-.12.08-.24.12-.37.04-.13.07-.25.1-.38.03-.11.06-.22.08-.34.03-.16.05-.31.07-.47.01-.09.03-.18.04-.28.02-.26.04-.51.04-.78-.03-4.41-3.61-7.99-8.03-7.99zm0 14.4c-1.98 0-3.75-.9-4.92-2.31.67-.36 1.49-.66 2.14-.95 1.16-.52 1.04-.84 1.08-1.27.01-.06.01-.11.01-.17-.41-.36-.74-.86-.96-1.44v-.01c0-.01-.01-.02-.01-.02-.05-.13-.09-.26-.12-.39-.28-.05-.44-.35-.5-.63-.06-.11-.18-.38-.15-.69.04-.41.2-.59.38-.67v-.06c0-.51.05-1.24.14-1.72.02-.13.05-.26.09-.39.17-.59.53-1.12 1.01-1.49.49-.38 1.19-.59 1.82-.59.62 0 1.32.2 1.82.59.48.37.84.9 1.01 1.49.04.13.07.26.09.4.09.48.14 1.21.14 1.72v.07c.18.08.33.26.37.66.03.31-.1.58-.16.69-.06.27-.21.57-.48.62-.03.13-.07.26-.12.38 0 .01-.01.04-.01.04-.21.57-.54 1.06-.94 1.42 0 .06.01.13.01.19.04.43-.12.75 1.05 1.27.65.29 1.47.6 2.14.95a6.415 6.415 0 01-4.93 2.31z"];
  init_define_process();
  var variable_default = ["M3.94 3.15c.47-.66 1.05-1.24 1.76-1.73l.13-.4c-1.11.45-2.05 1.01-2.84 1.7-1.02.88-1.8 1.9-2.32 3.05C.22 6.76 0 7.75 0 8.75c0 1.75.66 3.5 1.99 5.25l.13-.42c-.39-.94-.59-1.82-.59-2.63 0-1.28.22-2.64.67-4.1.45-1.45 1.03-2.69 1.74-3.7zm7.51 6.41l-.27-.15c-.3.41-.52.66-.66.77-.09.06-.21.1-.33.1-.15 0-.3-.1-.45-.28-.25-.33-.59-1.22-1.01-2.69.38-.65.69-1.08.95-1.28.19-.15.39-.22.59-.22.08 0 .22.03.43.08.2.06.39.08.54.08.22 0 .4-.07.54-.22.15-.15.22-.34.22-.57 0-.25-.07-.45-.22-.59-.15-.15-.35-.22-.63-.22-.24 0-.47.06-.69.17-.21.11-.49.36-.82.74-.25.28-.61.78-1.1 1.48a6.72 6.72 0 00-.97-2.38l-2.59.44-.05.27c.19-.04.36-.06.49-.06.26 0 .47.11.64.33.26.34.63 1.38 1.11 3.12-.37.49-.63.81-.77.96-.23.24-.41.4-.56.47-.11.06-.24.09-.39.09-.11 0-.29-.06-.53-.18-.17-.07-.32-.11-.45-.11-.25 0-.46.08-.62.24-.16.16-.24.37-.24.61 0 .23.08.42.23.57.15.15.35.22.61.22.25 0 .48-.05.7-.15.22-.1.49-.32.82-.65.33-.33.78-.86 1.36-1.59.22.69.42 1.19.58 1.51.16.31.35.54.56.68.21.14.47.21.79.21.31 0 .62-.11.93-.33.4-.29.82-.77 1.26-1.47zm2.56-8.54l-.12.42c.39.95.59 1.82.59 2.64 0 1.09-.17 2.26-.5 3.51-.26.96-.6 1.87-1.02 2.71-.42.85-.82 1.51-1.21 1.98-.39.48-.87.92-1.44 1.32l-.14.4c1.11-.45 2.05-1.02 2.84-1.7 1.03-.89 1.81-1.91 2.33-3.05.44-.99.66-1.99.66-3 0-1.73-.66-3.48-1.99-5.23z"];
  init_define_process();
  var vertical_bar_chart_asc_default = ["M6 7c-.55 0-1 .45-1 1v7c0 .55.45 1 1 1s1-.45 1-1V8c0-.55-.45-1-1-1zM2 9c-.55 0-1 .45-1 1v5c0 .55.45 1 1 1s1-.45 1-1v-5c0-.55-.45-1-1-1zm8-5c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1s1-.45 1-1V5c0-.55-.45-1-1-1zm4-4c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var vertical_bar_chart_desc_default = ["M6 4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1s1-.45 1-1V5c0-.55-.45-1-1-1zM2 0c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1zm8 7c-.55 0-1 .45-1 1v7c0 .55.45 1 1 1s1-.45 1-1V8c0-.55-.45-1-1-1zm4 2c-.55 0-1 .45-1 1v5c0 .55.45 1 1 1s1-.45 1-1v-5c0-.55-.45-1-1-1z"];
  init_define_process();
  var vertical_distribution_default = ["M1 2h14c.55 0 1-.45 1-1s-.45-1-1-1H1C.45 0 0 .45 0 1s.45 1 1 1zm14 11H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zM3 5c-.55 0-1 .45-1 1v3c0 .55.45 1 1 1h9c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1H3z"];
  init_define_process();
  var vertical_inbetween_default = ["M16 0H0v1a1 1 0 001 1h14a1 1 0 001-1V0zM0 15v1h16v-1a1 1 0 00-1-1H1a1 1 0 00-1 1zM8.707 3.293a1 1 0 00-1.414 0l-2 2a1 1 0 001.414 1.414L8 5.414l1.293 1.293a1 1 0 001.414-1.414l-2-2zm-2 6a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l2-2a1 1 0 00-1.414-1.414L8 10.586 6.707 9.293z"];
  init_define_process();
  var video_default = ["M15 2H1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1zM5 11V5l6 3-6 3z"];
  init_define_process();
  var virus_default = ["M11.918 11.107l.737.737.052-.051A1 1 0 0114.2 13.12l-.078.087-1.414 1.414a1 1 0 01-1.492-1.327l.029-.033-.863-.863c-.426.231-.89.402-1.38.502L9 14l.117.007A1 1 0 019 16H7l-.117-.007A1 1 0 017 14v-1.1a4.967 4.967 0 01-1.447-.539l-.846.846.078.087a1 1 0 01-1.492 1.327l-1.414-1.414-.078-.087a1 1 0 011.492-1.327l.744-.744A4.986 4.986 0 013.23 9.5H2a1 1 0 01-1.993.117L0 9.5v-2a1 1 0 011.993-.117L2 7.5h1.025a4.973 4.973 0 01.905-2.405l-.512-.513-.125.125A1 1 0 011.8 3.38l.078-.087 1.414-1.414a1 1 0 011.529 1.277l.573.575a4.969 4.969 0 011.604-.63V2l-.116-.007a1 1 0 010-1.986L7 0h2a1 1 0 01.117 1.993L9 2l.001 1.1c.639.13 1.233.381 1.757.73l.535-.537-.078-.087a1 1 0 011.492-1.327l1.414 1.414.078.087a1 1 0 01-1.492 1.327l-.535.536a4.97 4.97 0 01.803 2.257H14l.007-.117A1 1 0 0116 7.5v2l-.007.117A1 1 0 0114 9.5h-1.229a4.987 4.987 0 01-.853 1.607zM10 9a1 1 0 100 2 1 1 0 000-2zM6.5 5a1.5 1.5 0 100 3 1.5 1.5 0 000-3z"];
  init_define_process();
  var volume_down_default = ["M9 2c-.28 0-.53.11-.71.29L5.59 5H3c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h2.59l2.71 2.71c.17.18.42.29.7.29.55 0 1-.45 1-1V3c0-.55-.45-1-1-1zm3.57 1.44l-1.59 1.22C11.62 5.61 12 6.76 12 8s-.38 2.39-1.02 3.34l1.59 1.22C13.47 11.27 14 9.7 14 8c0-1.7-.53-3.27-1.43-4.56z"];
  init_define_process();
  var volume_off_default = ["M11 2c-.28 0-.53.11-.71.29L7.59 5H5c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h2.59l2.71 2.71c.17.18.42.29.7.29.55 0 1-.45 1-1V3c0-.55-.45-1-1-1z"];
  init_define_process();
  var volume_up_default = ["M7 1.86c-.28 0-.53.11-.71.29l-2.7 2.71H1c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h2.59l2.71 2.71a1.003 1.003 0 001.71-.71v-10c-.01-.55-.46-1-1.01-1zm6.74-.99l-1.58 1.22A9.985 9.985 0 0114 7.86c0 2.16-.69 4.15-1.85 5.78l1.58 1.22c1.42-1.97 2.26-4.38 2.26-7 .01-2.61-.84-5.02-2.25-6.99zM8.98 4.52C9.62 5.48 10 6.63 10 7.86s-.38 2.39-1.02 3.34l1.59 1.22c.9-1.29 1.43-2.86 1.43-4.56 0-1.7-.53-3.27-1.43-4.56L8.98 4.52z"];
  init_define_process();
  var walk_default = ["M13 8h-2c-.16 0-.31-.05-.44-.11v.01l-1.02-.51-.37 1.86 1.38.92-.01.02c.27.17.46.46.46.81v4c0 .55-.45 1-1 1s-1-.45-1-1v-3.46l-1.27-.85-1.8 4.67h-.01A.98.98 0 015 16c-.55 0-1-.45-1-1 0-.13.03-.25.07-.36h-.01L7.39 6H5.62l-.73 1.45h-.01C4.72 7.77 4.39 8 4 8c-.55 0-1-.45-1-1 0-.16.05-.31.11-.44H3.1l1-2h.01c.17-.33.5-.56.89-.56h3.16l.29-.75C8.17 2.9 8 2.47 8 2c0-1.1.9-2 2-2s2 .9 2 2c0 1-.73 1.82-1.69 1.97l-.5 1.32 1.43.71H13c.55 0 1 .45 1 1s-.45 1-1 1z"];
  init_define_process();
  var warning_sign_default = ["M15.84 13.5l.01-.01-7-12-.01.01c-.17-.3-.48-.5-.85-.5s-.67.2-.85.5l-.01-.01-7 12 .01.01c-.09.15-.15.31-.15.5 0 .55.45 1 1 1h14c.55 0 1-.45 1-1 0-.19-.06-.35-.15-.5zm-6.85-.51h-2v-2h2v2zm0-3h-2v-5h2v5z"];
  init_define_process();
  var waterfall_chart_default = ["M8 7c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm-4 4h1c.55 0 1-.45 1-1V8c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1zm7-6c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1s-1 .45-1 1v1c0 .55.45 1 1 1zm4-3h-1c-.55 0-1 .45-1 1v7c0 .55.45 1 1 1h1c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1zm0 10H2V3c0-.55-.45-1-1-1s-1 .45-1 1v10c0 .55.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var waves_default = ["M3 1a1 1 0 01.894.553c.102.202.393.607.779.957.419.381.72.49.827.49.108 0 .408-.109.827-.49.386-.35.677-.755.779-.957a1 1 0 011.788 0c.102.202.393.607.779.957.419.381.72.49.827.49.108 0 .408-.109.827-.49.386-.35.677-.755.779-.957a1 1 0 011.788 0c.173.344.38.75.637 1.072.277.347.437.375.469.375a1 1 0 110 2c-.968 0-1.642-.64-2.03-1.125a4.755 4.755 0 01-.076-.097 6.093 6.093 0 01-.221.212C12.175 4.442 11.393 5 10.5 5c-.892 0-1.675-.558-2.173-1.01A6.243 6.243 0 018 3.67c-.105.11-.214.217-.327.32C7.175 4.442 6.393 5 5.5 5c-.892 0-1.675-.558-2.173-1.01a6.119 6.119 0 01-.221-.212l-.075.097C2.64 4.36 1.968 5 1 5a1 1 0 010-2c.032 0 .191-.028.47-.375.256-.321.463-.728.636-1.072A1 1 0 013 1zm0 5a1 1 0 01.894.553c.102.202.393.607.779.957.419.381.72.49.827.49.108 0 .408-.109.827-.49.386-.35.677-.755.779-.957a1 1 0 011.788 0c.102.202.393.607.779.957.419.381.72.49.827.49.108 0 .408-.109.827-.49.386-.35.677-.755.779-.957a1 1 0 011.788 0c.173.344.38.75.637 1.072.277.347.437.375.469.375a1 1 0 110 2c-.968 0-1.642-.639-2.03-1.125a4.726 4.726 0 01-.076-.097 6.093 6.093 0 01-.221.212c-.498.452-1.28 1.01-2.173 1.01-.892 0-1.675-.558-2.173-1.01A6.243 6.243 0 018 8.67c-.105.11-.214.217-.327.32C7.175 9.442 6.393 10 5.5 10c-.892 0-1.675-.558-2.173-1.01a6.119 6.119 0 01-.221-.212l-.075.097C2.64 9.36 1.968 10 1 10a1 1 0 010-2c.032 0 .191-.028.47-.375.256-.321.463-.728.636-1.072A1 1 0 013 6zm.894 5.553a1 1 0 00-1.788 0c-.173.344-.38.75-.637 1.072-.278.347-.437.375-.469.375a1 1 0 100 2c.968 0 1.642-.639 2.03-1.125a4.9 4.9 0 00.076-.097c.072.073.146.143.221.212.498.452 1.28 1.01 2.173 1.01.892 0 1.675-.558 2.173-1.01.113-.103.222-.21.327-.32.105.11.214.217.327.32.498.452 1.28 1.01 2.173 1.01.892 0 1.675-.558 2.173-1.01.075-.069.149-.14.221-.212a4.9 4.9 0 00.075.097C13.36 14.36 14.032 15 15 15a1 1 0 100-2c-.032 0-.191-.028-.47-.375-.256-.321-.463-.728-.636-1.072a1 1 0 00-1.788 0c-.102.202-.393.607-.779.957-.419.381-.72.49-.827.49-.108 0-.408-.109-.827-.49-.386-.35-.677-.755-.779-.957a1 1 0 00-1.788 0c-.102.202-.393.607-.779.957-.419.381-.72.49-.827.49-.108 0-.408-.109-.827-.49-.386-.35-.677-.755-.779-.957z"];
  init_define_process();
  var widget_default = ["M13 11h2V5h-2v6zM3 5H1v6h2V5zm11-1c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zM2 12c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM5 3h6V1H5v2zM2 0C.9 0 0 .9 0 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm3 15h6v-2H5v2z"];
  init_define_process();
  var widget_button_default = ["M1 3h14c.55 0 1 .45 1 1v8c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1zm1 2v6h12V5H2zm3 4c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm3 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm3 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"];
  init_define_process();
  var widget_footer_default = ["M14 0H2c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 14H3v-3h10v3zm0-4H3V2h10v8z"];
  init_define_process();
  var widget_header_default = ["M14 0H2c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 14H3V6h10v8zm0-9H3V2h10v3z"];
  init_define_process();
  var wind_default = ["M10 4a2 2 0 112 2H4a1 1 0 000 2h8a4 4 0 10-4-4 1 1 0 002 0zM1 9a1 1 0 100 2h7.5a1.5 1.5 0 010 3c-.749 0-1.386-.538-1.52-1.199a1 1 0 10-1.96.398C5.35 14.82 6.83 16 8.5 16a3.5 3.5 0 100-7H1z"];
  init_define_process();
  var wrench_default = ["M15.83 3.7l-3.06 3.05-2.84-.7-.7-2.83L12.29.17a5.004 5.004 0 00-4.83 1.29 4.967 4.967 0 00-1.12 5.36L.58 12.58c-.36.36-.58.86-.58 1.41 0 1.1.9 2 2 2 .55 0 1.05-.22 1.41-.59l5.77-5.77c1.79.69 3.91.33 5.35-1.12 1.32-1.3 1.74-3.15 1.3-4.81z"];
  init_define_process();
  var zoom_in_default = ["M7.99 5.99v-2c0-.55-.45-1-1-1s-1 .45-1 1v2h-2c-.55 0-1 .45-1 1s.45 1 1 1h2v2c0 .55.45 1 1 1s1-.45 1-1v-2h2c.55 0 1-.45 1-1s-.45-1-1-1h-2zm7.56 7.44l-2.67-2.68a6.94 6.94 0 001.11-3.76c0-3.87-3.13-7-7-7s-7 3.13-7 7 3.13 7 7 7c1.39 0 2.68-.42 3.76-1.11l2.68 2.67a1.498 1.498 0 102.12-2.12zm-8.56-1.44c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"];
  init_define_process();
  var zoom_out_default = ["M3.99 5.99c-.55 0-1 .45-1 1s.45 1 1 1h6c.55 0 1-.45 1-1s-.45-1-1-1h-6zm11.56 7.44l-2.67-2.68a6.94 6.94 0 001.11-3.76c0-3.87-3.13-7-7-7s-7 3.13-7 7 3.13 7 7 7c1.39 0 2.68-.42 3.76-1.11l2.68 2.67a1.498 1.498 0 102.12-2.12zm-8.56-1.44c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"];
  init_define_process();
  var zoom_to_fit_default = ["M11 10a1.003 1.003 0 001.71.71l2-2c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71l-2-2a1.003 1.003 0 00-1.42 1.42L12.59 8 11.3 9.29c-.19.18-.3.43-.3.71zM1 5c.55 0 1-.45 1-1V2h2c.55 0 1-.45 1-1s-.45-1-1-1H1C.45 0 0 .45 0 1v3c0 .55.45 1 1 1zm4 1a1.003 1.003 0 00-1.71-.71l-2 2C1.11 7.47 1 7.72 1 8c0 .28.11.53.29.71l2 2a1.003 1.003 0 001.42-1.42L3.41 8 4.7 6.71c.19-.18.3-.43.3-.71zm1-1c.28 0 .53-.11.71-.29L8 3.41 9.29 4.7c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-2-2C8.53 1.11 8.28 1 8 1s-.53.11-.71.29l-2 2A1.003 1.003 0 006 5zm9 6c-.55 0-1 .45-1 1v2h-2c-.55 0-1 .45-1 1s.45 1 1 1h3c.55 0 1-.45 1-1v-3c0-.55-.45-1-1-1zm0-11h-3c-.55 0-1 .45-1 1s.45 1 1 1h2v2c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1zM4 14H2v-2c0-.55-.45-1-1-1s-1 .45-1 1v3c0 .55.45 1 1 1h3c.55 0 1-.45 1-1s-.45-1-1-1zm6-3c-.28 0-.53.11-.71.29L8 12.59 6.71 11.3A.965.965 0 006 11a1.003 1.003 0 00-.71 1.71l2 2c.18.18.43.29.71.29s.53-.11.71-.29l2-2A1.003 1.003 0 0010 11z"];
  var paths_exports2 = {};
  __export(paths_exports2, {
    Add: () => add_default2,
    AddClip: () => add_clip_default2,
    AddColumnLeft: () => add_column_left_default2,
    AddColumnRight: () => add_column_right_default2,
    AddLocation: () => add_location_default2,
    AddRowBottom: () => add_row_bottom_default2,
    AddRowTop: () => add_row_top_default2,
    AddToArtifact: () => add_to_artifact_default2,
    AddToFolder: () => add_to_folder_default2,
    AimpointsTarget: () => aimpoints_target_default2,
    Airplane: () => airplane_default2,
    AlignCenter: () => align_center_default2,
    AlignJustify: () => align_justify_default2,
    AlignLeft: () => align_left_default2,
    AlignRight: () => align_right_default2,
    AlignmentBottom: () => alignment_bottom_default2,
    AlignmentHorizontalCenter: () => alignment_horizontal_center_default2,
    AlignmentLeft: () => alignment_left_default2,
    AlignmentRight: () => alignment_right_default2,
    AlignmentTop: () => alignment_top_default2,
    AlignmentVerticalCenter: () => alignment_vertical_center_default2,
    Anchor: () => anchor_default2,
    Annotation: () => annotation_default2,
    Antenna: () => antenna_default2,
    AppHeader: () => app_header_default2,
    Application: () => application_default2,
    Applications: () => applications_default2,
    Archive: () => archive_default2,
    AreaOfInterest: () => area_of_interest_default2,
    Array: () => array_default2,
    ArrayBoolean: () => array_boolean_default2,
    ArrayDate: () => array_date_default2,
    ArrayFloatingPoint: () => array_floating_point_default2,
    ArrayNumeric: () => array_numeric_default2,
    ArrayString: () => array_string_default2,
    ArrayTimestamp: () => array_timestamp_default2,
    ArrowBottomLeft: () => arrow_bottom_left_default2,
    ArrowBottomRight: () => arrow_bottom_right_default2,
    ArrowDown: () => arrow_down_default2,
    ArrowLeft: () => arrow_left_default2,
    ArrowRight: () => arrow_right_default2,
    ArrowTopLeft: () => arrow_top_left_default2,
    ArrowTopRight: () => arrow_top_right_default2,
    ArrowUp: () => arrow_up_default2,
    ArrowsHorizontal: () => arrows_horizontal_default2,
    ArrowsVertical: () => arrows_vertical_default2,
    Asterisk: () => asterisk_default2,
    At: () => at_default2,
    AutomaticUpdates: () => automatic_updates_default2,
    Backlink: () => backlink_default2,
    Badge: () => badge_default2,
    BanCircle: () => ban_circle_default2,
    BankAccount: () => bank_account_default2,
    Barcode: () => barcode_default2,
    Blank: () => blank_default2,
    BlockedPerson: () => blocked_person_default2,
    Bold: () => bold_default2,
    Book: () => book_default2,
    Bookmark: () => bookmark_default2,
    Box: () => box_default2,
    Briefcase: () => briefcase_default2,
    BringData: () => bring_data_default2,
    Bug: () => bug_default2,
    Buggy: () => buggy_default2,
    Build: () => build_default2,
    Calculator: () => calculator_default2,
    Calendar: () => calendar_default2,
    Camera: () => camera_default2,
    CaretDown: () => caret_down_default2,
    CaretLeft: () => caret_left_default2,
    CaretRight: () => caret_right_default2,
    CaretUp: () => caret_up_default2,
    CargoShip: () => cargo_ship_default2,
    CellTower: () => cell_tower_default2,
    Changes: () => changes_default2,
    Chart: () => chart_default2,
    Chat: () => chat_default2,
    ChevronBackward: () => chevron_backward_default2,
    ChevronDown: () => chevron_down_default2,
    ChevronForward: () => chevron_forward_default2,
    ChevronLeft: () => chevron_left_default2,
    ChevronRight: () => chevron_right_default2,
    ChevronUp: () => chevron_up_default2,
    Circle: () => circle_default2,
    CircleArrowDown: () => circle_arrow_down_default2,
    CircleArrowLeft: () => circle_arrow_left_default2,
    CircleArrowRight: () => circle_arrow_right_default2,
    CircleArrowUp: () => circle_arrow_up_default2,
    Citation: () => citation_default2,
    Clean: () => clean_default2,
    Clip: () => clip_default2,
    Clipboard: () => clipboard_default2,
    Cloud: () => cloud_default2,
    CloudDownload: () => cloud_download_default2,
    CloudUpload: () => cloud_upload_default2,
    Code: () => code_default2,
    CodeBlock: () => code_block_default2,
    Cog: () => cog_default2,
    CollapseAll: () => collapse_all_default2,
    ColorFill: () => color_fill_default2,
    ColumnLayout: () => column_layout_default2,
    Comment: () => comment_default2,
    Comparison: () => comparison_default2,
    Compass: () => compass_default2,
    Compressed: () => compressed_default2,
    Confirm: () => confirm_default2,
    Console: () => console_default2,
    Contrast: () => contrast_default2,
    Control: () => control_default2,
    CreditCard: () => credit_card_default2,
    Cross: () => cross_default2,
    CrossCircle: () => cross_circle_default2,
    Crown: () => crown_default2,
    Cube: () => cube_default2,
    CubeAdd: () => cube_add_default2,
    CubeRemove: () => cube_remove_default2,
    CurvedRangeChart: () => curved_range_chart_default2,
    Cut: () => cut_default2,
    Cycle: () => cycle_default2,
    Dashboard: () => dashboard_default2,
    DataConnection: () => data_connection_default2,
    DataLineage: () => data_lineage_default2,
    Database: () => database_default2,
    Delete: () => delete_default2,
    Delta: () => delta_default2,
    DeriveColumn: () => derive_column_default2,
    Desktop: () => desktop_default2,
    Diagnosis: () => diagnosis_default2,
    DiagramTree: () => diagram_tree_default2,
    DirectionLeft: () => direction_left_default2,
    DirectionRight: () => direction_right_default2,
    Disable: () => disable_default2,
    Divide: () => divide_default2,
    Document: () => document_default2,
    DocumentOpen: () => document_open_default2,
    DocumentShare: () => document_share_default2,
    Dollar: () => dollar_default2,
    Dot: () => dot_default2,
    DoubleCaretHorizontal: () => double_caret_horizontal_default2,
    DoubleCaretVertical: () => double_caret_vertical_default2,
    DoubleChevronDown: () => double_chevron_down_default2,
    DoubleChevronLeft: () => double_chevron_left_default2,
    DoubleChevronRight: () => double_chevron_right_default2,
    DoubleChevronUp: () => double_chevron_up_default2,
    DoughnutChart: () => doughnut_chart_default2,
    Download: () => download_default2,
    DragHandleHorizontal: () => drag_handle_horizontal_default2,
    DragHandleVertical: () => drag_handle_vertical_default2,
    Draw: () => draw_default2,
    DrawerLeft: () => drawer_left_default2,
    DrawerLeftFilled: () => drawer_left_filled_default2,
    DrawerRight: () => drawer_right_default2,
    DrawerRightFilled: () => drawer_right_filled_default2,
    DriveTime: () => drive_time_default2,
    Duplicate: () => duplicate_default2,
    Edit: () => edit_default2,
    Eject: () => eject_default2,
    Emoji: () => emoji_default2,
    Endorsed: () => endorsed_default2,
    Envelope: () => envelope_default2,
    Equals: () => equals_default2,
    Eraser: () => eraser_default2,
    Error: () => error_default2,
    Euro: () => euro_default2,
    Exchange: () => exchange_default2,
    ExcludeRow: () => exclude_row_default2,
    ExpandAll: () => expand_all_default2,
    Export: () => export_default2,
    EyeOff: () => eye_off_default2,
    EyeOn: () => eye_on_default2,
    EyeOpen: () => eye_open_default2,
    FastBackward: () => fast_backward_default2,
    FastForward: () => fast_forward_default2,
    Feed: () => feed_default2,
    FeedSubscribed: () => feed_subscribed_default2,
    Film: () => film_default2,
    Filter: () => filter_default2,
    FilterKeep: () => filter_keep_default2,
    FilterList: () => filter_list_default2,
    FilterOpen: () => filter_open_default2,
    FilterRemove: () => filter_remove_default2,
    Flag: () => flag_default2,
    Flame: () => flame_default2,
    Flash: () => flash_default2,
    FloatingPoint: () => floating_point_default2,
    FloppyDisk: () => floppy_disk_default2,
    FlowBranch: () => flow_branch_default2,
    FlowEnd: () => flow_end_default2,
    FlowLinear: () => flow_linear_default2,
    FlowReview: () => flow_review_default2,
    FlowReviewBranch: () => flow_review_branch_default2,
    Flows: () => flows_default2,
    FolderClose: () => folder_close_default2,
    FolderNew: () => folder_new_default2,
    FolderOpen: () => folder_open_default2,
    FolderShared: () => folder_shared_default2,
    FolderSharedOpen: () => folder_shared_open_default2,
    Follower: () => follower_default2,
    Following: () => following_default2,
    Font: () => font_default2,
    Fork: () => fork_default2,
    Form: () => form_default2,
    Fuel: () => fuel_default2,
    FullCircle: () => full_circle_default2,
    FullStackedChart: () => full_stacked_chart_default2,
    Fullscreen: () => fullscreen_default2,
    Function: () => function_default2,
    GanttChart: () => gantt_chart_default2,
    Geofence: () => geofence_default2,
    Geolocation: () => geolocation_default2,
    Geosearch: () => geosearch_default2,
    GitBranch: () => git_branch_default2,
    GitCommit: () => git_commit_default2,
    GitMerge: () => git_merge_default2,
    GitNewBranch: () => git_new_branch_default2,
    GitPull: () => git_pull_default2,
    GitPush: () => git_push_default2,
    GitRepo: () => git_repo_default2,
    Glass: () => glass_default2,
    Globe: () => globe_default2,
    GlobeNetwork: () => globe_network_default2,
    Graph: () => graph_default2,
    GraphRemove: () => graph_remove_default2,
    GreaterThan: () => greater_than_default2,
    GreaterThanOrEqualTo: () => greater_than_or_equal_to_default2,
    Grid: () => grid_default2,
    GridView: () => grid_view_default2,
    GroupObjects: () => group_objects_default2,
    GroupedBarChart: () => grouped_bar_chart_default2,
    Hand: () => hand_default2,
    HandDown: () => hand_down_default2,
    HandLeft: () => hand_left_default2,
    HandRight: () => hand_right_default2,
    HandUp: () => hand_up_default2,
    Hat: () => hat_default2,
    Header: () => header_default2,
    HeaderOne: () => header_one_default2,
    HeaderThree: () => header_three_default2,
    HeaderTwo: () => header_two_default2,
    Headset: () => headset_default2,
    Heart: () => heart_default2,
    HeartBroken: () => heart_broken_default2,
    HeatGrid: () => heat_grid_default2,
    Heatmap: () => heatmap_default2,
    Helicopter: () => helicopter_default2,
    Help: () => help_default2,
    HelperManagement: () => helper_management_default2,
    HighPriority: () => high_priority_default2,
    HighVoltagePole: () => high_voltage_pole_default2,
    Highlight: () => highlight_default2,
    History: () => history_default2,
    Home: () => home_default2,
    HorizontalBarChart: () => horizontal_bar_chart_default2,
    HorizontalBarChartAsc: () => horizontal_bar_chart_asc_default2,
    HorizontalBarChartDesc: () => horizontal_bar_chart_desc_default2,
    HorizontalDistribution: () => horizontal_distribution_default2,
    HorizontalInbetween: () => horizontal_inbetween_default2,
    Hurricane: () => hurricane_default2,
    IdNumber: () => id_number_default2,
    ImageRotateLeft: () => image_rotate_left_default2,
    ImageRotateRight: () => image_rotate_right_default2,
    Import: () => import_default2,
    Inbox: () => inbox_default2,
    InboxFiltered: () => inbox_filtered_default2,
    InboxGeo: () => inbox_geo_default2,
    InboxSearch: () => inbox_search_default2,
    InboxUpdate: () => inbox_update_default2,
    InfoSign: () => info_sign_default2,
    Inheritance: () => inheritance_default2,
    InheritedGroup: () => inherited_group_default2,
    InnerJoin: () => inner_join_default2,
    Insert: () => insert_default2,
    Intelligence: () => intelligence_default2,
    Intersection: () => intersection_default2,
    IpAddress: () => ip_address_default2,
    Issue: () => issue_default2,
    IssueClosed: () => issue_closed_default2,
    IssueNew: () => issue_new_default2,
    Italic: () => italic_default2,
    JoinTable: () => join_table_default2,
    Key: () => key_default2,
    KeyBackspace: () => key_backspace_default2,
    KeyCommand: () => key_command_default2,
    KeyControl: () => key_control_default2,
    KeyDelete: () => key_delete_default2,
    KeyEnter: () => key_enter_default2,
    KeyEscape: () => key_escape_default2,
    KeyOption: () => key_option_default2,
    KeyShift: () => key_shift_default2,
    KeyTab: () => key_tab_default2,
    KnownVehicle: () => known_vehicle_default2,
    LabTest: () => lab_test_default2,
    Label: () => label_default2,
    Layer: () => layer_default2,
    LayerOutline: () => layer_outline_default2,
    Layers: () => layers_default2,
    Layout: () => layout_default2,
    LayoutAuto: () => layout_auto_default2,
    LayoutBalloon: () => layout_balloon_default2,
    LayoutCircle: () => layout_circle_default2,
    LayoutGrid: () => layout_grid_default2,
    LayoutGroupBy: () => layout_group_by_default2,
    LayoutHierarchy: () => layout_hierarchy_default2,
    LayoutLinear: () => layout_linear_default2,
    LayoutSkewGrid: () => layout_skew_grid_default2,
    LayoutSortedClusters: () => layout_sorted_clusters_default2,
    Learning: () => learning_default2,
    LeftJoin: () => left_join_default2,
    LessThan: () => less_than_default2,
    LessThanOrEqualTo: () => less_than_or_equal_to_default2,
    Lifesaver: () => lifesaver_default2,
    Lightbulb: () => lightbulb_default2,
    Lightning: () => lightning_default2,
    Link: () => link_default2,
    List: () => list_default2,
    ListColumns: () => list_columns_default2,
    ListDetailView: () => list_detail_view_default2,
    Locate: () => locate_default2,
    Lock: () => lock_default2,
    LogIn: () => log_in_default2,
    LogOut: () => log_out_default2,
    LowVoltagePole: () => low_voltage_pole_default2,
    Manual: () => manual_default2,
    ManuallyEnteredData: () => manually_entered_data_default2,
    ManyToMany: () => many_to_many_default2,
    ManyToOne: () => many_to_one_default2,
    Map: () => map_default2,
    MapCreate: () => map_create_default2,
    MapMarker: () => map_marker_default2,
    Maximize: () => maximize_default2,
    Media: () => media_default2,
    Menu: () => menu_default2,
    MenuClosed: () => menu_closed_default2,
    MenuOpen: () => menu_open_default2,
    MergeColumns: () => merge_columns_default2,
    MergeLinks: () => merge_links_default2,
    Minimize: () => minimize_default2,
    Minus: () => minus_default2,
    MobilePhone: () => mobile_phone_default2,
    MobileVideo: () => mobile_video_default2,
    Modal: () => modal_default2,
    ModalFilled: () => modal_filled_default2,
    Moon: () => moon_default2,
    More: () => more_default2,
    Mountain: () => mountain_default2,
    Move: () => move_default2,
    Mugshot: () => mugshot_default2,
    MultiSelect: () => multi_select_default2,
    Music: () => music_default2,
    Nest: () => nest_default2,
    NewDrawing: () => new_drawing_default2,
    NewGridItem: () => new_grid_item_default2,
    NewLayer: () => new_layer_default2,
    NewLayers: () => new_layers_default2,
    NewLink: () => new_link_default2,
    NewObject: () => new_object_default2,
    NewPerson: () => new_person_default2,
    NewPrescription: () => new_prescription_default2,
    NewTextBox: () => new_text_box_default2,
    Ninja: () => ninja_default2,
    NotEqualTo: () => not_equal_to_default2,
    Notifications: () => notifications_default2,
    NotificationsSnooze: () => notifications_snooze_default2,
    NotificationsUpdated: () => notifications_updated_default2,
    NumberedList: () => numbered_list_default2,
    Numerical: () => numerical_default2,
    Office: () => office_default2,
    Offline: () => offline_default2,
    OilField: () => oil_field_default2,
    OneColumn: () => one_column_default2,
    OneToMany: () => one_to_many_default2,
    OneToOne: () => one_to_one_default2,
    OpenApplication: () => open_application_default2,
    Outdated: () => outdated_default2,
    PageLayout: () => page_layout_default2,
    PanelStats: () => panel_stats_default2,
    PanelTable: () => panel_table_default2,
    Paperclip: () => paperclip_default2,
    Paragraph: () => paragraph_default2,
    Path: () => path_default2,
    PathSearch: () => path_search_default2,
    Pause: () => pause_default2,
    People: () => people_default2,
    Percentage: () => percentage_default2,
    Person: () => person_default2,
    Phone: () => phone_default2,
    PieChart: () => pie_chart_default2,
    Pin: () => pin_default2,
    Pivot: () => pivot_default2,
    PivotTable: () => pivot_table_default2,
    Play: () => play_default2,
    Playbook: () => playbook_default2,
    Plus: () => plus_default2,
    PolygonFilter: () => polygon_filter_default2,
    Power: () => power_default2,
    PredictiveAnalysis: () => predictive_analysis_default2,
    Prescription: () => prescription_default2,
    Presentation: () => presentation_default2,
    Print: () => print_default2,
    Projects: () => projects_default2,
    Properties: () => properties_default2,
    Property: () => property_default2,
    PublishFunction: () => publish_function_default2,
    Pulse: () => pulse_default2,
    Rain: () => rain_default2,
    Random: () => random_default2,
    Record: () => record_default2,
    RectHeight: () => rect_height_default2,
    RectWidth: () => rect_width_default2,
    Rectangle: () => rectangle_default2,
    Redo: () => redo_default2,
    Refresh: () => refresh_default2,
    Regex: () => regex_default2,
    RegressionChart: () => regression_chart_default2,
    Remove: () => remove_default2,
    RemoveColumn: () => remove_column_default2,
    RemoveColumnLeft: () => remove_column_left_default2,
    RemoveColumnRight: () => remove_column_right_default2,
    RemoveRowBottom: () => remove_row_bottom_default2,
    RemoveRowTop: () => remove_row_top_default2,
    Repeat: () => repeat_default2,
    Reset: () => reset_default2,
    Resolve: () => resolve_default2,
    Rig: () => rig_default2,
    RightJoin: () => right_join_default2,
    Ring: () => ring_default2,
    Rocket: () => rocket_default2,
    RocketSlant: () => rocket_slant_default2,
    RotateDocument: () => rotate_document_default2,
    RotatePage: () => rotate_page_default2,
    Route: () => route_default2,
    Satellite: () => satellite_default2,
    Saved: () => saved_default2,
    ScatterPlot: () => scatter_plot_default2,
    Search: () => search_default2,
    SearchAround: () => search_around_default2,
    SearchTemplate: () => search_template_default2,
    SearchText: () => search_text_default2,
    SegmentedControl: () => segmented_control_default2,
    Select: () => select_default2,
    Selection: () => selection_default2,
    SendMessage: () => send_message_default2,
    SendTo: () => send_to_default2,
    SendToGraph: () => send_to_graph_default2,
    SendToMap: () => send_to_map_default2,
    SeriesAdd: () => series_add_default2,
    SeriesConfiguration: () => series_configuration_default2,
    SeriesDerived: () => series_derived_default2,
    SeriesFiltered: () => series_filtered_default2,
    SeriesSearch: () => series_search_default2,
    Settings: () => settings_default2,
    Shapes: () => shapes_default2,
    Share: () => share_default2,
    SharedFilter: () => shared_filter_default2,
    Shield: () => shield_default2,
    Ship: () => ship_default2,
    Shop: () => shop_default2,
    ShoppingCart: () => shopping_cart_default2,
    SignalSearch: () => signal_search_default2,
    SimCard: () => sim_card_default2,
    Slash: () => slash_default2,
    SmallCross: () => small_cross_default2,
    SmallInfoSign: () => small_info_sign_default2,
    SmallMinus: () => small_minus_default2,
    SmallPlus: () => small_plus_default2,
    SmallSquare: () => small_square_default2,
    SmallTick: () => small_tick_default2,
    Snowflake: () => snowflake_default2,
    SocialMedia: () => social_media_default2,
    Sort: () => sort_default2,
    SortAlphabetical: () => sort_alphabetical_default2,
    SortAlphabeticalDesc: () => sort_alphabetical_desc_default2,
    SortAsc: () => sort_asc_default2,
    SortDesc: () => sort_desc_default2,
    SortNumerical: () => sort_numerical_default2,
    SortNumericalDesc: () => sort_numerical_desc_default2,
    SplitColumns: () => split_columns_default2,
    Square: () => square_default2,
    StackedChart: () => stacked_chart_default2,
    StadiumGeometry: () => stadium_geometry_default2,
    Star: () => star_default2,
    StarEmpty: () => star_empty_default2,
    StepBackward: () => step_backward_default2,
    StepChart: () => step_chart_default2,
    StepForward: () => step_forward_default2,
    Stop: () => stop_default2,
    Stopwatch: () => stopwatch_default2,
    Strikethrough: () => strikethrough_default2,
    Style: () => style_default2,
    SwapHorizontal: () => swap_horizontal_default2,
    SwapVertical: () => swap_vertical_default2,
    Switch: () => switch_default2,
    SymbolCircle: () => symbol_circle_default2,
    SymbolCross: () => symbol_cross_default2,
    SymbolDiamond: () => symbol_diamond_default2,
    SymbolRectangle: () => symbol_rectangle_default2,
    SymbolSquare: () => symbol_square_default2,
    SymbolTriangleDown: () => symbol_triangle_down_default2,
    SymbolTriangleUp: () => symbol_triangle_up_default2,
    Syringe: () => syringe_default2,
    Tag: () => tag_default2,
    TakeAction: () => take_action_default2,
    Tank: () => tank_default2,
    Target: () => target_default2,
    Taxi: () => taxi_default2,
    Temperature: () => temperature_default2,
    TextHighlight: () => text_highlight_default2,
    Th: () => th_default2,
    ThDerived: () => th_derived_default2,
    ThDisconnect: () => th_disconnect_default2,
    ThFiltered: () => th_filtered_default2,
    ThList: () => th_list_default2,
    ThirdParty: () => third_party_default2,
    ThumbsDown: () => thumbs_down_default2,
    ThumbsUp: () => thumbs_up_default2,
    Tick: () => tick_default2,
    TickCircle: () => tick_circle_default2,
    Time: () => time_default2,
    TimelineAreaChart: () => timeline_area_chart_default2,
    TimelineBarChart: () => timeline_bar_chart_default2,
    TimelineEvents: () => timeline_events_default2,
    TimelineLineChart: () => timeline_line_chart_default2,
    Tint: () => tint_default2,
    Torch: () => torch_default2,
    Tractor: () => tractor_default2,
    Train: () => train_default2,
    Translate: () => translate_default2,
    Trash: () => trash_default2,
    Tree: () => tree_default2,
    TrendingDown: () => trending_down_default2,
    TrendingUp: () => trending_up_default2,
    Truck: () => truck_default2,
    TwoColumns: () => two_columns_default2,
    Unarchive: () => unarchive_default2,
    Underline: () => underline_default2,
    Undo: () => undo_default2,
    UngroupObjects: () => ungroup_objects_default2,
    UnknownVehicle: () => unknown_vehicle_default2,
    Unlock: () => unlock_default2,
    Unpin: () => unpin_default2,
    Unresolve: () => unresolve_default2,
    Updated: () => updated_default2,
    Upload: () => upload_default2,
    User: () => user_default2,
    Variable: () => variable_default2,
    VerticalBarChartAsc: () => vertical_bar_chart_asc_default2,
    VerticalBarChartDesc: () => vertical_bar_chart_desc_default2,
    VerticalDistribution: () => vertical_distribution_default2,
    VerticalInbetween: () => vertical_inbetween_default2,
    Video: () => video_default2,
    Virus: () => virus_default2,
    VolumeDown: () => volume_down_default2,
    VolumeOff: () => volume_off_default2,
    VolumeUp: () => volume_up_default2,
    Walk: () => walk_default2,
    WarningSign: () => warning_sign_default2,
    WaterfallChart: () => waterfall_chart_default2,
    Waves: () => waves_default2,
    Widget: () => widget_default2,
    WidgetButton: () => widget_button_default2,
    WidgetFooter: () => widget_footer_default2,
    WidgetHeader: () => widget_header_default2,
    Wind: () => wind_default2,
    Wrench: () => wrench_default2,
    ZoomIn: () => zoom_in_default2,
    ZoomOut: () => zoom_out_default2,
    ZoomToFit: () => zoom_to_fit_default2
  });
  init_define_process();
  init_define_process();
  var add_default2 = ["M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm5-9h-4V5c0-.55-.45-1-1-1s-1 .45-1 1v4H5c-.55 0-1 .45-1 1s.45 1 1 1h4v4c0 .55.45 1 1 1s1-.45 1-1v-4h4c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var add_clip_default2 = ["M15 0a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0V6h-3a1 1 0 110-2h3V1a1 1 0 011-1zM1 4a1 1 0 00-1 1v4a1 1 0 002 0V6h3a1 1 0 000-2H1zM0 19a1 1 0 001 1h4a1 1 0 100-2H2v-3a1 1 0 10-2 0v4zm15 1h-4a1 1 0 110-2h3v-3a1 1 0 112 0v4a1 1 0 01-1 1zm-7-5a3 3 0 100-6 3 3 0 000 6z"];
  init_define_process();
  var add_column_left_default2 = ["M4 11h2v2c0 .55.45 1 1 1s1-.45 1-1v-2h2c.55 0 1-.45 1-1s-.45-1-1-1H8V7c0-.55-.45-1-1-1s-1 .45-1 1v2H4c-.55 0-1 .45-1 1s.45 1 1 1zM19 0H1C.45 0 0 .45 0 1v18c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-7 18H2V2h10v16zm6 0h-5V2h5v16z"];
  init_define_process();
  var add_column_right_default2 = ["M10 11h2v2c0 .55.45 1 1 1s1-.45 1-1v-2h2c.55 0 1-.45 1-1s-.45-1-1-1h-2V7c0-.55-.45-1-1-1s-1 .45-1 1v2h-2c-.55 0-1 .45-1 1s.45 1 1 1zm9-11H1C.45 0 0 .45 0 1v18c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zM7 18H2V2h5v16zm11 0H8V2h10v16z"];
  init_define_process();
  var add_location_default2 = ["M10 0a1 1 0 010 2 8 8 0 108 8 1 1 0 012 0c0 5.523-4.477 10-10 10S0 15.523 0 10 4.477 0 10 0zm0 6a4 4 0 110 8 4 4 0 010-8zm6-6c.6 0 1 .4 1 1v2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1s-1-.4-1-1V5h-2c-.6 0-1-.4-1-1 0-.5.4-1 1-1h2V1c0-.6.4-1 1-1z"];
  init_define_process();
  var add_row_bottom_default2 = ["M19 0H1C.45 0 0 .45 0 1v18c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 18H2V8h16v10zm0-11H2V2h16v5zM7 14h2v2c0 .55.45 1 1 1s1-.45 1-1v-2h2c.55 0 1-.45 1-1s-.45-1-1-1h-2v-2c0-.55-.45-1-1-1s-1 .45-1 1v2H7c-.55 0-1 .45-1 1s.45 1 1 1z"];
  init_define_process();
  var add_row_top_default2 = ["M7 8h2v2c0 .55.45 1 1 1s1-.45 1-1V8h2c.55 0 1-.45 1-1s-.45-1-1-1h-2V4c0-.55-.45-1-1-1s-1 .45-1 1v2H7c-.55 0-1 .45-1 1s.45 1 1 1zm12-8H1C.45 0 0 .45 0 1v18c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 18H2v-5h16v5zm0-6H2V2h16v10z"];
  init_define_process();
  var add_to_artifact_default2 = ["M13 12H1c-.55 0-1 .45-1 1s.45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1zm0 4H1c-.55 0-1 .45-1 1s.45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1zM1 6h9c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1zm12 2H1c-.55 0-1 .45-1 1s.45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1zm6-4h-2V2c0-.55-.45-1-1-1s-1 .45-1 1v2h-2c-.55 0-1 .45-1 1s.45 1 1 1h2v2c0 .55.45 1 1 1s1-.45 1-1V6h2c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var add_to_folder_default2 = ["M.01 10V6H20v10c0 .55-.45 1-1 1H9.995v-3.99C9.965 11.332 8.635 10 6.987 10H.01zM19 3c.55 0 1 .45.99 1v1H0V2c0-.55.45-1 1-1h5.997c.28 0 .53.11.71.29L9.414 3H19zM6.987 12c.55 0 .999.45 1.009 1.01v5c0 .55-.45 1-1 1s-.999-.45-.999-1v-2.59l-4.288 4.29a1.003 1.003 0 01-1.42-1.42L4.579 14H1.989c-.55 0-1-.45-1-1s.45-1 1-1h4.998z"];
  init_define_process();
  var aimpoints_target_default2 = ["M2.296 12.163a4.492 4.492 0 00-1.792.98A9.99 9.99 0 010 10C0 4.477 4.477 0 10 0a9.99 9.99 0 013.143.504 4.492 4.492 0 00-.98 1.792 8 8 0 00-9.867 9.867zM18 10c0-.75-.103-1.475-.296-2.163a4.491 4.491 0 001.792-.98C19.823 7.847 20 8.903 20 10c0 5.523-4.477 10-10 10a9.992 9.992 0 01-3.142-.504 4.491 4.491 0 00.98-1.792A8 8 0 0018 10zM19 3.5a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0zM6 16.5a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0z", "M10 4a1 1 0 00-1 1v3a1 1 0 002 0V5a1 1 0 00-1-1zM11 10a1 1 0 011-1h3a1 1 0 010 2h-3a1 1 0 01-1-1zM4 10a1 1 0 011-1h3a1 1 0 010 2H5a1 1 0 01-1-1zM9 12a1 1 0 012 0v3a1 1 0 01-2 0v-3z"];
  init_define_process();
  var airplane_default2 = ["M20 2c0-1.1-.9-2-2-2-.55 0-1.05.22-1.41.59l-4.84 4.84L2 1 1 3l7.53 5.64L4.17 13H1l-1 1 4 2 2 4 1-1v-3.17l4.36-4.36L17 19l2-1-4.43-9.74 4.84-4.84c.37-.37.59-.87.59-1.42z"];
  init_define_process();
  var align_center_default2 = ["M5 5c-.55 0-1 .45-1 1s.45 1 1 1h10c.55 0 1-.45 1-1s-.45-1-1-1H5zM1 3h18c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1zm12 12c.55 0 1-.45 1-1s-.45-1-1-1H7c-.55 0-1 .45-1 1s.45 1 1 1h6zm4 2H3c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zm2-8H1c-.55 0-1 .45-1 1s.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var align_justify_default2 = ["M1 3h18c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1zm18 14H1c-.55 0-1 .45-1 1s.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1zm0-12H1c-.55 0-1 .45-1 1s.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1zm0 4H1c-.55 0-1 .45-1 1s.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1zm0 4H1c-.55 0-1 .45-1 1s.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var align_left_default2 = ["M1 7h10c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1zm0-4h18c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1zm14 14H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zm4-8H1c-.55 0-1 .45-1 1s.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1zM1 15h6c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1z"];
  init_define_process();
  var align_right_default2 = ["M19 17H5c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1zM1 3h18c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1zm18 10h-6c-.55 0-1 .45-1 1s.45 1 1 1h6c.55 0 1-.45 1-1s-.45-1-1-1zm0-4H1c-.55 0-1 .45-1 1s.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1zm0-4H9c-.55 0-1 .45-1 1s.45 1 1 1h10c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var alignment_bottom_default2 = ["M12 16h4c.55 0 1-.45 1-1V8c0-.55-.45-1-1-1h-4c-.55 0-1 .45-1 1v7c0 .55.45 1 1 1zm7 2H1c-.55 0-1 .45-1 1s.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1zM4 16h4c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1z"];
  init_define_process();
  var alignment_horizontal_center_default2 = ["M19 9h-2V7c0-.55-.45-1-1-1h-4c-.55 0-1 .45-1 1v2H9V3c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v6H1c-.55 0-1 .45-1 1s.45 1 1 1h2v6c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-6h2v2c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-2h2c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var alignment_left_default2 = ["M1 0C.45 0 0 .45 0 1v18c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1zm11 11H5c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h7c.55 0 1-.45 1-1v-4c0-.55-.45-1-1-1zm7-8H5c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var alignment_right_default2 = ["M19 0c-.55 0-1 .45-1 1v18c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1zm-4 11H8c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h7c.55 0 1-.45 1-1v-4c0-.55-.45-1-1-1zm0-8H1c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var alignment_top_default2 = ["M8 4H4c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h4c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zm11-4H1C.45 0 0 .45 0 1s.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1zm-3 4h-4c-.55 0-1 .45-1 1v7c0 .55.45 1 1 1h4c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1z"];
  init_define_process();
  var alignment_vertical_center_default2 = ["M17 3h-6V1c0-.55-.45-1-1-1S9 .45 9 1v2H3c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h6v2H7c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h2v2c0 .55.45 1 1 1s1-.45 1-1v-2h2c.55 0 1-.45 1-1v-4c0-.55-.45-1-1-1h-2V9h6c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var anchor_default2 = ["M11 5.83a3.001 3.001 0 10-2 0V7H6v2h3v8.917a6.003 6.003 0 01-4.985-5.488l.278.278a1 1 0 001.414-1.414l-2-2a1 1 0 00-1.414 0l-2 2a1 1 0 101.414 1.414l.303-.303a8 8 0 0015.98 0l.303.303a1 1 0 001.414-1.414l-2-2a1 1 0 00-1.414 0l-2 2a1 1 0 001.414 1.414l.278-.278A6.003 6.003 0 0111 17.917V9h3V7h-3V5.83zM11 3a1 1 0 11-2 0 1 1 0 012 0z"];
  init_define_process();
  var annotation_default2 = ["M9.41 13.41l7.65-7.65-2.83-2.83-7.65 7.65 2.83 2.83zm10-10c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2-.55 0-1.05.22-1.41.59l-1.65 1.65 2.83 2.83 1.64-1.66zM18 18H2V2h8.93l2-2H1C.45 0 0 .45 0 1v18c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V7.07l-2 2V18zM4 16l4.41-1.59-2.81-2.79L4 16z"];
  init_define_process();
  var antenna_default2 = ["M2.01 10.758a8.025 8.025 0 001.01 3.204l.02.035c.034.058.061.117.084.178.163.44.054.951-.33 1.239-.435.328-1.059.242-1.342-.224a9.797 9.797 0 01-.221-.383 10 10 0 1117.48.106c-.269.474-.89.58-1.335.267-.392-.275-.518-.783-.37-1.228a1.19 1.19 0 01.078-.18l.019-.036A8.026 8.026 0 102.01 10.758zm4.272.772a1.464 1.464 0 01.091.32c.07.425-.052.87-.402 1.128-.44.325-1.068.235-1.316-.252a6 6 0 1110.734-.09c-.24.492-.867.593-1.312.275-.354-.253-.483-.695-.42-1.122a1.462 1.462 0 01.085-.321 4.021 4.021 0 00-5.87-4.878 4.02 4.02 0 00-1.59 4.94zm4.712 2.583A.999.999 0 0011 14v-4a1 1 0 10-2 0v4c0 .038.002.076.006.113l-3.753 4.223a1 1 0 001.494 1.328L10 16.005l3.252 3.66a1 1 0 101.495-1.33l-3.753-4.222z"];
  init_define_process();
  var app_header_default2 = ["M19 0a1 1 0 011 1v18a1 1 0 01-1 1H1a1 1 0 01-1-1V1a1 1 0 011-1h18zM8 6a1 1 0 00-1.993-.117L6 6v8a1 1 0 001.993.117L8 14v-3h4v3a1 1 0 001.993.117L14 14V6a1 1 0 00-1.993-.117L12 6v3H8V6z"];
  init_define_process();
  var application_default2 = ["M3.5 9h9c.28 0 .5-.22.5-.5s-.22-.5-.5-.5h-9c-.28 0-.5.22-.5.5s.22.5.5.5zm0 2h5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5h-5c-.28 0-.5.22-.5.5s.22.5.5.5zM19 1H1c-.55 0-1 .45-1 1v16c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zm-1 16H2V6h16v11zM3.5 13h7c.28 0 .5-.22.5-.5s-.22-.5-.5-.5h-7c-.28 0-.5.22-.5.5s.22.5.5.5z"];
  init_define_process();
  var applications_default2 = ["M15 5H1c-.55 0-1 .45-1 1v13c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm-1 13H2V8h12v10zM3.5 10h7c.28 0 .5-.22.5-.5s-.22-.5-.5-.5h-7c-.28 0-.5.22-.5.5s.22.5.5.5zm0 2h3c.28 0 .5-.22.5-.5s-.22-.5-.5-.5h-3c-.28 0-.5.22-.5.5s.22.5.5.5zm0 2h5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5h-5c-.28 0-.5.22-.5.5s.22.5.5.5zM19 0H5c-.55 0-1 .45-1 1v3h2V3h12v10h-1v2h2c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var archive_default2 = ["M16.434 0a1 1 0 01.857.486L20 5v14a1 1 0 01-1 1H1a1 1 0 01-1-1V5L2.709.486A1 1 0 013.566 0h12.868zM10 8c-.55 0-1 .45-1 1v4.58l-1.29-1.29-.081-.073A.996.996 0 007 11.99a1.003 1.003 0 00-.71 1.71l3 3 .096.084c.168.13.38.206.614.206.28 0 .53-.11.71-.29l3-3 .084-.096a1.003 1.003 0 00-1.504-1.324L11 13.58V9l-.007-.116A1.004 1.004 0 0010 8zm6-6H4L2 5.002h16L16 2z"];
  init_define_process();
  var area_of_interest_default2 = ["M5 4.664C5 2.09 7.241 0 10 0s4.99 2.091 5 4.664C15 7.245 10 14 10 14S5 7.245 5 4.664zM8 5a2 2 0 104.001-.001A2 2 0 008 5zM.504 12.132l4.302-2.458c.322.576.662 1.145.995 1.681l.025.04-3.294 1.881L6.468 18h7.064l3.936-4.724-3.293-1.882.024-.039c.333-.536.673-1.105.995-1.681l4.302 2.458a1 1 0 01.272 1.508l-5 6A1 1 0 0114 20H6a1 1 0 01-.768-.36l-5-6a1 1 0 01.272-1.508z"];
  init_define_process();
  var array_default2 = ["M19 0a1 1 0 01.993.883L20 1v18a1 1 0 01-.883.993L19 20h-4a1 1 0 01-.117-1.993L15 18h3V2h-3a1 1 0 01-.993-.883L14 1a1 1 0 01.883-.993L15 0h4zM5 0a1 1 0 01.117 1.993L5 2H2v16h3a1 1 0 01.993.883L6 19a1 1 0 01-.883.993L5 20H1a1 1 0 01-.993-.883L0 19V1A1 1 0 01.883.007L1 0h4zm5 9a1 1 0 110 2 1 1 0 010-2zM6 9a1 1 0 110 2 1 1 0 010-2zm8 0a1 1 0 110 2 1 1 0 010-2z"];
  init_define_process();
  var array_boolean_default2 = ["M19 0a1 1 0 01.993.883L20 1v18a1 1 0 01-.883.993L19 20h-4a1 1 0 01-.117-1.993L15 18h3V2h-3a1 1 0 01-.993-.883L14 1a1 1 0 01.883-.993L15 0h4zM5 0a1 1 0 01.117 1.993L5 2H2v16h3a1 1 0 01.993.883L6 19a1 1 0 01-.883.993L5 20H1a1 1 0 01-.993-.883L0 19V1A1 1 0 01.883.007L1 0h4zm10 7a1 1 0 01.993.883L16 8v4a1 1 0 01-.883.993L15 13H5a1 1 0 01-.993-.883L4 12V8a1 1 0 01.883-.993L5 7h10zm0 1h-5v4h5V8z"];
  init_define_process();
  var array_date_default2 = ["M19 0a1 1 0 01.993.883L20 1v18a1 1 0 01-.883.993L19 20h-4a1 1 0 01-.117-1.993L15 18h3V2h-3a1 1 0 01-.993-.883L14 1a1 1 0 01.883-.993L15 0h4zM5 0a1 1 0 01.117 1.993L5 2H2v16h3a1 1 0 01.993.883L6 19a1 1 0 01-.883.993L5 20H1a1 1 0 01-.993-.883L0 19V1A1 1 0 01.883.007L1 0h4zm2.5 5a.5.5 0 01.5.5V6h4v-.5a.5.5 0 01.5-.5h1a.5.5 0 01.5.5V6h1a1 1 0 01.993.883L16 7v7a1 1 0 01-.883.993L15 15H5a1 1 0 01-.993-.883L4 14V7a1 1 0 01.883-.993L5 6h1v-.5a.5.5 0 01.5-.5h1zM15 9H5v5h10V9z"];
  init_define_process();
  var array_floating_point_default2 = ["M19.992 1.104A1.25 1.25 0 0018.75 0H15c-.47 0-1 .359-1 1s.5 1 1.023 1h3L18 18h-3c-.5 0-1 .359-1 1 0 .69.5 1 1 1h3.75l.146-.008A1.25 1.25 0 0020 18.75V1.25l-.008-.146zM6 1c0-.69-.5-1-1-1H1.25l-.146.008A1.25 1.25 0 000 1.25v17.5l.008.146A1.25 1.25 0 001.25 20H5c.5 0 1-.359 1-1s-.5-1-1-1H2V2h3c.5 0 1-.359 1-1z", "M5.434 7.325c-.222.039-.45.058-.684.058v.88h1.68v4.825h1.221V6.25h-.908c-.04.208-.124.384-.254.528-.124.143-.277.26-.46.351a2.067 2.067 0 01-.595.196z", "M14.327 6.586c-.294-.219-.677-.329-1.147-.329s-.856.11-1.157.33a2.24 2.24 0 00-.695.827 3.822 3.822 0 00-.339 1.1c-.056.401-.085.79-.085 1.166 0 .376.029.765.085 1.166.063.401.176.77.339 1.11.169.332.4.607.695.827.301.213.687.32 1.157.32s.853-.107 1.147-.32c.301-.22.533-.495.696-.828.17-.338.282-.708.338-1.11a7.55 7.55 0 00.094-1.165 7.55 7.55 0 00-.094-1.166 3.47 3.47 0 00-.338-1.1 2.127 2.127 0 00-.696-.828zm-.564 5.426a.876.876 0 01-.583.197.89.89 0 01-.592-.197 1.516 1.516 0 01-.367-.546 3.485 3.485 0 01-.188-.808 8.056 8.056 0 01-.057-.978c0-.345.02-.668.057-.969.037-.307.1-.576.188-.808.094-.232.216-.414.367-.546a.864.864 0 01.592-.206.85.85 0 01.583.206c.157.132.279.314.367.546.094.232.16.501.197.808.038.301.056.624.056.969s-.018.67-.056.978a3.179 3.179 0 01-.197.808c-.088.226-.21.408-.367.546z", "M8.853 11.807h1.358v1.319H8.853v-1.32z"];
  init_define_process();
  var array_numeric_default2 = ["M19 0a1 1 0 01.993.883L20 1v18a1 1 0 01-.883.993L19 20h-4a1 1 0 01-.117-1.993L15 18h3V2h-3a1 1 0 01-.993-.883L14 1a1 1 0 01.883-.993L15 0h4zM5 0a1 1 0 01.117 1.993L5 2H2v16h3a1 1 0 01.993.883L6 19a1 1 0 01-.883.993L5 20H1a1 1 0 01-.993-.883L0 19V1A1 1 0 01.883.007L1 0h4zm8.995 6.09c.32 0 .603.047.85.14a1.679 1.679 0 011.015.985c.09.23.135.482.135.755 0 .287-.063.552-.19.795a1.642 1.642 0 01-.57.615v.02l.101.05c.068.039.138.09.209.155.107.097.203.215.29.355a2.09 2.09 0 01.3 1.09c0 .313-.053.597-.16.85a1.898 1.898 0 01-1.12 1.065 2.42 2.42 0 01-.85.145c-.533 0-.99-.127-1.37-.38a1.702 1.702 0 01-.73-1.08c-.013-.067.013-.11.08-.13l.87-.2.041-.003c.038.004.064.028.079.073.073.2.193.37.36.51.167.14.39.21.67.21.32 0 .567-.095.74-.285.173-.19.26-.432.26-.725 0-.347-.1-.618-.3-.815-.2-.197-.47-.295-.81-.295h-.29l-.044-.006c-.037-.013-.056-.044-.056-.094V9.1l.006-.044c.013-.037.044-.056.094-.056h.27l.145-.008a.925.925 0 00.575-.262c.18-.18.27-.42.27-.72 0-.273-.08-.495-.24-.665-.16-.17-.383-.255-.67-.255-.253 0-.453.063-.6.19-.147.127-.25.297-.31.51-.02.06-.06.083-.12.07l-.85-.2-.042-.015c-.035-.02-.048-.055-.038-.105a1.684 1.684 0 01.645-1.035c.17-.13.37-.232.6-.305.23-.073.482-.11.755-.11zm-7.99.11l.044.006c.037.013.056.044.056.094v6.6l-.006.044c-.013.037-.044.056-.094.056h-.92l-.044-.006c-.037-.013-.056-.044-.056-.094V7.54h-.02l-1.04.73-.04.02c-.047.016-.07-.01-.07-.08V7.19l.008-.051a.196.196 0 01.062-.089l1.09-.79.051-.033a.295.295 0 01.129-.027h.85zm3.34-.11c.32 0 .603.05.85.15.247.1.455.235.625.405.17.17.3.37.39.6.09.23.135.478.135.745 0 .307-.057.588-.17.845a3.16 3.16 0 01-.47.745l-1.98 2.4V12h2.52l.044.006c.037.013.056.044.056.094v.8l-.006.044c-.013.037-.044.056-.094.056h-3.82l-.044-.006c-.037-.013-.056-.044-.056-.094v-.75l.006-.05a.165.165 0 01.044-.08l2.4-2.99.124-.167c.077-.11.143-.222.196-.333.08-.167.12-.347.12-.54a.92.92 0 00-.235-.64c-.157-.173-.378-.26-.665-.26-.273 0-.487.077-.64.23-.153.153-.247.36-.28.62-.013.067-.05.093-.11.08l-.88-.18-.043-.015c-.035-.02-.047-.055-.037-.105a1.78 1.78 0 01.56-1.115c.167-.157.372-.282.615-.375a2.35 2.35 0 01.845-.14z"];
  init_define_process();
  var array_string_default2 = ["M19 0a1 1 0 01.993.883L20 1v18a1 1 0 01-.883.993L19 20h-4a1 1 0 01-.117-1.993L15 18h3V2h-3a1 1 0 01-.993-.883L14 1a1 1 0 01.883-.993L15 0h4zM5 0a1 1 0 01.117 1.993L5 2H2v16h3a1 1 0 01.993.883L6 19a1 1 0 01-.883.993L5 20H1a1 1 0 01-.993-.883L0 19V1A1 1 0 01.883.007L1 0h4zm2.012 6c.643 0 1.203.266 1.68.797.477.53.715 1.246.715 2.145a4.472 4.472 0 01-.965 2.814c-.644.83-1.66 1.5-3.047 2.011v-.581l.26-.104a3.87 3.87 0 001.624-1.285c.457-.632.686-1.29.686-1.971 0-.148-.023-.256-.07-.326-.023-.047-.054-.07-.093-.07-.038 0-.1.031-.186.093-.248.179-.558.268-.93.268-.45 0-.843-.18-1.18-.541A1.817 1.817 0 015 7.965c0-.527.194-.986.581-1.378A1.934 1.934 0 017.011 6zm5.593 0c.643 0 1.203.266 1.68.797.477.53.715 1.246.715 2.145a4.472 4.472 0 01-.965 2.814c-.644.83-1.659 1.5-3.047 2.011v-.581l.26-.104a3.87 3.87 0 001.624-1.285c.457-.632.686-1.29.686-1.971 0-.148-.023-.256-.07-.326-.023-.047-.054-.07-.093-.07-.038 0-.1.031-.186.093-.248.179-.558.268-.93.268-.45 0-.843-.18-1.18-.541a1.817 1.817 0 01-.506-1.285c0-.527.194-.986.581-1.378A1.934 1.934 0 0112.604 6z"];
  init_define_process();
  var array_timestamp_default2 = ["M19 0a1 1 0 01.993.883L20 1v18a1 1 0 01-.883.993L19 20h-4a1 1 0 01-.117-1.993L15 18h3V2h-3a1 1 0 01-.993-.883L14 1a1 1 0 01.883-.993L15 0h4zM5 0a1 1 0 01.117 1.993L5 2H2v16h3a1 1 0 01.993.883L6 19a1 1 0 01-.883.993L5 20H1a1 1 0 01-.993-.883L0 19V1A1 1 0 01.883.007L1 0h4zm5 4a6 6 0 110 12 6 6 0 010-12zm0 1a5 5 0 100 10 5 5 0 000-10zm2.854 2.146a.5.5 0 01.057.638l-.057.07-2.5 2.5a.5.5 0 01-.638.057l-.07-.057-1.5-1.5a.5.5 0 01.638-.765l.07.057L10 9.293l2.146-2.147a.5.5 0 01.708 0z"];
  init_define_process();
  var arrow_bottom_left_default2 = ["M18 3a1.003 1.003 0 00-1.71-.71L4 14.59V7c0-.55-.45-1-1-1s-1 .45-1 1v10c0 .55.45 1 1 1h10c.55 0 1-.45 1-1s-.45-1-1-1H5.41l12.3-12.29c.18-.18.29-.43.29-.71z"];
  init_define_process();
  var arrow_bottom_right_default2 = ["M17 6c-.55 0-1 .45-1 1v7.59L3.71 2.29a1.003 1.003 0 00-1.42 1.42L14.59 16H7c-.55 0-1 .45-1 1s.45 1 1 1h10c.55 0 1-.45 1-1V7c0-.55-.45-1-1-1z"];
  init_define_process();
  var arrow_down_default2 = ["M16 11c-.3 0-.5.1-.7.3L11 15.6V2c0-.5-.4-1-1-1s-1 .5-1 1v13.6l-4.3-4.3c-.2-.2-.4-.3-.7-.3-.5 0-1 .4-1 1 0 .3.1.5.3.7l6 6c.2.2.4.3.7.3s.5-.1.7-.3l6-6c.2-.2.3-.4.3-.7 0-.6-.5-1-1-1z"];
  init_define_process();
  var arrow_left_default2 = ["M18 9H4.41L8.7 4.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-6 6c-.18.18-.29.43-.29.71 0 .28.11.53.29.71l6 6a1.003 1.003 0 001.42-1.42L4.41 11H18c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var arrow_right_default2 = ["M18.71 9.29l-6-6a1.003 1.003 0 00-1.42 1.42L15.59 9H2c-.55 0-1 .45-1 1s.45 1 1 1h13.59l-4.29 4.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l6-6c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71z"];
  init_define_process();
  var arrow_top_left_default2 = ["M17.71 16.29L5.41 4H13c.55 0 1-.45 1-1s-.45-1-1-1H3c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1s1-.45 1-1V5.41L16.29 17.7c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71z"];
  init_define_process();
  var arrow_top_right_default2 = ["M17 2H7c-.55 0-1 .45-1 1s.45 1 1 1h7.59L2.29 16.29a1.003 1.003 0 001.42 1.42L16 5.41V13c0 .55.45 1 1 1s1-.45 1-1V3c0-.55-.45-1-1-1z"];
  init_define_process();
  var arrow_up_default2 = ["M16.7 7.3l-6-6c-.2-.2-.4-.3-.7-.3s-.5.1-.7.3l-6 6c-.2.2-.3.4-.3.7 0 .6.5 1 1 1 .3 0 .5-.1.7-.3L9 4.4V18c0 .5.4 1 1 1s1-.5 1-1V4.4l4.3 4.3c.2.2.4.3.7.3.5 0 1-.4 1-1 0-.3-.1-.5-.3-.7z"];
  init_define_process();
  var arrows_horizontal_default2 = ["M19.7 9.3l-5-5c-.2-.2-.4-.3-.7-.3-.6 0-1 .4-1 1 0 .3.1.5.3.7L16.6 9H3.4l3.3-3.3c.2-.2.3-.4.3-.7 0-.6-.4-1-1-1-.3 0-.5.1-.7.3l-5 5c-.2.2-.3.4-.3.7s.1.5.3.7l5 5c.2.2.4.3.7.3.6 0 1-.4 1-1 0-.3-.1-.5-.3-.7L3.4 11h13.2l-3.3 3.3c-.2.2-.3.4-.3.7 0 .6.4 1 1 1 .3 0 .5-.1.7-.3l5-5c.2-.2.3-.4.3-.7s-.1-.5-.3-.7z"];
  init_define_process();
  var arrows_vertical_default2 = ["M15 13c-.3 0-.5.1-.7.3L11 16.6V3.4l3.3 3.3c.2.2.4.3.7.3.6 0 1-.4 1-1 0-.3-.1-.5-.3-.7l-5-5c-.2-.2-.4-.3-.7-.3s-.5.1-.7.3l-5 5c-.2.2-.3.4-.3.7 0 .6.4 1 1 1 .3 0 .5-.1.7-.3L9 3.4v13.2l-3.3-3.3c-.2-.2-.4-.3-.7-.3-.6 0-1 .4-1 1 0 .3.1.5.3.7l5 5c.2.2.4.3.7.3s.5-.1.7-.3l5-5c.2-.2.3-.4.3-.7 0-.5-.4-1-1-1z"];
  init_define_process();
  var asterisk_default2 = ["M18.52 14.17l.01-.02L11.89 10l6.64-4.15-.01-.02A.97.97 0 0019 5c0-.55-.45-1-1-1-.2 0-.37.07-.52.17l-.01-.02L11 8.2V1c0-.55-.45-1-1-1S9 .45 9 1v7.2L2.53 4.15l-.01.02A.922.922 0 002 4c-.55 0-1 .45-1 1 0 .36.2.66.48.83l-.01.02L8.11 10l-6.64 4.15.01.02A.97.97 0 001 15c0 .55.45 1 1 1 .2 0 .37-.07.52-.17l.01.02L9 11.8V19c0 .55.45 1 1 1s1-.45 1-1v-7.2l6.47 4.04.01-.02c.15.11.32.18.52.18.55 0 1-.45 1-1 0-.36-.2-.66-.48-.83z"];
  init_define_process();
  var at_default2 = ["M12.298 6.818a6.507 6.507 0 00-1.672-.207c-1.057 0-1.881.345-2.472 1.036-.589.691-.884 1.63-.884 2.817 0 1.894.755 2.842 2.266 2.842 1.593 0 2.464-1.192 2.614-3.574l.148-2.914zm6.544-2.592C19.614 5.58 20 7.142 20 8.916c0 1.163-.186 2.224-.556 3.189-.374.963-.894 1.713-1.569 2.25a3.64 3.64 0 01-2.333.803c-.651 0-1.218-.17-1.696-.512a2.486 2.486 0 01-.967-1.39h-.148c-.405.635-.904 1.11-1.498 1.427-.596.318-1.264.475-2.007.475-1.345 0-2.405-.425-3.175-1.279-.774-.854-1.159-2.008-1.159-3.463 0-1.676.512-3.036 1.537-4.08 1.021-1.043 2.396-1.567 4.122-1.567.628 0 1.322.055 2.086.164.764.11 1.443.262 2.037.458l-.272 5.67v.294c0 1.3.43 1.951 1.289 1.951.652 0 1.169-.414 1.553-1.245.384-.829.577-1.886.577-3.171 0-1.39-.291-2.611-.868-3.664a5.948 5.948 0 00-2.463-2.433c-1.065-.569-2.287-.853-3.667-.853-1.757 0-3.287.357-4.588 1.072a7.19 7.19 0 00-2.978 3.069C2.571 7.408 2.23 8.953 2.23 10.708c0 2.358.639 4.172 1.92 5.438 1.279 1.27 3.115 1.902 5.509 1.902 1.826 0 3.729-.365 5.71-1.096v2.001c-1.734.698-3.62 1.047-5.66 1.047-3.056 0-5.437-.811-7.144-2.432C.855 15.945 0 13.683 0 10.781 0 8.659.462 6.77 1.388 5.116c.923-1.653 2.206-2.919 3.845-3.798C6.871.44 8.727 0 10.799 0c1.791 0 3.388.367 4.786 1.098a7.865 7.865 0 013.257 3.128z"];
  init_define_process();
  var automatic_updates_default2 = ["M10 18c-4.42 0-8-3.58-8-8 0-2.52 1.18-4.76 3-6.22V5c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1h2.06C1.61 3.82 0 6.71 0 10c0 5.52 4.48 10 10 10 .55 0 1-.45 1-1s-.45-1-1-1zm0-16c1.64 0 3.15.49 4.42 1.34l1.43-1.43A9.869 9.869 0 0010 0c-.55 0-1 .45-1 1s.45 1 1 1zm10 8c0-1.13-.2-2.21-.54-3.22L17.84 8.4A7.962 7.962 0 0115 16.22V15c0-.55-.45-1-1-1s-1 .45-1 1v4c0 .55.45 1 1 1h4c.55 0 1-.45 1-1s-.45-1-1-1h-2.06c2.45-1.82 4.06-4.71 4.06-8zm0-7a1.003 1.003 0 00-1.71-.71L12 8.59l-2.29-2.3a1.003 1.003 0 00-1.42 1.42l3 3c.18.18.43.29.71.29s.53-.11.71-.29l7-7c.18-.18.29-.43.29-.71z"];
  init_define_process();
  var backlink_default2 = ["M18.387 19.79l-.094-.083L14 15.415V18a1 1 0 01-2 0l.003-5.075.017-.126.03-.111.044-.111.052-.098.067-.096.08-.09a1.01 1.01 0 01.112-.097l.11-.071.114-.054.105-.035.15-.03L13 12h5a1 1 0 110 2h-2.585l4.292 4.293a1 1 0 01-1.32 1.497zM7.036 9.136l-4.45 4.45-.117.127a2 2 0 002.818 2.818l.127-.117 4.45-4.449a4 4 0 01-.885 3.704l-.15.16-2 2A4 4 0 011.02 12.33l.15-.16 2-2a3.998 3.998 0 013.865-1.035zm6.671-3.843a1 1 0 01.083 1.32l-.083.094-7 7a1 1 0 01-1.497-1.32l.083-.094 7-7a1 1 0 011.414 0zm4.121-4.121a4 4 0 01.151 5.497l-.15.16-2 2a3.998 3.998 0 01-3.864 1.036l4.45-4.45.116-.128a2 2 0 00-2.818-2.818l-.127.117-4.45 4.45a4 4 0 01.885-3.705l.15-.16 2-2a4 4 0 015.657 0z"];
  init_define_process();
  var badge_default2 = ["M16.94 5.73c-.19-1.41.62-2.52 1.38-3.59L17.03.65C14.89 1.76 11.88 1.48 10 0 8.12 1.48 5.11 1.76 2.97.65L1.68 2.14c.76 1.07 1.57 2.18 1.38 3.59C2.68 8.59 0 10.94 1.4 14.08c.56 1.43 1.81 2.37 3.4 2.75 1.95.46 4.4.91 5.2 3.17.8-2.26 3.25-2.71 5.2-3.17 1.6-.38 2.84-1.32 3.4-2.75 1.4-3.14-1.28-5.49-1.66-8.35z"];
  init_define_process();
  var ban_circle_default2 = ["M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm5 11H5c-.55 0-1-.45-1-1s.45-1 1-1h10c.55 0 1 .45 1 1s-.45 1-1 1z"];
  init_define_process();
  var bank_account_default2 = ["M19.2 8.02l-.78-.18C18.03 6.4 17.2 5.08 16.08 4l.5-2.28c.11-.42-.22-.78-.61-.72-1.06.12-2 .54-2.67 1.26-1.06-.42-2.34-.66-3.56-.66-3.12 0-5.79 1.5-7.4 3.72-.23-.05-.45-.11-.67-.11C.72 5.21 0 5.98 0 7c0 .72.39 1.32.95 1.62-.06.42-.12.9-.12 1.38 0 2.16.89 4.08 2.28 5.58l-.33 2.04c-.11.72.45 1.38 1.12 1.38h.72c.56 0 1-.42 1.11-1.02l.06-.48c1.17.54 2.5.9 3.95.9 1.39 0 2.78-.3 3.95-.9l.06.48c.11.6.56 1.02 1.11 1.02h.72c.67 0 1.22-.66 1.11-1.38l-.33-1.98c.78-.78 1.34-1.74 1.73-2.76l1-.24c.5-.12.89-.6.89-1.2V9.22c.11-.6-.28-1.08-.78-1.2zM15 10c-.6 0-1-.7-1-1.5S14.4 7 15 7s1 .7 1 1.5-.4 1.5-1 1.5zM7.55 5.83a.99.99 0 01-1.38-.28.99.99 0 01.28-1.38c2.34-1.56 4.77-1.56 7.11 0 .46.31.58.93.28 1.39-.31.46-.93.58-1.39.28-1.67-1.12-3.23-1.12-4.9-.01z"];
  init_define_process();
  var barcode_default2 = ["M6 16.98h2v-14H6v14zm3 0h1v-14H9v14zm-6 0h2v-14H3v14zm-3 0h2v-14H0v14zm16 0h2v-14h-2v14zm-4 0h1v-14h-1v14zm7-14v14h1v-14h-1zm-5 14h1v-14h-1v14z"];
  init_define_process();
  var p2 = [];
  var blank_default2 = p2;
  init_define_process();
  var blocked_person_default2 = ["M11.55 15.92c-1.48-.65-1.28-1.05-1.33-1.59-.01-.07-.01-.15-.01-.23.51-.45.92-1.07 1.19-1.78 0 0 .01-.04.02-.05.06-.15.11-.32.15-.48.34-.07.54-.44.61-.78.06-.11.14-.35.17-.62C10.33 9.42 8.92 7.38 8.92 5c0-.3.05-.58.09-.87-.33-.08-.67-.13-.99-.13-.79 0-1.68.25-2.31.73-.61.47-1.07 1.13-1.29 1.86-.05.16-.09.33-.11.5-.12.6-.17 1.51-.17 2.14v.08c-.24.09-.45.32-.49.83-.04.39.12.73.2.87.08.35.28.72.63.78.04.17.09.33.15.48 0 .01.01.02.01.03l.01.01c.27.72.7 1.35 1.22 1.8 0 .07-.01.14-.01.21-.05.54.1.94-1.38 1.59C3 16.56.77 17.26.32 18.31-.15 19.38.04 20 .04 20h15.95s.18-.62-.27-1.67c-.46-1.06-2.69-1.75-4.17-2.41zM14.97 0c-2.78 0-5.03 2.24-5.03 5s2.25 5 5.03 5S20 7.76 20 5s-2.25-5-5.03-5zm-3.03 5c0-1.66 1.35-3 3.02-3 .47 0 .9.11 1.29.3l-4.01 3.99c-.18-.4-.3-.83-.3-1.29zm3.03 3c-.47 0-.9-.11-1.29-.3l4.01-3.99c.19.39.3.82.3 1.29 0 1.66-1.36 3-3.02 3z"];
  init_define_process();
  var bold_default2 = ["M14.3 9c.4-.8.7-1.6.7-2.5C15 4 13 2 10.5 2H5c-.6 0-1 .4-1 1v13c0 .6.4 1 1 1h6.5c2.5 0 4.5-2 4.5-4.5 0-1.4-.7-2.7-1.7-3.5zM7 5h3.5c.8 0 1.5.7 1.5 1.5S11.3 8 10.5 8H7V5zm4.5 9H7v-3h4.5c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5z"];
  init_define_process();
  var book_default2 = ["M3 1v18c0 .55.45 1 1 1h2V0H4c-.55 0-1 .45-1 1zm14-1h-2v8l-2-2-2 2V0H7v20h10c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var bookmark_default2 = ["M6 0c-.55 0-1 .45-1 1v18c0 .55.32.68.71.29L9.3 15.7a.996.996 0 011.41 0l3.59 3.59c.38.39.7.26.7-.29v-8-4.5V1c0-.55-.45-1-1-1H6z"];
  init_define_process();
  var box_default2 = ["M19.89 6.56l-2.99-6h-.01C16.72.23 16.39 0 16 0H4c-.39 0-.72.23-.89.56H3.1l-3 6h.01C.05 6.69 0 6.84 0 7v12c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V7c0-.16-.05-.31-.11-.44zM11 2h4.38l2 4H11V2zM4.62 2H9v4H2.62l2-4zM18 18H2V8h16v10zM8 12h4c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1s.45 1 1 1z"];
  init_define_process();
  var briefcase_default2 = ["M19 5h-4V2c0-.55-.45-1-1-1H6c-.55 0-1 .45-1 1v3H1c-.55 0-1 .45-1 1v5h4v-1h2v1h8v-1h2v1h4V6c0-.55-.45-1-1-1zm-6 0H7V3h6v2zm3 8h-2v-1H6v1H4v-1H0v6c0 .55.45 1 1 1h18c.55 0 1-.45 1-1v-6h-4v1z"];
  init_define_process();
  var bring_data_default2 = ["M18 18a1 1 0 010 2H2a1 1 0 010-2h16zM9.995 3.005c.55 0 1 .45 1 .999v9.584l1.29-1.288a1.002 1.002 0 011.42 1.419l-3 2.996a1.015 1.015 0 01-1.42 0l-3-2.997a1.002 1.002 0 011.42-1.419l1.29 1.29V4.013c0-.55.45-1.009 1-1.009zM16 0a1 1 0 110 2 1 1 0 010-2zm-3 0a1 1 0 110 2 1 1 0 010-2zm-3 0a1 1 0 110 2 1 1 0 010-2zM7 0a1 1 0 110 2 1 1 0 010-2zM4 0a1 1 0 110 2 1 1 0 010-2z"];
  init_define_process();
  var bug_default2 = ["M6.006 4.272C6.124 2.136 7.866 0 10 0c2.133 0 3.877 2.136 3.994 4.272.49.438.909.956 1.234 1.532L17 5.017V3a1 1 0 112 0v2.667a1 1 0 01-.594.913l-2.5 1.111c.062.344.094.698.094 1.059V10h3a1 1 0 110 2h-3v.5c0 .604-.09 1.187-.255 1.737l2.661 1.182a1 1 0 01.594.914V19a1 1 0 11-2 0v-2.017l-2.147-.954A5.992 5.992 0 0110 18.5a5.992 5.992 0 01-4.853-2.471L3 16.983V19a1 1 0 11-2 0v-2.667a1 1 0 01.594-.913l2.661-1.183A6 6 0 014 12.5V12H1a1 1 0 110-2h3V8.75c0-.361.032-.715.093-1.059l-2.5-1.11A1 1 0 011 5.666V3a1 1 0 012 0v2.017l1.772.787a6.026 6.026 0 011.234-1.532zM6 11v1.5a4 4 0 008 0V8.75a4 4 0 00-8 0V11z"];
  init_define_process();
  var buggy_default2 = ["M15.836 1.014a1 1 0 011.058.539l2.482 4.962.02-.004a.5.5 0 01.604.49v4.5a.5.5 0 01-.5.5h-3.93a1.5 1.5 0 00-1.248.667l-1.406 2.11A.5.5 0 0112.5 15H8a.5.5 0 01-.354-.146l-2.414-2.415A1.5 1.5 0 004.172 12H.5a.5.5 0 01-.5-.5v-3A.5.5 0 01.5 8h.823L3.072 3.63a1 1 0 01.764-.615l12-2zm.289 3.472l1.231 2.462-2.758.591 1.527-3.053zM14.5 3.264l-1.56 3.12-.252-.638-.825-2.043 2.637-.44zm-9.78 1.63l5.122-.854.988 2.445.899 2.27L10.232 11H7.707L4.854 8.147A.5.5 0 004.5 8H3.477l1.242-3.106zM3 19a3 3 0 100-6 3 3 0 000 6zm14 0a3 3 0 100-6 3 3 0 000 6z"];
  init_define_process();
  var build_default2 = ["M19.43 16.67L9.31 7.81l1.47-1.56c.41-.44-.15-.8.15-1.6 1.08-2.76 4.19-2.99 4.19-2.99s.45-.47.87-.92C11.98-1 9.26.7 8.04 1.8L3.83 6.25l-.86.92c-.48.51-.48 1.33 0 1.84l-.87.92c-.48-.51-1.26-.51-1.74 0s-.48 1.33 0 1.84l1.74 1.84c.48.51 1.26.51 1.74 0s.48-1.33 0-1.84l.87-.92c.48.51 1.26.51 1.74 0l1.41-1.49 8.81 10.07c.76.76 2 .76 2.76 0 .76-.76.76-2 0-2.76z"];
  init_define_process();
  var calculator_default2 = ["M16 0H4c-.55 0-1 .45-1 1v18c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zM7 18H5v-2h2v2zm0-4H5v-2h2v2zm0-4H5V8h2v2zm4 8H9v-2h2v2zm0-4H9v-2h2v2zm0-4H9V8h2v2zm4 8h-2v-6h2v6zm0-8h-2V8h2v2zm0-4H5V2h10v4z"];
  init_define_process();
  var calendar_default2 = ["M15 5c.6 0 1-.4 1-1V2c0-.5-.4-1-1-1s-1 .5-1 1v2c0 .6.4 1 1 1zM5 5c.6 0 1-.4 1-1V2c0-.5-.4-1-1-1s-1 .5-1 1v2c0 .6.4 1 1 1zm13-2h-1v1c0 1.1-.9 2-2 2s-2-.9-2-2V3H7v1c0 1.1-.9 2-2 2s-2-.9-2-2V3H2c-.5 0-1 .5-1 1v14c0 .5.5 1 1 1h16c.5 0 1-.5 1-1V4c0-.5-.5-1-1-1zM7 17H3v-4h4v4zm0-5H3V8h4v4zm5 5H8v-4h4v4zm0-5H8V8h4v4zm5 5h-4v-4h4v4zm0-5h-4V8h4v4z"];
  init_define_process();
  var camera_default2 = ["M10 8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3zm9-4h-3.59L13.7 2.29A.956.956 0 0013 2H7c-.28 0-.53.11-.71.29L4.59 4H1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h4.11c1.26 1.24 2.99 2 4.89 2s3.63-.76 4.89-2H19c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zM4 8H2V6h2v2zm6 8c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"];
  init_define_process();
  var caret_down_default2 = ["M16 7c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1 0 .24.1.46.24.63l-.01.01 5 6 .01-.01c.19.22.45.37.76.37s.57-.15.76-.37l.01.01 5-6-.01-.01c.14-.17.24-.39.24-.63z"];
  init_define_process();
  var caret_left_default2 = ["M13 4c-.24 0-.46.1-.63.24l-.01-.01-6 5 .01.01c-.22.19-.37.45-.37.76s.15.57.37.76l-.01.01 6 5 .01-.01c.17.14.39.24.63.24.55 0 1-.45 1-1V5c0-.55-.45-1-1-1z"];
  init_define_process();
  var caret_right_default2 = ["M14 10c0-.31-.15-.57-.37-.76l.01-.01-6-5-.01.01C7.46 4.1 7.24 4 7 4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1 .24 0 .46-.1.63-.24l.01.01 6-5-.01-.01c.22-.19.37-.45.37-.76z"];
  init_define_process();
  var caret_up_default2 = ["M15.76 12.37l.01-.01-5-6-.01.01C10.57 6.15 10.31 6 10 6s-.57.15-.76.37l-.01-.01-5 6 .01.01c-.14.17-.24.39-.24.63 0 .55.45 1 1 1h10c.55 0 1-.45 1-1 0-.24-.1-.46-.24-.63z"];
  init_define_process();
  var cargo_ship_default2 = ["M12.5 1.25h4a1 1 0 011 1V5h-5V1.25zM2.75 5a.25.25 0 00-.25.25v6H.883a.5.5 0 00-.429.757l1.672 2.787c.17.284.384.533.63.741-.458.057-.959.09-1.506.09a.625.625 0 100 1.25c2.583 0 4.268-.68 5.202-1.146.687.466 1.88 1.146 3.548 1.146 1.65 0 2.837-.666 3.528-1.132l.005.003c.244.131.6.3 1.07.468.938.335 2.321.661 4.147.661a.625.625 0 100-1.25c-.319 0-.622-.01-.91-.03.398-.318.717-.738.914-1.23l.972-2.43a.5.5 0 00-.464-.685H5v-6A.25.25 0 004.75 5h-2zm3.455 11.95a.625.625 0 01.658.041c.569.407 1.597 1.134 3.137 1.134s2.568-.727 3.137-1.134a.625.625 0 01.724-.001l.007.005.045.029c.044.027.114.069.21.12.194.104.493.247.9.392.812.29 2.053.589 3.727.589a.625.625 0 110 1.25c-1.826 0-3.21-.326-4.148-.661a7.894 7.894 0 01-1.069-.468l-.005-.003c-.691.466-1.878 1.132-3.528 1.132-1.667 0-2.861-.68-3.548-1.146-.934.467-2.619 1.146-5.202 1.146a.625.625 0 110-1.25c2.66 0 4.23-.787 4.955-1.176zM17.5 6.25h-5V10h4a1 1 0 001-1V6.25zm-11.25-4a1 1 0 011-1h4V5h-5V2.25zm5 4h-5V9a1 1 0 001 1h4V6.25z"];
  init_define_process();
  var cell_tower_default2 = ["M11.5 8.32c.31-.35.51-.81.51-1.32 0-1.1-.9-2-2-2s-2 .9-2 2c0 .51.2.97.51 1.32L5.06 18.69c-.17.52.11 1.09.63 1.26s1.09-.11 1.26-.63L8.39 15h3.23l1.44 4.32c.17.52.74.81 1.26.63s.81-.74.63-1.26L11.5 8.32zM10.95 13H9.06l.95-2.84.94 2.84zM5.31 10.73a.996.996 0 101.37-1.45c-1.4-1.33-1.28-3.35-.01-4.54.4-.38.43-1.01.05-1.41-.36-.41-1-.43-1.4-.06-2.09 1.95-2.28 5.3-.01 7.46z", "M4.6 12.2C3 11.1 2 9 2 7c0-2.1.9-3.9 2.6-5.2.5-.3.5-1 .2-1.4-.3-.5-1-.5-1.4-.2C1.2 1.9-.1 4.2 0 7c.1 2.7 1.4 5.3 3.4 6.8.2.1.4.2.6.2.3 0 .6-.1.8-.4.4-.5.3-1.1-.2-1.4zM13.27 10.69c.38.4 1.01.42 1.41.04 2.27-2.16 2.08-5.51-.01-7.46a.996.996 0 10-1.36 1.46c1.28 1.19 1.39 3.21-.01 4.54-.39.39-.41 1.02-.03 1.42z", "M16.6.2c-.4-.3-1.1-.3-1.4.2-.3.4-.3 1.1.2 1.4C17.1 3.1 18 4.9 18 7c0 2-1 4.1-2.6 5.2-.5.3-.6.9-.2 1.4.2.3.5.4.8.4.2 0 .4-.1.6-.2C18.7 12.3 20 9.7 20 7c.09-2.8-1.2-5.1-3.4-6.8z"];
  init_define_process();
  var changes_default2 = ["M18 16H2c-1.1 0-2 .9-2 2s.9 2 2 2h16c1.1 0 2-.9 2-2s-.9-2-2-2zM3 5c.28 0 .53-.11.71-.29L5 3.41V13c0 .55.45 1 1 1s1-.45 1-1V3.41L8.29 4.7c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-3-3C6.53.11 6.28 0 6 0s-.53.11-.71.29l-3 3A1.003 1.003 0 003 5zm7.29 5.71l3 3c.18.18.43.29.71.29s.53-.11.71-.29l3-3a1.003 1.003 0 00-1.42-1.42L15 10.59V1c0-.55-.45-1-1-1s-1 .45-1 1v9.59L11.71 9.3A.965.965 0 0011 9a1.003 1.003 0 00-.71 1.71z"];
  init_define_process();
  var chart_default2 = ["M7 11v8c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-8l-2 2-4-2zm-7 8c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-8l-6 3v5zM17 7l-3 3v9c0 .55.45 1 1 1h4c.55 0 1-.45 1-1V8.74c-.26.15-.58.26-1 .26-1.92 0-2-2-2-2zm2-6h-4c-.55 0-1 .45-1 1s.45 1 1 1h1.59L10.8 8.78 7.45 7.11v.01C7.31 7.05 7.16 7 7 7s-.31.05-.44.11V7.1l-6 3v.01c-.33.17-.56.5-.56.89 0 .55.45 1 1 1 .16 0 .31-.05.44-.11v.01L7 9.12l3.55 1.78v-.01c.14.06.29.11.45.11.28 0 .53-.11.71-.29L18 4.41V6c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1z"];
  init_define_process();
  var chat_default2 = ["M19 0H7c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h5.59l3.71 3.71c.17.18.42.29.7.29.55 0 1-.45 1-1v-3h1c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zM7 13c-1.1 0-2-.9-2-2V4H1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h1v3a1.003 1.003 0 001.71.71L7.41 16H13c.55 0 1-.45 1-1v-.17L12.17 13H7z"];
  init_define_process();
  var chevron_backward_default2 = ["M8.41 10l5.29-5.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L7 8.59V4c0-.55-.45-1-1-1s-1 .45-1 1v12c0 .55.45 1 1 1s1-.45 1-1v-4.59l5.29 5.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L8.41 10z"];
  init_define_process();
  var chevron_down_default2 = ["M16 6c-.28 0-.53.11-.71.29L10 11.59l-5.29-5.3a1.003 1.003 0 00-1.42 1.42l6 6c.18.18.43.29.71.29s.53-.11.71-.29l6-6A1.003 1.003 0 0016 6z"];
  init_define_process();
  var chevron_forward_default2 = ["M13 3c-.55 0-1 .45-1 1v4.59l-5.29-5.3a1.003 1.003 0 00-1.42 1.42l5.3 5.29-5.29 5.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l5.29-5.3V16c0 .55.45 1 1 1s1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var chevron_left_default2 = ["M8.41 10l5.29-5.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-6 6c-.18.18-.29.43-.29.71 0 .28.11.53.29.71l6 6a1.003 1.003 0 001.42-1.42L8.41 10z"];
  init_define_process();
  var chevron_right_default2 = ["M13.71 9.29l-6-6a1.003 1.003 0 00-1.42 1.42l5.3 5.29-5.29 5.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l6-6c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71z"];
  init_define_process();
  var chevron_up_default2 = ["M16.71 12.29l-6-6C10.53 6.11 10.28 6 10 6s-.53.11-.71.29l-6 6a1.003 1.003 0 001.42 1.42L10 8.41l5.29 5.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71z"];
  init_define_process();
  var circle_default2 = ["M10 0C4.5 0 0 4.5 0 10s4.5 10 10 10 10-4.5 10-10S15.5 0 10 0zm0 18c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8z"];
  init_define_process();
  var circle_arrow_down_default2 = ["M14 10c-.28 0-.53.11-.71.29L11 12.59V5c0-.55-.45-1-1-1s-1 .45-1 1v7.59L6.71 10.3A.965.965 0 006 10a1.003 1.003 0 00-.71 1.71l4 4c.18.18.43.29.71.29s.53-.11.71-.29l4-4A1.003 1.003 0 0014 10zM10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"];
  init_define_process();
  var circle_arrow_left_default2 = ["M15 9H7.41L9.7 6.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-4 4c-.18.18-.29.43-.29.71 0 .28.11.53.29.71l4 4a1.003 1.003 0 001.42-1.42L7.41 11H15c.55 0 1-.45 1-1s-.45-1-1-1zm-5-9C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"];
  init_define_process();
  var circle_arrow_right_default2 = ["M15.71 9.29l-4-4a1.003 1.003 0 00-1.42 1.42L12.59 9H5c-.55 0-1 .45-1 1s.45 1 1 1h7.59l-2.29 2.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l4-4c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71zM10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"];
  init_define_process();
  var circle_arrow_up_default2 = ["M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.71-13.71C10.53 4.11 10.28 4 10 4s-.53.11-.71.29l-4 4a1.003 1.003 0 001.42 1.42L9 7.41V15c0 .55.45 1 1 1s1-.45 1-1V7.41l2.29 2.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-4-4z"];
  init_define_process();
  var citation_default2 = ["M4 1C1.79 1 0 2.79 0 5s1.79 4 4 4c.1 0 .2-.01.3-.02C3.82 11.32 2.53 13 1 13c-.55 0-1 .45-1 1s.45 1 1 1c3.87 0 7-4.48 7-10 0-2.21-1.79-4-4-4zM16 1c-2.21 0-4 1.79-4 4s1.79 4 4 4c.1 0 .2-.01.3-.02C15.82 11.32 14.53 13 13 13c-.55 0-1 .45-1 1s.45 1 1 1c3.87 0 7-4.48 7-10 0-2.21-1.79-4-4-4z"];
  init_define_process();
  var clean_default2 = ["M7 0L5 5 0 6.998 5 9l2 5 2-5 5-1.995L9 5zM15 10l-1.5 3.496-3.5 1.499 3.5 1.498L15 20l1.5-3.507L20 15l-3.5-1.504z"];
  init_define_process();
  var clip_default2 = ["M0 1a1 1 0 011-1h5a1 1 0 010 2H2v4a1 1 0 01-2 0V1zm1 19a1 1 0 01-1-1v-5a1 1 0 112 0v4h4a1 1 0 110 2H1zm18 0a1 1 0 001-1v-5a1 1 0 10-2 0v4h-4a1 1 0 100 2h5zm0-20a1 1 0 011 1v5a1 1 0 11-2 0V2h-4a1 1 0 110-2h5zm-9 14a4 4 0 100-8 4 4 0 000 8z"];
  init_define_process();
  var clipboard_default2 = ["M13 2c0-.55-.45-1-1-1h-.78a1.98 1.98 0 00-3.44 0H7c-.55 0-1 .45-1 1v2h7V2z", "M16 2h-2v3H5V2H3c-.55 0-1 .45-1 1v16c0 .55.45 1 1 1h13c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1z"];
  init_define_process();
  var cloud_default2 = ["M15 7c-.12 0-.24.03-.36.04C13.83 4.69 11.62 3 9 3 5.69 3 3 5.69 3 9c0 .05.01.09.01.14A3.98 3.98 0 000 13c0 2.21 1.79 4 4 4h11c2.76 0 5-2.24 5-5s-2.24-5-5-5z"];
  init_define_process();
  var cloud_download_default2 = ["M15 4c-.12 0-.24.03-.36.04C13.83 1.69 11.62 0 9 0 5.69 0 3 2.69 3 6c0 .05.01.09.01.14A3.98 3.98 0 000 10c0 2.21 1.79 4 4 4h.78c.55-.61 1.34-1 2.22-1v-2c0-1.66 1.34-3 3-3s3 1.34 3 3v2c.88 0 1.66.38 2.2.98C17.87 13.87 20 11.69 20 9c0-2.76-2.24-5-5-5zm-2 11c-.28 0-.53.11-.71.29L11 16.59V11c0-.55-.45-1-1-1s-1 .45-1 1v5.59L7.71 15.3A.965.965 0 007 15a1.003 1.003 0 00-.71 1.71l3 3c.18.18.43.29.71.29s.53-.11.71-.29l3-3A1.003 1.003 0 0013 15z"];
  init_define_process();
  var cloud_upload_default2 = ["M10.71 10.29c-.18-.18-.43-.29-.71-.29s-.53.11-.71.29l-3 3a1.003 1.003 0 001.42 1.42L9 13.41V19c0 .55.45 1 1 1s1-.45 1-1v-5.59l1.29 1.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-3-3zM15 4c-.12 0-.24.03-.36.04C13.83 1.69 11.62 0 9 0 5.69 0 3 2.69 3 6c0 .05.01.09.01.14A3.98 3.98 0 000 10c0 2.21 1.79 4 4 4 0-.83.34-1.58.88-2.12l3-3a2.993 2.993 0 014.24 0l3 3-.01.01c.52.52.85 1.23.87 2.02C18.28 13.44 20 11.42 20 9c0-2.76-2.24-5-5-5z"];
  init_define_process();
  var code_default2 = ["M6 6a1.003 1.003 0 00-1.71-.71l-4 4C.11 9.47 0 9.72 0 10c0 .28.11.53.29.71l4 4a1.003 1.003 0 001.42-1.42L2.41 10 5.7 6.71c.19-.18.3-.43.3-.71zm6-4c-.46 0-.83.31-.95.73l-4 14c-.02.09-.05.17-.05.27 0 .55.45 1 1 1 .46 0 .83-.31.95-.73l4-14c.02-.09.05-.17.05-.27 0-.55-.45-1-1-1zm7.71 7.29l-4-4a1.003 1.003 0 00-1.42 1.42l3.3 3.29-3.29 3.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l4-4c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71z"];
  init_define_process();
  var code_block_default2 = ["M19 5h-2V3c0-.55-.45-1-1-1h-4c-.55 0-1 .45-1 1v2H9V3c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v2H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zM8.71 15.29a1.003 1.003 0 01-1.42 1.42l-4-4C3.11 12.53 3 12.28 3 12s.11-.53.29-.71l4-4a1.003 1.003 0 011.42 1.42L5.41 12l3.3 3.29zm8-2.58l-4 4a1.003 1.003 0 01-1.42-1.42l3.3-3.29-3.29-3.29A.965.965 0 0111 8a1.003 1.003 0 011.71-.71l4 4c.18.18.29.43.29.71s-.11.53-.29.71z"];
  init_define_process();
  var cog_default2 = ["M19 8h-2.31c-.14-.46-.33-.89-.56-1.3l1.7-1.7a.996.996 0 000-1.41l-1.41-1.41a.996.996 0 00-1.41 0l-1.7 1.7c-.41-.22-.84-.41-1.3-.55V1c0-.55-.45-1-1-1H9c-.55 0-1 .45-1 1v2.33c-.48.14-.94.34-1.37.58L5 2.28a.972.972 0 00-1.36 0L2.28 3.64c-.37.38-.37.99 0 1.36L3.9 6.62c-.24.44-.44.89-.59 1.38H1c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h2.31c.14.46.33.89.56 1.3L2.17 15a.996.996 0 000 1.41l1.41 1.41c.39.39 1.02.39 1.41 0l1.7-1.7c.41.22.84.41 1.3.55V19c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-2.33c.48-.14.94-.35 1.37-.59L15 17.72c.37.37.98.37 1.36 0l1.36-1.36c.37-.37.37-.98 0-1.36l-1.62-1.62c.24-.43.45-.89.6-1.38H19c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1zm-9 6c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"];
  init_define_process();
  var collapse_all_default2 = ["M9.29 8.71c.18.18.43.29.71.29s.53-.11.71-.29l6-6a1.003 1.003 0 00-1.42-1.42L10 6.59l-5.29-5.3a1.003 1.003 0 00-1.42 1.42l6 6zm1.42 2.58c-.18-.18-.43-.29-.71-.29s-.53.11-.71.29l-6 6a1.003 1.003 0 001.42 1.42l5.29-5.3 5.29 5.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-6-6z"];
  init_define_process();
  var color_fill_default2 = ["M2.188 9h11.984L8 2.828 3.414 7.414C2.811 8.017 2.405 8.48 2.188 9zM8 0L6.586 1.414 2 6c-1 1-2 2.11-2 4 0 2 1 3 2 4l1 1c1 1 2 2 4 2 2.009 0 2.918-.913 3.868-1.867L11 15l4.586-4.586L17 9l-1.414-1.414-6.172-6.172L8 0zm10.5 13.5L17 11l-1.5 2.5c-.318.53-.5 1-.5 1.5 0 1 .5 2 2 2s2-1 2-2c0-.5-.182-.97-.5-1.5zM1 18a1 1 0 100 2h18a1 1 0 100-2H1z"];
  init_define_process();
  var column_layout_default2 = ["M19 1H1c-.55 0-1 .45-1 1v16c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zM5 17H2V3h3v14zm4 0H6V3h3v14zm9 0h-8V3h8v14z"];
  init_define_process();
  var comment_default2 = ["M19 1H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3v4a1.003 1.003 0 001.71.71l4.7-4.71H19c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zM4 10c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm6 0c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm6 0c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"];
  init_define_process();
  var comparison_default2 = ["M6 8H1c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h5c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1zm13-6h-5c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h5c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1zm0 3h-5V3h5v2zM6 14H1c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h5c.55 0 1-.45 1-1v-2c0-.55-.45-1-1-1zM6 2H1c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h5c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1zm4-2c-.55 0-1 .45-1 1v18c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1zm9 14h-5c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h5c.55 0 1-.45 1-1v-2c0-.55-.45-1-1-1zm0 3h-5v-2h5v2zm0-9h-5c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h5c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1zm0 3h-5V9h5v2z"];
  init_define_process();
  var compass_default2 = ["M15 10c0 .14-.03.28-.09.4l-3.99 8.98-.01.02a.991.991 0 01-1.82 0l-.01-.02-3.99-8.98c-.06-.12-.09-.26-.09-.4s.03-.28.09-.4L9.08.62 9.09.6a.991.991 0 011.82 0l.01.02 3.99 8.98c.06.12.09.26.09.4zm-5-6.54L7.09 10h5.81L10 3.46z"];
  init_define_process();
  var compressed_default2 = ["M19.89 6.56l-2.99-6h-.01C16.72.23 16.39 0 16 0H4c-.39 0-.72.23-.89.56H3.1l-3 6h.01C.05 6.69 0 6.84 0 7v12c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V7c0-.16-.05-.31-.11-.44zM11 2h4.38l2 4H11V2zM4.62 2H9v4H2.62l2-4zM18 18H2V8h7v4.59L6.71 10.3A.965.965 0 006 10a1.003 1.003 0 00-.71 1.71l4 4c.18.18.43.29.71.29s.53-.11.71-.29l4-4a1.003 1.003 0 00-1.42-1.42L11 12.59V8h7v10z"];
  init_define_process();
  var confirm_default2 = ["M9.71 5.29a1.003 1.003 0 00-1.42 1.42l3 3c.18.18.43.29.71.29s.53-.11.71-.29l7-7a1.003 1.003 0 00-1.42-1.42L12 7.59l-2.29-2.3zm7.93 2.32c.23.75.36 1.56.36 2.39 0 4.42-3.58 8-8 8s-8-3.58-8-8a7.998 7.998 0 0111.8-7.04l1.46-1.46C13.73.56 11.93 0 10 0 4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10c0-1.4-.29-2.73-.81-3.95l-1.55 1.56z"];
  init_define_process();
  var console_default2 = ["M19 19H1c-.55 0-1-.45-1-1V2c0-.55.45-1 1-1h18c.55 0 1 .45 1 1v16c0 .55-.45 1-1 1zM18 6H2v11h16V6zM4 8c.28 0 .53.11.71.29l2 2c.18.18.29.43.29.71s-.11.53-.29.71l-2 2a1.003 1.003 0 01-1.42-1.42L4.59 11l-1.3-1.29A1.003 1.003 0 014 8zm5 4h3c.55 0 1 .45 1 1s-.45 1-1 1H9c-.55 0-1-.45-1-1s.45-1 1-1z"];
  init_define_process();
  var contrast_default2 = ["M19 8h-1.26c-.19-.73-.48-1.42-.85-2.06l.94-.94a.996.996 0 000-1.41l-1.41-1.41a.996.996 0 00-1.41 0l-.94.94c-.65-.38-1.34-.67-2.07-.86V1c0-.55-.45-1-1-1H9c-.55 0-1 .45-1 1v1.26c-.76.2-1.47.5-2.13.89L5 2.28a.972.972 0 00-1.36 0L2.28 3.64c-.37.38-.37.98 0 1.36l.87.87c-.39.66-.69 1.37-.89 2.13H1c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h1.26c.19.73.48 1.42.85 2.06l-.94.94a.996.996 0 000 1.41l1.41 1.41c.39.39 1.02.39 1.41 0l.94-.94c.64.38 1.33.66 2.06.85V19c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-1.26c.76-.2 1.47-.5 2.13-.89l.88.87c.37.37.98.37 1.36 0l1.36-1.36c.37-.38.37-.98 0-1.36l-.87-.87c.4-.65.7-1.37.89-2.13H19c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1zm-9 7c-2.76 0-5-2.24-5-5s2.24-5 5-5v10z"];
  init_define_process();
  var control_default2 = ["M17 10h-7v7h7v-7zm0-7h-7v6h7V3zM9 3H3v14h6V3zm10-3H1C.45 0 0 .45 0 1v18c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 18H2V2h16v16z"];
  init_define_process();
  var credit_card_default2 = ["M19 3H1c-.55 0-1 .45-1 1v2h20V4c0-.55-.45-1-1-1zM0 16c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V8H0v8zm6.5-2h7c.28 0 .5.22.5.5s-.22.5-.5.5h-7c-.28 0-.5-.22-.5-.5s.22-.5.5-.5zm-4 0h2c.28 0 .5.22.5.5s-.22.5-.5.5h-2c-.28 0-.5-.22-.5-.5s.22-.5.5-.5z"];
  init_define_process();
  var cross_default2 = ["M11.41 10l4.29-4.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L10 8.59l-4.29-4.3a1.003 1.003 0 00-1.42 1.42L8.59 10 4.3 14.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l4.29-4.3 4.29 4.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L11.41 10z"];
  init_define_process();
  var cross_circle_default2 = ["M10 20c5.523 0 10-4.477 10-10S15.523 0 10 0 0 4.477 0 10s4.477 10 10 10zm4.7-13.29L11.41 10l3.3 3.29A1.003 1.003 0 0114 15c-.28 0-.53-.11-.71-.3L10 11.41l-3.29 3.3A1.003 1.003 0 015 14c0-.28.11-.53.3-.71L8.59 10l-3.3-3.29a1.003 1.003 0 011.42-1.42L10 8.59l3.29-3.3A1.003 1.003 0 0115 6c0 .28-.11.53-.3.71z"];
  init_define_process();
  var crown_default2 = ["M2 8l4 2 4-5 4 5 4-2-1 7H3L2 8zm8-6a1 1 0 110 2 1 1 0 010-2zM1 5a1 1 0 110 2 1 1 0 010-2zm18 0a1 1 0 110 2 1 1 0 010-2zM3 16h14v2H3v-2z"];
  init_define_process();
  var cube_default2 = ["M1.953 4.481l7.41-4.02c.394-.215.88-.215 1.275 0l7.409 4.02L10 9.22 1.953 4.48zm-.817.68L9.5 10.085v9.281a1.316 1.316 0 01-.138-.064l-7.714-4.186A1.211 1.211 0 011 14.057v-8.35c0-.193.048-.38.136-.547zm17.728 0c.088.166.136.353.136.546v8.35c0 .438-.247.842-.648 1.06l-7.714 4.186c-.045.024-.091.046-.138.064v-9.281l8.364-4.926z"];
  init_define_process();
  var cube_add_default2 = ["M17 3h2a1 1 0 010 2h-2v2a1 1 0 01-2 0V5h-2a1 1 0 010-2h2V1a1 1 0 012 0v2zm-3.969 4.435L10 9.22 1.953 4.48l7.41-4.02c.394-.215.88-.215 1.275 0l1.33.721A3.001 3.001 0 0013 7c0 .148.01.293.031.435zm.319.972A3 3 0 0019 7v7.057c0 .438-.247.842-.648 1.06l-7.714 4.186c-.045.024-.091.046-.138.064v-9.281l2.85-1.679zM1.136 5.16L9.5 10.086v9.281a1.316 1.316 0 01-.138-.064l-7.714-4.186A1.211 1.211 0 011 14.057v-8.35c0-.193.048-.38.136-.547z"];
  init_define_process();
  var cube_remove_default2 = ["M11.968 1.182A3.001 3.001 0 0013 7h.77L10 9.22 1.953 4.48l7.41-4.02c.394-.215.88-.215 1.275 0l1.33.721zM19 7v7.057c0 .438-.247.842-.648 1.06l-7.714 4.186c-.045.024-.091.046-.138.064v-9.281L15.74 7H19zM1.136 5.16L9.5 10.086v9.281a1.316 1.316 0 01-.138-.064l-7.714-4.186A1.211 1.211 0 011 14.057v-8.35c0-.193.048-.38.136-.547zM13 3h6a1 1 0 010 2h-6a1 1 0 010-2z"];
  init_define_process();
  var curved_range_chart_default2 = ["M19 16H3.02l2.14-1.74c2.25 1.7 7.33.46 11.83-2.99l-1.29-1.5c-3.56 2.74-7.31 4.03-8.93 3.19l10.55-8.57-.63-.78-10.59 8.6c-.64-1.64 1.46-4.91 5.09-7.7L9.9 3.01c-4.6 3.54-6.91 8.12-5.41 10.51L2 15.54V3c0-.55-.45-1-1-1s-1 .45-1 1v14a.998.998 0 001 1h18c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var cut_default2 = ["M16 2s.72-1.28 0-2l-5.29 6.25 1.28 1.54L16 2zm.08 10c-.55 0-1.07.12-1.54.32L4.31 0c-.7.72 0 2 0 2l4.45 6.56-3.19 3.77C5.09 12.12 4.56 12 4 12c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4c0-.65-.17-1.26-.45-1.8l2.54-3.67 2.49 3.67c-.27.54-.44 1.15-.44 1.8 0 2.21 1.76 4 3.92 4 2.17 0 3.92-1.79 3.92-4 .02-2.21-1.74-4-3.9-4zM4 18c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm12.08 0c-1.08 0-1.96-.9-1.96-2s.88-2 1.96-2 1.96.9 1.96 2-.88 2-1.96 2z"];
  init_define_process();
  var cycle_default2 = ["M16 10a4 4 0 110 8 4 4 0 010-8zM4 10a4 4 0 110 8 4 4 0 010-8zm7.299-5.543l.087.089 1.93 2.232 2.048.708a1 1 0 01.65 1.16l-.031.112a1 1 0 01-1.16.65l-.112-.031-2.302-.796a1 1 0 01-.337-.197l-.092-.094-1.387-1.603-1.891 1.982 2.046 2.274a1 1 0 01.25.547l.007.122v4.24a1 1 0 01-1.993.117l-.007-.117-.001-3.857-2.408-2.676a1 1 0 01-.063-1.26l.082-.099 3.29-3.45a1 1 0 011.394-.053zM16 12a2 2 0 100 4 2 2 0 000-4zM4 12a2 2 0 100 4 2 2 0 000-4zm9.5-10a1.5 1.5 0 110 3 1.5 1.5 0 010-3z"];
  init_define_process();
  var dashboard_default2 = ["M6 5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zM4 9c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm6-4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0-5C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm6-9c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm-8 5c0 1.1.9 2 2 2s2-.9 2-2c0-.33-2-8-2-8s-2 7.67-2 8zm6-9c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1z"];
  init_define_process();
  var data_connection_default2 = ["M2 11.9c.935.674 2.339 1.217 4.023 1.536A6.996 6.996 0 009.393 20c-3.988-.019-7.231-1.083-7.387-2.4L2 17.5v-5.6zM13 8c3.315 0 6 2.685 6 6s-2.685 6-6 6-6-2.685-6-6 2.685-6 6-6zm1 1l-4 6h2.5l-.5 4 4-6h-2.5l.5-4zm3-4.6v3.855a7.003 7.003 0 00-10.779 3.992c-2.408-.391-4.097-1.202-4.214-2.142L2 10V4.4c1.525 1.1 4.3 1.85 7.5 1.85S15.475 5.5 17 4.4zM9.5 0C13.637 0 17 1.125 17 2.5S13.637 5 9.5 5C5.35 5 2 3.875 2 2.5S5.35 0 9.5 0z"];
  init_define_process();
  var data_lineage_default2 = ["M1.053 0C.47 0 0 .471 0 1.053V4.21c0 .58.471 1.052 1.053 1.052h3.275a6.332 6.332 0 003.728 4.738 6.33 6.33 0 00-3.728 4.737l-3.275-.001C.47 14.737 0 15.208 0 15.789v3.158C0 19.53.471 20 1.053 20h7.435c.581 0 1.053-.471 1.053-1.053V15.79c0-.58-.472-1.052-1.053-1.052H5.406a5.293 5.293 0 015.195-4.21v2.105c0 .58.471 1.052 1.052 1.052h7.294c.582 0 1.053-.471 1.053-1.052V7.368c0-.58-.471-1.052-1.053-1.052h-7.294c-.581 0-1.052.471-1.052 1.052v2.106a5.293 5.293 0 01-5.194-4.21h3.081c.581 0 1.053-.472 1.053-1.053V1.053C9.54.47 9.069 0 8.488 0H1.053z"];
  init_define_process();
  var database_default2 = ["M2.01 5.1v5.4c0 1.38 3.58 2.5 8 2.5s8-1.12 8-2.5V5.1c-1.49 1.13-4.51 1.9-8 1.9-3.48 0-6.5-.77-8-1.9zm8 .9c4.42 0 8-1.12 8-2.5s-3.58-2.5-8-2.5-8 1.12-8 2.5S5.6 6 10.01 6zm-8 6.1v5.4c0 1.38 3.58 2.5 8 2.5s8-1.12 8-2.5v-5.4c-1.49 1.13-4.51 1.9-8 1.9-3.48 0-6.5-.77-8-1.9z"];
  init_define_process();
  var delete_default2 = ["M15 6a1.003 1.003 0 00-1.71-.71L10 8.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42L8.59 10 5.3 13.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l3.29-3.3 3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L11.41 10l3.29-3.29c.19-.18.3-.43.3-.71zm-5-6C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"];
  init_define_process();
  var delta_default2 = ["M10 0L0 20h20L10 0zM9 6l6 12H3L9 6z"];
  init_define_process();
  var derive_column_default2 = ["M7.1 8.2h-.99c.28-1.11.66-1.92 1.12-2.43.28-.32.56-.48.83-.48.05 0 .1.02.13.05.03.03.05.07.05.12 0 .04-.04.13-.11.25a.64.64 0 00-.12.35c0 .15.06.28.18.39.12.11.27.16.45.16.2 0 .36-.07.49-.2s.2-.31.2-.54c0-.26-.1-.47-.3-.63-.19-.16-.51-.24-.95-.24-.68 0-1.3.19-1.85.58-.56.38-1.09 1.02-1.59 1.91-.17.3-.34.5-.49.59-.15.08-.4.13-.74.12l-.23.77h.95l-1.39 5.24c-.23.86-.39 1.39-.47 1.59-.12.29-.3.54-.54.75-.1.08-.21.12-.35.12-.04 0-.07-.01-.1-.03l-.03-.04c0-.02.03-.07.1-.13.07-.07.1-.17.1-.31 0-.15-.05-.28-.16-.38-.11-.1-.27-.15-.47-.15-.25 0-.44.07-.59.2-.15.12-.23.28-.23.46 0 .19.09.36.27.5.19.14.47.21.86.21.61 0 1.16-.15 1.63-.46.48-.31.89-.78 1.25-1.43.35-.64.72-1.68 1.09-3.11l.8-3.03h.96l.24-.77zM19 0h-9c-.55 0-1 .45-1 1v3h2V2h7v16h-7v-2H9v3c0 .55.45 1 1 1h9c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-8.79 13.49c.15.28.32.49.52.61.19.12.44.19.73.19.28 0 .57-.1.86-.3.38-.25.77-.69 1.17-1.31l-.25-.14c-.27.37-.48.6-.61.69-.09.06-.19.09-.31.09-.14 0-.28-.09-.42-.26-.23-.29-.54-1.09-.93-2.4.35-.59.64-.97.87-1.15.17-.13.35-.2.55-.2.07 0 .2.03.39.08s.36.08.5.08c.2 0 .37-.07.5-.2.15-.14.22-.31.22-.52 0-.22-.07-.4-.2-.53s-.33-.2-.58-.2c-.22 0-.43.05-.63.15-.2.1-.45.32-.75.67-.23.25-.56.7-1.01 1.33a6.52 6.52 0 00-.91-2.15l-2.39.39-.05.25c.18-.03.33-.05.45-.05.24 0 .43.1.59.3.25.31.59 1.24 1.02 2.8-.34.44-.58.73-.7.87-.21.22-.38.36-.52.43-.1.05-.22.08-.35.08-.1 0-.26-.05-.49-.16a1.01 1.01 0 00-.42-.11c-.23 0-.42.07-.57.22-.15.14-.23.33-.23.55 0 .21.07.38.21.51.14.13.33.2.56.2.23 0 .44-.05.64-.14.2-.09.45-.29.75-.59s.72-.78 1.25-1.43c.21.61.39 1.06.54 1.35z"];
  init_define_process();
  var desktop_default2 = ["M19 0H1C.45 0 0 .45 0 1v13c0 .55.45 1 1 1h5.67l-.5 3H5c-.55 0-1 .45-1 1s.45 1 1 1h10c.55 0 1-.45 1-1s-.45-1-1-1h-1.17l-.5-3H19c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 13H2V2h16v11z"];
  init_define_process();
  var diagnosis_default2 = ["M4 2a1 1 0 01.117 1.993L4 4v5a2 2 0 001.85 1.995L6 11a2 2 0 001.995-1.85L8 9V4a1 1 0 01-.117-1.993L8 2h1a1 1 0 01.993.883L10 3v6a4.002 4.002 0 01-3 3.874V13a3 3 0 003 3 4 4 0 003.995-3.8L14 12V8.792a2.5 2.5 0 112 0V12a6 6 0 01-6 6 5 5 0 01-4.995-4.783L5 13v-.126A4.002 4.002 0 012.005 9.2L2 9V3a1 1 0 01.883-.993L3 2h1z"];
  init_define_process();
  var diagram_tree_default2 = ["M19 10v5h-2v-4h-6v4H9v-4H3v4H1v-5a1 1 0 011-1h7V5h2v4h7a1 1 0 011 1zM1 16h2a1 1 0 011 1v2a1 1 0 01-1 1H1a1 1 0 01-1-1v-2a1 1 0 011-1zm16 0h2a1 1 0 011 1v2a1 1 0 01-1 1h-2a1 1 0 01-1-1v-2a1 1 0 011-1zm-8 0h2a1 1 0 011 1v2a1 1 0 01-1 1H9a1 1 0 01-1-1v-2a1 1 0 011-1zM9 0h2a1 1 0 011 1v2a1 1 0 01-1 1H9a1 1 0 01-1-1V1a1 1 0 011-1z"];
  init_define_process();
  var direction_left_default2 = ["M20 3.02l-20 7 20 7-5-7z"];
  init_define_process();
  var direction_right_default2 = ["M20 10.02l-20-7 5 7-5 7z"];
  init_define_process();
  var disable_default2 = ["M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zM2 10c0-4.42 3.58-8 8-8 1.85 0 3.55.63 4.9 1.69L3.69 14.9A7.902 7.902 0 012 10zm8 8c-1.85 0-3.55-.63-4.9-1.69L16.31 5.1A7.902 7.902 0 0118 10c0 4.42-3.58 8-8 8z"];
  init_define_process();
  var divide_default2 = ["M11.25 6.25a1.25 1.25 0 11-2.5 0 1.25 1.25 0 012.5 0zM6 9c-.55 0-1 .45-1 1s.45 1 1 1h8c.55 0 1-.45 1-1s-.45-1-1-1H6zm4 6a1.25 1.25 0 100-2.5 1.25 1.25 0 000 2.5z"];
  init_define_process();
  var document_default2 = ["M11.98 0h-8c-.55 0-1 .45-1 1v18c0 .55.45 1 1 1h13c.55 0 1-.45 1-1V6l-6-6zm4 18h-11V2h6v5h5v11z"];
  init_define_process();
  var document_open_default2 = ["M8 15c0 .55.45 1 1 1s1-.45 1-1v-5c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1s.45 1 1 1h2.59L1.3 16.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L8 12.41V15zm5-15H5c-.55 0-1 .45-1 1v6h2V2h6v5h5v11H6v-.76L4.04 19.2c.1.45.48.8.96.8h13c.55 0 1-.45 1-1V6l-6-6z"];
  init_define_process();
  var document_share_default2 = ["M14.09 10.09c-.31.31-.67.57-1.09.72V18H2V2h6v5h1.18c.15-.42.39-.8.7-1.11v-.01l2.45-2.45c-.42-.29-.78-.65-1.01-1.11L9 0H1C.45 0 0 .45 0 1v18c0 .55.45 1 1 1h13c.55 0 1-.45 1-1V9.24l-.88.88-.03-.03zM19 0h-5c-.55 0-1 .45-1 1s.45 1 1 1h2.59L11.3 7.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L18 3.41V6c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var dollar_default2 = ["M15.57 11.19c-.27-.51-.63-.93-1.07-1.26-.44-.33-.95-.6-1.51-.79-.56-.2-1.14-.36-1.72-.5-.6-.14-1.19-.26-1.75-.38-.57-.13-1.07-.27-1.51-.44-.44-.17-.8-.38-1.07-.63s-.41-.59-.41-1c0-.33.09-.6.28-.81.19-.21.42-.36.69-.47.27-.11.57-.18.88-.22.31-.04.58-.06.8-.06.71 0 1.35.14 1.9.41.55.27.91.81 1.06 1.62h3.36c-.09-.84-.32-1.56-.69-2.16-.37-.6-.83-1.08-1.38-1.45-.56-.37-1.18-.64-1.86-.81-.19-.05-.38-.07-.57-.1V1c0-.55-.45-1-1-1H9c-.55 0-1 .45-1 1v1.1c-.22.03-.43.05-.66.1-.73.13-1.39.37-1.98.71-.6.34-1.09.8-1.47 1.35-.39.56-.58 1.25-.58 2.08 0 .76.13 1.41.4 1.93.26.52.62.95 1.06 1.28.44.33.94.6 1.5.79.55.2 1.13.36 1.74.5.58.14 1.16.26 1.72.38s1.07.26 1.51.43c.44.17.8.39 1.09.66.28.27.43.63.45 1.06.02.43-.08.78-.3 1.04-.22.26-.49.47-.83.6-.34.14-.7.23-1.09.28-.39.05-.73.07-1.03.07-.87 0-1.61-.2-2.23-.59-.62-.39-.98-1.08-1.07-2.06H3c.02.9.19 1.68.52 2.34.33.66.78 1.21 1.35 1.65.57.44 1.25.77 2.03.98.35.1.71.16 1.08.21V19c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1.13c.25-.04.5-.07.76-.13.77-.18 1.47-.46 2.1-.85.63-.39 1.14-.9 1.54-1.53.4-.63.59-1.39.59-2.29.01-.75-.13-1.37-.4-1.88z"];
  init_define_process();
  var dot_default2 = ["M10 6a4 4 0 100 8 4 4 0 100-8z"];
  init_define_process();
  var double_caret_horizontal_default2 = ["M8 4c-.24 0-.46.1-.63.24l-.01-.01-6 5 .01.01c-.22.19-.37.45-.37.76s.15.57.37.76l-.01.01 6 5 .01-.01c.17.14.39.24.63.24.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zm11 6c0-.31-.15-.57-.37-.76l.01-.01-6-5-.01.01C12.46 4.1 12.24 4 12 4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1 .24 0 .46-.1.63-.24l.01.01 6-5-.01-.01c.22-.19.37-.45.37-.76z"];
  init_define_process();
  var double_caret_vertical_default2 = ["M5 9h10c.55 0 1-.45 1-1 0-.24-.1-.46-.24-.63l.01-.01-5-6-.01.01C10.57 1.15 10.31 1 10 1s-.57.15-.76.37l-.01-.01-5 6 .01.01C4.1 7.54 4 7.76 4 8c0 .55.45 1 1 1zm10 2H5c-.55 0-1 .45-1 1 0 .24.1.46.24.63l-.01.01 5 6 .01-.01c.19.22.45.37.76.37s.57-.15.76-.37l.01.01 5-6-.01-.01c.14-.17.24-.39.24-.63 0-.55-.45-1-1-1z"];
  init_define_process();
  var double_chevron_down_default2 = ["M9.29 10.71c.18.18.43.29.71.29s.53-.11.71-.29l6-6a1.003 1.003 0 00-1.42-1.42L10 8.59l-5.29-5.3a1.003 1.003 0 00-1.42 1.42l6 6zM16 9c-.28 0-.53.11-.71.29L10 14.59l-5.29-5.3a1.003 1.003 0 00-1.42 1.42l6 6c.18.18.43.29.71.29s.53-.11.71-.29l6-6A1.003 1.003 0 0016 9z"];
  init_define_process();
  var double_chevron_left_default2 = ["M5.41 10l5.29-5.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-6 6c-.18.18-.29.43-.29.71 0 .28.11.53.29.71l6 6a1.003 1.003 0 001.42-1.42L5.41 10zm6 0l5.29-5.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-6 6c-.18.18-.29.43-.29.71 0 .28.11.53.29.71l6 6a1.003 1.003 0 001.42-1.42L11.41 10z"];
  init_define_process();
  var double_chevron_right_default2 = ["M11 10c0-.28-.11-.53-.29-.71l-6-6a1.003 1.003 0 00-1.42 1.42L8.59 10 3.3 15.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l6-6c.18-.18.29-.43.29-.71zm5.71-.71l-6-6a1.003 1.003 0 00-1.42 1.42l5.3 5.29-5.29 5.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l6-6c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71z"];
  init_define_process();
  var double_chevron_up_default2 = ["M4 11c.28 0 .53-.11.71-.29L10 5.41l5.29 5.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-6-6A.997.997 0 0010 3c-.28 0-.53.11-.71.29l-6 6A1.003 1.003 0 004 11zm6.71-1.71A.997.997 0 0010 9c-.28 0-.53.11-.71.29l-6 6a1.003 1.003 0 001.42 1.42l5.29-5.3 5.29 5.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-6-6z"];
  init_define_process();
  var doughnut_chart_default2 = ["M16 10c0 3.31-2.69 6-6 6s-6-2.69-6-6 2.69-6 6-6V0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10h-4zm-.09-1h4.04C19.48 4.28 15.72.52 11 .05V4.1A5.98 5.98 0 0115.91 9z"];
  init_define_process();
  var download_default2 = ["M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm4.71 11.71l-4 4c-.18.18-.43.29-.71.29s-.53-.11-.71-.29l-4-4a1.003 1.003 0 011.42-1.42L9 12.59V5c0-.55.45-1 1-1s1 .45 1 1v7.59l2.29-2.29c.18-.19.43-.3.71-.3a1.003 1.003 0 01.71 1.71z"];
  init_define_process();
  var drag_handle_horizontal_default2 = ["M7.5 11c-.83 0-1.5.67-1.5 1.5S6.67 14 7.5 14 9 13.33 9 12.5 8.33 11 7.5 11zm-5-5C1.67 6 1 6.67 1 7.5S1.67 9 2.5 9 4 8.33 4 7.5 3.33 6 2.5 6zm0 5c-.83 0-1.5.67-1.5 1.5S1.67 14 2.5 14 4 13.33 4 12.5 3.33 11 2.5 11zm15-2c.83 0 1.5-.67 1.5-1.5S18.33 6 17.5 6 16 6.67 16 7.5 16.67 9 17.5 9zm-5 2c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm5 0c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm-10-5C6.67 6 6 6.67 6 7.5S6.67 9 7.5 9 9 8.33 9 7.5 8.33 6 7.5 6zm5 0c-.83 0-1.5.67-1.5 1.5S11.67 9 12.5 9 14 8.33 14 7.5 13.33 6 12.5 6z"];
  init_define_process();
  var drag_handle_vertical_default2 = ["M7.5 6C6.67 6 6 6.67 6 7.5S6.67 9 7.5 9 9 8.33 9 7.5 8.33 6 7.5 6zm0 5c-.83 0-1.5.67-1.5 1.5S6.67 14 7.5 14 9 13.33 9 12.5 8.33 11 7.5 11zm0 5c-.83 0-1.5.67-1.5 1.5S6.67 19 7.5 19 9 18.33 9 17.5 8.33 16 7.5 16zm5-12c.83 0 1.5-.67 1.5-1.5S13.33 1 12.5 1 11 1.67 11 2.5 11.67 4 12.5 4zm-5-3C6.67 1 6 1.67 6 2.5S6.67 4 7.5 4 9 3.33 9 2.5 8.33 1 7.5 1zm5 10c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0 5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-10c-.83 0-1.5.67-1.5 1.5S11.67 9 12.5 9 14 8.33 14 7.5 13.33 6 12.5 6z"];
  init_define_process();
  var draw_default2 = ["M17.7 12.7c0-.1 0-.2-.1-.3l-2-7c-.1-.3-.3-.6-.6-.7L1.8 0l-.6.5L7.7 7c.3-.2.6-.3 1-.3 1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2c0-.4.1-.7.3-1L.5 1.2l-.5.6L4.7 15c.1.3.4.5.7.6l7 2c.1 0 .2.1.3.1.3 0 .5-.1.7-.3l4-4c.2-.2.3-.5.3-.7zm1 1c-.3 0-.5.1-.7.3l-4 4c-.2.2-.3.4-.3.7 0 .5.4 1 1 1 .3 0 .5-.1.7-.3l4-4c.2-.2.3-.4.3-.7 0-.6-.5-1-1-1z"];
  init_define_process();
  var drawer_left_default2 = ["M9 0a1 1 0 011 1v18a1 1 0 01-1 1H1a1 1 0 01-1-1V1a1 1 0 011-1h8zM8 2H2v16h6V2zm2 7h6.59L14.3 6.71A.965.965 0 0114 6a1.003 1.003 0 011.71-.71l4 4c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-4 4a1.003 1.003 0 01-1.42-1.42l2.3-2.29H10V9z"];
  init_define_process();
  var drawer_left_filled_default2 = ["M1 0h8a1 1 0 011 1v18a1 1 0 01-1 1H1a1 1 0 01-1-1V1a1 1 0 011-1zm9 9h6.59L14.3 6.71A.965.965 0 0114 6a1.003 1.003 0 011.71-.71l4 4c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-4 4a1.003 1.003 0 01-1.42-1.42l2.3-2.29H10V9z"];
  init_define_process();
  var drawer_right_default2 = ["M19 0a1 1 0 011 1v18a1 1 0 01-1 1h-8a1 1 0 01-1-1V1a1 1 0 011-1h8zm-1 2h-6v16h6V2zm-8 7H3.41L5.7 6.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-4 4C.11 9.47 0 9.72 0 10c0 .28.11.53.29.71l4 4a1.003 1.003 0 001.42-1.42L3.41 11H10V9z"];
  init_define_process();
  var drawer_right_filled_default2 = ["M11 0h8a1 1 0 011 1v18a1 1 0 01-1 1h-8a1 1 0 01-1-1V1a1 1 0 011-1zm-1 9H3.41L5.7 6.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-4 4C.11 9.47 0 9.72 0 10c0 .28.11.53.29.71l4 4a1.003 1.003 0 001.42-1.42L3.41 11H10V9z"];
  init_define_process();
  var drive_time_default2 = ["M20.01 7.7c0-.63-.5-1.14-1.1-1.14h-1.32l-.95-2.57c-.24-.64-.95-1.31-1.59-1.5 0 0-1.65-.49-5.05-.49s-5.04.49-5.04.49c-.63.19-1.35.86-1.59 1.5l-.95 2.57H1.1C.5 6.56 0 7.07 0 7.7c0 .63.5 1.14 1.1 1.14h.47l-.34.91c-.24.64-.43 1.72-.43 2.4v5.39c0 .8.63 1.45 1.4 1.45.77 0 1.4-.65 1.4-1.45v-.83h12.8v.83c0 .8.63 1.45 1.4 1.45s1.4-.65 1.4-1.45v-5.39c0-.68-.19-1.77-.43-2.4l-.34-.91h.47c.61 0 1.11-.51 1.11-1.14zm-16.47.34l1.12-3.16c.08-.22.32-.39.54-.39h9.6c.22 0 .46.17.54.39l1.12 3.16c.08.21-.04.39-.26.39H3.8c-.22-.01-.34-.18-.26-.39zm.96 4.94c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.68 1.5 1.5c0 .83-.67 1.5-1.5 1.5zm11 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"];
  init_define_process();
  var duplicate_default2 = ["M15 4H1c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zm-1 14H2V6h12v12zm5-18H5c-.55 0-1 .45-1 1v2h2V2h12v12h-1v2h2c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var edit_default2 = ["M4.59 12.59l2.83 2.83 7.65-7.65-2.83-2.83-7.65 7.65zM2 18l4.41-1.59-2.81-2.79L2 18zM16 2c-.55 0-1.05.22-1.41.59l-1.65 1.65 2.83 2.83 1.65-1.65A2.006 2.006 0 0016 2z"];
  init_define_process();
  var eject_default2 = ["M4 12h12c.55 0 1-.45 1-1 0-.25-.1-.47-.25-.64l.01-.01-6-7-.01.01C10.57 3.14 10.3 3 10 3s-.57.14-.75.36l-.01-.01-6 7 .01.01c-.15.17-.25.39-.25.64 0 .55.45 1 1 1zm12 1H4c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-2c0-.55-.45-1-1-1z"];
  init_define_process();
  var emoji_default2 = ["M10 0c5.523 0 10 4.477 10 10s-4.477 10-10 10S0 15.523 0 10 4.477 0 10 0zm0 2a8 8 0 100 16 8 8 0 000-16zm-4 8l.015.215C6.219 12.42 7.925 14 10 14a4 4 0 003.995-3.8L14 10h2l-.013.238C15.754 13.552 13.163 16 10 16a6 6 0 01-5.996-5.775L4 10h2zm1.5-4a1.5 1.5 0 110 3 1.5 1.5 0 010-3zm5 0a1.5 1.5 0 110 3 1.5 1.5 0 010-3z"];
  init_define_process();
  var endorsed_default2 = ["M19.83 9.38L18.81 7.6V5.62c0-.45-.23-.85-.61-1.08l-1.71-1-1.02-1.76a1.25 1.25 0 00-1.08-.61h-2.03l-1.74-1c-.38-.23-.87-.23-1.25 0l-1.74 1H5.65c-.44 0-.85.23-1.08.61L3.58 3.5l-1.8 1.04c-.38.24-.62.64-.62 1.08v2.06L.17 9.4c-.11.19-.17.4-.17.61s.06.42.17.61l.99 1.72v2.06c0 .45.23.85.61 1.08l1.78 1.02.99 1.72c.23.38.63.61 1.08.61h1.99l1.74 1c.19.11.41.17.62.17.21 0 .42-.06.61-.17l1.74-1h2.03c.44 0 .85-.23 1.08-.61l1.02-1.76 1.71-1c.38-.23.61-.64.61-1.08v-1.97l1.02-1.78c.27-.38.27-.85.04-1.25zm-5.08-.71l-5.01 5.01c-.18.18-.43.29-.71.29-.28 0-.53-.11-.71-.29l-3.01-3.01a1.003 1.003 0 011.42-1.42l2.3 2.3 4.31-4.3a1.003 1.003 0 011.71.71c0 .28-.12.53-.3.71z"];
  init_define_process();
  var envelope_default2 = ["M0 4.01v11.91l6.27-6.27L0 4.01zm18.91-1.03H1.09L10 10.97l8.91-7.99zm-5.18 6.66L20 15.92V4.01l-6.27 5.63zm-3.23 2.9c-.13.12-.31.19-.5.19s-.37-.07-.5-.19l-2.11-1.89-6.33 6.33h17.88l-6.33-6.33-2.11 1.89z"];
  init_define_process();
  var equals_default2 = ["M4 7h12a1 1 0 010 2H4a1 1 0 110-2zm0 4h12a1 1 0 010 2H4a1 1 0 010-2z"];
  init_define_process();
  var eraser_default2 = ["M18.71 8.43c.39-.4.39-1.05 0-1.45l-5.53-5.72a.967.967 0 00-1.4 0L1.29 12.1c-.39.4-.39 1.05 0 1.45l4.25 4.39 2.13 2.05h9.27c.02 0 .03.01.05.01.55 0 1-.45 1-1s-.45-1-1-1H9.46l.05-.05h.01l.81-.84 8.38-8.68zM7.52 17.94l-4.95-5.12 4.46-4.61 4.95 5.12-4.46 4.61z"];
  init_define_process();
  var error_default2 = ["M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm1 16H9v-2h2v2zm0-3H9V4h2v9z"];
  init_define_process();
  var euro_default2 = ["M8.89 4.47c.56-.31 1.23-.47 2.03-.47.44 0 .85.07 1.25.22.4.14.76.35 1.07.6.17.14.33.3.47.47l2.32-2.32c-.16-.15-.3-.32-.47-.46-.62-.49-1.33-.87-2.12-1.13-.8-.25-1.64-.38-2.52-.38-1.24 0-2.35.22-3.33.66-.99.44-1.82 1.05-2.49 1.82-.68.78-1.2 1.68-1.56 2.72-.09.26-.13.54-.2.8H2c-.55 0-1 .45-1 1s.45 1 1 1h1.04c-.01.2-.04.38-.04.58 0 .15.03.28.03.42H2c-.55 0-1 .45-1 1s.45 1 1 1h1.31c.07.3.13.6.23.89.36 1.02.88 1.92 1.56 2.67.68.76 1.51 1.35 2.49 1.79.98.43 2.09.65 3.33.65.99 0 1.9-.15 2.73-.46.83-.3 1.55-.74 2.17-1.32.03-.03.05-.06.08-.09l-2.41-2.15c-.01.01-.02.02-.02.03-.61.67-1.46 1-2.54 1-.8 0-1.47-.16-2.03-.47-.56-.31-1.01-.72-1.35-1.24-.28-.38-.47-.83-.63-1.3H12c.55 0 1-.45 1-1s-.45-1-1-1H6.56c0-.14-.02-.28-.02-.42 0-.2.02-.39.03-.58H13c.55 0 1-.45 1-1s-.45-1-1-1H6.94c.15-.46.34-.9.59-1.28.35-.52.8-.94 1.36-1.25zM18 11.38v0z"];
  init_define_process();
  var exchange_default2 = ["M2.5 8a2.5 2.5 0 000 5 2.5 2.5 0 000-5zm10.35 3.15a.495.495 0 10-.7.7L13.3 13H5.5c-.28 0-.5.22-.5.5s.22.5.5.5h7.79l-1.15 1.15c-.08.09-.14.21-.14.35a.495.495 0 00.85.35l2-2c.09-.09.15-.21.15-.35s-.06-.26-.15-.35l-2-2zM17.5 8a2.5 2.5 0 000 5 2.5 2.5 0 000-5zM7.15 9.85a.495.495 0 10.7-.7L6.71 8h7.79c.28 0 .5-.22.5-.5s-.22-.5-.5-.5H6.71l1.15-1.15c.08-.09.14-.21.14-.35a.495.495 0 00-.85-.35l-2 2c-.09.09-.15.21-.15.35s.06.26.15.35l2 2z"];
  init_define_process();
  var exclude_row_default2 = ["M1 3h18c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1zM0 13a1.003 1.003 0 001.71.71L4 11.41l2.29 2.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L5.41 10 7.7 7.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L4 8.59l-2.29-2.3A1.003 1.003 0 00.29 7.71L2.59 10 .3 12.29c-.19.18-.3.43-.3.71zm18-5h-7c-1.1 0-2 .9-2 2s.9 2 2 2h7c1.1 0 2-.9 2-2s-.9-2-2-2zm1 9H1c-.55 0-1 .45-1 1s.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var expand_all_default2 = ["M4 9c.28 0 .53-.11.71-.29L10 3.41l5.29 5.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-6-6C10.53 1.11 10.28 1 10 1s-.53.11-.71.29l-6 6A1.003 1.003 0 004 9zm12 2c-.28 0-.53.11-.71.29L10 16.59 4.71 11.3A.965.965 0 004 11a1.003 1.003 0 00-.71 1.71l6 6c.18.18.43.29.71.29s.53-.11.71-.29l6-6A1.003 1.003 0 0016 11z"];
  init_define_process();
  var export_default2 = ["M5 7c.28 0 .53-.11.71-.29L9 3.41V15c0 .55.45 1 1 1s1-.45 1-1V3.41l3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-5-5C10.53.11 10.28 0 10 0s-.53.11-.71.29l-5 5A1.003 1.003 0 005 7zm14 7c-.55 0-1 .45-1 1v3H2v-3c0-.55-.45-1-1-1s-1 .45-1 1v4c0 .55.45 1 1 1h18c.55 0 1-.45 1-1v-4c0-.55-.45-1-1-1z"];
  init_define_process();
  var eye_off_default2 = ["M20 9.96v-.03-.01-.02-.02a.794.794 0 00-.21-.43c-.55-.69-1.19-1.3-1.85-1.87l-3.93 2.62a3.966 3.966 0 01-3.96 3.77c-.47 0-.91-.1-1.33-.24l-2.24 1.49c.52.21 1.05.39 1.6.51 1.21.27 2.43.28 3.64.05 1.11-.21 2.17-.64 3.17-1.18 1.56-.84 2.99-2 4.23-3.3.23-.24.46-.49.67-.75a.87.87 0 00.21-.43v-.02-.02-.01-.03V10v-.04zm-.46-5.14c.27-.18.46-.47.46-.82 0-.55-.45-1-1-1-.21 0-.39.08-.54.18l-.01-.02L15 5.46c-.95-.53-1.95-.96-3.01-1.2a9.158 9.158 0 00-3.65-.04c-1.11.21-2.17.64-3.17 1.18-1.56.84-2.99 2-4.23 3.3-.23.24-.46.48-.67.75-.27.34-.27.76 0 1.1.64.79 1.39 1.5 2.16 2.15.26.21.52.41.79.61L.44 15.16l.01.02A1 1 0 000 16c0 .55.45 1 1 1 .21 0 .39-.08.54-.18l.01.02 18-12-.01-.02zm-8.67 3.4c-.25-.12-.53-.2-.83-.2-1.1 0-1.99.89-1.99 1.99 0 .03.02.06.02.09l-1.78 1.19c-.14-.4-.22-.83-.22-1.28 0-2.19 1.78-3.97 3.98-3.97 1.01 0 1.91.38 2.61 1l-1.79 1.18z"];
  init_define_process();
  var eye_on_default2 = ["M13.3 8.71c.18.18.43.29.71.29s.53-.11.71-.29l4.99-5a1.003 1.003 0 00-1.42-1.42L14 6.58l-2.29-2.29a.956.956 0 00-.7-.29 1.003 1.003 0 00-.71 1.71l3 3zM20 9.96v-.03-.01-.02-.02a.823.823 0 00-.21-.44c-.44-.55-.94-1.05-1.46-1.52l-2.2 2.2c-.55.54-1.3.88-2.12.88-.05 0-.09-.01-.14-.01a3.978 3.978 0 01-3.86 3.02 4.007 4.007 0 01-1.66-7.65A2.97 2.97 0 018.02 5c0-.28.05-.54.12-.8-1.05.22-2.07.64-3.02 1.15-1.57.85-3 2.02-4.24 3.33-.23.25-.46.5-.67.76-.28.35-.28.77 0 1.12.64.8 1.4 1.52 2.17 2.17 1.66 1.41 3.56 2.58 5.66 3.06 1.21.27 2.43.29 3.65.05 1.11-.21 2.18-.65 3.18-1.19 1.57-.85 3-2.02 4.24-3.33.23-.24.46-.49.67-.76.11-.12.18-.27.21-.44v-.02-.02-.01-.03V10c.01-.01.01-.03.01-.04zm-9.99 2.05c1.03 0 1.87-.79 1.98-1.8l-.09-.09-.01.01-2.1-2.11c-1 .11-1.77.95-1.77 1.98-.01 1.11.89 2.01 1.99 2.01z"];
  init_define_process();
  var eye_open_default2 = ["M10.01 7.984A2.008 2.008 0 008.012 9.99c0 1.103.9 2.006 1.998 2.006a2.008 2.008 0 001.998-2.006c0-1.103-.9-2.006-1.998-2.006zM20 9.96v-.03-.01-.02-.02a.827.827 0 00-.21-.442c-.64-.802-1.398-1.514-2.168-2.166-1.658-1.404-3.566-2.587-5.664-3.058a8.982 8.982 0 00-3.656-.05c-1.11.2-2.178.641-3.177 1.183-1.569.852-2.997 2.016-4.246 3.33-.23.25-.46.49-.67.761-.279.351-.279.773 0 1.124.64.802 1.4 1.514 2.169 2.166 1.658 1.404 3.566 2.577 5.664 3.058 1.209.271 2.438.281 3.656.05 1.11-.21 2.178-.651 3.177-1.193 1.569-.852 2.997-2.016 4.246-3.33.23-.24.46-.49.67-.751.11-.12.179-.271.209-.442v-.02-.02-.01-.03V10v-.04zM10.01 14A4.003 4.003 0 016.014 9.99a4.003 4.003 0 013.996-4.011 4.003 4.003 0 013.996 4.011 4.003 4.003 0 01-3.996 4.011z"];
  init_define_process();
  var fast_backward_default2 = ["M18 3c-.23 0-.42.09-.59.21l-.01-.01L11 8V4c0-.55-.45-1-1-1-.23 0-.42.09-.59.21L9.4 3.2l-8 6 .01.01C1.17 9.4 1 9.67 1 10s.17.6.41.79l-.01.01 8 6 .01-.01c.17.12.36.21.59.21.55 0 1-.45 1-1v-4l6.4 4.8.01-.01c.17.12.36.21.59.21.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var fast_forward_default2 = ["M19 10c0-.33-.17-.6-.41-.79l.01-.01-8-6-.01.01C10.42 3.09 10.23 3 10 3c-.55 0-1 .45-1 1v4L2.6 3.2l-.01.01C2.42 3.09 2.23 3 2 3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1 .23 0 .42-.09.59-.21l.01.01L9 12v4c0 .55.45 1 1 1 .23 0 .42-.09.59-.21l.01.01 8-6-.01-.01c.24-.19.41-.46.41-.79z"];
  init_define_process();
  var feed_default2 = ["M2.5 15a2.5 2.5 0 000 5 2.5 2.5 0 000-5zm.5-5c-.55 0-1 .45-1 1s.45 1 1 1c2.76 0 5 2.24 5 5 0 .55.45 1 1 1s1-.45 1-1c0-3.87-3.13-7-7-7zM3 0c-.55 0-1 .45-1 1s.45 1 1 1c8.28 0 15 6.72 15 15 0 .55.45 1 1 1s1-.45 1-1C20 7.61 12.39 0 3 0zm0 5c-.55 0-1 .45-1 1s.45 1 1 1c5.52 0 10 4.48 10 10 0 .55.45 1 1 1s1-.45 1-1C15 10.37 9.63 5 3 5z"];
  init_define_process();
  var feed_subscribed_default2 = ["M2.5 15a2.5 2.5 0 000 5 2.5 2.5 0 000-5zM3 2c1.76 0 3.44.31 5.01.87.03-.71.31-1.35.75-1.85C6.96.37 5.03 0 3 0c-.55 0-1 .45-1 1s.45 1 1 1zm10.32 4.67a.99.99 0 001.4 0l4.98-4.98c.19-.17.3-.42.3-.7 0-.55-.45-1-1-1a.99.99 0 00-.7.29l-4.27 4.27-2.28-2.28a.99.99 0 00-.7-.29c-.55 0-.99.45-.99 1 0 .28.11.52.29.7l2.97 2.99zM3 10c-.55 0-1 .45-1 1s.45 1 1 1c2.76 0 5 2.24 5 5 0 .55.45 1 1 1s1-.45 1-1c0-3.87-3.13-7-7-7zm13.94-2.69l-.82.82-.02-.02c-.2.2-.42.37-.67.51A14.8 14.8 0 0118 17c0 .55.45 1 1 1s1-.45 1-1c0-3.61-1.14-6.94-3.06-9.69zM3 5c-.55 0-1 .45-1 1s.45 1 1 1c5.52 0 10 4.48 10 10 0 .55.45 1 1 1s1-.45 1-1C15 10.37 9.63 5 3 5z"];
  init_define_process();
  var film_default2 = ["M19 2h-5v3H6V2H1c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h5v-3h8v3h5c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1zM4 17H2v-2h2v2zm0-3H2v-2h2v2zm0-3H2V9h2v2zm0-3H2V6h2v2zm0-3H2V3h2v2zm10 8H6V7h8v6zm4 4h-2v-2h2v2zm0-3h-2v-2h2v2zm0-3h-2V9h2v2zm0-3h-2V6h2v2zm0-3h-2V3h2v2z"];
  init_define_process();
  var filter_default2 = ["M18 1H2a1.003 1.003 0 00-.71 1.71L7 8.41V18a1.003 1.003 0 001.71.71l4-4c.18-.18.29-.43.29-.71V8.41l5.71-5.71c.18-.17.29-.42.29-.7 0-.55-.45-1-1-1z"];
  init_define_process();
  var filter_keep_default2 = ["M15 2c0-.55-.45-1-1-1H1a1.003 1.003 0 00-.71 1.71L5 7.41V16a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71V7.41l4.71-4.71c.18-.17.29-.42.29-.7zm4 11c-.28 0-.53.11-.71.29L15 16.59l-1.29-1.29A.965.965 0 0013 15a1.003 1.003 0 00-.71 1.71l2 2c.18.18.43.29.71.29s.53-.11.71-.29l4-4A1.003 1.003 0 0019 13z"];
  init_define_process();
  var filter_list_default2 = ["M15 2c0-.55-.45-1-1-1H1a1.003 1.003 0 00-.71 1.71L5 7.41V16a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71V7.41l4.71-4.71c.18-.17.29-.42.29-.7zm-4 8c0 .55.45 1 1 1h7c.55 0 1-.45 1-1s-.45-1-1-1h-7c-.55 0-1 .45-1 1zm8 7h-7c-.55 0-1 .45-1 1s.45 1 1 1h7c.55 0 1-.45 1-1s-.45-1-1-1zm0-4h-7c-.55 0-1 .45-1 1s.45 1 1 1h7c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var filter_open_default2 = ["M15 2c0 .28-.11.53-.29.7L10 7.41V13c0 .28-.11.53-.29.71l-3 3A1.003 1.003 0 015 16V7.41L.29 2.71A1.003 1.003 0 011 1h13c.55 0 1 .45 1 1zm4.707 11.293a1 1 0 010 1.414l-4 4c-.63.63-1.707.184-1.707-.707v-8c0-.89 1.077-1.337 1.707-.707l4 4z"];
  init_define_process();
  var filter_remove_default2 = ["M15 2c0-.55-.45-1-1-1H1a1.003 1.003 0 00-.71 1.71L5 7.41V16a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71V7.41l4.71-4.71c.18-.17.29-.42.29-.7zm2.91 13.5l1.79-1.79c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-1.79 1.79-1.79-1.79a1.003 1.003 0 00-1.42 1.42l1.79 1.79-1.79 1.79a1.003 1.003 0 001.42 1.42l1.79-1.79 1.79 1.79a1.003 1.003 0 001.42-1.42l-1.8-1.79z"];
  init_define_process();
  var flag_default2 = ["M3 3c-.55 0-1 .45-1 1v15c0 .55.45 1 1 1s1-.45 1-1V4c0-.55-.45-1-1-1zm0-3c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm2 4.08v8.28c3.01-2.41 8.67 2.64 13 0V4.08C13.61 7.14 8.01 1 5 4.08z"];
  init_define_process();
  var flame_default2 = ["M11.622 0c0 1.71.49 3.077 1.472 4.103C16.364 6.496 18 9.23 18 12.308c0 3.418-1.962 5.983-5.887 7.692 2.887-3 2.453-4.23-.49-8C8.5 13.5 9 14.5 9.5 16.5c-1.048 0-2 0-2.5-.5 0 .684 1.197 2.5 1.952 4-3.924-1.026-8.123-7.18-6.651-7.692.981-.342 2.126-.171 3.434.513C4.1 6.667 6.062 2.393 11.622 0z"];
  init_define_process();
  var flash_default2 = ["M4.96 6.37a1.003 1.003 0 001.42-1.42l-2-2a1.07 1.07 0 00-.71-.28 1.003 1.003 0 00-.71 1.71l2 1.99zm9.37.3c.28 0 .53-.11.71-.29l2-2a1.003 1.003 0 00-1.42-1.42l-2 2a1.003 1.003 0 00.71 1.71zM10 5c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1S9 .45 9 1v3c0 .55.45 1 1 1zm-5 5c0-.55-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1h3c.55 0 1-.45 1-1zm14-1h-3c-.55 0-1 .45-1 1s.45 1 1 1h3c.55 0 1-.45 1-1s-.45-1-1-1zm-9-3c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm5.04 1.63a1.003 1.003 0 00-1.42 1.42l2 2a1.003 1.003 0 001.42-1.42l-2-2zM10 15c-.55 0-1 .45-1 1v3c0 .55.45 1 1 1s1-.45 1-1v-3c0-.55-.45-1-1-1zm-4.33-1.67c-.28 0-.53.11-.71.29l-2 2a1.003 1.003 0 001.42 1.42l2-2a1.003 1.003 0 00-.71-1.71z"];
  init_define_process();
  var floating_point_default2 = ["M1 6.648c.343 0 .676-.028 1-.085.324-.057.614-.152.871-.284.267-.133.49-.303.672-.512.19-.208.314-.464.371-.767h1.329v9.947H3.457v-7.02H1V6.648zm13.965-1.635c.688 0 1.247.16 1.677.478.44.31.78.711 1.018 1.204.247.483.413 1.016.495 1.6.092.583.137 1.149.137 1.696 0 .547-.045 1.112-.137 1.696a5.182 5.182 0 01-.495 1.614 3.234 3.234 0 01-1.018 1.203c-.43.31-.99.465-1.677.465-.688 0-1.251-.155-1.691-.465-.431-.319-.77-.72-1.018-1.203a5.714 5.714 0 01-.495-1.614 12.116 12.116 0 01-.123-1.696c0-.547.04-1.113.123-1.696a5.534 5.534 0 01.495-1.6 3.26 3.26 0 011.018-1.204c.44-.319 1.004-.478 1.691-.478zm0 8.657c.34 0 .623-.096.853-.287.229-.2.407-.465.536-.794a4.61 4.61 0 00.288-1.176c.056-.447.083-.92.083-1.422 0-.502-.027-.971-.083-1.409a4.61 4.61 0 00-.288-1.176c-.129-.337-.307-.602-.536-.793-.23-.2-.514-.301-.853-.301-.348 0-.637.1-.866.3-.22.192-.399.457-.537.794-.128.337-.22.73-.274 1.176-.056.438-.083.907-.083 1.409 0 .501.027.975.082 1.422.055.447.147.84.275 1.176.138.329.317.593.537.794.229.191.518.287.866.287zm-5.104-.588H7.875V15h1.986v-1.918z"];
  init_define_process();
  var floppy_disk_default2 = ["M14 1h-3v5h3V1zm5.71 2.29l-3-3A.997.997 0 0016 0h-1v7H5V0H1C.45 0 0 .45 0 1v18c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V4c0-.28-.11-.53-.29-.71zM17 19H3v-8c0-.55.45-1 1-1h12c.55 0 1 .45 1 1v8z"];
  init_define_process();
  var flow_branch_default2 = ["M14.425 7.953a3.98 3.98 0 01.562 2.045 3.98 3.98 0 01-.583 2.08L18 15.671V12.98c0-.248.097-.496.29-.689.379-.379 1.047-.38 1.426 0a.94.94 0 01.283.696l-.001 5.049a.957.957 0 01-.276.69.955.955 0 01-.69.273h-5.059a.971.971 0 01-.689-.289 1.026 1.026 0 010-1.417.972.972 0 01.69-.29h2.702l-3.634-3.573a3.998 3.998 0 01-5.924-2.431H1a1 1 0 010-2h6.12a3.998 3.998 0 015.96-2.409L16.665 3l-2.694-.001a.972.972 0 01-.689-.29 1.035 1.035 0 010-1.425.94.94 0 01.696-.283l5.05.001c.248 0 .497.083.69.276a.954.954 0 01.272.69l.001 5.052a.971.971 0 01-.29.689 1.028 1.028 0 01-1.419 0 .972.972 0 01-.29-.69V4.323l-3.567 3.63z"];
  init_define_process();
  var flow_end_default2 = ["M12 9.919a3.998 3.998 0 014-3.92c2.21 0 4 1.79 4 3.997a3.998 3.998 0 01-4 3.996 3.998 3.998 0 01-4-3.916.967.967 0 01-.28.612L7.685 14.71a.958.958 0 01-.686.285c-.536 0-.994-.461-.994-.997 0-.273.107-.528.283-.704l2.379-2.302H.98c-.537 0-.976-.46-.976-.996s.44-.992.976-.992h7.676L6.287 6.687a.957.957 0 01-.283-.686c0-.536.458-.996.994-.996.274 0 .51.1.686.285l4.027 4.024c.159.158.27.365.29.605z"];
  init_define_process();
  var flow_linear_default2 = ["M5.125 10.997H.976C.439 10.997 0 10.537 0 10c0-.536.44-.993.976-.993h4.148a4.002 4.002 0 017.752 0h3.776L14.293 6.69a.962.962 0 01-.285-.687c0-.537.46-1.001.996-1.001a.96.96 0 01.698.3l4.005 4.015c.176.176.293.41.293.683a.972.972 0 01-.283.693L15.702 14.7a.997.997 0 01-.698.297c-.537 0-.996-.453-.996-.99 0-.273.107-.517.283-.692l2.371-2.318h-3.787a4.002 4.002 0 01-7.75 0z"];
  init_define_process();
  var flow_review_default2 = ["M6.13 9.004A4.005 4.005 0 0110.012 6c1.87 0 3.44 1.278 3.881 3.005h2.768l-2.354-2.317a.97.97 0 01-.283-.691c0-.536.462-.995 1-.995.273 0 .517.107.693.283l4 4.041a.97.97 0 01.284.692.956.956 0 01-.293.682l-3.991 3.997a.944.944 0 01-.694.292c-.537 0-1-.46-1-.997a.97.97 0 01.284-.692l2.345-2.29h-2.765a4.005 4.005 0 01-3.875 2.981 4.005 4.005 0 01-3.874-2.981H3.349l2.376 2.308a.97.97 0 01.283.691 1 1 0 01-.994.983.989.989 0 01-.713-.291L.293 10.699A.956.956 0 010 10.017a.97.97 0 01.283-.692l4.03-4.037a.996.996 0 01.701-.283c.537 0 .994.464.994 1a.97.97 0 01-.283.691L3.34 9.004h2.79z"];
  init_define_process();
  var flow_review_branch_default2 = ["M13.04 13.424c-.6.36-1.302.568-2.052.568a4 4 0 01-3.868-2.999H3.342l2.372 2.31c.176.176.283.42.283.694 0 .537-.452.998-.988.998a.935.935 0 01-.691-.289L.292 10.683A.96.96 0 010 9.999c0-.274.107-.518.283-.694l4.035-4.04a.973.973 0 01.691-.288c.536 0 .988.47.988 1.007a.975.975 0 01-.283.694L3.332 8.984h3.786a4 4 0 013.87-3.006c.771 0 1.492.22 2.102.599l3.565-3.57-2.538-.003a.974.974 0 01-.69-.29c-.38-.38-.38-1.052-.002-1.431A.94.94 0 0114.122 1l4.896.005a.96.96 0 01.69.277c.193.193.27.442.27.69l.005 4.9a.971.971 0 01-.289.69 1.023 1.023 0 01-1.416 0 .975.975 0 01-.29-.691l-.003-2.54-3.554 3.62c.351.596.553 1.291.553 2.034 0 .763-.213 1.477-.583 2.084l3.595 3.595.003-2.54c0-.249.097-.497.29-.69.38-.38 1.05-.381 1.429-.002a.94.94 0 01.282.697l-.005 4.9a.927.927 0 01-.277.675.974.974 0 01-.69.291L13.974 19a.97.97 0 01-.69-.29 1.03 1.03 0 01.002-1.42.974.974 0 01.69-.29l2.696-.003-3.632-3.573z"];
  init_define_process();
  var flows_default2 = ["M17.5 7.93a2.5 2.5 0 00-2.45 2h-2.3l-4.01-4-.75.75 3.26 3.25h-6.3a2.5 2.5 0 100 1h6.3l-3.26 3.25.75.75 4.01-4h2.3a2.5 2.5 0 102.45-3z"];
  init_define_process();
  var folder_close_default2 = ["M0 17c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V7H0v10zM19 4H9.41l-1.7-1.71A.997.997 0 007 2H1c-.55 0-1 .45-1 1v3h20V5c0-.55-.45-1-1-1z"];
  init_define_process();
  var folder_new_default2 = ["M12.994 7c0 1.655 1.344 3 2.998 3a3.002 3.002 0 002.999-3H20v10c0 .55-.45 1-1 1H1.01c-.55 0-1-.45-1-1V7h12.984zM10.76 6H0V3c0-.55.45-1 1-1h3.998c.28 0 .53.11.71.29L7.415 4h2.579c0 .768.29 1.469.765 2zm8.23-3c.55 0 1 .45 1 1s-.45 1-1 1h-1.998v2c0 .55-.45 1-1 1s-1-.45-1-1V5h-1.998c-.55 0-1-.45-1-1s.45-1 1-1h1.999V1c0-.55.45-1 .999-1 .55 0 1 .45 1 1v2h1.999z"];
  init_define_process();
  var folder_open_default2 = ["M20 9c0-.55-.45-1-1-1H5c-.43 0-.79.27-.93.65h-.01l-3 8h.01c-.04.11-.07.23-.07.35 0 .55.45 1 1 1h14c.43 0 .79-.27.93-.65h.01l3-8h-.01c.04-.11.07-.23.07-.35zM3.07 7.63C3.22 7.26 3.58 7 4 7h14V5c0-.55-.45-1-1-1H8.41l-1.7-1.71A.997.997 0 006 2H1c-.55 0-1 .45-1 1v12.31l3.07-7.68z"];
  init_define_process();
  var folder_shared_default2 = ["M11 4H9.41l-1.7-1.71A.997.997 0 007 2H1c-.55 0-1 .45-1 1v3h11.78C11.3 5.47 11 4.77 11 4zm8-1h-5c-.55 0-1 .45-1 1s.45 1 1 1h2.59L12.3 9.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L18 6.41V9c0 .55.45 1 1 1s1-.45 1-1V4c0-.55-.45-1-1-1zm-2.46 7.7l-1.42 1.42a2.996 2.996 0 11-4.24-4.24l.88-.88H0v10c0 .55.45 1 1 1h18c.55 0 1-.45 1-1v-5.18c-.31.11-.65.18-1 .18-1.02 0-1.92-.52-2.46-1.3z"];
  init_define_process();
  var folder_shared_open_default2 = ["M3.07 7.63C3.22 7.26 3.58 7 4 7h7.76l.54-.54A2.97 2.97 0 0111 4H8.41l-1.7-1.71A.997.997 0 006 2H1c-.55 0-1 .45-1 1v12.31l3.07-7.68zm13.47 3.07l-1.42 1.42A2.996 2.996 0 0110 10c0-.77.3-1.47.78-2H5c-.43 0-.79.27-.93.65h-.01l-3 8h.01c-.04.11-.07.23-.07.35 0 .55.45 1 1 1h14c.43 0 .79-.27.93-.65h.01l2.01-5.36c-1-.01-1.88-.52-2.41-1.29zM19 3h-5c-.55 0-1 .45-1 1s.45 1 1 1h2.59L12.3 9.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L18 6.41V9c0 .55.45 1 1 1s1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var follower_default2 = ["M11.54 15.92c-1.48-.65-1.28-1.05-1.33-1.59-.01-.07-.01-.15-.01-.23.51-.45.92-1.07 1.19-1.78 0 0 .01-.04.02-.05.06-.15.11-.32.15-.48.34-.07.54-.44.61-.78.08-.14.23-.48.2-.87-.05-.5-.25-.73-.47-.82v-.09c0-.63-.06-1.55-.17-2.15-.02-.17-.06-.33-.11-.5a3.69 3.69 0 00-1.29-1.86C9.69 4.25 8.8 4 8.01 4c-.8 0-1.69.25-2.32.73-.61.47-1.06 1.13-1.28 1.86-.05.17-.09.33-.11.5-.12.6-.18 1.51-.18 2.14v.08c-.23.09-.44.32-.49.83-.04.39.12.73.2.87.08.35.28.72.63.78.04.17.09.33.15.48 0 .01.01.02.01.03l.01.01c.27.72.7 1.35 1.22 1.8 0 .07-.01.14-.01.21-.05.54.1.94-1.38 1.59-1.48.65-3.71 1.35-4.16 2.4C-.16 19.38.02 20 .02 20h15.95s.18-.62-.27-1.67c-.46-1.06-2.68-1.75-4.16-2.41zm8.15-12.63l-3-3a.956.956 0 00-.7-.29 1.003 1.003 0 00-.71 1.71L16.58 3H13c-.55 0-1 .45-1 1s.45 1 1 1h3.58l-1.29 1.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71 0-.28-.11-.53-.3-.71z"];
  init_define_process();
  var following_default2 = ["M11.55 15.92c-1.48-.65-1.28-1.05-1.33-1.59-.01-.07-.01-.15-.01-.23.51-.45.92-1.07 1.19-1.78 0 0 .01-.04.02-.05.06-.15.11-.32.15-.48.34-.07.54-.44.61-.78.08-.14.23-.48.2-.87-.05-.5-.25-.73-.47-.82v-.09c0-.63-.06-1.55-.17-2.15-.02-.17-.06-.33-.11-.5a3.69 3.69 0 00-1.29-1.86C9.7 4.25 8.81 4 8.02 4c-.79 0-1.68.25-2.31.73-.61.47-1.07 1.13-1.29 1.86-.05.16-.09.33-.11.5-.12.6-.18 1.51-.18 2.14v.08c-.23.09-.44.32-.48.83-.04.39.12.73.2.87.08.35.28.72.63.78.04.17.09.33.15.48 0 .01.01.02.01.03l.01.01c.27.72.7 1.35 1.22 1.8 0 .07-.01.14-.01.21-.05.54.1.94-1.38 1.59C3 16.56.77 17.26.32 18.31-.15 19.38.04 20 .04 20h15.95s.18-.62-.27-1.67c-.46-1.06-2.69-1.75-4.17-2.41zM19 3h-3.58l1.29-1.29A1.003 1.003 0 0015.29.29l-3 3c-.17.18-.28.43-.28.71 0 .28.11.53.29.71l3 3c.18.18.43.29.7.29a1.003 1.003 0 00.71-1.71L15.42 5H19c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var font_default2 = ["M17.93 18.64l-7-18C10.78.27 10.42 0 10 0s-.78.27-.93.64l-7 18c-.04.11-.07.23-.07.36 0 .55.45 1 1 1 .42 0 .78-.27.93-.64L6.41 13h7.19l2.47 6.36c.15.37.51.64.93.64.55 0 1-.45 1-1 0-.13-.03-.25-.07-.36zM7.18 11L10 3.76 12.82 11H7.18z"];
  init_define_process();
  var fork_default2 = ["M16.71 11.29a1.003 1.003 0 00-1.42 1.42l1.3 1.29h-2.17l-8-8h10.17L15.3 7.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71l-3-3a1.003 1.003 0 00-1.42 1.42L16.59 4H1c-.55 0-1 .45-1 1s.45 1 1 1h2.59l9.71 9.71c.17.18.42.29.7.29h2.59l-1.29 1.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71l-3-3z"];
  init_define_process();
  var form_default2 = ["M2 13v4h4v-4H2zm-1-2h6c.55 0 1 .45 1 1v6c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1v-6c0-.55.45-1 1-1zm11-7h7c.55 0 1 .45 1 1s-.45 1-1 1h-7c-.55 0-1-.45-1-1s.45-1 1-1zM8 1a1.003 1.003 0 01.71 1.71l-5 6C3.53 8.89 3.28 9 3 9s-.53-.11-.71-.29l-2-2a1.003 1.003 0 011.42-1.42L3 6.59l4.29-5.3C7.47 1.11 7.72 1 8 1zm4 13h7c.55 0 1 .45 1 1s-.45 1-1 1h-7c-.55 0-1-.45-1-1s.45-1 1-1z"];
  init_define_process();
  var fuel_default2 = ["M2.196 2H0v2h2c.317 0 .619.139.825.38l3.493 4.075-1.873 1.248a1 1 0 00-.445.832V18c0 .5.5 1 1 1h14c.5 0 1-.5 1-1V7.1c0-.034-.001-.067-.004-.1H20V3s0-1-1-1h-8c-.5 0-1 .5-1 1v3L8.12 7.254 4.463 3.035A3 3 0 002.196 2zM18 4v2h-6V4h6z"];
  init_define_process();
  var full_circle_default2 = ["M9.96 0a10 10 0 100 20 10 10 0 100-20z"];
  init_define_process();
  var full_stacked_chart_default2 = ["M15 16h2c.55 0 1-.45 1-1v-5h-4v5c0 .55.45 1 1 1zM12 2c0-.55-.45-1-1-1H9c-.55 0-1 .45-1 1v4h4V2zm6 4h-4v3h4V6zm0-4c0-.55-.45-1-1-1h-2c-.55 0-1 .45-1 1v3h4V2zm-6 5H8v5h4V7zm-9 9h2c.55 0 1-.45 1-1v-3H2v3c0 .55.45 1 1 1zm6 0h2c.55 0 1-.45 1-1v-2H8v2c0 .55.45 1 1 1zm10 1H1c-.55 0-1 .45-1 1s.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1zM6 2c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v3h4V2zm0 4H2v5h4V6z"];
  init_define_process();
  var fullscreen_default2 = ["M3.41 2H6c.55 0 1-.45 1-1s-.45-1-1-1H1C.45 0 0 .45 0 1v5c0 .55.45 1 1 1s1-.45 1-1V3.41L7.29 8.7c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L3.41 2zM8 11c-.28 0-.53.11-.71.29L2 16.59V14c0-.55-.45-1-1-1s-1 .45-1 1v5c0 .55.45 1 1 1h5c.55 0 1-.45 1-1s-.45-1-1-1H3.41l5.29-5.29c.19-.18.3-.43.3-.71 0-.55-.45-1-1-1zM19 0h-5c-.55 0-1 .45-1 1s.45 1 1 1h2.59L11.3 7.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L18 3.41V6c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1zm0 13c-.55 0-1 .45-1 1v2.59l-5.29-5.29A.965.965 0 0012 11a1.003 1.003 0 00-.71 1.71l5.3 5.29H14c-.55 0-1 .45-1 1s.45 1 1 1h5c.55 0 1-.45 1-1v-5c0-.55-.45-1-1-1z"];
  init_define_process();
  var function_default2 = ["M10.14 5.82H8.73c.4-1.66.94-2.87 1.6-3.64.4-.48.8-.72 1.18-.72.08 0 .14.02.19.07.05.05.07.1.07.18 0 .07-.05.19-.16.37s-.16.36-.16.52c0 .23.08.43.25.59a.9.9 0 00.64.25c.28 0 .51-.1.7-.3.19-.2.28-.47.28-.81 0-.39-.14-.7-.42-.94-.28-.24-.74-.36-1.36-.36-.97 0-1.86.29-2.65.87-.79.56-1.54 1.52-2.26 2.85-.24.46-.48.75-.7.88-.22.13-.57.19-1.06.19l-.32 1.15H5.9l-1.99 7.85c-.33 1.29-.56 2.09-.67 2.39-.17.44-.43.81-.77 1.12a.74.74 0 01-.5.19c-.05 0-.1-.02-.14-.05l-.04-.07c0-.03.05-.1.15-.2.1-.1.15-.26.15-.47 0-.23-.08-.42-.23-.57-.16-.15-.38-.23-.67-.23-.35 0-.63.1-.85.29-.21.2-.32.43-.32.7 0 .29.13.54.39.75.25.22.65.33 1.2.33.88 0 1.66-.23 2.33-.69.68-.46 1.27-1.17 1.78-2.14.51-.96 1.03-2.52 1.56-4.66l1.14-4.54H9.8l.34-1.15zm6.8 1.95c.25-.2.51-.29.78-.29.1 0 .29.04.56.11.27.08.51.11.72.11.29 0 .52-.1.72-.3.18-.19.28-.45.28-.77 0-.33-.1-.6-.29-.8-.19-.2-.47-.29-.82-.29-.32 0-.62.08-.9.23-.28.15-.64.49-1.08 1-.33.38-.81 1.05-1.44 2a9.712 9.712 0 00-1.31-3.22l-3.4.59-.07.37c.25-.05.47-.08.64-.08.34 0 .62.15.84.44.35.46.84 1.85 1.46 4.19-.49.66-.82 1.09-1 1.3-.3.33-.55.54-.74.64-.15.08-.32.12-.51.12-.14 0-.38-.08-.7-.24-.22-.1-.42-.16-.59-.16-.33 0-.6.11-.82.32-.21.22-.32.49-.32.83 0 .31.1.57.3.77.2.2.47.29.8.29.32 0 .63-.07.92-.21.29-.14.64-.43 1.08-.88.43-.45 1.03-1.16 1.79-2.14.29.93.55 1.61.76 2.03.21.42.46.73.74.91.28.19.62.28 1.04.28.4 0 .81-.15 1.23-.44.55-.38 1.1-1.04 1.68-1.97l-.35-.21c-.39.55-.68.89-.87 1.03-.12.09-.27.13-.44.13-.2 0-.4-.13-.59-.38-.33-.43-.77-1.63-1.33-3.6.47-.86.89-1.44 1.23-1.71z"];
  init_define_process();
  var gantt_chart_default2 = ["M4 7h5c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1zm3 2v1c0 .55.45 1 1 1h6c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1H8c-.55 0-1 .45-1 1zm12 3h-6c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-1c0-.55-.45-1-1-1zm0 4H2V3c0-.55-.45-1-1-1s-1 .45-1 1v14c0 .55.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var geofence_default2 = ["M8 11l.075.003.126.017.111.03.111.044.098.052.096.067.09.08c.036.035.068.073.097.112l.071.11.054.114.035.105.03.148L9 12V18a1 1 0 01-1.993.117L7 18v-3.586l-5.293 5.293a1 1 0 01-1.497-1.32l.083-.094L5.584 13h-3.58a1 1 0 01-.117-1.993L2.004 11H8zm3.018-11a1.003 1.003 0 01.39.087l.12.063.031.02.1.078 8.027 7.026.062.064.068.086.044.068.064.128.04.117.024.113.011.108v.1l-.007.073-.019.103-.037.121-.039.09-.05.087-4.996 7.994c-.06.097-.137.183-.226.254l-.093.067-.095.053-.087.037-.125.037a1.018 1.018 0 01-.218.026H11v-5a3 3 0 00-2.824-2.995L8 9H3V6a1 1 0 01.321-.734l.098-.08 7-5a1.01 1.01 0 01.45-.178L11.018 0z"];
  init_define_process();
  var geolocation_default2 = ["M0 8.33l9.17 2.5 2.5 9.17L20 0z"];
  init_define_process();
  var geosearch_default2 = ["M8 18.88c-3.79 0-6.88-3.09-6.88-6.88 0-.61.08-1.22.23-1.79.03.01.06-.01.1-.01h.09v.55c0 .23.21.42.44.42.04 0 .09-.01.12-.02l.9.88c.09.09.23.09.32 0s.09-.23 0-.32l-.86-.9c0-.02.05-.04.05-.07v-.13c0-.18.1-.25.29-.41h.53c.1 0 .19-.01.27-.05.01-.01.02 0 .03-.01.02-.01.03-.02.05-.04.01-.01.02-.01.02-.02l.02-.02 1.13-1.13c-.16-.32-.3-.65-.42-.99h-.64v-.53c0-.01.06.06.06-.1h.38c-.04-.16-.08-.32-.1-.48h-.71c.2-.16.42-.31.64-.45C4.02 6.09 4 5.8 4 5.5c0-.14.01-.28.02-.43C1.62 6.46 0 9.04 0 12c0 4.41 3.59 8 8 8 3.87 0 7.09-2.77 7.82-6.44l-.97-1.1c-.26 3.57-3.23 6.42-6.85 6.42zm-2.12-3.67v-.35h.15c.29 0 .49-.23.49-.53v-.68c0-.01.01-.01 0-.02L4.71 11.8h-.77c-.29 0-.47.24-.47.53v2c0 .29.18.53.47.53h.33v2.02c0 .28.28.51.56.51s.56-.23.56-.51v-1.22h-.01c.29 0 .5-.16.5-.45zm13.83-2.92l-3.68-3.68c.14-.21.27-.42.38-.65.02-.04.04-.07.05-.11.11-.22.2-.45.28-.69v-.01c.07-.24.13-.48.17-.73l.03-.17c.04-.24.06-.49.06-.75C17 2.46 14.54 0 11.5 0S6 2.46 6 5.5 8.46 11 11.5 11c.26 0 .51-.02.76-.06l.17-.03c.25-.04.49-.1.73-.17h.01c.24-.08.47-.17.69-.28.04-.02.07-.04.11-.05.23-.11.44-.24.65-.38l3.68 3.68c.17.18.42.29.7.29a1.003 1.003 0 00.71-1.71zM11.5 9.5c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4zm1.93 5.33v-.65c0-.11-.13-.21-.24-.21-.11 0-.24.09-.24.21v.65c0 .11.13.21.24.21.11 0 .24-.1.24-.21zm-2.41.67h.83c.29 0 .46-.21.46-.5v-1.86l.23-.22c-.34.05-.69.08-1.04.08-.36 0-.7-.03-1.05-.08.03.05.06.1.08.16V15c.01.29.2.5.49.5z"];
  init_define_process();
  var git_branch_default2 = ["M15 2c-1.66 0-3 1.34-3 3 0 1.3.84 2.4 2 2.82V9c0 1.1-.9 2-2 2H8c-.73 0-1.41.21-2 .55V5.82C7.16 5.4 8 4.3 8 3c0-1.66-1.34-3-3-3S2 1.34 2 3c0 1.3.84 2.4 2 2.82v8.37C2.84 14.6 2 15.7 2 17c0 1.66 1.34 3 3 3s3-1.34 3-3c0-1.25-.77-2.3-1.85-2.75C6.45 13.52 7.16 13 8 13h4c2.21 0 4-1.79 4-4V7.82C17.16 7.4 18 6.3 18 5c0-1.66-1.34-3-3-3zM5 2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm0 16c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zM15 6c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"];
  init_define_process();
  var git_commit_default2 = ["M19 9h-4.1a5 5 0 00-9.8 0H1c-.55 0-1 .45-1 1s.45 1 1 1h4.1a5 5 0 009.8 0H19c.55 0 1-.45 1-1s-.45-1-1-1zm-9 4c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"];
  init_define_process();
  var git_merge_default2 = ["M15 8c-1.3 0-2.4.84-2.82 2H11c-2.49 0-4.54-1.83-4.92-4.21A2.995 2.995 0 005 0C3.34 0 2 1.34 2 3c0 1.3.84 2.4 2 2.81v8.37C2.84 14.6 2 15.7 2 17c0 1.66 1.34 3 3 3s3-1.34 3-3c0-1.3-.84-2.4-2-2.82V9.86C7.27 11.17 9.03 12 11 12h1.18A2.996 2.996 0 0018 11c0-1.66-1.34-3-3-3zM5 18c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zM5 4c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm10 8c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"];
  init_define_process();
  var git_new_branch_default2 = ["M17 3h-1V2c0-.55-.45-1-1-1s-1 .45-1 1v1h-1c-.55 0-1 .45-1 1s.45 1 1 1h1v1c0 .55.45 1 1 1s1-.45 1-1V5h1c.55 0 1-.45 1-1s-.45-1-1-1zm-3 4.86V9c0 1.1-.9 2-2 2H8c-.73 0-1.41.21-2 .55V5.82C7.16 5.4 8 4.3 8 3c0-1.66-1.34-3-3-3S2 1.34 2 3c0 1.3.84 2.4 2 2.82v8.37C2.84 14.6 2 15.7 2 17c0 1.66 1.34 3 3 3s3-1.34 3-3c0-1.25-.77-2.3-1.85-2.75C6.45 13.52 7.16 13 8 13h4c2.21 0 4-1.79 4-4V7.86c-.32.08-.65.14-1 .14s-.68-.06-1-.14zM5 2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm0 16c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"];
  init_define_process();
  var git_pull_default2 = ["M17 14.18V7c0-2.21-1.79-4-4-4h-2.59l1.29-1.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-3 3C7.11 3.47 7 3.72 7 4c0 .28.11.53.29.71l3 3a1.003 1.003 0 001.42-1.42L10.41 5H13c1.1 0 2 .9 2 2v7.18A2.996 2.996 0 0016 20c1.66 0 3-1.34 3-3 0-1.3-.84-2.4-2-2.82zM16 18c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zM4 1C2.34 1 1 2.34 1 4c0 1.3.84 2.4 2 2.82v7.37C1.84 14.6 1 15.7 1 17c0 1.66 1.34 3 3 3s3-1.34 3-3c0-1.3-.84-2.4-2-2.82V6.82C6.16 6.4 7 5.3 7 4c0-1.66-1.34-3-3-3zm0 17c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zM4 5c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"];
  init_define_process();
  var git_push_default2 = ["M15 11c0-.28-.11-.53-.29-.71l-3-3C11.53 7.11 11.28 7 11 7s-.53.11-.71.29l-3 3a1.003 1.003 0 001.42 1.42l1.29-1.3V19c0 .55.45 1 1 1s1-.45 1-1v-8.59l1.29 1.29c.18.19.43.3.71.3.55 0 1-.45 1-1zm4-11H1C.45 0 0 .45 0 1v16c0 .55.45 1 1 1h7v-2H2v-2h6v-1H4V2h14v11h-4v1h4v2h-4v2h5c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zM5 8h2V6H5v2zm2-5H5v2h2V3z"];
  init_define_process();
  var git_repo_default2 = ["M7 3H5v2h2V3zm0 6H5v2h2V9zm0-3H5v2h2V6zm12-6H1C.45 0 0 .45 0 1v16c0 .55.45 1 1 1h4v2l2-1 2 1v-2h10c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 16H9v-1H5v1H2v-2h16v2zm0-3H4V2h14v11z"];
  init_define_process();
  var glass_default2 = ["M17 6V0H3v6c0 3.53 2.61 6.43 6 6.92V18H6c-.55 0-1 .45-1 1s.45 1 1 1h8c.55 0 1-.45 1-1s-.45-1-1-1h-3v-5.08c3.39-.49 6-3.39 6-6.92z"];
  init_define_process();
  var globe_default2 = ["M7.53 4.37c.1-.1.1-.26 0-.35l-.68-.68c-.1-.1-.25-.1-.35 0-.1.1-.1.26 0 .35l.68.68c.1.1.25.1.35 0zm3.17.06h.3c.09 0 .16-.01.16-.1 0-.09-.07-.1-.16-.1h-.3c-.09 0-.16.01-.16.1s.07.1.16.1zm.98 1.15c.09 0 .19-.08.19-.17v-.42c0-.09-.1-.17-.19-.17s-.19.08-.19.17v.42c0 .09.1.17.19.17zm-6.5 4.19c-.35 0-.56.28-.56.63v2.37c0 .35.21.62.56.62h.39v2.4c0 .34.33.61.67.61s.67-.27.67-.61v-1.44h-.02c.35 0 .6-.19.6-.54v-.41h.18c.35 0 .58-.28.58-.62v-.81c0-.01.01-.01 0-.02L6.1 9.77h-.92zM10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm0 18c-4.42 0-8-3.58-8-8 0-.74.11-1.46.3-2.14h.03v.65c0 .28.25.5.53.5.05 0 .1-.01.15-.02l1.05 1.05c.1.11.28.11.38 0 .1-.1.11-.27 0-.38L3.42 8.59c0-.03.05-.05.05-.08v-.16c0-.22.12-.3.34-.49h.63c.12 0 .23-.01.32-.07.01-.01.02 0 .03-.01.02-.02.04-.03.06-.04.01-.01.02-.01.03-.02l.02-.02 2.15-2.15c.24-.24.24-.63 0-.86-.23-.24-.62-.19-.86.04l-.41.46H5v-.64c0-.01.07.07.07-.12h.87c.17 0 .3-.12.3-.29 0-.17-.13-.29-.3-.29H4.88C6.27 2.7 8.05 2 10 2s3.73.7 5.12 1.86h-1.58l-.01-.04c-.06 0-.12 0-.17.04l-.71.7c-.09.09-.09.23 0 .31.09.09.23.09.32 0l.56-.6.01-.03h.34c0 .19-.1.13-.1.16v.1c0 .29-.2.5-.49.5h-.51c-.25 0-.52.28-.52.54v.23h-.12c-.16 0-.27.08-.27.24v.33h-.32c-.23 0-.41.15-.41.38 0 .22.18.35.41.35.1 0 .19.04.26-.16l.06.01.66-.59h.23l.53.5c.04.04.11.03.16-.01.04-.04.04-.16 0-.2L13 6.15h.32l.12.16c.25.25.65.23.89-.02l.12-.14H15c.02 0 .11.07.11.07v.33s-.06-.01-.07-.01h-.49c-.16 0-.28.13-.28.29 0 .16.13.29.28.29h.49c.01 0 .07-.01.07-.01v.2c-.19.28-.33.57-.62.57h-1.28s0-.01-.01-.01l-.58-.58a.622.622 0 00-.89 0l-.58.58s0 .01-.01.01h-.34c-.35 0-.67.28-.67.63v1.25c0 .35.32.61.67.61h1.22c.46.19.78.48.97.94v2.28c0 .35.23.6.58.6h.98c.35 0 .54-.25.54-.6v-2.2l1.21-1.17.04-.02.02-.01h.04c.1-.11.2-.26.2-.42V8.49c0-.25-.22-.44-.42-.63h.58c.02.38.29.57.63.57h.43c.13.51.18 1.03.18 1.57 0 4.42-3.58 8-8 8zm6.16-5.65c-.14 0-.29.11-.29.25v.77c0 .14.15.25.29.25.14 0 .29-.11.29-.25v-.77c0-.14-.15-.25-.29-.25zM10.5 3.48c0-.34-.28-.57-.62-.57h-.74c-.34 0-.57.25-.57.59 0 .05-.13.06.06.1v.64c0 .2.09.36.29.36.2 0 .29-.16.29-.36v-.19h.68c.33 0 .61-.23.61-.57z"];
  init_define_process();
  var globe_network_default2 = ["M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm7.39 7h-3.63c-.31-1.99-.92-3.66-1.72-4.73 2.45.65 4.41 2.42 5.35 4.73zM13 10c0 .69-.04 1.36-.11 2H7.11a18.419 18.419 0 010-4h5.77c.08.64.12 1.31.12 2zm-3-8c1.07 0 2.25 2.05 2.75 5h-5.5c.5-2.95 1.68-5 2.75-5zm-2.04.27C7.16 3.34 6.55 5.01 6.24 7H2.61c.94-2.31 2.9-4.08 5.35-4.73zM2 10c0-.69.11-1.36.28-2h3.83a18.419 18.419 0 000 4H2.28c-.17-.64-.28-1.31-.28-2zm.61 3h3.63c.31 1.99.92 3.66 1.72 4.73A7.996 7.996 0 012.61 13zM10 18c-1.07 0-2.25-2.05-2.75-5h5.5c-.5 2.95-1.68 5-2.75 5zm2.04-.27c.79-1.07 1.4-2.74 1.72-4.73h3.63a7.996 7.996 0 01-5.35 4.73zM13.89 12a18.419 18.419 0 000-4h3.83c.17.64.28 1.31.28 2s-.11 1.36-.28 2h-3.83z"];
  init_define_process();
  var graph_default2 = ["M17.5 4A2.5 2.5 0 0015 6.5c0 .06.01.12.02.18l-1.9.84C12.38 6.6 11.27 6 10 6c-.83 0-1.59.25-2.23.68L4.91 4.14c.05-.21.09-.42.09-.64a2.5 2.5 0 00-5 0A2.5 2.5 0 002.5 6c.42 0 .81-.11 1.16-.3l2.79 2.48C6.17 8.73 6 9.34 6 10c0 1.41.73 2.64 1.83 3.35l-.56 1.67A2.498 2.498 0 005 17.5a2.5 2.5 0 005 0c0-.74-.32-1.39-.83-1.85l.56-1.68c.09.01.18.03.27.03 2.21 0 4-1.79 4-4 0-.22-.03-.44-.07-.65l2.02-.9c.43.34.96.55 1.55.55a2.5 2.5 0 000-5z"];
  init_define_process();
  var graph_remove_default2 = ["M17.41 4l2.29-2.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L16 2.59 13.71.3A.965.965 0 0013 0a1.003 1.003 0 00-.71 1.71L14.59 4 12.3 6.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L16 5.41l2.29 2.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L17.41 4zM19 10c-.83 0-1.55-.36-2.09-.91l-.03.03-.88-.88-.88.88a2.996 2.996 0 11-4.24-4.24l.88-.88-.88-.88.03-.03C10.36 2.55 10 1.83 10 1c0-.35.07-.68.18-.99-.06 0-.12-.01-.18-.01C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10c0-.06-.01-.12-.01-.18-.31.11-.64.18-.99.18z"];
  init_define_process();
  var greater_than_default2 = ["M12.838 10l-9.154 3.051a1 1 0 00.632 1.898l12-4c.912-.304.912-1.594 0-1.898l-12-4a1 1 0 00-.632 1.898L12.838 10z"];
  init_define_process();
  var greater_than_or_equal_to_default2 = ["M3.684 11.051a1 1 0 00.632 1.898l12-4c.912-.304.912-1.594 0-1.898l-12-4a1 1 0 00-.632 1.898L12.838 8l-9.154 3.051zM4 15h12a1 1 0 110 2H4a1 1 0 010-2z"];
  init_define_process();
  var grid_default2 = ["M19 11c.55 0 1-.45 1-1s-.45-1-1-1h-2V5h2c.55 0 1-.45 1-1s-.45-1-1-1h-2V1c0-.55-.45-1-1-1s-1 .45-1 1v2h-4V1c0-.55-.45-1-1-1S9 .45 9 1v2H5V1c0-.55-.45-1-1-1S3 .45 3 1v2H1c-.55 0-1 .45-1 1s.45 1 1 1h2v4H1c-.55 0-1 .45-1 1s.45 1 1 1h2v4H1c-.55 0-1 .45-1 1s.45 1 1 1h2v2c0 .55.45 1 1 1s1-.45 1-1v-2h4v2c0 .55.45 1 1 1s1-.45 1-1v-2h4v2c0 .55.45 1 1 1s1-.45 1-1v-2h2c.55 0 1-.45 1-1s-.45-1-1-1h-2v-4h2zM9 15H5v-4h4v4zm0-6H5V5h4v4zm6 6h-4v-4h4v4zm0-6h-4V5h4v4z"];
  init_define_process();
  var grid_view_default2 = ["M0 19c0 .55.45 1 1 1h8v-9H0v8zM0 1v8h9V0H1C.45 0 0 .45 0 1zm19-1h-8v9h9V1c0-.55-.45-1-1-1zm-8 20h8c.55 0 1-.45 1-1v-8h-9v9z"];
  init_define_process();
  var group_objects_default2 = ["M6 7c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3zm8-3H6c-3.31 0-6 2.69-6 6s2.69 6 6 6h8c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 11H6c-2.76 0-5-2.24-5-5s2.24-5 5-5h8c2.76 0 5 2.24 5 5s-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"];
  init_define_process();
  var grouped_bar_chart_default2 = ["M12 16h1c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1h-1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1zm7 1H1c-.55 0-1 .45-1 1s.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1zm-3-1h1c.55 0 1-.45 1-1V8c0-.55-.45-1-1-1h-1c-.55 0-1 .45-1 1v7c0 .55.45 1 1 1zm-9 0h1c.55 0 1-.45 1-1v-5c0-.55-.45-1-1-1H7c-.55 0-1 .45-1 1v5c0 .55.45 1 1 1zm-4 0h1c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v13c0 .55.45 1 1 1z"];
  init_define_process();
  var hand_default2 = ["M17 5c-.42 0-.79.27-.93.64L14.38 10h-.77l1.34-6.67c.03-.1.05-.21.05-.33a.998.998 0 00-1.98-.19h-.01L11.57 10H11V1c0-.55-.45-1-1-1S9 .45 9 1v9h-.2L6.97 2.76a.997.997 0 00-1.73-.41l-.03.03c-.01.02-.02.03-.03.04-.01.02-.01.03-.02.04v.01c-.01.01-.02.02-.02.03v.01c-.02.01-.02.02-.03.03 0 0 0 .01-.01.01 0 .01 0 .02-.01.03 0 0 0 .01-.01.01 0 .01-.01.02-.01.03 0 0 0 .01-.01.01 0 .01-.01.02-.01.03 0 .01 0 .01-.01.02 0 .01-.01.02-.01.03 0 .01 0 .01-.01.02 0 .01-.01.02-.01.03v.02c0 .01 0 .02-.01.03V3c0 .05 0 .09.01.14l1.45 10.25L6 12.7v.01L3.84 9.45h-.01A.98.98 0 003 9c-.55 0-1 .45-1 1 0 .2.06.39.17.55L6 18.44C7.06 19.4 8.46 20 10 20c3.31 0 6-2.69 6-6v-1.84l.01-.03v-.06l1.94-5.75A1.003 1.003 0 0017 5z"];
  init_define_process();
  var hand_down_default2 = ["M17.68 9.84C15.91 9 14.27 6.49 13.45 4.9 12.41 2.43 12.21 0 7.87 0 5.49 0 3.95.76 3.05 2.65 2.31 4.2 2 5.48 2 9.79v.99c0 .82.69 1.48 1.54 1.48.38 0 .73-.14 1-.36.19.6.78 1.05 1.47 1.05.47 0 .89-.2 1.17-.52.26.47.77.79 1.36.79.65 0 1.2-.39 1.43-.93l.03.77v5.44c0 .48.23.91.59 1.18.21.19.5.32.85.32h.06c.83 0 1.5-.67 1.5-1.5v-8.24l.01-.67c.85.98 1.92 1.76 3.24 1.89 1.79.19 2.09-1.33 1.43-1.64z"];
  init_define_process();
  var hand_left_default2 = ["M15.1 6.54c-1.58-.81-4.09-2.46-4.94-4.23-.31-.65-1.82-.35-1.64 1.43.13 1.33.91 2.4 1.89 3.24L9.74 7H1.5C.67 7 0 7.67 0 8.5v.06c0 .36.13.64.32.85.27.36.7.59 1.18.59h5.44l.78.01c-.54.23-.93.78-.93 1.43 0 .59.32 1.1.79 1.36-.32.28-.52.7-.52 1.17 0 .69.44 1.28 1.05 1.47-.22.27-.36.62-.36 1 0 .85.66 1.54 1.48 1.54h.99c4.31 0 5.59-.31 7.14-1.05 1.89-.9 2.65-2.44 2.65-4.82-.01-4.32-2.44-4.52-4.91-5.57z"];
  init_define_process();
  var hand_right_default2 = ["M20 8.5c0-.83-.67-1.5-1.5-1.5h-8.24l-.67-.01c.98-.85 1.76-1.92 1.89-3.24.18-1.79-1.33-2.08-1.65-1.43-.84 1.76-3.35 3.41-4.93 4.23C2.43 7.59 0 7.79 0 12.13c0 2.38.76 3.92 2.65 4.82C4.2 17.69 5.48 18 9.79 18h.99c.82 0 1.48-.69 1.48-1.54 0-.38-.14-.73-.36-1 .6-.19 1.05-.78 1.05-1.47 0-.47-.2-.89-.52-1.17.47-.26.79-.77.79-1.36 0-.65-.39-1.2-.93-1.43l.77-.03h5.44c.48 0 .91-.23 1.18-.59.19-.21.32-.49.32-.85v-.03-.03z"];
  init_define_process();
  var hand_up_default2 = ["M16.46 7.74c-.38 0-.73.14-1 .36-.19-.6-.78-1.05-1.47-1.05-.47 0-.89.2-1.17.52-.26-.47-.77-.79-1.36-.79-.65 0-1.2.39-1.43.93L10 6.94V1.5c0-.48-.23-.91-.59-1.18C9.2.13 8.92 0 8.56 0H8.5C7.67 0 7 .67 7 1.5v8.24l-.01.67c-.84-.98-1.92-1.76-3.24-1.89-1.79-.18-2.08 1.33-1.43 1.65 1.77.84 3.41 3.35 4.23 4.94 1.05 2.47 1.25 4.9 5.58 4.9 2.38 0 3.92-.76 4.82-2.65.74-1.56 1.05-2.84 1.05-7.15v-.99c0-.81-.69-1.48-1.54-1.48z"];
  init_define_process();
  var hat_default2 = ["M18.5 13c1.118 0 1.466.534 1.498 1.366L20 14.5v.5c0 1.945-5.69 3-10 3S0 16.945 0 15v-.5c0-.908.323-1.5 1.5-1.5.895 0 3.5 1.2 8.5 1.2l.411-.003C15.143 14.134 17.631 13 18.5 13zm-5-10c1.725 0 2.954 2.729 3.688 8.186-1.455.263-3.805.72-6.392.801l-.434.01L10 12c-2.896 0-5.585-.524-7.189-.814C3.546 5.73 4.775 3 6.5 3 8.6 3 8.329 5.5 10 5.5S11.5 3 13.5 3z"];
  init_define_process();
  var header_default2 = ["M16 1c-.55 0-1 .45-1 1v7H5V2c0-.55-.45-1-1-1s-1 .45-1 1v16c0 .55.45 1 1 1s1-.45 1-1v-7h10v7c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1z"];
  init_define_process();
  var header_one_default2 = ["M10 0c.55 0 1 .45 1 1v14c0 .55-.45 1-1 1s-1-.45-1-1V9H2v6c0 .55-.45 1-1 1s-1-.45-1-1V1c0-.55.45-1 1-1s1 .45 1 1v6h7V1c0-.55.45-1 1-1zm7.4 10.77c.17-.2.29-.46.34-.77H19v10h-1.5v-7.11H15v-1.24c.32 0 .63-.03.93-.08.31-.06.58-.16.83-.29.26-.12.47-.3.64-.51z"];
  init_define_process();
  var header_three_default2 = ["M10.989 1c0-.55-.45-1-.999-1-.55 0-.999.45-.999 1v6H1.998V1c0-.55-.45-1-.999-1C.449 0 0 .45 0 1v14c0 .55.45 1 .999 1 .55 0 .999-.45.999-1V9h6.993v6c0 .55.45 1 .999 1 .55 0 .999-.45.999-1V1zm7.461 13.645c.49.11.87.38 1.14.82.27.44.41.97.41 1.61a3 3 0 01-.24 1.23c-.16.36-.38.67-.66.92-.27.25-.59.44-.96.58-.37.14-.75.21-1.16.21-.5 0-.93-.08-1.3-.24a2.55 2.55 0 01-.93-.68c-.25-.29-.44-.65-.57-1.06-.13-.42-.2-.88-.21-1.38h1.39c-.02.58.11 1.07.38 1.46.28.39.68.58 1.23.58.47 0 .86-.15 1.17-.45.31-.3.47-.72.47-1.27 0-.37-.07-.67-.2-.89-.13-.22-.3-.39-.51-.5-.21-.11-.45-.18-.71-.21-.26-.03-.53-.04-.81-.03v-1.17c.22.01.45 0 .68-.05.23-.05.43-.13.61-.24.18-.11.32-.27.43-.47.11-.2.16-.45.16-.74 0-.41-.12-.74-.37-.99s-.57-.37-.96-.37c-.24 0-.45.06-.63.17-.18.11-.33.26-.45.45s-.2.4-.26.63c-.05.23-.08.47-.07.72h-1.39c.01-.47.09-.9.23-1.3s.33-.75.57-1.04c.24-.3.53-.53.87-.69.34-.17.73-.25 1.16-.25.33 0 .66.05.98.16.32.11.61.27.87.48.26.21.47.47.62.8.15.32.23.7.23 1.12 0 .48-.09.91-.29 1.27-.2.36-.5.63-.92.79v.02z"];
  init_define_process();
  var header_two_default2 = ["M16.6 17.41c-.22.17-.4.36-.56.55-.16.19-.27.4-.33.61h4.28V20H14c.01-.81.18-1.52.53-2.13.35-.6.81-1.13 1.41-1.58.28-.23.58-.46.89-.68.31-.22.59-.46.85-.71.26-.26.48-.53.63-.83.16-.3.25-.64.26-1.02 0-.18-.02-.37-.06-.57-.04-.2-.11-.39-.22-.56s-.26-.31-.45-.43-.44-.18-.75-.18c-.28 0-.52.06-.71.19s-.34.3-.45.52c-.11.22-.2.48-.25.78-.05.3-.08.62-.09.97h-1.43c0-.54.07-1.04.2-1.5.13-.47.32-.87.58-1.2.26-.34.58-.6.95-.78.37-.19.81-.29 1.3-.29.54 0 .99.09 1.35.29.36.19.65.44.87.74.22.29.38.62.47.97.09.35.14.68.14 1 0 .4-.05.75-.16 1.07-.11.32-.26.61-.44.88-.19.27-.4.52-.63.74-.24.22-.48.43-.73.63s-.5.38-.75.56c-.26.17-.5.35-.71.53zM10 0c.55 0 1 .45 1 1v14c0 .55-.45 1-1 1s-1-.45-1-1V9H2v6c0 .55-.45 1-1 1s-1-.45-1-1V1c0-.55.45-1 1-1s1 .45 1 1v6h7V1c0-.55.45-1 1-1z"];
  init_define_process();
  var headset_default2 = ["M18.97 9H19A9 9 0 001 9h.03C.41 9.73 0 10.8 0 12c0 1.74.84 3.2 2 3.76V16c0 1.66 1.34 3 3 3h3c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-2c0-.55-.45-1-1-1H9c-.55 0-1 .45-1 1H5c-.55 0-1-.45-1-1 .55 0 1-.45 1-1V9c0-.55-.45-1-1-1h-.92C3.57 4.61 6.47 2 10 2s6.43 2.61 6.92 6H16c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h1c1.66 0 3-1.79 3-4 0-1.2-.41-2.27-1.03-3z"];
  init_define_process();
  var heart_default2 = ["M20 6.25C20 3.35 17.65 1 14.75 1c-1.02 0-1.95.31-2.75.82v-.04c-.09.06-.17.12-.26.19-.04.03-.09.06-.14.1-.68.51-1.24 1.18-1.6 1.96-.4-.86-1.04-1.57-1.8-2.1-.04-.02-.07-.05-.1-.08a7 7 0 00-.6-.33c-.13-.04-.23-.1-.35-.15-.05-.02-.1-.05-.15-.07v.02C6.45 1.13 5.87 1 5.25 1A5.25 5.25 0 000 6.25c0 .09.01.17.01.25H0c0 .06.01.12.02.18s.01.12.02.18C.13 7.89.44 9 1.07 10.17 2.23 12.33 4.1 14.11 7 16.53v.01c.9.75 1.89 1.55 3 2.46.71-.58 1.38-1.12 2-1.63 3.48-2.86 5.64-4.78 6.93-7.18.63-1.17.94-2.27 1.03-3.3.01-.07.01-.14.02-.21 0-.06.01-.11.02-.17h-.01c0-.09.01-.17.01-.26z"];
  init_define_process();
  var heart_broken_default2 = ["M8.11 7.45C8.05 7.31 8 7.16 8 7c0-.07.03-.13.04-.19h-.02l.86-4.32A5.159 5.159 0 005.25 1 5.25 5.25 0 000 6.25c0 .09.01.17.01.25H0c0 .06.01.12.02.18s.01.12.02.18C.13 7.89.44 9 1.07 10.17c1.38 2.58 3.76 4.6 7.71 7.83l-.76-3.8h.02c-.01-.07-.04-.13-.04-.2 0-.21.08-.39.18-.54l-.02-.01 1.68-2.52-1.73-3.48zM20 6.25C20 3.35 17.65 1 14.75 1c-1.54 0-2.92.67-3.88 1.73l-.83 4.13 1.85 3.69h-.01c.07.14.12.29.12.45 0 .21-.08.39-.18.54l.02.01-1.77 2.66.81 4.07c4.16-3.39 6.63-5.45 8.05-8.1.63-1.17.94-2.27 1.03-3.3.01-.07.01-.14.02-.21 0-.06.01-.11.02-.17h-.01c0-.08.01-.16.01-.25z"];
  init_define_process();
  var heat_grid_default2 = ["M14 12h6V8h-6v4zM0 12h6V8H0v4zm1-3h4v2H1V9zm-1 7c0 .55.45 1 1 1h5v-4H0v3zM19 3h-5v4h6V4c0-.55-.45-1-1-1zm0 3h-4V4h4v2zM0 4v3h6V3H1c-.55 0-1 .45-1 1zm7 3h6V3H7v4zm7 10h5c.55 0 1-.45 1-1v-3h-6v4zm-7 0h6v-4H7v4zm1-3h4v2H8v-2zm-1-2h6V8H7v4z"];
  init_define_process();
  var heatmap_default2 = ["M6 0a6 6 0 100 12A6 6 0 106 0z", "M10.5 8a4.5 4.5 0 100 9 4.5 4.5 0 100-9z", "M16.5 7a3.5 3.5 0 100 7 3.5 3.5 0 100-7zM18 16a2 2 0 100 4 2 2 0 100-4zM2.5 14a2.5 2.5 0 100 5 2.5 2.5 0 100-5zM16.5 0a2.5 2.5 0 100 5 2.5 2.5 0 100-5z"];
  init_define_process();
  var helicopter_default2 = ["M10 3v2H1V3.5a.5.5 0 00-1 0v5a.5.5 0 001 0V7l5 2c0 1.54.824 3.575 3 4.835V16H5.5a.5.5 0 100 1H16.5a.5.5 0 00.224-.053l2-1a.5.5 0 10-.448-.894L16.382 16H15v-1.1A5.002 5.002 0 0014 5h-1V3h6.5a.5.5 0 000-1h-16a.5.5 0 000 1H10zm4 13v-1c-1.608 0-2.928-.258-4-.683V16h4zm0-6V6a4 4 0 014 4h-4z"];
  init_define_process();
  var help_default2 = ["M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zM7.41 4.62c.65-.54 1.51-.82 2.56-.82.54 0 1.03.08 1.48.25.44.17.83.39 1.14.68.32.29.56.63.74 1.02.17.39.26.82.26 1.27s-.08.87-.24 1.23c-.16.37-.4.73-.71 1.11l-1.21 1.58c-.14.17-.28.33-.32.48-.05.15-.11.35-.11.6v.97H9v-2s.06-.58.24-.81l1.21-1.64c.25-.3.41-.56.51-.77s.14-.44.14-.67c0-.35-.11-.63-.32-.85s-.5-.33-.88-.33c-.37 0-.67.11-.89.33-.22.23-.37.54-.46.94-.03.12-.11.17-.23.16l-1.95-.29c-.12-.01-.16-.08-.14-.22.13-.93.52-1.67 1.18-2.22zM9 14h2.02L11 16H9v-2z"];
  init_define_process();
  var helper_management_default2 = ["M17 10h-3v3h3v-3zm0 4h-3v3h3v-3zm0-8h-3v3h3V6zm2-6H1C.4 0 0 .4 0 1v18c0 .5.4 1 1 1h18c.5 0 1-.5 1-1V1c0-.6-.5-1-1-1zm-1 18H2V2h16v16zm-9-4H6v3h3v-3zm4 0h-3v3h3v-3z"];
  init_define_process();
  var high_priority_default2 = ["M12 16v4H8v-4h4zm1-16l-1 14H8L7 0h6z"];
  init_define_process();
  var high_voltage_pole_default2 = ["M7 0a1 1 0 00-1 1v3H4V2a1 1 0 000-2H1a1 1 0 100 2h1v2H1a1 1 0 000 2h1v2H1a1 1 0 100 2h3a1 1 0 000-2V6h2v13a1 1 0 001.928.374L10 14.54l2.073 4.836A1 1 0 0014 19V6h2v2a1 1 0 100 2h3a1 1 0 100-2h-1V6h1a1 1 0 100-2h-1V2h1a1 1 0 100-2h-3a1 1 0 100 2v2h-2V1a1 1 0 00-1-1H7zm1 2v2h4V2H8zm4 12.128L11.088 12 12 9.872v4.256zM8.516 6L10 9.462 11.483 6H8.516zm.396 6L8 9.872v4.256L8.912 12z"];
  init_define_process();
  var highlight_default2 = ["M11.22 14.09l3.03-3.03.71.71L20 6.73l-5.71-5.71-5.04 5.04.71.71-3.02 3.04 4.28 4.28zm6.8 3.91h-16c-.55 0-1 .45-1 1s.45 1 1 1h16c.55 0 1-.45 1-1s-.45-1-1-1zm-15-1h4.04c.28 0 .53-.11.71-.3l2.02-2.02-3.44-3.45-4.04 4.04c-.18.18-.3.44-.3.71.01.57.46 1.02 1.01 1.02z"];
  init_define_process();
  var history_default2 = ["M10 0C6.71 0 3.82 1.6 2 4.05V2c0-.55-.45-1-1-1s-1 .45-1 1v4c0 .55.45 1 1 1h4c.55 0 1-.45 1-1s-.45-1-1-1H3.76C5.23 3.17 7.47 2 10 2c4.42 0 8 3.58 8 8s-3.58 8-8 8-8-3.58-8-8c0-.55-.45-1-1-1s-1 .45-1 1c0 5.52 4.48 10 10 10s10-4.48 10-10S15.52 0 10 0zm0 3c-.55 0-1 .45-1 1v6c0 .28.11.53.29.71l3 3a1.003 1.003 0 001.42-1.42L11 9.59V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var home_default2 = ["M2 12v7c0 .55.45 1 1 1h5v-7h4v7h5c.55 0 1-.45 1-1v-7l-8-8-8 8zm17.71-2.71L17 6.59V3c0-.55-.45-1-1-1s-1 .45-1 1v1.59L10.71.3C10.53.11 10.28 0 10 0s-.53.11-.71.29l-9 9a1.003 1.003 0 001.42 1.42L10 2.41l8.29 8.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71z"];
  init_define_process();
  var horizontal_bar_chart_default2 = ["M1 1c-.55 0-1 .45-1 1v16c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1zm3 5h11c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1zm8 8H4c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h8c.55 0 1-.45 1-1v-2c0-.55-.45-1-1-1zm7-6H4c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h15c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1z"];
  init_define_process();
  var horizontal_bar_chart_asc_default2 = ["M1 9h11c.55 0 1-.45 1-1V7c0-.55-.45-1-1-1H1c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1zm0-5h9c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1H1c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1zm18 12H1c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h18c.55 0 1-.45 1-1v-1c0-.55-.45-1-1-1zM1 14h14c.55 0 1-.45 1-1v-1c0-.55-.45-1-1-1H1c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1z"];
  init_define_process();
  var horizontal_bar_chart_desc_default2 = ["M10 16H1c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h9c.55 0 1-.45 1-1v-1c0-.55-.45-1-1-1zm2-5H1c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h11c.55 0 1-.45 1-1v-1c0-.55-.45-1-1-1zm3-5H1c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V7c0-.55-.45-1-1-1zm4-5H1c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1z"];
  init_define_process();
  var horizontal_distribution_default2 = ["M12 2H8c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h4c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1zM1 0C.45 0 0 .45 0 1v18c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1zm18 0c-.55 0-1 .45-1 1v18c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var horizontal_inbetween_default2 = ["M11.293 13.707a.999.999 0 001.412 0l2.963-2.962a1 1 0 000-1.49l-2.963-2.962a.999.999 0 10-1.412 1.412L13.587 10l-2.294 2.295a.999.999 0 000 1.412zM7.295 13.707a.999.999 0 001.412-1.412L6.413 10l2.294-2.295a.999.999 0 10-1.412-1.412L4.332 9.255A.996.996 0 004 10a.996.996 0 00.332.745l2.963 2.962zM0 20V0h1a1 1 0 011 1v18a1 1 0 01-1 1H0zM20 20V0h-1a1 1 0 00-1 1v18a1 1 0 001 1h1z"];
  init_define_process();
  var hurricane_default2 = ["M0 14c1.648.775 3 1 4 1-1-1-2-3.112-2-5a5.098 5.098 0 000-.045C2 5.17 6.201 1 11.172 1c3.206 0 6.9.667 8.828 5-1.648-.775-3-1-4-1 1 1 2 3.112 2 5v.045C18 14.83 13.799 19 8.828 19c-3.206 0-6.9-.667-8.828-5zm10-7a3 3 0 100 6 3 3 0 000-6z"];
  init_define_process();
  var id_number_default2 = ["M2 5v10h16V5H2zm0-2h16c1.1 0 2 .9 2 2v10c0 1.1-.9 2-2 2H2c-1.1 0-2-.9-2-2V5c0-1.1.9-2 2-2z", "M8.88 12.38c-.17-.39-1.01-.66-1.56-.9-.56-.24-.48-.39-.5-.6v-.09c.19-.17.35-.4.45-.67 0 0 0-.02.01-.02l.06-.18c.13-.03.2-.17.23-.29.03-.05.09-.18.08-.33-.04-.18-.11-.27-.2-.3v-.03c0-.24-.02-.58-.06-.81-.01-.06-.02-.12-.04-.19-.08-.27-.25-.52-.48-.7C6.63 7.09 6.3 7 6 7s-.63.09-.87.27c-.23.17-.4.42-.48.7-.02.06-.03.13-.04.19-.04.22-.06.57-.06.81V9c-.09.03-.17.12-.19.31-.01.14.05.27.08.32.03.14.1.27.23.3.02.06.03.12.06.18v.01c.11.27.27.51.47.68v.08c-.02.2.04.35-.51.6-.56.24-1.39.51-1.56.9-.19.39-.12.62-.12.62h5.98c-.01 0 .06-.23-.11-.62zM12 7h4c.55 0 1 .45 1 1s-.45 1-1 1h-4c-.55 0-1-.45-1-1s.45-1 1-1zM12 11h4c.55 0 1 .45 1 1s-.45 1-1 1h-4c-.55 0-1-.45-1-1s.45-1 1-1z"];
  init_define_process();
  var image_rotate_left_default2 = ["M10.5 13c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.67-1.5 1.5.67 1.5 1.5 1.5zM14 7H1c-.55 0-1 .45-1 1v11c0 .55.45 1 1 1h13c.55 0 1-.45 1-1V8c0-.55-.45-1-1-1zm-1 10l-5-3-1 2-2-4-3 4.5V9h11v8zm3-15h-1.59l.29-.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-2 2c-.18.18-.29.43-.29.71 0 .28.11.53.29.71l2 2a1.003 1.003 0 001.42-1.42l-.3-.29H16c1.1 0 2 .9 2 2v3c0 .55.45 1 1 1s1-.45 1-1V6c0-2.21-1.79-4-4-4z"];
  init_define_process();
  var image_rotate_right_default2 = ["M5.29 4.29a1.003 1.003 0 001.42 1.42l2-2C8.89 3.53 9 3.28 9 3c0-.28-.11-.53-.29-.71l-2-2a1.003 1.003 0 00-1.42 1.42l.3.29H4C1.79 2 0 3.79 0 6v3c0 .55.45 1 1 1s1-.45 1-1V6c0-1.1.9-2 2-2h1.59l-.3.29zM15.5 13c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.67-1.5 1.5.67 1.5 1.5 1.5zM19 7H6c-.55 0-1 .45-1 1v11c0 .55.45 1 1 1h13c.55 0 1-.45 1-1V8c0-.55-.45-1-1-1zm-1 10l-5-3-1 2-2-4-3 4.5V9h11v8z"];
  init_define_process();
  var import_default2 = ["M9.29 15.71c.18.18.43.29.71.29s.53-.11.71-.29l5-5a1.003 1.003 0 00-1.42-1.42L11 12.59V1c0-.55-.45-1-1-1S9 .45 9 1v11.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42l5 5zM19 14c-.55 0-1 .45-1 1v3H2v-3c0-.55-.45-1-1-1s-1 .45-1 1v4c0 .55.45 1 1 1h18c.55 0 1-.45 1-1v-4c0-.55-.45-1-1-1z"];
  init_define_process();
  var inbox_default2 = ["M16.92 3.56l-.01-.02c-.16-.35-.5-.6-.91-.6H4c-.41 0-.76.25-.91.6l-.01.02L0 10.49v6.46c0 .55.45 1 1 1h18c.55 0 1-.45 1-1v-6.46l-3.08-6.93zM15 10.95c-.55 0-1 .45-1 1v1H6v-1c0-.55-.45-1-1-1H1.98l2.67-6h10.7l2.67 6H15z"];
  init_define_process();
  var inbox_filtered_default2 = ["M10.262 3l1.958 1.958v.05H4.65l-2.67 5.997H5c.55 0 1 .45 1 .999v1h8v-1c0-.55.45-1 1-1h3.02l-.635-1.426.625-.63c.354-.353.598-.8.707-1.289L20 10.545v6.456c0 .55-.45.999-1 .999H1c-.55 0-1-.45-1-1v-6.455L3.08 3.62l.01-.02c.15-.35.5-.6.91-.6h6.262zm9.088-3a.642.642 0 01.46 1.1l-3.03 3.03v2.95c0 .18-.07.34-.19.46l-1.28 1.29c-.11.1-.27.17-.45.17-.35 0-.64-.29-.64-.64V4.13L11.19 1.1a.642.642 0 01.45-1.1h7.71z"];
  init_define_process();
  var inbox_geo_default2 = ["M7.427 3a7.467 7.467 0 00-.411 2.009H4.65l-2.67 5.996H5c.55 0 1 .45 1 .999v1h8V13c.165.01.332 0 .5 0a7.48 7.48 0 005.5-2.4V17c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1v-6.455L3.08 3.62l.01-.02c.15-.35.5-.6.91-.6h3.427zm5.715-.596a.133.133 0 01-.193 0l-.374-.374a.133.133 0 010-.193.133.133 0 01.193 0l.373.374a.133.133 0 010 .193zm1.743.033c-.05 0-.088-.006-.088-.055 0-.05.038-.056.088-.056h.165c.05 0 .088.006.088.055 0 .05-.038.056-.088.056h-.165zm.539.632c-.05 0-.104-.044-.104-.094v-.23c0-.05.054-.094.104-.094.05 0 .104.044.104.094v.23c0 .05-.055.094-.104.094zm-3.575 2.304h.506l1.182 1.2c.006.005 0 .005 0 .01v.446c0 .187-.126.341-.319.341h-.098v.226c0 .192-.138.296-.33.296h.01v.792c0 .188-.181.336-.368.336s-.369-.149-.369-.335v-1.32h-.214c-.193 0-.308-.149-.308-.341V5.72c0-.192.115-.346.308-.346zM14.5 0C17.536 0 20 2.464 20 5.5S17.536 11 14.5 11A5.502 5.502 0 019 5.5C9 2.464 11.464 0 14.5 0zm0 9.9c2.431 0 4.4-1.969 4.4-4.4 0-.297-.027-.583-.099-.864h-.236c-.188 0-.336-.104-.347-.313h-.319c.11.104.231.209.231.346v.705c0 .088-.055.17-.11.23h-.022l-.011.006-.022.011-.666.643v1.21c0 .193-.104.33-.296.33h-.54c-.192 0-.319-.137-.319-.33V6.221a.915.915 0 00-.533-.518h-.671c-.192 0-.368-.143-.368-.335V4.68c0-.192.176-.346.368-.346l.193-.005.319-.32a.342.342 0 01.489 0l.319.32c.005 0 .005.005.005.005h.704c.16 0 .237-.16.341-.313v-.11l-.038.005h-.27a.159.159 0 01-.153-.16c0-.087.066-.159.154-.159h.269l.039.006V3.42s-.05-.038-.061-.038h-.302l-.067.076a.342.342 0 01-.489.011l-.066-.088h-.176l.248.259c.021.022.021.088 0 .11-.028.022-.067.028-.088.006l-.292-.276h-.127l-.363.325-.033-.006c-.038.11-.087.089-.143.089-.126 0-.225-.072-.225-.193 0-.127.099-.209.225-.209h.176v-.182c0-.088.061-.131.149-.131h.066v-.127c0-.143.149-.297.286-.297h.28c.16 0 .27-.115.27-.275V2.42c0-.016.055.017.055-.088h-.187l-.005.017-.308.33a.123.123 0 01-.177 0c-.049-.044-.049-.121 0-.171l.391-.385c.027-.022.06-.022.094-.022l.005.022h.869A4.376 4.376 0 0014.5 1.1a4.402 4.402 0 00-2.816 1.018h.583c.094 0 .165.066.165.159s-.072.16-.165.16h-.478c0 .104-.039.06-.039.066v.351h.429l.226-.252c.132-.127.346-.155.473-.022a.332.332 0 010 .473l-1.183 1.182-.011.011c-.005.005-.011.005-.016.011a.115.115 0 00-.034.022c-.005.006-.01 0-.016.006a.309.309 0 01-.176.038h-.347c-.12.104-.187.148-.187.27v.088c0 .016-.027.027-.027.043l.561.589c.06.06.055.154 0 .209a.143.143 0 01-.209 0l-.578-.578a.425.425 0 01-.082.011c-.154 0-.292-.12-.292-.274v-.358h-.016c-.104.374-.165.77-.165 1.177 0 2.431 1.969 4.4 4.4 4.4zm3.388-3.107c.077 0 .16.06.16.137v.424c0 .077-.083.137-.16.137s-.16-.06-.16-.137V6.93c0-.077.083-.137.16-.137zm-3.113-4.879c0 .187-.154.314-.335.314h-.374v.104c0 .11-.05.198-.16.198s-.16-.088-.16-.198V1.98c-.104-.022-.033-.028-.033-.055 0-.187.127-.325.314-.325h.407c.187 0 .341.127.341.314z"];
  init_define_process();
  var inbox_search_default2 = ["M7.136 3a6.327 6.327 0 00-.098 2.009H4.65l-2.67 5.996H5c.55 0 1 .45 1 .999v1h8v-1c0-.55.45-1 1-1h1.076l1.14 1.14a2.767 2.767 0 001.974.806c.282 0 .554-.042.81-.12V17c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1v-6.455L3.08 3.62l.01-.02c.15-.35.5-.6.91-.6h3.136zm3.244 1.33c0 1.62 1.31 2.93 2.93 2.93s2.93-1.31 2.93-2.93-1.31-2.93-2.93-2.93-2.93 1.31-2.93 2.93zm6.47 2.43l2.89 2.85c.13.15.22.35.23.56 0 .43-.35.78-.78.78-.23 0-.42-.08-.56-.22l-2.87-2.87c-.17.1-.33.2-.51.29-.03.01-.06.03-.09.04-.18.07-.35.15-.55.21-.19.06-.37.11-.57.14-.05.01-.1.02-.14.02-.2.03-.39.05-.6.05A4.3 4.3 0 019 4.31C9 1.93 10.93.01 13.3 0c2.37 0 4.3 1.93 4.3 4.3 0 .21-.02.4-.05.6-.01.05-.01.09-.02.14-.04.2-.08.38-.14.58-.05.19-.13.36-.21.54-.01.03-.03.06-.04.09-.08.18-.18.34-.29.51z"];
  init_define_process();
  var inbox_update_default2 = ["M10.083 3a6.04 6.04 0 00.001 2.009H4.65l-2.67 5.996H5c.55 0 1 .45 1 .999v1h8v-1c0-.55.45-1 1-1h3.02l-.53-1.19a5.97 5.97 0 001.824-.811L20 10.545v6.456c0 .55-.45.999-1 .999H1c-.55 0-1-.45-1-1v-6.455L3.08 3.62l.01-.02c.15-.35.5-.6.91-.6h6.083zM16 8a4 4 0 110-8 4 4 0 010 8z"];
  init_define_process();
  var info_sign_default2 = ["M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zM9 4h2v2H9V4zm4 12H7v-1h2V8H8V7h3v8h2v1z"];
  init_define_process();
  var inheritance_default2 = ["M6 10c0 2.21 1.79 4 4 4h6.59l-2.29-2.29A.965.965 0 0114 11a1.003 1.003 0 011.71-.71l4 4c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-4 4a1.003 1.003 0 01-1.42-1.42l2.3-2.29H10c-3.31 0-6-2.69-6-6H1a1 1 0 01-1-1V1a1 1 0 011-1h8a1 1 0 011 1v8a1 1 0 01-1 1H6zM2 2v6h6V2H2z"];
  init_define_process();
  var inherited_group_default2 = ["M1 9c.55 0 1 .45 1 1v4c0 1.1.9 2 2 2h2.59l-.3-.29a1.003 1.003 0 011.42-1.42l2 2c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-2 2A1.003 1.003 0 016 19c0-.28.11-.53.3-.71l.29-.29H4c-2.21 0-4-1.79-4-4v-4c0-.55.45-1 1-1zm6.996-9c.79 0 1.68.25 2.309.73a3.63 3.63 0 011.4 2.36c.11.6.17 1.52.17 2.15v.09c.22.09.42.32.47.82.03.39-.12.73-.2.87-.07.34-.27.71-.61.78-.04.16-.09.33-.15.48-.01.01-.02.05-.02.05-.27.71-.68 1.33-1.19 1.78 0 .08 0 .16.01.23.05.55-.15.95 1.33 1.6 1.469.66 3.698 1.35 4.178 2.39.45 1.05.27 1.67.27 1.67h-5.227a1.982 1.982 0 00-.319-.417l-2-2A2.003 2.003 0 005 15H4c-.548 0-1-.452-1-1v-1.462c.511-.213 1.023-.413 1.468-.608 1.479-.65 1.329-1.05 1.379-1.59l.01-.21c-.52-.45-.95-1.08-1.22-1.8l-.01-.01-.01-.03c-.07-.15-.12-.32-.16-.49-.34-.06-.54-.43-.62-.78-.08-.14-.24-.48-.2-.87.05-.51.26-.74.49-.83v-.08c0-.64.05-1.55.17-2.15a3.648 3.648 0 011.4-2.36C6.317.25 7.207 0 7.996 0zm5.997 3c.59 0 1.26.19 1.73.55.46.35.8.85.97 1.4.04.13.07.25.08.38.08.45.13 1.14.13 1.61v.07c.16.07.31.24.35.62.02.29-.09.55-.15.65-.05.26-.2.53-.46.59-.03.12-.07.25-.11.36-.01.01-.01.04-.01.04-.2.53-.51 1-.89 1.34 0 .06 0 .12.01.17.04.41-.11.71 1 1.19 1.099.5 2.768 1.01 3.128 1.79.34.79.2 1.25.2 1.25h-3.039V15c-.06-.33-.17-.69-.33-1.06-.45-.97-1.37-1.52-3.238-2.3-.17-.07-.76-.31-.77-.32-.1-.04-.2-.08-.28-.12.05-.14.04-.29.06-.45l.01-.16c-.25-.21-.47-.48-.65-.79.22-.34.41-.71.56-1.12l.028-.078-.002.013-.006.035.06-.15c.36-.26.6-.67.72-1.13.18-.37.29-.82.25-1.3-.05-.5-.21-.92-.47-1.22-.02-.53-.06-1.11-.12-1.59.38-.17.83-.26 1.24-.26z"];
  init_define_process();
  var inner_join_default2 = ["M8.7 4.7C7.4 6 6.5 7.9 6.5 10s.8 4 2.2 5.3c-.8.5-1.7.7-2.7.7-3.3 0-6-2.7-6-6s2.7-6 6-6c1 0 1.9.2 2.7.7zm-3.34 9.25c-.55-1.2-.86-2.54-.86-3.95s.31-2.75.86-3.95a4.001 4.001 0 000 7.9zM14 4c3.3 0 6 2.7 6 6s-2.7 6-6 6c-1 0-1.9-.2-2.7-.7 1.3-1.3 2.2-3.2 2.2-5.3s-.8-3.9-2.2-5.3C12.1 4.2 13 4 14 4zm.6 2.05c.55 1.2.86 2.54.86 3.95s-.31 2.75-.86 3.95c1.9-.31 3.36-1.96 3.36-3.95S16.5 6.36 14.6 6.05zM10 5.5C8.8 6.7 8 8.2 8 10s.8 3.3 2 4.4c1.2-1.1 2-2.7 2-4.5s-.8-3.3-2-4.4z"];
  init_define_process();
  var insert_default2 = ["M19 0H1C.4 0 0 .4 0 1v18c0 .5.4 1 1 1h18c.5 0 1-.5 1-1V1c0-.6-.5-1-1-1zm-1 18H2V2h16v16zM5 11h4v4c0 .6.4 1 1 1s1-.4 1-1v-4h4c.6 0 1-.4 1-1s-.4-1-1-1h-4V5c0-.6-.4-1-1-1s-1 .4-1 1v4H5c-.6 0-1 .4-1 1s.4 1 1 1z"];
  init_define_process();
  var intelligence_default2 = ["M10 9c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.46-1-1-1zm4.992.975v-.044a.42.42 0 00-.106-.225 7.726 7.726 0 00-1.087-1.125c-.831-.731-1.78-1.343-2.824-1.587a4.153 4.153 0 00-1.819-.025c-.562.112-1.093.337-1.593.619-.78.443-1.5 1.05-2.124 1.73a6.88 6.88 0 00-.331.395.461.461 0 000 .58c.318.42.7.788 1.087 1.126.83.731 1.78 1.343 2.824 1.587.606.144 1.218.15 1.83.025.557-.112 1.088-.337 1.594-.619.78-.443 1.5-1.05 2.118-1.73.113-.126.231-.257.337-.395a.442.442 0 00.107-.225V10c-.013-.012-.013-.019-.013-.025zM10 12c-1.107 0-2-.893-2-2s.893-2 2-2 2 .893 2 2-.893 2-2 2zM7 1a1 1 0 00-1-1H1a1 1 0 00-1 1v5a1 1 0 002 0V2h4a1 1 0 001-1zm6 0a1 1 0 011-1h5a1 1 0 011 1v5a1 1 0 11-2 0V2h-4a1 1 0 01-1-1zm0 18a1 1 0 001 1h5a1 1 0 001-1v-5a1 1 0 10-2 0v4h-4a1 1 0 00-1 1zm-6 0a1 1 0 01-1 1H1a1 1 0 01-1-1v-5a1 1 0 112 0v4h4a1 1 0 011 1z"];
  init_define_process();
  var intersection_default2 = ["M13 4c-1.31 0-2.51.43-3.5 1.14A5.977 5.977 0 006 4c-3.31 0-6 2.69-6 6s2.69 6 6 6c1.31 0 2.51-.43 3.5-1.14.99.71 2.19 1.14 3.5 1.14 3.31 0 6-2.69 6-6s-2.69-6-6-6zm-4.93 9.41c-.61.37-1.31.59-2.07.59-2.21 0-4-1.79-4-4s1.79-4 4-4c.76 0 1.46.22 2.07.59C7.4 7.56 7 8.73 7 10s.4 2.44 1.07 3.41zM13 14c-.76 0-1.46-.22-2.07-.59C11.6 12.44 12 11.27 12 10s-.4-2.44-1.07-3.41C11.54 6.22 12.24 6 13 6c2.21 0 4 1.79 4 4s-1.79 4-4 4z"];
  init_define_process();
  var ip_address_default2 = ["M6 3.66C6 5.69 10 11 10 11s4-5.31 4-7.34C13.99 1.64 12.21 0 10 0S6 1.64 6 3.66zM8 4c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2zM14 13.5V13h-4v1h3v2h-2v1h3v-3.5zM3 12h14c.55 0 1 .45 1 1v6c0 .55-.45 1-1 1H3c-.55 0-1-.45-1-1v-6c0-.55.45-1 1-1zm4 1v6h1v-6H7zm3 1v5h1v-5h-1z"];
  init_define_process();
  var issue_default2 = ["M10 20C4.477 20 0 15.523 0 10S4.477 0 10 0s10 4.477 10 10-4.477 10-10 10zm0-2a8 8 0 100-16 8 8 0 000 16zm1-2H9v-2h2v2zm0-3H9V4h2v9z"];
  init_define_process();
  var issue_closed_default2 = ["M15.364 5.9a.997.997 0 01-.707-.293l-2.121-2.122a1 1 0 111.414-1.414l1.414 1.414L18.192.657a1 1 0 011.414 1.414l-3.535 3.536a.997.997 0 01-.707.292zM11.78.157a3.002 3.002 0 00-1.437 1.85 8 8 0 107.1 5.055l.042-.042 1.472-1.472A9.959 9.959 0 0120 10c0 5.523-4.477 10-10 10S0 15.523 0 10 4.477 0 10 0c.608 0 1.202.054 1.78.158zM11 16H9v-2h2v2zm0-3H9V4h2v9z"];
  init_define_process();
  var issue_new_default2 = ["M13.167.512a2.98 2.98 0 00-.131.524c-.74.115-1.39.5-1.848 1.052a8 8 0 106.724 6.724 2.997 2.997 0 001.052-1.848 2.98 2.98 0 00.524-.13A9.99 9.99 0 0120 10c0 5.523-4.477 10-10 10S0 15.523 0 10 4.477 0 10 0a9.99 9.99 0 013.167.512zM11 16H9v-2h2v2zm0-3H9V4h2v9zm6-10h1.5a1 1 0 010 2H17v1.5a1 1 0 01-2 0V5h-1.5a1 1 0 010-2H15V1.5a1 1 0 012 0V3z"];
  init_define_process();
  var italic_default2 = ["M11.7 4H14c.6 0 1-.4 1-1s-.4-1-1-1H7c-.6 0-1 .4-1 1s.4 1 1 1h2.2L7.3 15H5c-.6 0-1 .4-1 1s.4 1 1 1h7c.6 0 1-.4 1-1s-.4-1-1-1H9.8l1.9-11z"];
  init_define_process();
  var join_table_default2 = ["M19 6h-4V2c0-.55-.45-1-1-1H1c-.55 0-1 .45-1 1v11c0 .55.45 1 1 1h4v4c0 .55.45 1 1 1h13c.55 0 1-.45 1-1V7c0-.55-.45-1-1-1zM6 12H2V9h4v3zm0-4H2V5h4v3zm7 9H7v-3h6v3zm0-4H7V9h6v4zm0-5H7V5h6v3zm5 9h-4v-3h4v3zm0-4h-4v-3h4v3z"];
  init_define_process();
  var key_default2 = ["M14 0c-3.31 0-6 2.69-6 6 0 1.11.32 2.14.85 3.03L.44 17.44a1.498 1.498 0 102.12 2.12l.79-.79.94.94c.18.18.43.29.71.29s.53-.11.71-.29l3-3c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71l-.94-.94 3.2-3.2A5.9 5.9 0 0014 12c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 9c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"];
  init_define_process();
  var key_backspace_default2 = ["M19 3H7c-.28 0-.53.11-.71.29l-6 6C.11 9.47 0 9.72 0 10c0 .28.11.53.29.71l6 6c.18.18.43.29.71.29h12c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1zm-2.29 9.29a1.003 1.003 0 01-1.42 1.42L13 11.41l-2.29 2.29c-.18.19-.43.3-.71.3a1.003 1.003 0 01-.71-1.71l2.3-2.29-2.3-2.29a1.003 1.003 0 011.42-1.42L13 8.59l2.29-2.29c.18-.19.43-.3.71-.3a1.003 1.003 0 01.71 1.71L14.41 10l2.3 2.29z"];
  init_define_process();
  var key_command_default2 = ["M15.5 12H14V8h1.5C17.43 8 19 6.43 19 4.5S17.43 1 15.5 1 12 2.57 12 4.5V6H8V4.5C8 2.57 6.43 1 4.5 1S1 2.57 1 4.5 2.57 8 4.5 8H6v4H4.5C2.57 12 1 13.57 1 15.5S2.57 19 4.5 19 8 17.43 8 15.5V14h4v1.5c0 1.93 1.57 3.5 3.5 3.5s3.5-1.57 3.5-3.5-1.57-3.5-3.5-3.5zm0-9c.83 0 1.5.67 1.5 1.5S16.33 6 15.5 6 14 5.33 14 4.5 14.67 3 15.5 3zm-11 14c-.83 0-1.5-.67-1.5-1.5S3.67 14 4.5 14s1.5.67 1.5 1.5S5.33 17 4.5 17zm0-11C3.67 6 3 5.33 3 4.5S3.67 3 4.5 3 6 3.67 6 4.5 5.33 6 4.5 6zm7.5 6H8V8h4v4zm3.5 5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"];
  init_define_process();
  var key_control_default2 = ["M16.71 7.29l-6-6C10.53 1.11 10.28 1 10 1s-.53.11-.71.29l-6 6a1.003 1.003 0 001.42 1.42L10 3.41l5.29 5.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71z"];
  init_define_process();
  var key_delete_default2 = ["M19.71 9.29l-6-6A.997.997 0 0013 3H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h12c.28 0 .53-.11.71-.29l6-6c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71zm-9 3a1.003 1.003 0 01-1.42 1.42L7 11.41 4.71 13.7c-.18.19-.43.3-.71.3a1.003 1.003 0 01-.71-1.71L5.59 10l-2.3-2.29a1.003 1.003 0 011.42-1.42L7 8.59 9.29 6.3c.18-.19.43-.3.71-.3a1.003 1.003 0 01.71 1.71L8.41 10l2.3 2.29z"];
  init_define_process();
  var key_enter_default2 = ["M18 2c-.55 0-1 .45-1 1v5c0 2.21-1.79 4-4 4H4.41L6.7 9.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-4 4c-.18.18-.29.43-.29.71 0 .28.11.53.29.71l4 4a1.003 1.003 0 001.42-1.42L4.41 14H13c3.31 0 6-2.69 6-6V3c0-.55-.45-1-1-1z"];
  init_define_process();
  var key_escape_default2 = ["M2 8c.55 0 1-.45 1-1V4.41l6.29 6.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L4.41 3H7c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1v5c0 .55.45 1 1 1zm9-6.94V3.1c3.39.49 6 3.38 6 6.9 0 3.87-3.13 7-7 7-3.52 0-6.41-2.61-6.9-6H1.06c.5 4.5 4.31 8 8.94 8a9 9 0 009-9c0-4.63-3.5-8.44-8-8.94z"];
  init_define_process();
  var key_option_default2 = ["M13 4h6c.55 0 1-.45 1-1s-.45-1-1-1h-6c-.55 0-1 .45-1 1s.45 1 1 1zm6 12h-4.42L6.87 2.5l-.02.01A.977.977 0 006 2H1c-.55 0-1 .45-1 1s.45 1 1 1h4.42l7.71 13.5.01-.01c.18.3.49.51.86.51h5c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var key_shift_default2 = ["M17.74 10.35l-6.99-8.01-.01.01C10.56 2.14 10.3 2 10 2s-.56.14-.74.35l-.01-.01-7 8 .01.01A.95.95 0 002 11c0 .55.45 1 1 1h3v5c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-5h3c.55 0 1-.45 1-1 0-.25-.1-.48-.26-.65z"];
  init_define_process();
  var key_tab_default2 = ["M19 13H4.41l2.29-2.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L2 12.59V10c0-.55-.45-1-1-1s-1 .45-1 1v8c0 .55.45 1 1 1s1-.45 1-1v-2.59l3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L4.41 15H19c.55 0 1-.45 1-1s-.45-1-1-1zm0-12c-.55 0-1 .45-1 1v2.59L14.71 1.3A.965.965 0 0014 1a1.003 1.003 0 00-.71 1.71L15.59 5H1c-.55 0-1 .45-1 1s.45 1 1 1h14.59L13.3 9.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L18 7.41V10c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1z"];
  init_define_process();
  var known_vehicle_default2 = ["M19 4a.997.997 0 00-.707.293L14 8.586l-2.293-2.293a1 1 0 00-1.414 1.414l3 3a.997.997 0 001.414 0l5-5A1 1 0 0019 4zm-2.048 7.291c.011.072.048.134.048.209a1.5 1.5 0 01-1.5 1.5c-.225 0-.433-.057-.624-.145-.279.085-.57.145-.876.145a2.99 2.99 0 01-2.121-.879l-3-3 .007-.007A3.027 3.027 0 018.184 8H4V7l1-3h10l.19.568 1.307-1.308c-.336-.356-.758-.658-1.165-.772 0 0-1.74-.488-5.332-.488s-5.332.488-5.332.488c-.67.188-1.424.864-1.674 1.502L2.99 4H3L2 7H1a1 1 0 000 2h.333l-.28.84L1 10v7.5a1.5 1.5 0 103 0V17h12v.5a1.5 1.5 0 003 0V10l-.19-.568-1.858 1.86zM4.5 13a1.5 1.5 0 110-3 1.5 1.5 0 010 3z"];
  init_define_process();
  var lab_test_default2 = ["M13 2a1 1 0 010 2v4l4 8v1a1 1 0 01-1 1H4a1 1 0 01-1-1v-1l4-8V4a1 1 0 110-2h6zm-2 2H9v4l-2 4h6l-2-4V4z"];
  init_define_process();
  var label_default2 = ["M3 12h14v-1H3v1zm11-9H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V9l-6-6zm4 12H2V5h11v3H3v1h10v1h5v5zm-4-6V5l4 4h-4z"];
  init_define_process();
  var layer_default2 = ["M19.5 9.1l-9-5c-.2-.1-.3-.1-.5-.1s-.3 0-.5.1l-9 5c-.3.2-.5.5-.5.9s.2.7.5.9l9 5c.2.1.3.1.5.1s.3 0 .5-.1l9-5c.3-.2.5-.5.5-.9s-.2-.7-.5-.9z"];
  init_define_process();
  var layer_outline_default2 = ["M9.514 4.126l-9 5a1 1 0 000 1.748l9 5a1 1 0 00.972 0l9-5a1 1 0 000-1.748l-9-5a1 1 0 00-.972 0zM10 6.144l6.94 3.855L10 13.855 3.059 9.999 10 6.144z"];
  init_define_process();
  var layers_default2 = ["M.5 6.9l9 5c.2.1.3.1.5.1s.3 0 .5-.1l9-5c.3-.2.5-.5.5-.9s-.2-.7-.5-.9l-9-5c-.2-.1-.3-.1-.5-.1s-.3 0-.5.1l-9 5c-.3.2-.5.5-.5.9s.2.7.5.9z", "M19 9c-.2 0-.3 0-.5.1L10 13.9 1.5 9.1C1.3 9 1.2 9 1 9c-.6 0-1 .4-1 1 0 .4.2.7.5.9l9 5c.2.1.3.1.5.1s.3 0 .5-.1l9-5c.3-.2.5-.5.5-.9 0-.6-.4-1-1-1z", "M19 13c-.2 0-.3 0-.5.1L10 17.9l-8.5-4.7c-.2-.2-.3-.2-.5-.2-.6 0-1 .4-1 1 0 .4.2.7.5.9l9 5c.2.1.3.1.5.1s.3 0 .5-.1l9-5c.3-.2.5-.5.5-.9 0-.6-.4-1-1-1z"];
  init_define_process();
  var layout_default2 = ["M18 6c-1.1 0-2 .9-2 2 0 .37.11.71.28 1.01l-2.27 2.27c-.3-.17-.64-.28-1.01-.28-.93 0-1.71.64-1.93 1.5H8.93c-.22-.86-1-1.5-1.93-1.5-.37 0-.71.11-1.01.28L3.72 9.01C3.89 8.71 4 8.37 4 8c0-.34-.09-.66-.24-.94l3.66-3.38c.31.2.68.32 1.08.32 1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2c0 .34.09.66.24.94L3.08 6.32C2.77 6.12 2.4 6 2 6 .9 6 0 6.9 0 8s.9 2 2 2c.37 0 .71-.11 1.01-.28l2.27 2.27c-.17.3-.28.64-.28 1.01s.11.71.28 1.01l-2.27 2.27C2.71 16.11 2.37 16 2 16c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2c0-.37-.11-.71-.28-1.01l2.27-2.27c.3.17.64.28 1.01.28.93 0 1.71-.64 1.93-1.5h2.14c.22.86 1 1.5 1.93 1.5 1.1 0 2-.9 2-2 0-.37-.11-.71-.28-1.01l2.27-2.27c.3.17.64.28 1.01.28 1.1 0 2-.9 2-2s-.9-2-2-2z"];
  init_define_process();
  var layout_auto_default2 = ["M18 13c-.53 0-1.01.21-1.37.55L11.9 10.6c.06-.19.1-.39.1-.6s-.04-.41-.1-.6l4.72-2.95c.37.34.85.55 1.38.55 1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2c0 .21.04.41.1.6l-4.73 2.96c-.24-.23-.54-.4-.87-.48V3.93c.86-.22 1.5-1 1.5-1.93 0-1.1-.9-2-2-2S8 .9 8 2c0 .93.64 1.71 1.5 1.93v4.14c-.33.09-.63.26-.87.48L3.9 5.6c.06-.19.1-.39.1-.6 0-1.1-.9-2-2-2s-2 .9-2 2 .9 2 2 2c.53 0 1.01-.21 1.37-.55L8.1 9.4c-.06.19-.1.39-.1.6s.04.41.1.6l-4.72 2.95C3.01 13.21 2.53 13 2 13c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2c0-.21-.04-.41-.1-.6l4.73-2.96c.24.23.54.4.87.48v4.14C8.64 16.29 8 17.07 8 18c0 1.1.9 2 2 2s2-.9 2-2c0-.93-.64-1.71-1.5-1.93v-4.14c.33-.09.63-.26.87-.48l4.73 2.96c-.06.18-.1.38-.1.59 0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2z"];
  init_define_process();
  var layout_balloon_default2 = ["M18 16c-.14 0-.28.02-.42.05l-1.73-3.45c.69-.45 1.14-1.22 1.14-2.1s-.46-1.65-1.14-2.1l1.73-3.45c.14.03.28.05.42.05 1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2c0 .6.27 1.13.69 1.5l-1.77 3.54c-.14-.02-.28-.04-.42-.04a2.5 2.5 0 00-2.45 2h-4.1A2.5 2.5 0 005.5 8c-.14 0-.28.02-.42.04L3.31 4.5C3.73 4.13 4 3.6 4 3c0-1.1-.9-2-2-2s-2 .9-2 2 .9 2 2 2c.14 0 .28-.02.42-.05L4.14 8.4C3.46 8.85 3 9.62 3 10.5s.46 1.65 1.14 2.1l-1.73 3.45A1.84 1.84 0 002 16c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2c0-.6-.27-1.13-.69-1.5l1.77-3.54c.14.02.28.04.42.04a2.5 2.5 0 002.45-2h4.1a2.5 2.5 0 002.45 2c.14 0 .28-.02.42-.04l1.77 3.54c-.42.37-.69.9-.69 1.5 0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2z"];
  init_define_process();
  var layout_circle_default2 = ["M18.3 8c-.2-.9-.6-1.7-1.1-2.5.2-.3.3-.7.3-1 0-1.1-.9-2-2-2-.4 0-.7.1-1 .3-.8-.5-1.6-.8-2.5-1.1-.1-1-1-1.7-2-1.7S8.2.8 8 1.7c-.9.3-1.7.6-2.5 1.1-.3-.2-.7-.3-1-.3-1.1 0-2 .9-2 2 0 .4.1.7.3 1-.5.8-.8 1.6-1.1 2.5C.8 8.2 0 9 0 10s.8 1.8 1.7 2c.2.9.6 1.7 1.1 2.5-.2.3-.3.7-.3 1 0 1.1.9 2 2 2 .4 0 .7-.1 1-.3.8.5 1.6.8 2.5 1.1.1 1 1 1.7 2 1.7s1.8-.8 2-1.7c.9-.2 1.7-.6 2.5-1.1.3.2.7.3 1 .3 1.1 0 2-.9 2-2 0-.4-.1-.7-.3-1 .5-.8.8-1.6 1.1-2.5 1-.1 1.7-1 1.7-2s-.8-1.8-1.7-2zm-1.8 5.8c-.3-.2-.6-.3-1-.3-1.1 0-2 .9-2 2 0 .4.1.7.3 1-.6.3-1.2.6-1.9.8-.3-.7-1-1.3-1.9-1.3-.8 0-1.6.5-1.9 1.3-.7-.2-1.3-.4-1.9-.8.2-.3.3-.6.3-1 0-1.1-.9-2-2-2-.4 0-.7.1-1 .3-.3-.6-.6-1.2-.8-1.9.8-.3 1.3-1.1 1.3-1.9s-.5-1.6-1.2-1.8c.2-.7.4-1.3.8-1.9.3.2.6.3 1 .3 1.1 0 2-.9 2-2 0-.4-.1-.7-.3-1 .6-.3 1.2-.6 1.9-.8.2.7 1 1.2 1.8 1.2s1.6-.5 1.9-1.3c.7.2 1.3.4 1.9.8-.2.3-.3.6-.3 1 0 1.1.9 2 2 2 .4 0 .7-.1 1-.3.3.6.6 1.2.8 1.9-.8.3-1.3 1.1-1.3 1.9s.5 1.6 1.2 1.8c-.1.7-.4 1.4-.7 2z"];
  init_define_process();
  var layout_grid_default2 = ["M2 0a2 2 0 100 4 2 2 0 100-4zM10 0a2 2 0 100 4 2 2 0 100-4zM18 0a2 2 0 100 4 2 2 0 100-4zM18 8a2 2 0 100 4 2 2 0 100-4zM18 16a2 2 0 100 4 2 2 0 100-4zM10 16a2 2 0 100 4 2 2 0 100-4zM2 16a2 2 0 100 4 2 2 0 100-4zM2 8a2 2 0 100 4 2 2 0 100-4zM10 8a2 2 0 100 4 2 2 0 100-4z"];
  init_define_process();
  var layout_group_by_default2 = ["M2 2a2 2 0 100 4 2 2 0 100-4zM18 0a2 2 0 100 4 2 2 0 100-4zM18 8a2 2 0 100 4 2 2 0 100-4zM18 16a2 2 0 100 4 2 2 0 100-4zM2 14a2 2 0 100 4 2 2 0 100-4zM2 8a2 2 0 100 4 2 2 0 100-4zM13 12a2 2 0 100 4 2 2 0 100-4zM13 4a2 2 0 100 4 2 2 0 100-4z"];
  init_define_process();
  var layout_hierarchy_default2 = ["M18.5 16.07v-4.14c.86-.22 1.5-1 1.5-1.93 0-1.1-.9-2-2-2-.93 0-1.71.64-1.93 1.5h-4.14c-.18-.7-.73-1.25-1.43-1.43V3.93c.86-.22 1.5-1 1.5-1.93 0-1.1-.9-2-2-2S8 .9 8 2c0 .93.64 1.71 1.5 1.93v4.14c-.7.18-1.25.73-1.43 1.43H3.93C3.71 8.64 2.93 8 2 8c-1.1 0-2 .9-2 2 0 .93.64 1.71 1.5 1.93v4.14c-.86.22-1.5 1-1.5 1.93 0 1.1.9 2 2 2s2-.9 2-2c0-.93-.64-1.71-1.5-1.93v-4.14c.7-.18 1.25-.73 1.43-1.43h4.14c.18.7.73 1.25 1.43 1.43v4.14c-.86.22-1.5 1-1.5 1.93 0 1.1.9 2 2 2s2-.9 2-2c0-.93-.64-1.71-1.5-1.93v-4.14c.7-.18 1.25-.73 1.43-1.43h4.14c.18.7.73 1.25 1.43 1.43v4.14c-.86.22-1.5 1-1.5 1.93 0 1.1.9 2 2 2s2-.9 2-2c0-.93-.64-1.71-1.5-1.93z"];
  init_define_process();
  var layout_linear_default2 = ["M16.5 7a2.5 2.5 0 00-2.45 2h-2.1a2.5 2.5 0 00-4.9 0h-2.1a2.5 2.5 0 100 1h2.1a2.5 2.5 0 004.9 0h2.1a2.5 2.5 0 102.45-3z"];
  init_define_process();
  var layout_skew_grid_default2 = ["M2 0a2 2 0 100 4 2 2 0 100-4zM18 0a2 2 0 100 4 2 2 0 100-4zM18 8a2 2 0 100 4 2 2 0 100-4zM18 16a2 2 0 100 4 2 2 0 100-4zM2 16a2 2 0 100 4 2 2 0 100-4zM2 8a2 2 0 100 4 2 2 0 100-4zM10 12a2 2 0 100 4 2 2 0 100-4zM10 4a2 2 0 100 4 2 2 0 100-4z"];
  init_define_process();
  var layout_sorted_clusters_default2 = ["M2 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM2 0C.9 0 0 .9 0 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm16 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-8 4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"];
  init_define_process();
  var learning_default2 = ["M10.551 1.127a1.256 1.256 0 00-1.102 0L.456 5.89c-.608.309-.608.913 0 1.222l8.993 4.762c.334.17.767.17 1.102 0l8.992-4.762c.61-.309.61-.913 0-1.222l-8.992-4.762z", "M18 6.5l.016 4.514c.002.548.447.99.994.99a.99.99 0 00.99-.99V6.5h-2zM3.366 10.033l6.401 3.358a.5.5 0 00.465 0l6.406-3.358a.25.25 0 01.366.221v5.109a.25.25 0 01-.139.224l-6.64 3.302a.5.5 0 01-.446 0l-6.64-3.302A.25.25 0 013 15.363v-5.108a.25.25 0 01.366-.222z"];
  init_define_process();
  var left_join_default2 = ["M8.7 4.7C7.4 6 6.5 7.9 6.5 10s.8 4 2.2 5.3c-.8.5-1.7.7-2.7.7-3.3 0-6-2.7-6-6s2.7-6 6-6c1 0 1.9.2 2.7.7zM14 4c3.3 0 6 2.7 6 6s-2.7 6-6 6c-1 0-1.9-.2-2.7-.7 1.3-1.3 2.2-3.2 2.2-5.3s-.8-3.9-2.2-5.3C12.1 4.2 13 4 14 4zm.6 2.05c.55 1.2.86 2.54.86 3.95s-.31 2.75-.86 3.95c1.9-.31 3.36-1.96 3.36-3.95S16.5 6.36 14.6 6.05zM10 5.5C8.8 6.7 8 8.2 8 10s.8 3.3 2 4.4c1.2-1.1 2-2.7 2-4.5s-.8-3.3-2-4.4z"];
  init_define_process();
  var less_than_default2 = ["M7.162 10l9.154 3.052a1 1 0 01-.632 1.897l-12-4c-.912-.304-.912-1.594 0-1.897l12-4a1 1 0 01.632 1.897L7.162 10z"];
  init_define_process();
  var less_than_or_equal_to_default2 = ["M16.316 11.051L7.162 8l9.154-3.051a1 1 0 10-.632-1.898l-12 4c-.912.304-.912 1.594 0 1.898l12 4a1 1 0 10.632-1.898zM16 15H4a1 1 0 100 2h12a1 1 0 100-2z"];
  init_define_process();
  var lifesaver_default2 = ["M8.143 14.644L7.028 17.43c.919.368 1.922.57 2.972.57s2.053-.202 2.972-.57l-1.115-2.786A4.986 4.986 0 0110 15a4.986 4.986 0 01-1.857-.356zm-2.787-2.787A4.986 4.986 0 015 10c0-.656.126-1.283.356-1.857L2.57 7.028A7.978 7.978 0 002 10c0 1.05.202 2.053.57 2.972l2.786-1.115zm2.787-6.5A4.986 4.986 0 0110 5c.656 0 1.283.126 1.857.356l1.115-2.786A7.978 7.978 0 0010 2c-1.05 0-2.053.202-2.972.57l1.115 2.786zm6.5 2.786c.23.574.357 1.2.357 1.857 0 .656-.126 1.283-.356 1.857l2.786 1.115c.368-.919.57-1.922.57-2.972s-.202-2.053-.57-2.972l-2.786 1.115zM10 13a3 3 0 100-6 3 3 0 000 6zm0 7C4.477 20 0 15.523 0 10S4.477 0 10 0s10 4.477 10 10-4.477 10-10 10z"];
  init_define_process();
  var lightbulb_default2 = ["M6.33 13.39c0 .34.27.61.6.61h6.13c.33 0 .6-.27.6-.61C14.03 9.78 16 9.4 16 6.09 16 2.72 13.31 0 10 0S4 2.72 4 6.09c0 3.31 1.97 3.69 2.33 7.3zM13 15H7c-.55 0-1 .45-1 1s.45 1 1 1h6c.55 0 1-.45 1-1s-.45-1-1-1zm-1 3H8c-.55 0-1 .45-1 1s.45 1 1 1h4c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var lightning_default2 = ["M9 11H6a1 1 0 01-1-1L5.91.9a1 1 0 01.995-.9h6.256a.839.839 0 01.779 1.15L11.2 8h2.978a.822.822 0 01.748 1.162l-4.764 10.481A.608.608 0 019 19.392V11z"];
  init_define_process();
  var link_default2 = ["M10.85 11.98l-4.44 4.44-1 1c-.36.36-.86.58-1.41.58-1.1 0-2-.9-2-2 0-.55.22-1.05.59-1.41l5.44-5.44C7.69 9.06 7.36 9 7 9c-1.11 0-2.09.46-2.82 1.18l-.01-.01-3 3 .01.01C.46 13.91 0 14.89 0 16c0 2.21 1.79 4 4 4 1.11 0 2.09-.46 2.82-1.18l.01.01 3-3-.01-.01C10.54 15.09 11 14.11 11 13c0-.36-.06-.69-.15-1.02zM20 4c0-2.21-1.79-4-4-4-1.11 0-2.09.46-2.82 1.18l-.01-.01-3 3 .01.01C9.46 4.91 9 5.89 9 7c0 .36.06.69.15 1.02l4.44-4.44 1-1c.36-.36.86-.58 1.41-.58 1.1 0 2 .9 2 2 0 .55-.22 1.05-.59 1.41l-5.44 5.44c.34.09.67.15 1.03.15 1.11 0 2.09-.46 2.82-1.18l.01.01 3-3-.01-.01C19.54 6.09 20 5.11 20 4zM5 14a1.003 1.003 0 001.71.71l8-8a1.003 1.003 0 00-1.42-1.42l-2 2-2 2-2 2-2 2c-.18.18-.29.43-.29.71z"];
  init_define_process();
  var list_default2 = ["M1.03 1C.46 1 0 1.46 0 2.03v.95C0 3.54.46 4 1.03 4h17.95C19.54 4 20 3.54 20 2.97v-.94C20 1.46 19.54 1 18.97 1H1.03zM0 17.97C0 18.54.46 19 1.03 19h17.95c.56 0 1.03-.46 1.03-1.03v-.95c0-.56-.46-1.03-1.03-1.03H1.03C.46 16 0 16.46 0 17.03v.94zM0 12.97C0 13.54.46 14 1.03 14h17.95c.56 0 1.03-.46 1.03-1.03v-.95c0-.56-.46-1.03-1.03-1.03H1.03C.46 11 0 11.46 0 12.03v.94zM0 7.97C0 8.54.46 9 1.03 9h17.95C19.54 9 20 8.54 20 7.97v-.94C20 6.46 19.54 6 18.97 6H1.03C.46 6 0 6.46 0 7.03v.94z"];
  init_define_process();
  var list_columns_default2 = ["M0 2.973v-.936C0 1.468.46 1.01 1.029 1H7.97C8.541 1 9 1.468 9 2.027v.946C9 3.542 8.53 4 7.971 4H1.03C.459 4 0 3.542 0 2.973zm0 5v-.936C0 6.468.46 6.01 1.029 6H7.97C8.541 6 9 6.468 9 7.027v.946C9 8.542 8.53 9 7.971 9H1.03C.459 9 0 8.542 0 7.973zm0 5v-.936C0 11.468.46 11.01 1.029 11H7.97C8.541 11 9 11.468 9 12.027v.946C9 13.542 8.53 14 7.971 14H1.03C.459 14 0 13.542 0 12.973zm0 5v-.936C0 16.468.46 16.01 1.029 16H7.97C8.541 16 9 16.468 9 17.027v.946C9 18.542 8.53 19 7.971 19H1.03C.459 19 0 18.542 0 17.973zm11-15v-.936c0-.569.46-1.027 1.029-1.037h6.942C19.541 1 20 1.468 20 2.027v.946C20 3.542 19.53 4 18.971 4H12.03C11.459 4 11 3.542 11 2.973zm0 5v-.936c0-.569.46-1.027 1.029-1.037h6.942C19.541 6 20 6.468 20 7.027v.946C20 8.542 19.53 9 18.971 9H12.03C11.459 9 11 8.542 11 7.973zm0 5v-.936c0-.569.46-1.027 1.029-1.037h6.942c.57 0 1.029.468 1.029 1.027v.946c0 .569-.47 1.027-1.029 1.027H12.03c-.57 0-1.029-.458-1.029-1.027zm0 5v-.936c0-.569.46-1.027 1.029-1.037h6.942c.57 0 1.029.468 1.029 1.027v.946c0 .569-.47 1.027-1.029 1.027H12.03c-.57 0-1.029-.458-1.029-1.027z"];
  init_define_process();
  var list_detail_view_default2 = ["M8 6H1c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h7c.55 0 1-.45 1-1V7c0-.55-.45-1-1-1zm0 5H1c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h7c.55 0 1-.45 1-1v-1c0-.55-.45-1-1-1zm0 5H1c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h7c.55 0 1-.45 1-1v-1c0-.55-.45-1-1-1zM8 1H1c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h7c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zm11 0h-7c-.55 0-1 .45-1 1v16c0 .55.45 1 1 1h7c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1z"];
  init_define_process();
  var locate_default2 = ["M10 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm9 1h-1.07c-.45-3.61-3.32-6.45-6.93-6.91V1c0-.55-.45-1-1-1S9 .45 9 1v1.09C5.39 2.55 2.52 5.39 2.07 9H1c-.55 0-1 .45-1 1s.45 1 1 1h1.07c.45 3.61 3.32 6.45 6.93 6.91V19c0 .55.45 1 1 1s1-.45 1-1v-1.09c3.61-.46 6.48-3.29 6.93-6.91H19c.55 0 1-.45 1-1s-.45-1-1-1zm-4 2h.9a5.98 5.98 0 01-4.9 4.91V15c0-.55-.45-1-1-1s-1 .45-1 1v.91A5.98 5.98 0 014.1 11H5c.55 0 1-.45 1-1s-.45-1-1-1h-.9A5.98 5.98 0 019 4.09V5c0 .55.45 1 1 1s1-.45 1-1v-.91A5.98 5.98 0 0115.9 9H15c-.55 0-1 .45-1 1s.45 1 1 1z"];
  init_define_process();
  var lock_default2 = ["M15.93 9H14V4.99c0-2.21-1.79-4-4-4s-4 1.79-4 4V9H3.93c-.55 0-.93.44-.93.99v8c0 .55.38 1.01.93 1.01h12c.55 0 1.07-.46 1.07-1.01v-8c0-.55-.52-.99-1.07-.99zM8 9V4.99c0-1.1.9-2 2-2s2 .9 2 2V9H8z"];
  init_define_process();
  var log_in_default2 = ["M19 0h-8c-.55 0-1 .45-1 1s.45 1 1 1h7v16h-7c-.55 0-1 .45-1 1s.45 1 1 1h8c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-4 10c0-.28-.11-.53-.29-.71l-5-5a1.003 1.003 0 00-1.42 1.42L11.59 9H1c-.55 0-1 .45-1 1s.45 1 1 1h10.59L8.3 14.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l5-5c.18-.18.29-.43.29-.71z"];
  init_define_process();
  var log_out_default2 = ["M19.71 9.29l-5-5a1.003 1.003 0 00-1.42 1.42L16.59 9H6c-.55 0-1 .45-1 1s.45 1 1 1h10.59l-3.29 3.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l5-5c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71zM9 18H2V2h7c.55 0 1-.45 1-1s-.45-1-1-1H1C.45 0 0 .45 0 1v18c0 .55.45 1 1 1h8c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var low_voltage_pole_default2 = ["M10 0a1 1 0 00-1 1v2H5V2a1 1 0 00-2 0v1H2a1 1 0 000 2h1v2H2a1 1 0 000 2h4a1 1 0 000-2H5V5h4v14a1 1 0 102 0V5h4v2h-1a1 1 0 100 2h4a1 1 0 100-2h-1V5h1a1 1 0 100-2h-1V2a1 1 0 10-2 0v1h-4V1a1 1 0 00-1-1z"];
  init_define_process();
  var manual_default2 = ["M20 1.1a.976.976 0 00-.83-.88C15.15-.43 12.07.34 10 2.5 7.93.34 4.85-.43.84.22.37.3.03.67 0 1.1v15.01c0 .07 0 .14.01.21.09.52.61.88 1.15.79 3.85-.62 6.4.16 8 2.46.02.02.03.04.05.07.02.02.04.04.06.07l.01.01a1.07 1.07 0 00.28.19c.01 0 .01.01.02.01.03.01.07.03.1.04.01 0 .02.01.04.01.03.01.07.02.1.02.01 0 .02 0 .04.01H10c.04 0 .09 0 .13-.01.01 0 .03 0 .04-.01.03-.01.06-.01.1-.02.01 0 .03-.01.04-.01.03-.01.07-.02.1-.04.01 0 .02-.01.03-.01.07-.03.13-.07.19-.11.01 0 .01-.01.02-.01.02-.02.04-.03.06-.05.01-.01.02-.02.03-.02l.05-.05c.01-.01.02-.02.02-.03.01-.02.02-.03.04-.05 1.61-2.3 4.15-3.09 8-2.46.54.09 1.06-.26 1.15-.79-.01-.05 0-.09 0-.13V1.1zM9 16.63c-1.78-1.31-4.12-1.83-7-1.55V2c3.26-.37 5.51.39 7 2.35v12.28zm9-1.56c-2.88-.28-5.22.24-7 1.55V4.34c1.49-1.96 3.74-2.71 7-2.35v13.08z"];
  init_define_process();
  var manually_entered_data_default2 = ["M1 12h4.34l2-2H1c-.55 0-1 .45-1 1s.45 1 1 1zm16.77-3.94l1.65-1.65c.36-.36.58-.86.58-1.41 0-1.1-.9-2-2-2-.55 0-1.05.22-1.41.59l-1.65 1.65 2.83 2.82zM1 4h12.34l2-2H1c-.55 0-1 .45-1 1s.45 1 1 1zM0 15c0 .55.45 1 1 1h.34l2-2H1c-.55 0-1 .45-1 1zm1-7h8.34l2-2H1c-.55 0-1 .45-1 1s.45 1 1 1zm18 2h-.34l-2 2H19c.55 0 1-.45 1-1s-.45-1-1-1zm0 4h-4.34l-2 2H19c.55 0 1-.45 1-1s-.45-1-1-1zM4 19l4.41-1.59-2.81-2.79L4 19zM14.23 5.94l-7.65 7.65 2.83 2.83 7.65-7.65-2.83-2.83z"];
  init_define_process();
  var many_to_many_default2 = ["M17 6a1 1 0 100-2 1 1 0 000 2zm0 2a3 3 0 01-2.73-1.754c-.2.068-.408.154-.617.264-.884.465-1.92 1.418-2.605 3.49.685 2.072 1.721 3.025 2.605 3.49.21.11.416.196.617.264a3 3 0 11-.165 2.034 6.262 6.262 0 01-1.383-.528c-.983-.518-1.948-1.364-2.722-2.705-.774 1.34-1.739 2.187-2.722 2.705-.48.252-.95.419-1.383.528A3.001 3.001 0 010 15a3 3 0 015.73-1.246c.2-.068.408-.154.617-.264.884-.465 1.92-1.418 2.605-3.49-.685-2.072-1.721-3.025-2.605-3.49a4.21 4.21 0 00-.617-.264 3 3 0 11.165-2.034c.433.11.904.276 1.383.528.983.518 1.948 1.364 2.722 2.705.774-1.34 1.739-2.187 2.722-2.705.48-.252.95-.419 1.383-.528A3.001 3.001 0 0120 5a3 3 0 01-3 3zM4 5a1 1 0 10-2 0 1 1 0 002 0zm12 10a1 1 0 102 0 1 1 0 00-2 0zM3 14a1 1 0 110 2 1 1 0 010-2z"];
  init_define_process();
  var many_to_one_default2 = ["M3 2a1 1 0 100 2 1 1 0 000-2zm0 4c1.296 0 2.4-.821 2.82-1.972.487.039 1.086.13 1.667.347.947.352 1.773 1 2.032 2.318.323 1.644 1.234 2.675 2.264 3.307-1.03.632-1.941 1.663-2.264 3.307-.259 1.318-1.085 1.966-2.032 2.318a6.244 6.244 0 01-1.668.347 3.001 3.001 0 10.019 2.004c.633-.042 1.491-.158 2.347-.476 1.402-.523 2.867-1.625 3.296-3.807.259-1.318 1.085-1.966 2.032-2.318.24-.09.484-.158.722-.21a3 3 0 100-2.33 5.329 5.329 0 01-.722-.21c-.947-.352-1.773-1-2.032-2.318-.428-2.182-1.894-3.284-3.296-3.807-.856-.318-1.714-.434-2.347-.476A3.001 3.001 0 000 3a3 3 0 003 3zm13 4a1 1 0 102 0 1 1 0 00-2 0zM2 17a1 1 0 112 0 1 1 0 01-2 0z"];
  init_define_process();
  var map_default2 = ["M19.54 4.18l.01-.02-6-4-.01.02C13.39.08 13.21 0 13 0s-.39.08-.54.18l-.01-.02L7 3.8 1.55.17l-.01.01A.969.969 0 001 0C.45 0 0 .45 0 1v14c0 .35.19.64.46.82l-.01.02 6 4 .01-.02c.15.1.33.18.54.18s.39-.08.54-.18l.01.02L13 16.2l5.45 3.63.01-.02c.15.11.33.19.54.19.55 0 1-.45 1-1V5c0-.35-.19-.64-.46-.82zM6 17.13l-4-2.67V2.87l4 2.67v11.59zm6-2.67l-4 2.67V5.54l4-2.67v11.59zm6 2.67l-4-2.67V2.87l4 2.67v11.59z"];
  init_define_process();
  var map_create_default2 = ["M18 9.22v7.91l-4-2.67V9.22c-.61-.55-1-1.33-1-2.22-.35 0-.69-.07-1-.18v7.65l-4 2.67V5.54l2.02-1.35c0-.06-.02-.13-.02-.19 0-1.66 1.34-3 3-3 0-.34.07-.66.17-.97C13.12.02 13.06 0 13 0c-.21 0-.39.08-.54.18l-.01-.02L7 3.8 1.55.17l-.01.01A.969.969 0 001 0C.45 0 0 .45 0 1v14c0 .35.19.64.46.82l-.01.02 6 4 .01-.02c.15.1.33.18.54.18s.39-.08.54-.18l.01.02L13 16.2l5.45 3.63.01-.02c.15.11.33.19.54.19.55 0 1-.45 1-1V6.82c-.31.11-.65.18-1 .18 0 .89-.39 1.67-1 2.22zM6 17.13l-4-2.67V2.87l4 2.67v11.59zM12 4c0 .55.45 1 1 1h2v2c0 .55.45 1 1 1s1-.45 1-1V5h2c.55 0 1-.45 1-1s-.45-1-1-1h-2V1c0-.55-.45-1-1-1s-1 .45-1 1v2h-2c-.55 0-1 .45-1 1z"];
  init_define_process();
  var map_marker_default2 = ["M9.98 0c-3.87 0-7 2.98-7 6.67 0 3.68 7 13.33 7 13.33s7-9.65 7-13.33c0-3.68-3.14-6.67-7-6.67zm0 10c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"];
  init_define_process();
  var maximize_default2 = ["M19 0h-5c-.55 0-1 .45-1 1s.45 1 1 1h2.59L11.3 7.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L18 3.41V6c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1zM8 11c-.28 0-.53.11-.71.29L2 16.59V14c0-.55-.45-1-1-1s-1 .45-1 1v5c0 .55.45 1 1 1h5c.55 0 1-.45 1-1s-.45-1-1-1H3.41l5.29-5.29c.19-.18.3-.43.3-.71 0-.55-.45-1-1-1z"];
  init_define_process();
  var media_default2 = ["M15 9c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm4-7H1c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1zm-1 13l-6-5-2 2-4-5-4 8V4h16v11z"];
  init_define_process();
  var menu_default2 = ["M1 6h18c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1zm18 3H1c-.55 0-1 .45-1 1s.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1zm0 5H1c-.55 0-1 .45-1 1s.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var menu_closed_default2 = ["M8 6h11c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1s.45 1 1 1zM4 6c-.28 0-.53.11-.71.29l-3 3C.11 9.47 0 9.72 0 10c0 .28.11.53.29.71l3 3A1.003 1.003 0 005 13V7c0-.55-.45-1-1-1zm15 8H8c-.55 0-1 .45-1 1s.45 1 1 1h11c.55 0 1-.45 1-1s-.45-1-1-1zm0-5H8c-.55 0-1 .45-1 1s.45 1 1 1h11c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var menu_open_default2 = ["M12 9H1c-.55 0-1 .45-1 1s.45 1 1 1h11c.55 0 1-.45 1-1s-.45-1-1-1zm0 5H1c-.55 0-1 .45-1 1s.45 1 1 1h11c.55 0 1-.45 1-1s-.45-1-1-1zm0-10H1c-.55 0-1 .45-1 1s.45 1 1 1h11c.55 0 1-.45 1-1s-.45-1-1-1zm7.71 5.29l-3-3A1.003 1.003 0 0015 7v6a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71z"];
  init_define_process();
  var merge_columns_default2 = ["M6.71 6.29a1.003 1.003 0 00-1.42 1.42L6.59 9H2V2h5v2.18c.42.15.8.39 1.11.7l.01-.01.88.89V1c0-.55-.45-1-1-1H1C.45 0 0 .45 0 1v18c0 .55.45 1 1 1h7c.55 0 1-.45 1-1v-4.76l-.88.88-.01-.01c-.31.31-.69.56-1.11.71V18H2v-7h4.59L5.3 12.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71l-3-3zM19 0h-7c-.55 0-1 .45-1 1v4.76l.88-.88.01.01c.31-.31.69-.55 1.11-.7V2h5v7h-4.59l1.29-1.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-3 3c-.18.18-.29.43-.29.71 0 .28.11.53.29.71l3 3a1.003 1.003 0 001.42-1.42L13.41 11H18v7h-5v-2.18c-.42-.15-.8-.39-1.11-.7l-.01.01-.88-.89V19c0 .55.45 1 1 1h7c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var merge_links_default2 = ["M10 13c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm8-5c-.93 0-1.71.64-1.93 1.5H14V4c0-2.21-1.79-4-4-4S6 1.79 6 4v5.5H3.93C3.71 8.64 2.93 8 2 8c-1.1 0-2 .9-2 2s.9 2 2 2c.93 0 1.71-.64 1.93-1.5H6V16c0 2.21 1.79 4 4 4s4-1.79 4-4v-5.5h2.07c.22.86 1 1.5 1.93 1.5 1.1 0 2-.9 2-2s-.9-2-2-2zm-5 8c0 1.66-1.34 3-3 3s-3-1.34-3-3V4c0-1.66 1.34-3 3-3s3 1.34 3 3v12zM10 3c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"];
  init_define_process();
  var minimize_default2 = ["M8 11H3c-.55 0-1 .45-1 1s.45 1 1 1h2.59L.3 18.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L7 14.41V17c0 .55.45 1 1 1s1-.45 1-1v-5c0-.55-.45-1-1-1zM20 1a1.003 1.003 0 00-1.71-.71L13 5.59V3c0-.55-.45-1-1-1s-1 .45-1 1v5c0 .55.45 1 1 1h5c.55 0 1-.45 1-1s-.45-1-1-1h-2.59l5.29-5.29c.19-.18.3-.43.3-.71z"];
  init_define_process();
  var minus_default2 = ["M16 9H4c-.55 0-1 .45-1 1s.45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var mobile_phone_default2 = ["M15 0H5c-.55 0-1 .45-1 1v18c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-5 19c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm4-3H6V3h8v13z"];
  init_define_process();
  var mobile_video_default2 = ["M19 5c-.28 0-.53.11-.71.29L15 8.59V5c0-.55-.45-1-1-1H1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h13c.55 0 1-.45 1-1v-3.59l3.29 3.29c.18.19.43.3.71.3.55 0 1-.45 1-1V6c0-.55-.45-1-1-1z"];
  init_define_process();
  var modal_default2 = ["M19 1a1 1 0 011 1v16a1 1 0 01-1 1H1a1 1 0 01-1-1V2a1 1 0 011-1h18zm-1 4H2v12h16V5zm-3-3h-2v2h2V2zm3 0h-2v2h2V2z"];
  init_define_process();
  var modal_filled_default2 = ["M20 5v13a1 1 0 01-1 1H1a1 1 0 01-1-1V5h20zm-3-4h2a1 1 0 011 1v1h-3V1zm-2 2H0V2a1 1 0 011-1h14v2z"];
  init_define_process();
  var moon_default2 = ["M19 14.15A9.94 9.94 0 019.94 20C4.45 20 0 15.55 0 10.06 0 6.03 2.4 2.56 5.85 1a9.811 9.811 0 00-.88 4.09c0 5.49 4.45 9.94 9.94 9.94 1.46 0 2.84-.31 4.09-.88z"];
  init_define_process();
  var more_default2 = ["M3.5 8a2.5 2.5 0 100 5 2.5 2.5 0 100-5zM17.5 8a2.5 2.5 0 100 5 2.5 2.5 0 100-5zM10.5 8a2.5 2.5 0 100 5 2.5 2.5 0 100-5z"];
  init_define_process();
  var mountain_default2 = ["M20 16H4l7-11h1l2 2h1l5 9zm-4-5l-1.5-3h-1l-1-1-1-1L8 11.5l3-1.5 1 1 1-1 3 1zM8.055 8L2.79 16H0l7-8h1.055z"];
  init_define_process();
  var move_default2 = ["M19.71 9.29l-3-3a1.003 1.003 0 00-1.42 1.42L16.59 9H11V3.41l1.29 1.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-3-3C10.53.11 10.28 0 10 0s-.53.11-.71.29l-3 3a1.003 1.003 0 001.42 1.42L9 3.41V9H3.41L4.7 7.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-3 3C.11 9.47 0 9.72 0 10c0 .28.11.53.29.71l3 3a1.003 1.003 0 001.42-1.42L3.41 11H9v5.59L7.71 15.3A.965.965 0 007 15a1.003 1.003 0 00-.71 1.71l3 3c.18.18.43.29.71.29s.53-.11.71-.29l3-3a1.003 1.003 0 00-1.42-1.42L11 16.59V11h5.59l-1.29 1.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71z"];
  init_define_process();
  var mugshot_default2 = ["M19 0H1C.45 0 0 .45 0 1v18c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 18h-.07c-.05-.2-.12-.42-.22-.67-.46-1.05-2.68-1.75-4.16-2.4-1.48-.65-1.28-1.05-1.33-1.59-.01-.07-.01-.15-.01-.23.51-.45.92-1.07 1.19-1.78 0 0 .01-.04.02-.05.06-.15.11-.32.15-.48.34-.07.54-.44.61-.78.08-.14.23-.48.2-.87-.05-.5-.25-.73-.47-.82v-.09c0-.63-.06-1.55-.17-2.15-.02-.17-.06-.33-.11-.5a3.67 3.67 0 00-1.29-1.86C11.7 3.25 10.81 3 10.02 3s-1.68.25-2.31.73c-.61.47-1.07 1.13-1.29 1.86-.05.16-.09.33-.11.5-.12.6-.17 1.51-.17 2.14v.08c-.24.09-.44.32-.49.83-.04.39.12.73.2.87.08.35.28.72.63.78.04.17.09.33.15.48 0 .01.01.02.01.03l.01.01c.27.72.7 1.35 1.22 1.8 0 .07-.01.14-.01.21-.05.54.1.94-1.38 1.59-1.48.65-3.7 1.35-4.16 2.4-.12.27-.18.49-.23.69H2V2h16v16z"];
  init_define_process();
  var multi_select_default2 = ["M19 3H7c-.55 0-1 .45-1 1v1h12v6h1c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1zm-6 6H1c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1zm-1 6H2v-4h10v4zm4-9H4c-.55 0-1 .45-1 1v1h12v6h1c.55 0 1-.45 1-1V7c0-.55-.45-1-1-1z"];
  init_define_process();
  var music_default2 = ["M19 0c-.08 0-.16.03-.24.05V.03l-12 3v.02C6.33 3.16 6 3.53 6 4v11.35c-.59-.22-1.27-.35-2-.35-2.21 0-4 1.12-4 2.5S1.79 20 4 20c1.94 0 3.55-.86 3.92-2H8V7.78l10-2.5v7.07c-.59-.22-1.27-.35-2-.35-2.21 0-4 1.12-4 2.5s1.79 2.5 4 2.5c1.94 0 3.55-.86 3.92-2H20V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var nest_default2 = ["M2 2c.55 0 1 .45 1 1v5c0 2.21 1.79 4 4 4h8.59L13.3 9.71A.965.965 0 0113 9a1.003 1.003 0 011.71-.71l4 4c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-4 4a1.003 1.003 0 01-1.42-1.42l2.3-2.29H7c-3.31 0-6-2.69-6-6V3c0-.55.45-1 1-1z"];
  init_define_process();
  var new_drawing_default2 = ["M18.7 13.7c.5 0 1 .4 1 1 0 .257-.073.44-.22.614l-.08.086-4 4c-.2.2-.4.3-.7.3-.6 0-1-.5-1-1 0-.257.073-.44.22-.614L14 18l4-4c.2-.2.4-.3.7-.3zM1.8 0l8.378 2.982A3.003 3.003 0 0013 7a3.003 3.003 0 003.877 2.87l.723 2.53.049.06a.41.41 0 01.051.24c0 .167-.07.403-.208.593l-.092.107-4 4c-.2.2-.4.3-.7.3-.075 0-.15-.056-.225-.084L12.4 17.6l-7-2-.112-.042c-.223-.094-.431-.244-.542-.45L4.7 15 0 1.8l.5-.6L7 7.7c-.2.3-.3.6-.3 1 0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2a1.68 1.68 0 00-.871.22L7.7 7 1.2.5l.6-.5zM16 0c.55 0 1 .45 1 1v2h2c.55 0 1 .45 1 1s-.45 1-1 1h-2v2c0 .432-.278.803-.664.941l-.01.004A.989.989 0 0116 8c-.55 0-1-.45-1-1V5h-2c-.55 0-1-.45-1-1l.007-.116C12.065 3.388 12.489 3 13 3h2V1c0-.55.45-1 1-1z"];
  init_define_process();
  var new_grid_item_default2 = ["M8 0H1C.45 0 0 .45 0 1v7c0 .55.45 1 1 1h7c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm0 11H1c-.55 0-1 .45-1 1v7c0 .55.45 1 1 1h7c.55 0 1-.45 1-1v-7c0-.55-.45-1-1-1zm6 7h-1v-1c0-.55-.45-1-1-1s-1 .45-1 1v2c0 .55.45 1 1 1h2c.55 0 1-.45 1-1s-.45-1-1-1zm5-7h-2c-.55 0-1 .45-1 1s.45 1 1 1h1v1c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1zm0-11h-7c-.55 0-1 .45-1 1v7c0 .55.45 1 1 1h7c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-5 11h-2c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1s1-.45 1-1v-1h1c.55 0 1-.45 1-1s-.45-1-1-1zm5 5c-.55 0-1 .45-1 1v1h-1c-.55 0-1 .45-1 1s.45 1 1 1h2c.55 0 1-.45 1-1v-2c0-.55-.45-1-1-1z"];
  init_define_process();
  var new_layer_default2 = ["M11.513 2.663A2 2 0 0013 6h1v1a2 2 0 104 0v-.733l1.5.833c.3.2.5.5.5.9s-.2.7-.5.9l-9 5c-.2.1-.3.1-.5.1s-.3 0-.5-.1l-9-5C.2 8.7 0 8.4 0 8s.2-.7.5-.9l9-5c.2-.1.3-.1.5-.1s.3 0 .5.1l1.013.563zM17 3h2a1 1 0 010 2h-2v2a1 1 0 01-2 0V5h-2a1 1 0 010-2h2V1a1 1 0 012 0v2z"];
  init_define_process();
  var new_layers_default2 = ["M17 3h2a1 1 0 010 2h-2v2a1 1 0 01-2 0V5h-2a1 1 0 010-2h2V1a1 1 0 012 0v2zm-1.252 5.984L10.5 11.9c-.2.1-.3.1-.5.1s-.3 0-.5-.1l-9-5C.2 6.7 0 6.4 0 6s.2-.7.5-.9l9-5c.2-.1.3-.1.5-.1s.3 0 .5.1L13.92 2H13a2 2 0 100 4h1v1a2 2 0 001.748 1.984zm2.07-1.15C17.935 7.58 18 7.298 18 7V6h1c.353 0 .684-.091.972-.251.018.078.028.162.028.251 0 .4-.2.7-.5.9l-1.682.934zM19 9c.6 0 1 .4 1 1 0 .4-.2.7-.5.9l-9 5c-.2.1-.3.1-.5.1s-.3 0-.5-.1l-9-5c-.3-.2-.5-.5-.5-.9 0-.6.4-1 1-1 .2 0 .3 0 .5.1l8.5 4.8 8.5-4.8c.2-.1.3-.1.5-.1zm0 4c.6 0 1 .4 1 1 0 .4-.2.7-.5.9l-9 5c-.2.1-.3.1-.5.1s-.3 0-.5-.1l-9-5c-.3-.2-.5-.5-.5-.9 0-.6.4-1 1-1 .2 0 .3 0 .5.2l8.5 4.7 8.5-4.8c.2-.1.3-.1.5-.1z"];
  init_define_process();
  var new_link_default2 = ["M14.5 12a2.5 2.5 0 00-2.45 2h-7.1a2.5 2.5 0 100 1h7.1a2.5 2.5 0 102.45-3zM19 5h-2V3c0-.55-.45-1-1-1s-1 .45-1 1v2h-2c-.55 0-1 .45-1 1s.45 1 1 1h2v2c0 .55.45 1 1 1s1-.45 1-1V7h2c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var new_object_default2 = ["M12 4c0 .6.4 1 1 1h2v2c0 .6.4 1 1 1 .5 0 1-.4 1-1V5h2c.5 0 1-.4 1-1s-.5-1-1-1h-2V1c0-.6-.5-1-1-1-.6 0-1 .4-1 1v2h-2c-.6 0-1 .5-1 1zm7 3c0 1.7-1.3 3-3 3s-3-1.3-3-3c-1.7 0-3-1.3-3-3s1.3-3 3-3c0-.2 0-.4.1-.5-1-.3-2-.5-3.1-.5C4.5 0 0 4.5 0 10s4.5 10 10 10 10-4.5 10-10c0-1.1-.2-2.1-.5-3H19z"];
  init_define_process();
  var new_person_default2 = ["M11.41 15.92c-1.46-.65-1.26-1.05-1.31-1.59-.01-.07-.01-.15-.01-.23.5-.45.91-1.07 1.18-1.78 0 0 .01-.04.02-.05.06-.15.11-.32.15-.48.33-.07.53-.44.6-.78.08-.14.23-.48.2-.87-.05-.5-.24-.73-.47-.82v-.09c0-.63-.06-1.55-.17-2.15-.02-.17-.06-.33-.11-.5-.22-.73-.67-1.4-1.27-1.86C9.58 4.25 8.7 4 7.92 4c-.78 0-1.66.25-2.28.73-.61.47-1.06 1.13-1.27 1.86-.05.16-.08.33-.11.5-.12.6-.18 1.51-.18 2.14v.08c-.23.09-.43.32-.48.83-.04.39.12.73.2.87.08.35.28.72.62.78.04.17.09.33.15.48 0 .01.01.02.01.03l.01.01c.27.72.69 1.35 1.21 1.8 0 .07-.01.14-.01.21-.05.54.1.94-1.36 1.59-1.46.65-3.66 1.35-4.11 2.4C-.14 19.38.04 20 .04 20h15.75s.18-.62-.27-1.67c-.45-1.06-2.65-1.75-4.11-2.41zM18.87 3h-2V1c0-.55-.45-1-1-1s-1 .45-1 1v2h-2c-.55 0-1 .45-1 1s.45 1 1 1h2v2c0 .55.45 1 1 1s1-.45 1-1V5h2c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var new_prescription_default2 = ["M11.95 10.23c.16-.18.22-.22.46-.22h1.48c.25 0 .47.08.59.33.1.2.09.41-.05.66l-2.71 3.58L14.88 19c.13.21.16.46.03.69-.12.21-.34.31-.57.31H12.7c-.31 0-.56-.17-.7-.44l-1.9-2.67-1.93 2.68c-.15.27-.42.43-.73.43H5.98c-.25 0-.47-.08-.59-.33-.1-.2-.09-.41.05-.66l3.09-4.35L4.26 9H3v4.32c0 .41-.3.69-.7.69H.7c-.41 0-.7-.28-.7-.69V.69C0 .28.3 0 .7 0h4.42c.71 0 1.36.1 1.94.3.59.2 1.11.49 1.54.87.44.38.78.84 1.02 1.39.25.54.37 1.13.37 1.77 0 1.01-.28 1.88-.84 2.6-.43.54-1.35 1.29-2 1.59l3.09 3.94 1.71-2.23zM4.71 6.04c.71 0 1.45-.16 1.81-.46.33-.28.5-.69.5-1.25s-.17-.97-.5-1.25c-.35-.3-1.1-.46-1.81-.46h-1.7v3.42h1.7zM19 3c.55 0 1 .45 1 1s-.45 1-1 1h-2v2c0 .55-.45 1-1 1s-1-.45-1-1V5h-2c-.55 0-1-.45-1-1s.45-1 1-1h2V1c0-.55.45-1 1-1s1 .45 1 1v2h2z"];
  init_define_process();
  var new_text_box_default2 = ["M19 3h-2V1c0-.55-.45-1-1-1s-1 .45-1 1v2h-2c-.55 0-1 .45-1 1s.45 1 1 1h2v2c0 .55.45 1 1 1s1-.45 1-1V5h2c.55 0 1-.45 1-1s-.45-1-1-1zM5 7.5v1c0 .28.22.5.5.5s.5-.22.5-.5V8h2v7h-.5c-.28 0-.5.22-.5.5s.22.5.5.5h2c.28 0 .5-.22.5-.5s-.22-.5-.5-.5H9V8h2v.5c0 .28.22.5.5.5s.5-.22.5-.5v-1c0-.28-.22-.5-.5-.5h-6c-.28 0-.5.22-.5.5zM16 9c-.55 0-1 .45-1 1v8H2V5h8c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1v15c0 .55.45 1 1 1h15c.55 0 1-.45 1-1v-9c0-.55-.45-1-1-1z"];
  init_define_process();
  var ninja_default2 = ["M20 6s-2.98 2.43-6.12 2.19C13.52 5.31 12.05 0 6 0c0 0 2.41 2.99 2.16 6.12C5.27 6.49 0 7.97 0 14c0 0 2.98-2.43 6.11-2.19C6.47 14.69 7.94 20 14 20c0 0-2.42-2.99-2.16-6.13C14.73 13.51 20 12.02 20 6zm-10 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"];
  init_define_process();
  var not_equal_to_default2 = ["M9.487 7l.532-3.196a1 1 0 011.962.392L11.513 7H16a1 1 0 010 2h-4.82l-.333 2H16a1 1 0 010 2h-5.487l-.532 3.196a1 1 0 01-1.962-.392L8.487 13H4a1 1 0 010-2h4.82l.333-2H4a1 1 0 110-2h5.487z"];
  init_define_process();
  var notifications_default2 = ["M10 20c1.1 0 2-.9 2-2H8c0 1.1.9 2 2 2zm7-5c-.55 0-1-.45-1-1V8c0-2.61-1.67-4.81-4-5.63V2c0-1.1-.9-2-2-2S8 .9 8 2v.37C5.67 3.19 4 5.39 4 8v6c0 .55-.45 1-1 1s-1 .45-1 1 .45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var notifications_snooze_default2 = ["M10 18c0 1.1-.9 2-2 2s-2-.9-2-2zM8 0c.476 0 .914.168 1.258.448C8.508.878 8.09 1.562 8 2.5c-.133 1.4.4 2.367 1.6 2.9C8.533 6.6 8 7.467 8 8v1.2a2.8 2.8 0 002.8 2.8H14v2c0 .51.388.935.884.993L15 15c.55 0 1 .45 1 1s-.45 1-1 1H1c-.55 0-1-.45-1-1s.45-1 1-1 1-.45 1-1V8c0-2.61 1.67-4.81 4-5.63V2c0-1.1.9-2 2-2z", "M16 9.25v-.395a.75.75 0 00-.75-.75h-2.813L15.834 3.9A.75.75 0 0016 3.43v-.68a.75.75 0 00-.75-.75h-4.5a.75.75 0 00-.75.75v.184c0 .414.336.75.75.75h2.813L10.22 7.831a1 1 0 00-.221.627v.792c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75z"];
  init_define_process();
  var notifications_updated_default2 = ["M10 20c1.1 0 2-.9 2-2H8c0 1.1.9 2 2 2zm2-17.834A2.994 2.994 0 008 4.99c0 .808.319 1.557.876 2.114l2.97 2.99a2.99 2.99 0 004.154.072V14c0 .55.45 1 1 1s1 .45 1 1-.45 1-1 1H3c-.55 0-1-.45-1-1s.45-1 1-1 1-.45 1-1V8c0-2.61 1.67-4.81 4-5.63V2c0-1.1.9-2 2-2s2 .9 2 2v.166zm1.26 6.514l-2.97-2.99a.973.973 0 01-.29-.7c0-.55.44-1 .99-1 .27 0 .52.11.7.29l2.28 2.28 4.27-4.27a.99.99 0 01.7-.29c.55 0 1 .45 1 1 0 .28-.11.53-.3.7l-4.98 4.98a.99.99 0 01-1.4 0z"];
  init_define_process();
  var numbered_list_default2 = ["M1.74 9.01h1.27V1h-.95c-.04.24-.12.45-.26.62-.13.17-.29.3-.47.41-.19.11-.4.18-.63.23-.23.04-.46.07-.71.07v1.03h1.75v5.65zm.43 7.93c.18-.14.37-.28.58-.43.21-.14.42-.29.63-.45.21-.16.41-.33.61-.5.2-.18.37-.38.52-.59.15-.21.28-.45.37-.7.09-.25.14-.54.14-.85 0-.25-.04-.52-.12-.8-.08-.28-.21-.54-.39-.78-.19-.24-.43-.44-.73-.59-.3-.17-.68-.25-1.12-.25-.41 0-.77.08-1.08.23-.32.16-.58.37-.8.64-.22.27-.38.59-.49.96-.11.37-.16.77-.16 1.21h1.19c.01-.28.03-.53.08-.77s.12-.45.21-.62c.09-.18.22-.31.38-.42.16-.1.35-.15.59-.15.26 0 .47.05.63.14.16.09.29.21.38.35.09.14.15.29.18.45.03.16.05.31.05.45-.01.31-.08.58-.22.81-.14.24-.32.45-.53.66-.22.2-.45.39-.71.57-.26.18-.51.36-.74.54-.5.36-.89.78-1.17 1.27-.3.47-.45 1.04-.46 1.69H5v-1.14H1.43c.05-.17.14-.33.27-.49.13-.15.29-.3.47-.44zM18 4.02H8c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h10c.55 0 1-.45 1-1v-1c0-.56-.45-1-1-1zm0 9H8c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h10c.55 0 1-.45 1-1v-1c0-.56-.45-1-1-1z"];
  init_define_process();
  var numerical_default2 = ["M2.39 5.75c-.17.21-.38.39-.63.52s-.52.23-.83.29c-.3.05-.61.08-.93.08v1.24h2.49V15h1.49V4.98H2.73c-.05.31-.17.57-.34.77zm17.2 4.71c-.27-.44-.65-.71-1.14-.82v-.02c.42-.16.72-.43.92-.79.2-.36.29-.79.29-1.27 0-.42-.08-.8-.23-1.12-.15-.33-.36-.59-.62-.8-.26-.21-.55-.37-.87-.48-.32-.11-.65-.16-.98-.16-.43 0-.82.08-1.16.25-.34.16-.63.39-.87.69-.24.29-.43.64-.57 1.04-.14.4-.22.83-.23 1.3h1.39c-.01-.25.02-.49.07-.72.06-.23.14-.44.26-.63s.27-.34.45-.45c.18-.11.39-.17.63-.17.39 0 .71.12.96.37s.37.58.37.99c0 .29-.05.54-.16.74-.11.2-.25.36-.43.47-.18.11-.38.19-.61.24-.23.05-.46.06-.68.05v1.17c.28-.01.55 0 .81.03s.5.1.71.21c.21.11.38.28.51.5.13.22.2.52.2.89 0 .55-.16.97-.47 1.27-.31.3-.7.45-1.17.45-.55 0-.95-.19-1.23-.58-.27-.39-.4-.88-.38-1.46h-1.39c.01.5.08.96.21 1.38.13.41.32.77.57 1.06.25.29.56.52.93.68.37.16.8.24 1.3.24.41 0 .79-.07 1.16-.21.37-.14.69-.33.96-.58.28-.25.5-.56.66-.92a3 3 0 00.24-1.23c0-.64-.14-1.17-.41-1.61zM8.58 12.41c.21-.18.45-.36.7-.53.25-.18.5-.36.75-.56.25-.2.49-.41.73-.63.23-.22.44-.47.63-.74.18-.27.33-.56.44-.88.11-.32.16-.67.16-1.07 0-.32-.05-.65-.14-1-.09-.35-.25-.68-.47-.97-.22-.3-.51-.55-.87-.74-.36-.2-.81-.29-1.35-.29-.49 0-.93.1-1.3.29-.37.18-.69.44-.95.78-.26.33-.45.73-.58 1.2-.13.46-.2.96-.2 1.5h1.43c.01-.35.04-.67.09-.97.05-.3.14-.56.25-.78.11-.22.26-.39.45-.52s.43-.19.71-.19c.31 0 .56.06.75.18.19.12.34.26.45.43.11.17.18.36.22.56.04.2.06.39.06.57-.01.38-.1.72-.26 1.02-.15.3-.37.57-.63.83-.26.25-.54.49-.85.71-.31.22-.61.45-.89.68-.6.45-1.06.98-1.41 1.58-.35.61-.52 1.32-.53 2.13h6.01v-1.43H7.69c.06-.21.17-.42.33-.61s.34-.38.56-.55z"];
  init_define_process();
  var office_default2 = ["M19 6h-5V1c0-.55-.45-1-1-1H1C.45 0 0 .45 0 1v18c0 .55.45 1 1 1h4v-6h4v6h10c.55 0 1-.45 1-1V7c0-.55-.45-1-1-1zM6 12H2V8h4v4zm0-6H2V2h4v4zm6 6H8V8h4v4zm0-6H8V2h4v4zm6 11h-4v-3h4v3zm0-5h-4V8h4v4z"];
  init_define_process();
  var offline_default2 = ["M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zM7 18l2-7H5l8-9-2 7h4l-8 9z"];
  init_define_process();
  var oil_field_default2 = ["M19 17.99h-1.36l-4.35-9.57 2.91-.86 1.66 4.1c.11.27.43.4.72.31.12-.04.22-.11.28-.2.06-.11 1.47-2.08 1.05-5.6C19.79 5.12 19.3 0 16.01 0 14.89.01 13.99.83 14 1.84c0 .19.04.38.1.56l1.34 3.31L.72 10.03v.02c-.41.12-.72.49-.72.94 0 .55.45 1 1 1 .1 0 .19-.03.28-.06v.02l2-.59 1.47 6.63H3c-.55 0-1 .45-1 1s.45 1 1 1h16c.55 0 1-.45 1-1s-.45-1-1-1zM5.2 10.8l3.95-1.16-2.83 6.22L5.2 10.8zm2.35 7.19l3.95-8.68 3.95 8.68h-7.9z"];
  init_define_process();
  var one_column_default2 = ["M14.94 0h-4c-.55 0-1 .45-1 1v18c0 .55.45 1 1 1h4c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-8 6c-.28 0-.53.11-.71.29l-3 3c-.18.18-.29.43-.29.71s.11.53.29.71l3 3A1.003 1.003 0 007.94 13V7c0-.55-.45-1-1-1z"];
  init_define_process();
  var one_to_many_default2 = ["M18 3a1 1 0 11-2 0 1 1 0 012 0zm-3.82 1.028a6.243 6.243 0 00-1.667.347c-.947.352-1.773 1-2.032 2.318C10.158 8.337 9.247 9.368 8.217 10c1.03.632 1.941 1.663 2.264 3.307.259 1.318 1.085 1.966 2.032 2.318.581.217 1.18.308 1.668.347a3.001 3.001 0 11-.019 2.004c-.633-.042-1.491-.158-2.347-.476-1.402-.523-2.868-1.625-3.296-3.807-.259-1.318-1.085-1.966-2.032-2.318a5.314 5.314 0 00-.722-.21 3 3 0 110-2.33c.238-.052.481-.12.722-.21.947-.352 1.773-1 2.032-2.318.428-2.182 1.894-3.284 3.296-3.807.856-.318 1.714-.434 2.347-.476A3.001 3.001 0 0120 3a3 3 0 01-5.82 1.028zM4 10a1 1 0 100 .002v-.002zM17 18a1 1 0 100-2 1 1 0 000 2z"];
  init_define_process();
  var one_to_one_default2 = ["M2 10a1 1 0 112 0 1 1 0 01-2 0zm3.83-1a3.001 3.001 0 100 2h8.34a3.001 3.001 0 100-2H5.83zM17 9a1 1 0 100 2 1 1 0 000-2z"];
  init_define_process();
  var open_application_default2 = ["M4 1h14c.55 0 1 .45 1 1v13c0 .55-.45 1-1 1h-8v-2h7V4H5v6H3V2c0-.55.45-1 1-1zm2.5 5h7c.28 0 .5-.22.5-.5s-.22-.5-.5-.5h-7c-.28 0-.5.22-.5.5s.22.5.5.5zm0 2h3c.28 0 .5-.22.5-.5S9.78 7 9.5 7h-3c-.28 0-.5.22-.5.5s.22.5.5.5zm5 2h-5c-.28 0-.5-.22-.5-.5s.22-.5.5-.5h5c.28 0 .5.22.5.5s-.22.5-.5.5zM7 17c0 .55.45 1 1 1s1-.45 1-1v-5c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1s.45 1 1 1h2.59L.3 18.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L7 14.41V17z"];
  init_define_process();
  var outdated_default2 = ["M10 0c5.52 0 10 4.48 10 10s-4.48 10-10 10S0 15.52 0 10c0-.55.45-1 1-1s1 .45 1 1c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8C7.47 2 5.22 3.17 3.76 5H5c.55 0 1 .45 1 1s-.45 1-1 1H1c-.55 0-1-.45-1-1V2c0-.55.45-1 1-1s1 .45 1 1v2.05C3.82 1.6 6.71 0 10 0zm1 16H9v-2h2v2zm0-3H9V4h2v9z"];
  init_define_process();
  var page_layout_default2 = ["M19 1H1c-.55 0-1 .45-1 1v16c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zM7 17H2V8h5v9zm11 0H8V8h10v9zm0-10H2V3h16v4z"];
  init_define_process();
  var panel_stats_default2 = ["M1 1h18a1 1 0 011 1v15a1 1 0 01-1 1H1a1 1 0 01-1-1V2a1 1 0 011-1zm1 2v13h16V3H2zm9 0h1v13h-1V3zm2 7h3.952v1H13v-1zm0 2h3.952v1H13v-1zm0 2h3.952v1H13v-1zm0-6h3.952v1H13V8zm0-2h3.952v1H13V6zm0-2h3.952v1H13V4z"];
  init_define_process();
  var panel_table_default2 = ["M19 1H1c-.6 0-1 .4-1 1v15c0 .6.4 1 1 1h18c.6 0 1-.4 1-1V2c0-.6-.4-1-1-1zm-9 11H7V9h3v3zm0-4H7V5h3v3zm-8 8V3h4v13H2zm5 0v-3h3v3H7zm11 0h-7v-3h7v3zm0-4h-7V9h7v3zm0-4h-7V5h7v3z"];
  init_define_process();
  var paperclip_default2 = ["M18.35 2.67A5.664 5.664 0 0014.33 1c-1.44 0-2.89.56-3.99 1.67l-9.16 9.27C.4 12.73 0 13.78 0 14.83s.39 2.1 1.18 2.9c.78.79 1.82 1.18 2.85 1.18 1.04 0 2.07-.39 2.87-1.2l9.14-9.27c.96-.96.96-2.5.02-3.45-.94-.95-2.49-.96-3.44 0l-7.59 7.69c-.31.32-.3.83.01 1.14.31.31.81.31 1.13.02l7.59-7.69c.31-.31.84-.31 1.13-.02.31.31.31.85 0 1.16l-9.14 9.27c-.93.95-2.54.93-3.45.02-.94-.95-.92-2.55.02-3.49l9.16-9.25c1.55-1.56 4.18-1.59 5.72-.03 1.56 1.57 1.55 4.26 0 5.82l-8.89 9.02c-.3.31-.3.81.01 1.11.3.3.79.31 1.1.01v.01l8.91-9.02A5.645 5.645 0 0020 6.73c0-1.48-.55-2.94-1.65-4.06z"];
  init_define_process();
  var paragraph_default2 = ["M16.5 1H7C4.2 1 2 3.2 2 6s2.2 5 5 5v6.5c0 .8.7 1.5 1.5 1.5s1.5-.7 1.5-1.5V4h2v13.5c0 .8.7 1.5 1.5 1.5s1.5-.7 1.5-1.5V4h1.5c.8 0 1.5-.7 1.5-1.5S17.3 1 16.5 1z"];
  init_define_process();
  var path_default2 = ["M18 0H2C.9 0 0 .9 0 2s.9 2 2 2h7v4H4c-1.1 0-2 .9-2 2s.9 2 2 2h5v4H6c-1.1 0-2 .9-2 2s.9 2 2 2h8c1.1 0 2-.9 2-2s-.9-2-2-2h-3v-4h5c1.1 0 2-.9 2-2s-.9-2-2-2h-5V4h7c1.1 0 2-.9 2-2s-.9-2-2-2z"];
  init_define_process();
  var path_search_default2 = ["M4 7c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm15 11.69l-5-2.5v-3.63c-.32.11-.66.22-1 .29v3.32l-6 2.57v-7.25c-.36-.27-.69-.57-1-.9v8.1l-5-2.5V10c.55 0 1-.45 1-1s-.45-1-1-1V1.31l3.43 1.71c.11-.31.24-.62.39-.92L.72.05A.545.545 0 00.5 0C.22 0 0 .22 0 .5v16c0 .2.12.36.28.44l6 3c.07.04.14.06.22.06.07 0 .14-.01.2-.04l6.79-2.91 5.79 2.9c.07.03.14.05.22.05.28 0 .5-.22.5-.5v-4.21c-.31.13-.64.21-1 .21v3.19zM10 5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm3-1c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm6.72-.94l-1.43-.72c.2.43.36.89.48 1.36l.23.11V5.5c-.55 0-1 .45-1 1s.45 1 1 1v1.96l1 1V3.5c0-.2-.12-.36-.28-.44zm-3.69 5.56c.14-.21.27-.42.38-.65.02-.04.04-.07.05-.11.11-.22.2-.45.28-.69v-.01c.07-.24.13-.48.17-.73l.03-.17c.04-.25.06-.5.06-.76C17 2.46 14.54 0 11.5 0S6 2.46 6 5.5 8.46 11 11.5 11c.26 0 .51-.02.76-.06l.17-.03c.25-.04.49-.1.73-.17h.01c.24-.08.47-.17.69-.28.04-.02.07-.03.11-.05.23-.11.44-.24.65-.38l.18.18 3.5 3.5c.17.18.42.29.7.29a1.003 1.003 0 00.71-1.71l-3.68-3.67zm-4.53.88c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"];
  init_define_process();
  var pause_default2 = ["M7 3H4c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1zm9 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var people_default2 = ["M16.94 17a4.92 4.92 0 00-.33-1.06c-.45-.97-1.37-1.52-3.24-2.3-.17-.07-.76-.31-.77-.32-.1-.04-.2-.08-.28-.12.05-.14.04-.29.06-.45 0-.05.01-.11.01-.16-.25-.21-.47-.48-.65-.79.22-.34.41-.71.56-1.12l.04-.11c-.01.02-.01.02-.02.08l.06-.15c.36-.26.6-.67.72-1.13.18-.37.29-.82.25-1.3-.05-.5-.21-.92-.47-1.22-.02-.53-.06-1.11-.12-1.59.38-.17.83-.26 1.24-.26.59 0 1.26.19 1.73.55.46.35.8.85.97 1.4.04.13.07.25.08.38.08.45.13 1.14.13 1.61v.07c.16.07.31.24.35.62.02.29-.09.55-.15.65-.05.26-.2.53-.46.59-.03.12-.07.25-.11.36-.01.01-.01.04-.01.04-.2.53-.51 1-.89 1.34 0 .06 0 .12.01.17.04.41-.11.71 1 1.19 1.1.5 2.77 1.01 3.13 1.79.34.79.2 1.25.2 1.25h-3.04zm-5.42-3.06c1.47.66 3.7 1.35 4.18 2.39.45 1.05.27 1.67.27 1.67H.04s-.19-.62.27-1.67c.46-1.05 2.68-1.75 4.16-2.4 1.48-.65 1.33-1.05 1.38-1.59 0-.07.01-.14.01-.21-.52-.45-.95-1.08-1.22-1.8l-.01-.01c0-.01-.01-.02-.01-.03-.07-.15-.12-.32-.16-.49-.34-.06-.54-.43-.62-.78-.08-.14-.24-.48-.2-.87.05-.51.26-.74.49-.83v-.08c0-.64.05-1.55.17-2.15a3.648 3.648 0 011.4-2.36C6.32 2.25 7.21 2 8 2s1.68.25 2.31.73a3.63 3.63 0 011.4 2.36c.11.6.17 1.52.17 2.15v.09c.22.09.42.32.47.82.03.39-.12.73-.2.87-.07.34-.27.71-.61.78-.04.16-.09.33-.15.48-.01.01-.02.05-.02.05-.27.71-.68 1.33-1.19 1.78 0 .08 0 .16.01.23.05.55-.15.95 1.33 1.6z"];
  init_define_process();
  var percentage_default2 = ["M15 10c-1.66 0-3 1.34-3 3v2c0 1.66 1.34 3 3 3s3-1.34 3-3v-2c0-1.66-1.34-3-3-3zm1 5c0 .55-.45 1-1 1s-1-.45-1-1v-2c0-.55.45-1 1-1s1 .45 1 1v2zM8 7V5c0-1.66-1.34-3-3-3S2 3.34 2 5v2c0 1.66 1.34 3 3 3s3-1.34 3-3zM4 7V5c0-.55.45-1 1-1s1 .45 1 1v2c0 .55-.45 1-1 1s-1-.45-1-1zm11-4a1.003 1.003 0 00-1.88-.48L5.14 16.49a1.003 1.003 0 101.74.99l7.99-13.97c.08-.15.13-.32.13-.51z"];
  init_define_process();
  var person_default2 = ["M19.61 17.91c-.57-1.32-3.35-2.19-5.19-3.01-1.85-.82-1.59-1.31-1.66-1.99-.01-.09-.01-.19-.02-.29.63-.56 1.15-1.33 1.49-2.22 0 0 .02-.05.02-.06.07-.19.13-.39.19-.6.42-.09.67-.55.76-.98.1-.17.29-.6.25-1.08-.06-.62-.31-.91-.59-1.03v-.11c0-.79-.07-1.93-.22-2.68A4.55 4.55 0 0012.9.92C12.11.32 11 0 10.01 0s-2.1.32-2.89.92a4.55 4.55 0 00-1.74 2.94c-.14.75-.22 1.89-.22 2.68v.1c-.29.11-.55.4-.61 1.04-.04.48.15.91.25 1.08.1.44.35.91.79.98.05.21.12.41.19.6 0 .01.01.03.01.04l.01.02c.34.91.87 1.69 1.52 2.25 0 .09-.01.18-.02.26-.07.68.13 1.17-1.72 1.99S.96 16.59.39 17.91C-.18 19.23.05 20 .05 20h19.9s.23-.77-.34-2.09z"];
  init_define_process();
  var phone_default2 = ["M19.91 15.51c-.08-.08-4.21-2.5-4.35-2.57a.876.876 0 00-.4-.1c-.19 0-.42.13-.71.4-.28.27-1.17 1.49-1.43 1.76s-.48.4-.65.4c-.08 0-.19-.02-.32-.07s-1.45-.73-4.2-3.15-3.11-4-3.13-4.44c0-.17.13-.39.4-.65.28-.25.57-.51.89-.74.32-.24.61-.5.88-.78s.4-.52.4-.71c0-.13-.03-.27-.1-.4C7.12 4.32 4.62.19 4.53.1c-.19-.18-.92-.1-1.29.1C.25 1.82 0 4 .05 4.86c.05.89.61 5.58 5.2 9.93 5.7 5.41 9.66 5.2 9.92 5.2.87 0 3.52-.48 4.65-3.19.16-.38.31-1.07.09-1.29z"];
  init_define_process();
  var pie_chart_default2 = ["M9 .98c-4.5.5-8 4.31-8 8.94 0 4.97 4.03 9.04 9 9.04 4.63 0 8.44-3.96 8.94-7.96H9V.98z", "M10-.08V10h10C20 4 15.52-.08 10-.08z"];
  init_define_process();
  var pin_default2 = ["M11.77 1.16c-.81.81-.74 2.28.02 3.76L6.1 8.71c-2.17-1.46-4.12-2-4.94-1.18l4.95 4.95-4.95 6.36 6.36-4.95 4.95 4.95c.82-.82.27-2.77-1.19-4.94l3.8-5.69c1.47.76 2.94.84 3.76.02l-7.07-7.07z"];
  init_define_process();
  var pivot_default2 = ["M5.83 9.75L.29 15.29a1.003 1.003 0 001.42 1.42l5.54-5.54c-.57-.37-1.05-.85-1.42-1.42zM19 11c-.55 0-1 .45-1 1v1.59l-3.83-3.83c-.37.56-.85 1.04-1.41 1.41L16.59 15H15c-.55 0-1 .45-1 1s.45 1 1 1h4c.55 0 1-.45 1-1v-4c0-.55-.45-1-1-1zm-5-4c0-2.21-1.79-4-4-4S6 4.79 6 7s1.79 4 4 4 4-1.79 4-4zm-4 2c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"];
  init_define_process();
  var pivot_table_default2 = ["M3 5H1c-.55 0-1 .45-1 1v13c0 .55.45 1 1 1h2c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm0-5H1C.45 0 0 .45 0 1v2c0 .55.45 1 1 1h2c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm13.71 5.29C16.53 5.11 16.28 5 16 5s-.53.11-.71.29l-3 3a1.003 1.003 0 001.42 1.42L15 8.41V11c0 2.21-1.79 4-4 4H8.41l1.29-1.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-3 3c-.18.18-.29.43-.29.71 0 .28.11.53.29.71l3 3a1.003 1.003 0 001.42-1.42L8.41 17H11c3.31 0 6-2.69 6-6V8.41l1.29 1.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-3-3zM19 0H6c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h13c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var play_default2 = ["M16 10c0-.36-.2-.67-.49-.84l.01-.01-10-6-.01.01A.991.991 0 005 3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1 .19 0 .36-.07.51-.16l.01.01 10-6-.01-.01c.29-.17.49-.48.49-.84z"];
  init_define_process();
  var playbook_default2 = ["M1.707.293A1 1 0 00.293 1.707L2.086 3.5.293 5.293a1 1 0 001.414 1.414L3.5 4.914l1.793 1.793a1 1 0 001.414-1.414L4.914 3.5l1.793-1.793A1 1 0 005.293.293L3.5 2.086 1.707.293z", "M16 20a4 4 0 100-8 4 4 0 000 8zm0-2a2 2 0 100-4 2 2 0 000 4z", "M18.29 5.7L16 3.41V8a3 3 0 01-3 3H4a1 1 0 00-1 1v7a1 1 0 11-2 0v-7a3 3 0 013-3h9a1 1 0 001-1V3.41l-2.29 2.3a1.003 1.003 0 01-1.42-1.42l4-4c.18-.18.43-.29.71-.29.28 0 .53.11.71.29l4 4A1.003 1.003 0 0119 6c-.28 0-.53-.11-.71-.3z"];
  init_define_process();
  var plus_default2 = ["M16 9h-5V4c0-.55-.45-1-1-1s-1 .45-1 1v5H4c-.55 0-1 .45-1 1s.45 1 1 1h5v5c0 .55.45 1 1 1s1-.45 1-1v-5h5c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var polygon_filter_default2 = ["M18 7c-.27 0-.52.05-.75.15l-6.28-4.88c.01-.09.03-.18.03-.27 0-1.1-.9-2-2-2S7 .9 7 2c0 .06.01.12.02.19l-4.19 3C2.57 5.07 2.29 5 2 5 .9 5 0 5.9 0 7c0 .74.4 1.38 1 1.72v7.55c-.6.35-1 .99-1 1.73 0 1.1.9 2 2 2 .74 0 1.38-.4 1.72-1h7.55c.35.6.98 1 1.72 1 1.1 0 2-.9 2-2 0-.37-.11-.72-.29-1.02L18.03 11A2 2 0 0018 7zm-5.03 9c-.72.01-1.35.41-1.69 1H3.72c-.17-.3-.42-.55-.72-.72V8.72c.6-.34 1-.98 1-1.72 0-.06-.01-.12-.02-.19l4.19-3c.26.12.54.19.83.19.27 0 .52-.05.75-.15l6.28 4.88c-.01.09-.03.18-.03.27 0 .37.11.72.29 1.02L12.97 16z"];
  init_define_process();
  var power_default2 = ["M10 10c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1S9 .45 9 1v8c0 .55.45 1 1 1zm3-7.45v2.16c2.36 1.12 4 3.5 4 6.29 0 3.87-3.13 7-7 7s-7-3.13-7-7c0-2.79 1.64-5.17 4-6.29V2.55C3.51 3.79 1 7.09 1 11a9 9 0 0018 0c0-3.91-2.51-7.21-6-8.45z"];
  init_define_process();
  var predictive_analysis_default2 = ["M20 8.01c0-1.26-.61-2.43-1.61-3.12C17.86 2.5 15.8.79 13.4.79c-.58 0-1.14.1-1.69.29A3.533 3.533 0 009.17 0C8.05 0 7 .55 6.32 1.45c-.15-.02-.3-.03-.45-.03-1.63 0-3.03 1.12-3.46 2.71C.97 4.65 0 6.05 0 7.66c0 .48.09.95.26 1.4-.17.44-.26.91-.26 1.39 0 1.38.72 2.64 1.89 3.29.67.7 1.59 1.09 2.54 1.09.61 0 1.19-.15 1.71-.45.68.82 1.68 1.3 2.73 1.3.66 0 1.28-.18 1.83-.52.61.49 1.34.81 2.11.91 1.3 1.43 2.3 3.28 2.31 3.3 0 0 .35.61.33.61.96-.01 1.77-.2 1.64-1.3.01.02-.92-2.89-.92-2.89.52-.26.94-.69 1.21-1.23 1.12-.66 1.84-1.91 1.84-3.26 0-.3-.03-.6-.1-.89.57-.64.88-1.51.88-2.4zm-1.54 1.28l-.18-.2-.77-.84c-.33-.37-.67-1.17-.73-1.73 0 0-.13-1.25-.13-1.26-.06-.74-1.17-.73-1.13.14 0 .02.13 1.26.13 1.26.04.36.15.77.3 1.17-.08-.01-.15-.02-.22-.02 0 0-2.57-.12-2.57-.13-.73-.03-.89 1.22-.05 1.25l2.57.13c.53.03 1.29.37 1.61.72l.61.67.02.06c.1.27.14.55.14.83 0 .93-.51 1.77-1.34 2.18l-.2.1-.09.23c-.19.48-.6.82-1.1.93l-.67.14.87 2.75c-.48-.76-1.19-1.79-2.02-2.67l-.15-.16-.21-.02c-.51-.04-.99-.21-1.42-.48l1.7-1.48c.44-.39 1.04-.55 1.24-.49 0 0 .78.22.78.23.78.2 1.03-.92.29-1.21l-.78-.23c-.69-.2-1.67.22-2.24.72l-1.91 1.66-.39.32c-.44.36-.93.55-1.5.55-.8 0-1.54-.41-1.97-1.07v-1.88c0-.5.21-.98.34-1.07 0 0 .65-.43.64-.43.87-.69.21-1.57-.64-1.14 0-.01-.65.43-.65.43-.31.2-.54.56-.7.97-.13-.13-.28-.25-.43-.35 0 0-1.91-1.26-1.91-1.28-.81-.56-1.5.63-.61 1.11 0-.02 1.89 1.28 1.89 1.28.46.31.77.97.77 1.36v.84c-.43.24-.78.36-1.24.36-.67 0-1.31-.29-1.77-.79l-.07-.08-.09-.05a2.425 2.425 0 01-1.31-2.16c0-.38.09-.74.25-1.08l.15-.31-.14-.33c-.17-.34-.25-.7-.25-1.08 0-1.13.76-2.1 1.85-2.37l.39-.09.07-.43a2.41 2.41 0 012.39-2.05c.19 0 .39.02.58.07l.4.1.22-.38A2.41 2.41 0 019.17 1.3c.55 0 1.08.19 1.5.53l-.44.45-.01-.01-.31.31c-.41.35-.92.53-1.11.5 0 0-.84-.13-.84-.14-.83-.15-1.09 1.08-.18 1.29.01 0 .84.14.84.14.03 0 .06 0 .09.01-.14.46-.18.96-.12 1.4 0 0 .21 1.24.19 1.23.13.65 1.32.44 1.16-.22 0-.01-.19-1.23-.19-1.23-.07-.48.15-1.19.45-1.5l.48-.5c.07-.06.13-.12.19-.18l.93-.95c.5-.23 1.04-.34 1.59-.34 1.93 0 3.57 1.4 3.89 3.34l.05.31.26.15a2.445 2.445 0 01.87 3.4z"];
  init_define_process();
  var prescription_default2 = ["M13.95 10.23c.16-.18.22-.22.46-.22h1.48c.25 0 .47.08.59.33.1.2.09.41-.05.66l-2.71 3.58L16.88 19c.13.21.16.46.03.69-.12.21-.34.31-.57.31H14.7c-.31 0-.56-.17-.7-.44l-1.9-2.67-1.93 2.68c-.15.27-.42.43-.73.43H7.98c-.25 0-.47-.08-.59-.33-.1-.2-.09-.41.05-.66l3.09-4.35L6.26 9H5v4.32c0 .41-.3.69-.7.69H2.7c-.41 0-.7-.28-.7-.69V.69c0-.41.3-.69.7-.69h4.42c.71 0 1.36.1 1.94.3.59.2 1.11.49 1.54.87.44.38.78.84 1.02 1.39.24.54.36 1.14.36 1.78 0 1.01-.28 1.88-.84 2.6-.43.54-1.35 1.29-2 1.59l3.09 3.94 1.72-2.24zM6.71 6.04c.71 0 1.45-.16 1.81-.46.33-.28.5-.69.5-1.25s-.17-.97-.5-1.25c-.35-.3-1.1-.46-1.81-.46h-1.7v3.42h1.7z"];
  init_define_process();
  var presentation_default2 = ["M19 1h-8c0-.55-.45-1-1-1S9 .45 9 1H1c-.55 0-1 .45-1 1s.45 1 1 1h1v11c0 .55.45 1 1 1h4.59L4.3 18.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L9 16.41V19c0 .55.45 1 1 1s1-.45 1-1v-2.59l3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L12.41 15H17c.55 0 1-.45 1-1V3h1c.55 0 1-.45 1-1s-.45-1-1-1zm-3 12H4V3h12v10z"];
  init_define_process();
  var print_default2 = ["M14 16H6v-4H4v5c0 .55.45 1 1 1h10c.55 0 1-.45 1-1v-5h-2v4zm2-13c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1v1h12V3zm3 2H1c-.55 0-1 .45-1 1v7c0 .55.45 1 1 1h2v-3h14v3h2c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm-1 4h-2V7h2v2z"];
  init_define_process();
  var projects_default2 = ["M18 4c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v2h16V4zm-2-3c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1v1h12V1zm3 6H1c-.55 0-1 .45-1 1v11c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V8c0-.55-.45-1-1-1zm-5 7c0 .55-.45 1-1 1H7c-.55 0-1-.45-1-1v-2h1v2h6v-2h1v2z"];
  init_define_process();
  var properties_default2 = ["M2 15c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-7c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm5-4h12c.55 0 1-.45 1-1s-.45-1-1-1H7c-.55 0-1 .45-1 1s.45 1 1 1zM2 1C.9 1 0 1.9 0 3s.9 2 2 2 2-.9 2-2-.9-2-2-2zm17 8H7c-.55 0-1 .45-1 1s.45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1zm0 7H7c-.55 0-1 .45-1 1s.45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var property_default2 = ["M3 5c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm5-1h11c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1s.45 1 1 1zM3 15c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm16 1H8c-.55 0-1 .45-1 1s.45 1 1 1h11c.55 0 1-.45 1-1s-.45-1-1-1zm-1-8H9c-1.1 0-2 .9-2 2s.9 2 2 2h9c1.1 0 2-.9 2-2s-.9-2-2-2zM3 7c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"];
  init_define_process();
  var publish_function_default2 = ["M7.01 10.11c.35-.64.72-1.68 1.09-3.11l.8-3.03h.96l.24-.77h-.99c.28-1.11.66-1.92 1.12-2.43.28-.32.56-.48.83-.48.05 0 .1.02.13.05.03.03.05.07.05.12 0 .04-.04.13-.11.25-.08.12-.11.24-.11.35 0 .15.06.28.18.39.12.11.27.16.45.16.2 0 .36-.07.49-.2s.2-.31.2-.54c0-.26-.1-.47-.3-.63-.2-.16-.52-.24-.96-.24-.68 0-1.3.19-1.86.58-.55.38-1.08 1.02-1.58 1.91-.17.3-.34.5-.49.59-.15.08-.4.13-.74.12l-.23.77h.95L5.74 9.21c-.23.86-.39 1.39-.47 1.59-.12.29-.3.54-.54.75-.1.08-.21.12-.35.12-.04 0-.07-.01-.1-.03l-.03-.04c0-.02.03-.07.1-.13.07-.07.1-.17.1-.31 0-.15-.05-.28-.16-.38-.11-.1-.27-.15-.47-.15-.25 0-.44.07-.59.2-.15.12-.23.28-.23.46 0 .19.09.36.27.5.19.14.47.21.86.21.61 0 1.16-.15 1.63-.46.48-.31.89-.79 1.25-1.43zm3.7 1.18c-.18-.18-.43-.29-.71-.29s-.53.11-.71.29l-3 3a1.003 1.003 0 001.42 1.42L9 14.41V19c0 .55.45 1 1 1s1-.45 1-1v-4.59l1.29 1.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-3-3zm4.15-6.78c.17-.13.36-.2.55-.2.07 0 .2.03.39.08s.36.08.5.08c.2 0 .37-.07.5-.2.13-.14.2-.31.2-.52 0-.22-.07-.4-.2-.53s-.33-.2-.58-.2c-.22 0-.43.05-.63.15-.2.1-.45.32-.75.67-.23.25-.56.7-1.01 1.33a6.52 6.52 0 00-.91-2.15l-2.38.39-.05.25c.18-.03.33-.05.45-.05.24 0 .43.1.59.3.25.31.59 1.24 1.02 2.79-.34.44-.58.73-.7.87-.21.22-.38.36-.52.43-.1.05-.22.08-.35.08-.1 0-.26-.05-.49-.16a1.01 1.01 0 00-.42-.11c-.23 0-.42.07-.57.22-.17.14-.24.32-.24.55 0 .21.07.38.21.51.14.13.33.2.56.2.23 0 .44-.05.64-.14.2-.09.45-.29.75-.59s.72-.78 1.25-1.43c.2.62.38 1.07.53 1.35.15.28.32.49.52.61.19.12.44.19.73.19.28 0 .57-.1.86-.3.38-.25.77-.69 1.17-1.31l-.25-.14c-.27.37-.48.6-.61.69-.09.06-.19.09-.31.09-.14 0-.28-.09-.42-.26-.23-.29-.54-1.09-.93-2.4.37-.58.66-.96.9-1.14z"];
  init_define_process();
  var pulse_default2 = ["M19 10h-2.38L14.9 6.55h-.01c-.17-.32-.5-.55-.89-.55-.43 0-.79.28-.93.66h-.01l-2.75 7.57L7.98 1.82h-.02A.978.978 0 007 1c-.44 0-.8.29-.94.69h-.01L3.28 10H1c-.55 0-1 .45-1 1s.45 1 1 1h3c.44 0 .8-.29.94-.69h.01l1.78-5.34 2.29 12.21h.02c.08.46.47.82.96.82.43 0 .79-.28.93-.66h.01l3.21-8.82.96 1.92h.01c.16.33.49.56.88.56h3c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var rain_default2 = ["M4 10a3 3 0 111.065-5.806A5.001 5.001 0 0114.63 3.11 3.5 3.5 0 1115.5 10H4zm0 2a1 1 0 011 1v5a1 1 0 11-2 0v-5a1 1 0 011-1zm9 1a1 1 0 10-2 0v6a1 1 0 102 0v-6zm3-1a1 1 0 011 1v3a1 1 0 11-2 0v-3a1 1 0 011-1zm-7 1a1 1 0 10-2 0v3a1 1 0 102 0v-3z"];
  init_define_process();
  var random_default2 = ["M14.47 5h2.12L15.3 6.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71l-3-3a1.003 1.003 0 00-1.42 1.42L16.59 3H14c-.31 0-.57.15-.76.37l-.01-.01-2.93 3.52 1.3 1.56L14.47 5zm2.24 7.29a1.003 1.003 0 00-1.42 1.42l1.3 1.29h-2.12L4.77 3.36l-.01.01A.998.998 0 004 3H1c-.55 0-1 .45-1 1s.45 1 1 1h2.53l9.7 11.64.01-.01c.19.22.45.37.76.37h2.59l-1.29 1.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71l-3-3zM3.53 15H1c-.55 0-1 .45-1 1s.45 1 1 1h3c.31 0 .57-.15.76-.37l.01.01 2.93-3.52-1.3-1.56L3.53 15z"];
  init_define_process();
  var record_default2 = ["M10 3a7 7 0 100 14 7 7 0 100-14z"];
  init_define_process();
  var rect_height_default2 = ["M4 18V2h12v16H4zM2 1a1 1 0 011-1h14a1 1 0 011 1v18a1 1 0 01-1 1H3a1 1 0 01-1-1V1zm4.293 11.705a.999.999 0 111.412-1.412L10 13.587l2.295-2.294a.999.999 0 011.412 1.412l-2.962 2.963a1 1 0 01-1.49 0l-2.962-2.963zm0-3.998a.999.999 0 010-1.412l2.962-2.963A1.008 1.008 0 0110 4a.996.996 0 01.745.332l2.962 2.963a.999.999 0 01-1.412 1.412L10 6.413 7.705 8.707a.999.999 0 01-1.412 0z"];
  init_define_process();
  var rect_width_default2 = ["M18 16H2V4h16v12zM1 18a1 1 0 01-1-1V3a1 1 0 011-1h18a1 1 0 011 1v14a1 1 0 01-1 1H1zM7.295 6.293a.999.999 0 111.412 1.412L6.413 10l2.294 2.295a.999.999 0 11-1.412 1.412l-2.963-2.962A.992.992 0 014 10a.996.996 0 01.332-.745l2.963-2.962zm3.998 0a.999.999 0 011.412 0l2.963 2.962.04.038A.996.996 0 0116 10a.996.996 0 01-.332.745l-2.963 2.962a.999.999 0 01-1.412-1.412L13.587 10l-2.294-2.295a.999.999 0 010-1.412z"];
  init_define_process();
  var rectangle_default2 = ["M1 4h18c.55 0 1 .45 1 1v10c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V5c0-.55.45-1 1-1zm1 2v8h16V6H2z"];
  init_define_process();
  var redo_default2 = ["M19.71 5.29l-4-4a1.003 1.003 0 00-1.42 1.42L16.59 5H6c-3.31 0-6 2.69-6 6s2.69 6 6 6h5v-2H6c-2.21 0-4-1.79-4-4s1.79-4 4-4h10.59L14.3 9.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l4-4c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71zM15 14c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"];
  init_define_process();
  var refresh_default2 = ["M19 1c-.55 0-1 .45-1 1v2.06C16.18 1.61 13.29 0 10 0 4.48 0 0 4.48 0 10c0 .55.45 1 1 1s1-.45 1-1c0-4.42 3.58-8 8-8 2.52 0 4.76 1.18 6.22 3H15c-.55 0-1 .45-1 1s.45 1 1 1h4c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zm0 8c-.55 0-1 .45-1 1 0 4.42-3.58 8-8 8-2.52 0-4.76-1.18-6.22-3H5c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1s1-.45 1-1v-2.06C3.82 18.39 6.71 20 10 20c5.52 0 10-4.48 10-10 0-.55-.45-1-1-1z"];
  init_define_process();
  var regex_default2 = ["M0 17.5a2.5 2.5 0 115 0 2.5 2.5 0 01-5 0zM14 0a1 1 0 00-1 1v3.768L9.737 2.884a1 1 0 10-1 1.732L12 6.5 8.737 8.384a1 1 0 001 1.732L13 8.232V12a1 1 0 102 0V8.232l3.263 1.884a1 1 0 001-1.732L16 6.5l3.263-1.884a1 1 0 10-1-1.732L15 4.768V1a1 1 0 00-1-1z"];
  init_define_process();
  var regression_chart_default2 = ["M19 16H3.1L19.31 3.39l-.61-.79L2 15.59V3c0-.55-.45-1-1-1s-1 .45-1 1v14c0 .55.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1zm-9-9c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm-5 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm10-2c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2-2 .9-2 2zm-5 4c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2-2 .9-2 2z"];
  init_define_process();
  var remove_default2 = ["M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm5-9H5c-.55 0-1 .45-1 1s.45 1 1 1h10c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var remove_column_default2 = ["M19 0H5c-.55 0-1 .45-1 1v4h2V2h5v16H6v-3H4v4c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 18h-5V2h5v16zM6.29 13.71a1.003 1.003 0 001.42-1.42L5.41 10 7.7 7.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L4 8.59l-2.29-2.3A1.003 1.003 0 00.29 7.71L2.59 10 .3 12.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L4 11.41l2.29 2.3z"];
  init_define_process();
  var remove_column_left_default2 = ["M4 11h6c.55 0 1-.45 1-1s-.45-1-1-1H4c-.55 0-1 .45-1 1s.45 1 1 1zM19 0H1C.45 0 0 .45 0 1v18c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-7 18H2V2h10v16zm6 0h-5V2h5v16z"];
  init_define_process();
  var remove_column_right_default2 = ["M19 0H1C.45 0 0 .45 0 1v18c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zM7 18H2V2h5v16zm11 0H8V2h10v16zm-8-7h6c.55 0 1-.45 1-1s-.45-1-1-1h-6c-.55 0-1 .45-1 1s.45 1 1 1z"];
  init_define_process();
  var remove_row_bottom_default2 = ["M7 14h6c.55 0 1-.45 1-1s-.45-1-1-1H7c-.55 0-1 .45-1 1s.45 1 1 1zM19 0H1C.45 0 0 .45 0 1v18c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 18H2V8h16v10zm0-11H2V2h16v5z"];
  init_define_process();
  var remove_row_top_default2 = ["M7 8h6c.55 0 1-.45 1-1s-.45-1-1-1H7c-.55 0-1 .45-1 1s.45 1 1 1zm12-8H1C.45 0 0 .45 0 1v18c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 18H2v-5h16v5zm0-6H2V2h16v10z"];
  init_define_process();
  var repeat_default2 = ["M14 6c0 .55.45 1 1 1h4c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1v2.05C16.18 1.6 13.29 0 10 0 4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10c0-.55-.45-1-1-1s-1 .45-1 1c0 4.42-3.58 8-8 8s-8-3.58-8-8 3.58-8 8-8c2.53 0 4.77 1.17 6.24 3H15c-.55 0-1 .45-1 1z"];
  init_define_process();
  var reset_default2 = ["M6 6c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V2c0-.55.45-1 1-1s1 .45 1 1v2.05C3.82 1.6 6.71 0 10 0c5.52 0 10 4.48 10 10s-4.48 10-10 10S0 15.52 0 10c0-.55.45-1 1-1s1 .45 1 1c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8C7.47 2 5.23 3.17 3.76 5H5c.55 0 1 .45 1 1z"];
  init_define_process();
  var resolve_default2 = ["M8.7 4.7C7.9 4.2 7 4 6 4c-3.3 0-6 2.7-6 6s2.7 6 6 6c1 0 1.9-.2 2.7-.7C7.3 14 6.5 12.1 6.5 10s.9-4 2.2-5.3zM14 4c-1 0-1.9.2-2.7.7 1.4 1.4 2.2 3.2 2.2 5.3s-.9 4-2.2 5.3c.8.5 1.7.7 2.7.7 3.3 0 6-2.7 6-6s-2.7-6-6-6zm-4 1.5C8.8 6.7 8 8.2 8 10s.8 3.3 2 4.4c1.2-1.1 2-2.7 2-4.5s-.8-3.3-2-4.4z"];
  init_define_process();
  var rig_default2 = ["M7 4.2C7 5.75 8.34 7 10 7s3-1.46 3-2.8C13 1.45 10.94 0 10 0H6c0 2.74 3.76 1.96 1 4.2zm11.71 14.09L13 12.59V9.01c0-.55-.45-1-1-1H8c-.55 0-1 .45-1 1v3.58l-5.71 5.7a1.003 1.003 0 001.42 1.42L7 15.42V19c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-3.58l4.29 4.29a1.003 1.003 0 001.42-1.42zM10.21 8c.01 0 .01.01 0 0 .01.01.01 0 0 0z"];
  init_define_process();
  var right_join_default2 = ["M8.7 4.7C7.4 6 6.5 7.9 6.5 10s.8 4 2.2 5.3c-.8.5-1.7.7-2.7.7-3.3 0-6-2.7-6-6s2.7-6 6-6c1 0 1.9.2 2.7.7zm-3.34 9.25c-.55-1.2-.86-2.54-.86-3.95s.31-2.75.86-3.95a4.001 4.001 0 000 7.9zM14 4c3.3 0 6 2.7 6 6s-2.7 6-6 6c-1 0-1.9-.2-2.7-.7 1.3-1.3 2.2-3.2 2.2-5.3s-.8-3.9-2.2-5.3C12.1 4.2 13 4 14 4zm-4 1.5C8.8 6.7 8 8.2 8 10s.8 3.3 2 4.4c1.2-1.1 2-2.7 2-4.5s-.8-3.3-2-4.4z"];
  init_define_process();
  var ring_default2 = ["M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm0 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"];
  init_define_process();
  var rocket_default2 = ["M7 7.5c0-3 1.857-6.25 3-7.5 1.143 1.25 3 4.5 3 7.5s-.714 6.25-1 7.5H8c-.286-1.25-1-4.5-1-7.5zm6.84 2.5c-.139 1.62-.47 3.405-.84 5.01l4 .99-1-4-2.16-2zm-4.832 6C9 16.139 9 16.284 9 16.429 9 17.143 9 17.5 10 20c1-2.5 1-2.857 1-3.571 0-.145 0-.29-.008-.429H9.008zM7 15.011c-.37-1.605-.701-3.39-.84-5.011L4 12l-1 4 4-.989zM10 5a1 1 0 100 2 1 1 0 000-2z"];
  init_define_process();
  var rocket_slant_default2 = ["M10 5c2.121-2.121 6.308-2.924 8-3-.076 1.692-.879 5.879-3 8-1.192 1.192-2.543 1.823-3.748 2.384-.442.207-.865.404-1.252.616-.203.111-.597.302-.986.49-.444.215-.88.426-1.014.51l-2-2c.158-.252 1-2 1-2s1.37-3.37 3-5zm5 1a1 1 0 11-2 0 1 1 0 012 0zM3 17s0-2 2-4l2 2c-2 2-4 2-4 2zm11-2l-4 4-1.298-4.233c1.033-.56 1.881-.962 2.643-1.322 1.275-.604 2.307-1.092 3.554-2.015L14 15zM1 10l4-4 3.557-.899c-.923 1.247-1.412 2.28-2.015 3.554-.36.762-.762 1.61-1.322 2.643L1 10z"];
  init_define_process();
  var rotate_document_default2 = ["M8.71 6.29A.997.997 0 008 6H3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h9c.55 0 1-.45 1-1v-8c0-.28-.11-.53-.29-.71l-4-4zM11 18H4V8h3v3c0 .55.45 1 1 1h3v6zm3-16h-1.59l.29-.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-2 2C9.11 2.47 9 2.72 9 3c0 .28.11.53.29.71l2 2a1.003 1.003 0 001.42-1.42l-.3-.29H14c1.1 0 2 .9 2 2v3c0 .55.45 1 1 1s1-.45 1-1V6c0-2.21-1.79-4-4-4z"];
  init_define_process();
  var rotate_page_default2 = ["M14 2h-1.59l.29-.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-2 2C9.11 2.47 9 2.72 9 3c0 .28.11.53.29.71l2 2a1.003 1.003 0 001.42-1.42l-.3-.29H14c1.1 0 2 .9 2 2v3c0 .55.45 1 1 1s1-.45 1-1V6c0-2.21-1.79-4-4-4zm-2 5H3c-.55 0-1 .45-1 1v11c0 .55.45 1 1 1h9c.55 0 1-.45 1-1V8c0-.55-.45-1-1-1zm-1 11H4V9h7v9z"];
  init_define_process();
  var route_default2 = ["M14.028 6.016c.146.275.31.57.485.872.304.524.628 1.047.952 1.545l.118.178-.208-.006-.577-.005c-2.093.004-2.841.303-2.841.895 0 .069.271.248 1.245.567l1.008.313c2.671.831 3.99 1.827 3.99 4.167 0 2.76-1.928 4.059-4.832 4.376-.782.085-1.52.098-2.452.066l-1.15-.046H6.221l.535-.811a67.46 67.46 0 001.122-1.787h2.04l.686.03c1.028.046 1.77.043 2.523-.039 1.832-.2 2.673-.767 2.673-1.789 0-.69-.483-1.09-1.992-1.585l-.83-.257c-1.192-.364-2.037-.7-2.59-1.165.399-1 .612-1.844.612-2.538a6.018 6.018 0 00-.382-2.098c.745-.573 1.884-.822 3.41-.883zM5 4.2c2.648 0 4.791 2.151 4.8 4.797C9.8 11.652 5 18.6 5 18.6l-.5-.744C3.273 15.993.2 11.121.2 8.997A4.802 4.802 0 015 4.2zm0 2.4a2.4 2.4 0 10.002 4.802A2.4 2.4 0 005 6.6zM17 .333a2.671 2.671 0 012.667 2.665C19.667 4.473 17 8.333 17 8.333l-.391-.587c-.741-1.137-2.276-3.629-2.276-4.748A2.668 2.668 0 0117 .333z"];
  init_define_process();
  var satellite_default2 = ["M9 18c.6 0 1 .4 1 1s-.4 1-1 1c-5 0-9-4-9-9 0-.6.4-1 1-1s1 .4 1 1c0 3.9 3.1 7 7 7zm0-4c.6 0 1 .4 1 1s-.4 1-1 1c-2.8 0-5-2.2-5-5 0-.6.4-1 1-1s1 .4 1 1c0 1.7 1.3 3 3 3zm5.7-3.7c.4-.4 1-.4 1.4 0l3.6 3.6c.4.4.4 1 0 1.4l-1.4 1.4c-.4.4-1 .4-1.4 0l-3.6-3.6c-.4-.4-.4-1 0-1.4l1.4-1.4zM4.7.3c.4-.4 1-.4 1.4 0l3.6 3.6c.4.4.4 1 0 1.4L8.3 6.7c-.4.4-1 .4-1.4 0L3.3 3.1c-.4-.4-.4-1 0-1.4L4.7.3zm11.1 1c.4-.4 1-.4 1.4 0l1.6 1.6c.4.4.4 1 0 1.4l-6.5 6.5c-.4.4-1 .4-1.4 0L9.3 9.2c-.4-.4-.4-1 0-1.4l6.5-6.5zM9 12c-.6 0-1-.4-1-1s.4-1 1-1 1 .4 1 1-.4 1-1 1z"];
  init_define_process();
  var saved_default2 = ["M12 0H4c-.55 0-1 .45-1 1v18c0 .55.45 1 1 1h13c.55 0 1-.45 1-1V6l-6-6zm4 18H5V2h6v5h5v11zm-8.29-6.71a1.003 1.003 0 00-1.42 1.42l3 3c.18.18.43.29.71.29.32 0 .59-.16.77-.38l.01.01 4-5-.01-.01c.14-.18.23-.38.23-.62 0-.55-.45-1-1-1-.32 0-.59.16-.77.38l-.01-.01-3.3 4.13-2.21-2.21z"];
  init_define_process();
  var scatter_plot_default2 = ["M9 9c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm5 2c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm4-5c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm1 10H2V3c0-.55-.45-1-1-1s-1 .45-1 1v14c0 .55.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1zM5 15c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2z"];
  init_define_process();
  var search_default2 = ["M19.56 17.44l-4.94-4.94A8.004 8.004 0 0016 8c0-4.42-3.58-8-8-8S0 3.58 0 8s3.58 8 8 8c1.67 0 3.21-.51 4.5-1.38l4.94 4.94a1.498 1.498 0 102.12-2.12zM8 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"];
  init_define_process();
  var search_around_default2 = ["M9.9 6.9a3 3 0 100 6 3 3 0 100-6zM3 14c-1.7 0-3 1.3-3 3s1.3 3 3 3 3-1.3 3-3-1.3-3-3-3zm0 5c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zM3 0C1.3 0 0 1.3 0 3s1.3 3 3 3 3-1.3 3-3-1.3-3-3-3zm0 5c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zM17 14c-1.7 0-3 1.3-3 3s1.3 3 3 3 3-1.3 3-3-1.3-3-3-3zm0 5c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zM17 0c-1.7 0-3 1.3-3 3s1.3 3 3 3 3-1.3 3-3-1.3-3-3-3zm0 5c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zM10 10L5 5", "M5.379 4.671l5.02 5.02-.707.708-5.02-5.02zM10 10l5-5", "M14.621 4.671l.707.708-5.02 5.02-.707-.707z", "M10 10l5 5M10.379 9.671l5.02 5.02-.707.708-5.02-5.02z", "M10 10l-5 5M9.621 9.671l.707.708-5.02 5.02-.707-.707z"];
  init_define_process();
  var search_template_default2 = ["M13 8H5c-.55 0-1 .45-1 1s.45 1 1 1h8c.55 0 1-.45 1-1s-.45-1-1-1zm0 3H5c-.55 0-1 .45-1 1s.45 1 1 1h8c.55 0 1-.45 1-1s-.45-1-1-1zm0-6H5c-.55 0-1 .45-1 1s.45 1 1 1h8c.55 0 1-.45 1-1s-.45-1-1-1zm6.56 12.44l-3.23-3.23A8.939 8.939 0 0018 9a9 9 0 10-9 9c1.94 0 3.74-.62 5.21-1.67l3.23 3.23a1.498 1.498 0 102.12-2.12zM9 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"];
  init_define_process();
  var search_text_default2 = ["M19.56 17.44l-3.23-3.23A8.939 8.939 0 0018 9a9 9 0 10-9 9c1.94 0 3.74-.62 5.21-1.67l3.23 3.23a1.498 1.498 0 102.12-2.12zM9 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7zm3.5-11h-7c-.28 0-.5.22-.5.5v2c0 .28.22.5.5.5s.5-.22.5-.5V7h2v6h-.5c-.28 0-.5.22-.5.5s.22.5.5.5h3c.28 0 .5-.22.5-.5s-.22-.5-.5-.5H10V7h2v.5c0 .28.22.5.5.5s.5-.22.5-.5v-2c0-.28-.22-.5-.5-.5z"];
  init_define_process();
  var segmented_control_default2 = ["M19 5H1c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm-1 8h-8V7h8v6z"];
  init_define_process();
  var select_default2 = ["M19.71 18.29l-4.25-4.25L20 12.91 9.93 9.33c.04-.1.07-.21.07-.33V3c0-.55-.45-1-1-1H4V1c0-.55-.45-1-1-1S2 .45 2 1v1H1c-.55 0-1 .45-1 1s.45 1 1 1h1v5c0 .55.45 1 1 1h6c.12 0 .23-.03.34-.07L12.91 20l1.14-4.54 4.25 4.25c.17.18.42.29.7.29a1.003 1.003 0 00.71-1.71zM8 8H4V4h4v4z"];
  init_define_process();
  var selection_default2 = ["M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z", "M10 6a4 4 0 100 8 4 4 0 100-8z"];
  init_define_process();
  var send_message_default2 = ["M1.754.135L19.393 9.06c.57.288.775.943.458 1.462-.107.176-.266.32-.458.418l-17.64 8.925c-.57.288-1.288.1-1.604-.418C.05 19.287 0 19.183 0 19v-7l11-2L0 8V1.075C0 .481.529 0 1.18 0c.201 0 .399.047.574.135z"];
  init_define_process();
  var send_to_default2 = ["M19 0h-5c-.6 0-1 .4-1 1s.4 1 1 1h2.6l-4.3 4.3c-.2.2-.3.4-.3.7 0 .6.4 1 1 1 .3 0 .5-.1.7-.3L18 3.4V6c0 .5.5 1 1 1s1-.5 1-1V1c0-.6-.5-1-1-1zm0 9c-1 0-1.9-.5-2.5-1.3l-1.4 1.4c-.5.6-1.3.9-2.1.9-1.7 0-3-1.3-3-3 0-.8.3-1.6.9-2.1l1.4-1.4C11.5 2.9 11 2 11 1c0-.3.1-.6.2-.9-.4-.1-.8-.1-1.2-.1C4.5 0 0 4.5 0 10s4.5 10 10 10 10-4.5 10-10c0-.4 0-.8-.1-1.2-.3.1-.6.2-.9.2z"];
  init_define_process();
  var send_to_graph_default2 = ["M8 11H3c-.55 0-1 .45-1 1s.45 1 1 1h2.59L.3 18.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L7 14.41V17c0 .55.45 1 1 1s1-.45 1-1v-5c0-.55-.45-1-1-1zm10 2c-.53 0-1.01.21-1.37.55L11.9 10.6c.06-.19.1-.39.1-.6 0-.21-.04-.41-.1-.6l4.72-2.95c.37.34.85.55 1.38.55 1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2c0 .21.04.41.1.6l-4.73 2.96c-.24-.23-.54-.4-.87-.48V3.93c.86-.22 1.5-1 1.5-1.93 0-1.1-.9-2-2-2S8 .9 8 2c0 .93.64 1.71 1.5 1.93v4.14c-.33.09-.63.26-.87.48L7.6 7.91 5.42 6.55 3.9 5.6c.06-.19.1-.39.1-.6 0-1.1-.9-2-2-2s-2 .9-2 2 .9 2 2 2c.53 0 1.01-.21 1.37-.55L9 9.96V10h.06L12 11.84l.4.25 1.51.94 2.19 1.37c-.06.19-.1.39-.1.6 0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2zm-7-2.96l-.06-.04H11v.04z"];
  init_define_process();
  var send_to_map_default2 = ["M8 11H3c-.55 0-1 .45-1 1s.45 1 1 1h2.59L.3 18.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L7 14.41V17c0 .55.45 1 1 1s1-.45 1-1v-5c0-.55-.45-1-1-1zm11.54-6.82l.01-.02-6-4-.01.02C13.39.08 13.21 0 13 0s-.39.08-.54.18l-.01-.02L7 3.8 1.55.17l-.01.01A.969.969 0 001 0C.45 0 0 .45 0 1v9c0-.55.45-1 1-1h1V2.87l4 2.67V9h2V5.54l4-2.67v11.6l-1 .67v2.4l2-1.33 5.45 3.63.01-.02c.15.1.33.18.54.18.55 0 1-.45 1-1V5c0-.35-.19-.64-.46-.82zM18 17.13l-4-2.67V2.87l4 2.67v11.59z"];
  init_define_process();
  var series_add_default2 = ["M13.29 9.29c.3.62.8 1.12 1.42 1.42l-3 3c-.18.18-.43.29-.71.29s-.53-.11-.71-.3L7 10.41l-5 5V17h17c.55 0 1 .45 1 1s-.45 1-1 1H1a.998.998 0 01-1-1V4c0-.55.45-1 1-1s1 .45 1 1v8.59l4.29-4.3C6.47 8.11 6.72 8 7 8s.53.11.71.29l3.29 3.3 2.29-2.3zM12 5c0-.5.4-1 1-1h2V2c0-.6.4-1 1-1 .5 0 1 .4 1 1v2h2c.5 0 1 .4 1 1s-.5 1-1 1h-2v2c0 .6-.5 1-1 1-.6 0-1-.4-1-1V6h-2c-.6 0-1-.4-1-1z"];
  init_define_process();
  var series_configuration_default2 = ["M11.91 10.67c.52.45 1.13.8 1.8 1.03l-2.01 2.01c-.18.18-.43.29-.71.29-.28 0-.53-.11-.71-.3L7 10.41l-5 5V17h16.99c.55 0 1 .45 1 1s-.45 1-1 1H1a.998.998 0 01-1-1V4c0-.55.45-1 1-1s1 .45 1 1v8.59l4.29-4.3C6.47 8.11 6.72 8 7 8c.28 0 .53.11.71.29l3.29 3.3.91-.92zM18.5 4.6h1.04c.25 0 .45.2.46.44v.9c0 .25-.2.45-.45.45h-1.04c-.07.22-.16.42-.27.62l.73.73c.17.17.17.44 0 .61l-.61.61c-.17.17-.44.17-.61 0l-.73-.73c-.2.11-.4.2-.62.26v1.05c0 .25-.2.45-.45.45h-.9c-.25 0-.45-.2-.45-.45V8.51c-.21-.06-.4-.15-.58-.25l-.76.77c-.17.17-.46.17-.64 0l-.64-.64a.465.465 0 010-.64l.76-.77c-.1-.19-.19-.38-.25-.59h-1.04c-.25 0-.45-.2-.45-.45v-.9c0-.25.2-.45.45-.45h1.04c.07-.22.16-.42.27-.61l-.73-.73a.429.429 0 010-.61l.61-.61c.17-.17.44-.17.61 0l.73.73c.2-.11.4-.2.62-.26V1.45a.44.44 0 01.44-.45h.9c.25 0 .45.2.45.45V2.5c.21.06.4.15.58.25l.76-.77c.17-.17.46-.17.64 0l.64.64c.17.17.17.46 0 .64l-.76.77c.1.17.19.36.25.57zm-4.69.9c0 .93.75 1.69 1.69 1.69.93 0 1.69-.75 1.69-1.69s-.75-1.69-1.69-1.69-1.69.76-1.69 1.69z"];
  init_define_process();
  var series_derived_default2 = ["M18.82 6.58c-.03.05-.07.09-.11.13 0 0 0-.01-.01-.01l-2 2c-.2.2-.4.3-.7.3-.6 0-1-.4-1-1 0-.3.1-.5.3-.7L16.6 6H11c-.6 0-1-.4-1-1s.4-1 1-1h5.6l-1.3-1.3c-.2-.2-.3-.4-.3-.7 0-.6.4-1 1-1 .3 0 .5.1.7.3l3 3c.2.2.3.4.3.7s-.1.5-.3.7l-.88.88zm-5.53 2.71c.3.62.8 1.12 1.42 1.42l-3 3c-.18.18-.43.29-.71.29s-.53-.11-.71-.3L7 10.41l-5 5V17h17c.55 0 1 .45 1 1s-.45 1-1 1H1a.998.998 0 01-1-1V4c0-.55.45-1 1-1s1 .45 1 1v8.59l4.29-4.3C6.47 8.11 6.72 8 7 8s.53.11.71.29l3.29 3.3 2.29-2.3z"];
  init_define_process();
  var series_filtered_default2 = ["M12.14 10.45c.21.67.65 1.23 1.22 1.61l-1.65 1.65c-.18.18-.43.29-.71.29s-.53-.11-.71-.3L7 10.41l-5 5V17h17c.55 0 1 .45 1 1s-.45 1-1 1H1a.998.998 0 01-1-1V4c0-.55.45-1 1-1s1 .45 1 1v8.59l4.29-4.3C6.47 8.11 6.72 8 7 8s.53.11.71.29l3.29 3.3 1.14-1.14zM19.35 1a.642.642 0 01.46 1.1l-3.03 3.03v2.95c0 .18-.07.34-.19.46l-1.28 1.29c-.11.1-.27.17-.45.17-.35 0-.64-.29-.64-.64V5.13L11.19 2.1a.642.642 0 01.45-1.1h7.71z"];
  init_define_process();
  var series_search_default2 = ["M11.28 11.31l-.28.28-3.29-3.3C7.53 8.11 7.28 8 7 8s-.53.11-.71.29L2 12.59V4c0-.55-.45-1-1-1s-1 .45-1 1v14a.998.998 0 001 1h18c.55 0 1-.45 1-1s-.45-1-1-1H2v-1.59l5-5 3.29 3.29c.18.19.43.3.71.3s.53-.11.71-.29l2.09-2.09c-.17.02-.34.02-.51.02-.7 0-1.38-.12-2.01-.33zm-.93-6c0-1.62 1.31-2.93 2.93-2.93s2.93 1.31 2.93 2.93-1.31 2.93-2.93 2.93-2.93-1.31-2.93-2.93zm6.47 2.43c.11-.17.21-.33.29-.51.01-.03.03-.06.04-.09.08-.18.16-.35.21-.54.06-.2.1-.38.14-.58.01-.05.01-.09.02-.14.03-.2.05-.39.05-.6 0-2.37-1.93-4.3-4.3-4.3-2.37.01-4.3 1.93-4.3 4.31s1.93 4.3 4.3 4.3c.21 0 .4-.02.6-.05.04 0 .09-.01.14-.02.2-.03.38-.08.57-.14.2-.06.37-.14.55-.21.03-.01.06-.03.09-.04.18-.09.34-.19.51-.29l2.87 2.87c.14.14.33.22.56.22.43 0 .78-.35.78-.78a.938.938 0 00-.23-.56l-2.89-2.85z"];
  init_define_process();
  var settings_default2 = ["M4 1c0-.55-.45-1-1-1S2 .45 2 1v5h2V1zM2 19c0 .55.45 1 1 1s1-.45 1-1v-6H2v6zm9-18c0-.55-.45-1-1-1S9 .45 9 1v8h2V1zm7 0c0-.55-.45-1-1-1s-1 .45-1 1v3h2V1zM9 19c0 .55.45 1 1 1s1-.45 1-1v-3H9v3zm9-14h-2c-.55 0-1 .45-1 1v3c0 .55.45 1 1 1h2c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm-2 14c0 .55.45 1 1 1s1-.45 1-1v-8h-2v8zM4 7H2c-.55 0-1 .45-1 1v3c0 .55.45 1 1 1h2c.55 0 1-.45 1-1V8c0-.55-.45-1-1-1zm7 3H9c-.55 0-1 .45-1 1v3c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-3c0-.55-.45-1-1-1z"];
  init_define_process();
  var shapes_default2 = ["M7.88 11.12a.958.958 0 011.277.33l3.719 6.207c.081.136.124.29.124.447 0 .495-.419.896-.936.896H4.936a.969.969 0 01-.436-.103.878.878 0 01-.392-1.21l3.409-6.208a.915.915 0 01.362-.36zM15 5a4 4 0 110 8 4 4 0 010-8zM8 1a1 1 0 011 1v6a1 1 0 01-1 1H2a1 1 0 01-1-1V2a1 1 0 011-1h6z"];
  init_define_process();
  var share_default2 = ["M15 18H2V5h8.76l2-2H1c-.55 0-1 .45-1 1v15c0 .55.45 1 1 1h15c.55 0 1-.45 1-1V7.24l-2 2V18zm4-18h-7c-.55 0-1 .45-1 1s.45 1 1 1h4.59l-7.3 7.29a1.003 1.003 0 001.42 1.42L18 3.41V8c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var shared_filter_default2 = ["M13.917 17.209c1.01.454 2.543.928 2.873 1.643.31.722.186 1.148.186 1.148H6.026s-.13-.426.186-1.148 1.842-1.203 2.86-1.65c1.017-.447.914-.722.948-1.093 0-.048.007-.097.007-.145a3.067 3.067 0 01-.839-1.237l-.007-.007c0-.007-.006-.014-.006-.02a1.757 1.757 0 01-.11-.337c-.234-.042-.372-.296-.426-.537a1.045 1.045 0 01-.138-.598c.034-.35.179-.509.337-.57v-.056c0-.44.034-1.065.117-1.478a2.508 2.508 0 01.962-1.623c.426-.33 1.038-.501 1.58-.501.544 0 1.155.172 1.588.502a2.496 2.496 0 01.963 1.622c.075.413.117 1.045.117 1.478v.062c.15.062.288.22.323.564.02.268-.083.502-.138.598-.048.234-.185.488-.42.537a2.635 2.635 0 01-.116.364 3.094 3.094 0 01-.818 1.224c0 .055 0 .11.007.158.034.378-.103.653.914 1.1z", "M14.976 16.57c-.24-.099-.455-.186-.65-.273l-.007-.004a3.801 3.801 0 01-.194-.091c.224-.288.41-.609.554-.946l.001-.002.013-.033c.018-.043.036-.087.052-.13l.011-.027.016-.04c.105-.092.19-.19.256-.284.129-.184.213-.38.265-.563.105-.226.225-.592.192-1.026l-.001-.011-.002-.011a1.854 1.854 0 00-.325-.91 9.924 9.924 0 00-.12-1.246 3.09 3.09 0 00-.106-.475l-.001-.006a3.543 3.543 0 00-.763-1.353c.27-.092.56-.139.83-.139.495 0 1.05.156 1.444.456a2.269 2.269 0 01.875 1.475c.069.375.106.95.106 1.344v.056c.138.056.263.2.294.513.019.244-.075.456-.125.543-.044.213-.169.444-.381.488-.025.1-.056.206-.094.3a2.815 2.815 0 01-.756 1.144c0 .05 0 .1.006.144.004.043.006.086.007.127.01.283.018.518.824.872.192.087.404.173.623.263.83.34 1.752.717 1.99 1.231.28.657.168 1.044.168 1.044h-2.081a3.864 3.864 0 00-.188-.542l-.005-.013-.006-.012c-.183-.397-.491-.681-.76-.88a5.614 5.614 0 00-.896-.522 17.36 17.36 0 00-.916-.4l-.15-.061zM14 1c.55 0 1 .45 1 1 0 .28-.11.53-.29.7L10 7.41v.897a3.182 3.182 0 00-.69.4 3.508 3.508 0 00-1.343 2.259c-.07.37-.107.836-.122 1.237a1.836 1.836 0 00-.339.926c-.046.458.09.84.195 1.06.053.178.138.376.27.56.055.08.125.162.21.242v.143l.053.052L6.71 16.71A1.003 1.003 0 015 16V7.41L.29 2.71A1.003 1.003 0 011 1h13z", "M9.059 14.361c-.23-.044-.366-.296-.42-.535a1.045 1.045 0 01-.138-.598c.034-.35.179-.509.337-.57v-.056c0-.44.034-1.065.117-1.478A2.508 2.508 0 0110 9.441V13c0 .28-.11.53-.29.71l-.651.651z"];
  init_define_process();
  var shield_default2 = ["M10 20c6-3.81 9-9.048 9-15.714-2 0-5-1.429-9-4.286-4 2.857-7 4.286-9 4.286C1 10.952 4 16.19 10 20zm0-17.348c2.577 1.734 4.776 2.88 6.667 3.419-.44 4.627-2.636 8.353-6.667 11.297V2.652z"];
  init_define_process();
  var ship_default2 = ["M6.84.804L6.5 2.5h-3a1 1 0 00-1 1v4.893l-1.58.451a.99.99 0 00-.691 1.192c.46 1.82 1.163 4.356 1.701 5.571-.218.012-.445.018-.68.018a.625.625 0 100 1.25c2.583 0 4.268-.68 5.202-1.146.687.466 1.88 1.146 3.548 1.146 1.65 0 2.837-.666 3.528-1.132l.005.003c.244.131.6.3 1.07.468.938.335 2.321.661 4.147.661a.625.625 0 100-1.25c-.323 0-.63-.011-.922-.031a.996.996 0 00.184-.334l1.67-5.168a1 1 0 00-.677-1.27l-1.505-.43V3.5a1 1 0 00-1-1h-3L13.16.804A1 1 0 0012.18 0H7.82a1 1 0 00-.98.804zM5 7.679l3.75-1.072V5H5v2.679zm6.25-1.072L15 7.68V5h-3.75v1.607zM6.205 16.95a.625.625 0 01.658.042c.569.407 1.597 1.134 3.137 1.134s2.568-.727 3.137-1.134a.625.625 0 01.724-.001l.007.005.045.029c.044.027.114.069.21.12.194.104.493.247.9.392.811.29 2.053.589 3.727.589a.625.625 0 110 1.25c-1.826 0-3.21-.326-4.148-.661a7.894 7.894 0 01-1.069-.468l-.005-.003c-.691.466-1.878 1.132-3.528 1.132-1.667 0-2.861-.68-3.548-1.146-.934.467-2.619 1.146-5.202 1.146a.625.625 0 110-1.25c2.66 0 4.23-.787 4.955-1.176z"];
  init_define_process();
  var shop_default2 = ["M17.94 3.63c-.01-.02-.01-.03-.02-.04l-.03-.09h-.01c-.18-.3-.49-.5-.86-.5h-14c-.42 0-.77.25-.92.61L0 8.5h.02a2.5 2.5 0 005 0 2.5 2.5 0 005 0 2.5 2.5 0 005 0 2.5 2.5 0 005 0l-2.08-4.87zM3.02 2h14c.55 0 1-.45 1-1s-.45-1-1-1h-14c-.55 0-1 .45-1 1s.44 1 1 1zm13 14h-12v-4h-2v7c0 .55.45 1 1 1h14c.55 0 1-.45 1-1v-7h-2v4z"];
  init_define_process();
  var shopping_cart_default2 = ["M18 14H8.72l-.67-2H17c.44 0 .8-.29.94-.69h.01l2-6h-.01c.03-.1.06-.2.06-.31 0-.55-.45-1-1-1H5.39l-.44-1.32h-.01C4.8 2.29 4.44 2 4 2H1c-.55 0-1 .45-1 1s.45 1 1 1h2.28l3.33 10H5c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2h9c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2zM6.05 6h11.56l-1.33 4H7.39L6.05 6z"];
  init_define_process();
  var signal_search_default2 = ["M7.15 10.33c.888.8 1.999 1.36 3.228 1.574l2.326 6.98a.846.846 0 01-.535 1.07.844.844 0 01-1.072-.535l-1.225-3.671H7.125L5.9 19.419a.85.85 0 01-1.072.536.85.85 0 01-.536-1.071l2.857-8.555zm1.353 1.305l-.808 2.413h1.607l-.8-2.413zM5 5.5c0 .76.13 1.49.37 2.17-.496 1.056-.313 2.356.704 3.29.385.353.404.94.038 1.311a.982.982 0 01-1.356.038c-2.183-2.01-2-5.125.01-6.94a.95.95 0 01.24-.156A6.421 6.421 0 005 5.5z", "M3.874 13.185c-1.346-.918-2.187-2.67-2.187-4.34 0-1.752.757-3.254 2.187-4.339.42-.25.42-.834.168-1.168-.252-.418-.84-.418-1.177-.167C1.014 4.59-.08 6.509.005 8.846c.084 2.253 1.177 4.423 2.86 5.675.168.083.336.166.504.166.253 0 .505-.083.673-.333.337-.418.253-.918-.168-1.169zM12.246 12.309a.98.98 0 01-1.354-.037.917.917 0 01-.206-.324 6.54 6.54 0 001.959-.049 5.125 5.125 0 01-.399.41zM14.631 11.476l1.228 1.229a6.6 6.6 0 01-1.723 1.816c-.169.083-.337.166-.505.166-.253 0-.505-.083-.673-.333-.337-.418-.253-.918.168-1.169.62-.422 1.133-1.022 1.505-1.709z", "M11.5 0C14.54 0 17 2.46 17 5.5c0 .26-.02.51-.06.75l-.03.17c-.04.25-.1.49-.17.73v.01c-.08.24-.17.47-.28.69-.01.04-.03.07-.05.11-.11.23-.24.44-.38.65l3.68 3.68A1.003 1.003 0 0119 14c-.28 0-.53-.11-.7-.29l-3.68-3.68c-.21.14-.42.27-.65.38-.04.01-.07.03-.11.05-.22.11-.45.2-.69.28h-.01c-.24.07-.48.13-.73.17l-.17.03c-.25.04-.5.06-.76.06C8.46 11 6 8.54 6 5.5S8.46 0 11.5 0zm0 1.5c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z"];
  init_define_process();
  var sim_card_default2 = ["M16.71 5.29l-5-5A.997.997 0 0011 0H4c-.55 0-1 .45-1 1v18c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V6c0-.28-.11-.53-.29-.71zM9 7h2v3H9V7zM6 7h2v3H6V7zm2 11H6v-3h2v3zm3 0H9v-3h2v3zm3 0h-2v-3h2v3zm0-4H6v-3h8v3zm0-4h-2V7h2v3z"];
  init_define_process();
  var slash_default2 = ["M12 2c-.46 0-.85.32-.97.74L7.04 16.7c-.02.1-.04.2-.04.3 0 .55.45 1 1 1 .46 0 .85-.32.97-.74L12.96 3.3c.02-.1.04-.2.04-.3 0-.55-.45-1-1-1z"];
  init_define_process();
  var small_cross_default2 = ["M11.41 10l3.29-3.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L10 8.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42L8.59 10 5.3 13.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l3.29-3.3 3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L11.41 10z"];
  init_define_process();
  var small_info_sign_default2 = ["M17 10a7 7 0 11-14 0 7 7 0 0114 0zm-6-5v2H9V5h2zm0 3v6h1v1H8v-1h1V9H8V8h3z"];
  init_define_process();
  var small_minus_default2 = ["M14 9H6c-.55 0-1 .45-1 1s.45 1 1 1h8c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var small_plus_default2 = ["M14 9h-3V6c0-.55-.45-1-1-1s-1 .45-1 1v3H6c-.55 0-1 .45-1 1s.45 1 1 1h3v3c0 .55.45 1 1 1s1-.45 1-1v-3h3c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var small_square_default2 = ["M5 5v10h10V5H5zM4 3a1 1 0 00-1 1v12a1 1 0 001 1h12a1 1 0 001-1V4a1 1 0 00-1-1H4z"];
  init_define_process();
  var small_tick_default2 = ["M15 5c-.28 0-.53.11-.71.29L8 11.59l-2.29-2.3a1.003 1.003 0 00-1.42 1.42l3 3c.18.18.43.29.71.29s.53-.11.71-.29l7-7A1.003 1.003 0 0015 5z"];
  init_define_process();
  var snowflake_default2 = ["M11 11.776v2.81l2.31 2.242a.987.987 0 010 1.415c-.399.39-1.044.39-1.442 0L11 17.414V19a.99.99 0 01-.996 1A.996.996 0 019 19v-1.636l-.912.879c-.398.39-1.043.39-1.441 0a.987.987 0 010-1.415L9 14.536v-2.79l-2.548 1.435-.837 3.063c-.146.534-.705.85-1.248.707a.998.998 0 01-.721-1.224l.309-1.132-1.4.793a1.03 1.03 0 01-1.393-.366.99.99 0 01.373-1.366l1.445-.818-1.224-.322a.998.998 0 01-.72-1.225c.145-.533.704-.85 1.248-.707l3.193.84 2.462-1.395-2.532-1.434-3.123.82a1.022 1.022 0 01-1.249-.706.998.998 0 01.721-1.225L2.91 7.18l-1.4-.793a.99.99 0 01-.373-1.366 1.03 1.03 0 011.392-.366l1.445.818-.328-1.2a.998.998 0 01.72-1.225 1.022 1.022 0 011.25.707l.855 3.132L9 8.311V5.414L6.647 3.121a.987.987 0 010-1.414 1.033 1.033 0 011.441 0L9 2.586V1c0-.552.44-1 1.004-1A.99.99 0 0111 1l-.007 1.536.875-.829a1.033 1.033 0 011.441 0 .987.987 0 010 1.414L11 5.364v2.918l2.53-1.42.855-3.131c.146-.534.705-.85 1.249-.707a.998.998 0 01.72 1.224l-.327 1.2 1.4-.792a1.03 1.03 0 011.392.366.99.99 0 01-.373 1.366l-1.355.768 1.153.303a.998.998 0 01.721 1.225c-.146.533-.705.85-1.249.707l-3.123-.821-2.576 1.459 2.506 1.42 3.193-.84a1.022 1.022 0 011.249.707.998.998 0 01-.72 1.225l-1.224.322 1.4.793a.99.99 0 01.373 1.366 1.03 1.03 0 01-1.393.366l-1.356-.768.31 1.132a.998.998 0 01-.721 1.224 1.022 1.022 0 01-1.249-.707l-.837-3.063L11 11.776z"];
  init_define_process();
  var social_media_default2 = ["M11.5 5c.8 0 1.6-.4 2-1 2 1.2 3.3 3.3 3.5 5.7 0 .5.5.9 1 .9.6 0 1-.5 1-1v-.1c-.2-3.3-2.2-6.2-5.1-7.6C13.7.8 12.7 0 11.5 0 10.1 0 9 1.1 9 2.5S10.1 5 11.5 5zm5 7c-1.4 0-2.5 1.1-2.5 2.5 0 .4.1.7.2 1.1-1.1.9-2.6 1.4-4.2 1.4-1.9 0-3.6-.8-4.9-2-.2-.2-.5-.4-.8-.4-.5 0-1 .5-1 1 0 .3.1.5.3.7C5.3 18 7.5 19 10 19c2.2 0 4.2-.8 5.8-2.1.2.1.5.1.7.1 1.4 0 2.5-1.1 2.5-2.5S17.9 12 16.5 12zM5 10.5c0-1.1-.7-2.1-1.7-2.4.5-1.9 1.9-3.5 3.6-4.4.3-.2.6-.5.6-.9 0-.5-.4-1-1-1-.2 0-.4.1-.6.2-2.4 1.2-4.2 3.6-4.7 6.4C.5 8.9 0 9.6 0 10.5 0 11.9 1.1 13 2.5 13S5 11.9 5 10.5z"];
  init_define_process();
  var sort_default2 = ["M19 16h-9c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h9c.55 0 1-.45 1-1v-1c0-.55-.45-1-1-1zm0-5h-9c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h9c.55 0 1-.45 1-1v-1c0-.55-.45-1-1-1zM7 15c-.28 0-.53.11-.71.29L5 16.59V11c0-.55-.45-1-1-1s-1 .45-1 1v5.59L1.71 15.3A.965.965 0 001 15a1.003 1.003 0 00-.71 1.71l3 3c.18.18.43.29.71.29s.53-.11.71-.29l3-3A1.003 1.003 0 007 15zM19 1h-9c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h9c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zm0 5h-9c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h9c.55 0 1-.45 1-1V7c0-.55-.45-1-1-1z"];
  init_define_process();
  var sort_alphabetical_default2 = ["M8 15c-.28 0-.53.11-.71.29L6 16.59v-5.58c0-.55-.45-1-1-1s-1 .45-1 1v5.58L2.71 15.3c-.18-.18-.43-.3-.71-.3a1.003 1.003 0 00-.71 1.71l3 3c.18.18.43.29.71.29s.53-.11.71-.29l3-3A1.003 1.003 0 008 15zm8.89-.79v-1.22H11.3v1.3h3.51L11 18.78V20h5.99v-1.3h-3.91l3.81-4.49zM14.97 0h-1.95L9.01 11.01h1.89l.98-2.92h4.17l.98 2.92h1.96L14.97 0zm-2.59 6.63l1.58-4.74H14l1.57 4.74h-3.19z"];
  init_define_process();
  var sort_alphabetical_desc_default2 = ["M8.01 15c-.28 0-.53.11-.71.29L6 16.59v-5.58c0-.55-.45-1-1-1s-1 .45-1 1v5.58L2.71 15.3c-.18-.18-.43-.3-.71-.3a1.003 1.003 0 00-.71 1.71l3 3a1.014 1.014 0 001.42 0l3-3c.18-.18.29-.43.29-.71.01-.55-.44-1-.99-1zm4.44-5.65l6.4-7.88V0H10.5v1.67h5.91L10 9.44v1.57h9V9.35h-6.55zm1.27 3.64L11 20h1.59l.56-1.56h2.68l.55 1.56h1.64l-2.68-7.01h-1.62zm-.16 4.3l.93-2.57h.02l.9 2.57h-1.85z"];
  init_define_process();
  var sort_asc_default2 = ["M10 8h5c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1h-5c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1zm0 5h7c.55 0 1-.45 1-1v-1c0-.55-.45-1-1-1h-7c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1zm0-10h3c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1h-3c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1zm9 12h-9c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h9c.55 0 1-.45 1-1v-1c0-.55-.45-1-1-1zM7 14c-.28 0-.53.11-.71.29L5 15.59V10c0-.55-.45-1-1-1s-1 .45-1 1v5.59L1.71 14.3A.965.965 0 001 14a1.003 1.003 0 00-.71 1.71l3 3c.18.18.43.29.71.29s.53-.11.71-.29l3-3A1.003 1.003 0 007 14z"];
  init_define_process();
  var sort_desc_default2 = ["M13 15h-3c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-1c0-.55-.45-1-1-1zm-6-1c-.28 0-.53.11-.71.29L5 15.59V10c0-.55-.45-1-1-1s-1 .45-1 1v5.59L1.71 14.3A.965.965 0 001 14a1.003 1.003 0 00-.71 1.71l3 3c.18.18.43.29.71.29s.53-.11.71-.29l3-3A1.003 1.003 0 007 14zM19 0h-9c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h9c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-4 10h-5c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h5c.55 0 1-.45 1-1v-1c0-.55-.45-1-1-1zm2-5h-7c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h7c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1z"];
  init_define_process();
  var sort_numerical_default2 = ["M9 14.99c-.28 0-.53.11-.71.29L7 16.58v-5.59c0-.55-.45-1-1-1s-1 .45-1 1v5.59l-1.29-1.29a.965.965 0 00-.71-.3 1.003 1.003 0 00-.71 1.71l3 3c.18.18.43.29.71.29.28 0 .53-.11.71-.29l3-3c.18-.18.29-.43.29-.71a.99.99 0 00-1-1zm8.88.23c-.08-.42-.22-.79-.42-1.12-.2-.33-.47-.6-.8-.8-.33-.2-.76-.3-1.28-.3a2.333 2.333 0 00-1.72.71c-.21.22-.37.48-.49.78-.11.3-.17.62-.17.97 0 .27.04.54.13.8.08.26.22.5.4.7.19.21.43.38.71.5a2.142 2.142 0 001.72.02c.25-.12.47-.31.66-.58l.02.02c-.01.19-.04.4-.08.63-.04.24-.11.46-.21.67-.1.21-.23.38-.39.53a.92.92 0 01-.62.22c-.24 0-.44-.08-.6-.25-.16-.17-.27-.36-.31-.59h-1.31c.04.29.12.56.24.79.12.23.28.43.48.59.19.16.42.28.67.36.25.08.52.12.82.12.49 0 .9-.1 1.23-.31.34-.21.61-.48.82-.82.21-.34.37-.71.47-1.13.1-.42.15-.83.15-1.25 0-.43-.04-.85-.12-1.26zm-1.42.63c-.05.15-.11.28-.2.4-.09.12-.2.21-.34.27s-.3.1-.49.1c-.17 0-.33-.04-.46-.11s-.24-.17-.33-.29c-.08-.12-.15-.25-.19-.4-.04-.15-.06-.31-.06-.47 0-.15.02-.3.07-.45.05-.15.11-.28.2-.39.09-.12.2-.21.33-.28.13-.07.27-.11.44-.11.17 0 .33.04.47.11.14.07.25.17.34.28a1.387 1.387 0 01.28.86c.01.17-.02.33-.06.48zM15.32 11H17V0h-1.25c-.05.34-.17.62-.34.85-.17.23-.39.42-.63.57-.25.15-.52.25-.83.31-.3.06-.62.09-.94.09v1.41h2.31V11z"];
  init_define_process();
  var sort_numerical_desc_default2 = ["M9 15c-.28 0-.53.11-.71.29L7 16.59v-5.58c0-.55-.45-1-1-1s-1 .45-1 1v5.58L3.71 15.3c-.18-.18-.43-.3-.71-.3a1.003 1.003 0 00-.71 1.71l3 3c.18.18.43.29.71.29.28 0 .53-.11.71-.29l3-3A1.003 1.003 0 009 15zm6.7-1.33a1.5 1.5 0 01-.44.43c-.17.11-.37.19-.58.23-.22.04-.44.06-.67.05v1.07h1.66V20H17v-6.99h-1.06c-.04.26-.12.48-.24.66zm3.15-10.3c-.11-.68-.29-1.26-.55-1.76-.26-.5-.62-.89-1.08-1.18C16.75.14 16.17 0 15.46 0c-.54 0-1.03.09-1.46.27-.43.18-.79.44-1.09.76-.3.33-.52.71-.67 1.15-.16.44-.24.92-.24 1.43 0 .54.08 1.04.23 1.47.15.44.37.81.65 1.12.28.31.61.55 1 .72.39.17.82.26 1.3.26.46 0 .88-.11 1.26-.33.38-.22.68-.53.9-.94l.03.03c-.03.35-.07.74-.12 1.16-.05.42-.15.81-.29 1.18-.14.37-.35.68-.61.92-.26.25-.62.37-1.06.37-.43 0-.77-.13-1.03-.4-.25-.27-.4-.62-.44-1.05h-1.64c.02.43.11.83.29 1.18.17.35.39.66.67.91a3.027 3.027 0 002.07.8c.71 0 1.3-.17 1.79-.5.48-.33.87-.76 1.17-1.29.3-.53.51-1.12.64-1.76.13-.64.19-1.28.19-1.92.01-.77-.05-1.49-.15-2.17zM17.1 4.44c-.08.27-.19.5-.34.71-.15.21-.34.37-.57.49-.23.12-.5.18-.8.18-.3 0-.56-.06-.78-.19-.22-.13-.4-.29-.55-.49-.14-.2-.25-.44-.32-.7-.07-.27-.11-.55-.11-.84 0-.28.04-.55.11-.82.07-.26.18-.49.32-.7.14-.2.33-.36.55-.48.22-.12.48-.17.78-.17.31 0 .57.06.8.18.23.12.42.28.57.48.15.2.26.43.34.69.08.26.11.53.11.82 0 .29-.04.57-.11.84z"];
  init_define_process();
  var split_columns_default2 = ["M15 13a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71l-3-3a1.003 1.003 0 00-1.42 1.42L16.59 9H11V2h5v2c.77 0 1.47.3 2 .78V1c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v3.78C2.53 4.3 3.23 4 4 4V2h5v7H3.41L4.7 7.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-3 3C.11 9.47 0 9.72 0 10c0 .28.11.53.29.71l3 3a1.003 1.003 0 001.42-1.42L3.41 11H9v7H4v-2c-.77 0-1.47-.3-2-.78V19c0 .55.45 1 1 1h14c.55 0 1-.45 1-1v-3.78c-.53.48-1.23.78-2 .78v2h-5v-7h5.59l-1.29 1.29c-.19.18-.3.43-.3.71z"];
  init_define_process();
  var square_default2 = ["M19 0H1C.45 0 0 .45 0 1v18c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 18H2V2h16v16z"];
  init_define_process();
  var stacked_chart_default2 = ["M12 2c0-.55-.45-1-1-1H9c-.55 0-1 .45-1 1v4h4V2zm3 14h2c.55 0 1-.45 1-1v-5h-4v5c0 .55.45 1 1 1zm3-10c0-.55-.45-1-1-1h-2c-.55 0-1 .45-1 1v3h4V6zm-6 1H8v5h4V7zm-9 9h2c.55 0 1-.45 1-1v-3H2v3c0 .55.45 1 1 1zm16 1H1c-.55 0-1 .45-1 1s.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1zM6 9c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v2h4V9zm3 7h2c.55 0 1-.45 1-1v-2H8v2c0 .55.45 1 1 1z"];
  init_define_process();
  var stadium_geometry_default2 = ["M15 7H5a3 3 0 000 6h10a3 3 0 100-6zM5 5a5 5 0 000 10h10a5 5 0 000-10H5z"];
  init_define_process();
  var star_default2 = ["M10 0l3.1 6.6 6.9 1-5 5.1 1.2 7.3-6.2-3.4L3.8 20 5 12.7 0 7.6l6.9-1z"];
  init_define_process();
  var star_empty_default2 = ["M20 7.6l-6.9-1.1L10 0 6.9 6.6 0 7.6l5 5.1L3.8 20l6.2-3.4 6.2 3.4-1.2-7.2 5-5.2zM10 15l-4.5 2.4.9-5.2-3.6-3.6 5-.8L10 3.1l2.2 4.7 5 .8-3.6 3.7.9 5.2L10 15z"];
  init_define_process();
  var step_backward_default2 = ["M15 3c-.23 0-.42.09-.59.21l-.01-.01L8 8V4c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-4l6.4 4.8.01-.01c.17.12.36.21.59.21.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var step_chart_default2 = ["M19 16H2v-3h4c.55 0 1-.45 1-1V8h3v2c0 .55.45 1 1 1h5c.55 0 1-.45 1-1V6h2c.55 0 1-.45 1-1s-.45-1-1-1h-3c-.55 0-1 .45-1 1v4h-3V7c0-.55-.45-1-1-1H6c-.55 0-1 .45-1 1v4H2V3c0-.55-.45-1-1-1s-1 .45-1 1v14c0 .55.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var step_forward_default2 = ["M15 3h-2c-.55 0-1 .45-1 1v4L5.6 3.2l-.01.01C5.42 3.09 5.23 3 5 3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1 .23 0 .42-.09.59-.21l.01.01L12 12v4c0 .55.45 1 1 1h2c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var stop_default2 = ["M16 3H4c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var stopwatch_default2 = ["M10 6a6 6 0 106 6h-6V6zm-.998-1.938A1.015 1.015 0 019 4V2H7a1 1 0 110-2h6a1 1 0 010 2h-2v2c0 .02 0 .041-.002.062A8.001 8.001 0 0110 20a8 8 0 01-.998-15.938z"];
  init_define_process();
  var strikethrough_default2 = ["M18 9h-4.46a4.7 4.7 0 00-.4-.14c-.19-.05-.51-.14-.96-.25-.45-.11-.9-.23-1.37-.35-.47-.12-.89-.23-1.27-.33s-.6-.16-.65-.17c-.53-.15-.95-.37-1.27-.66-.32-.28-.49-.68-.49-1.19 0-.36.09-.66.26-.9s.39-.43.65-.57c.26-.14.55-.24.87-.3s.63-.09.93-.09c.89 0 1.63.19 2.21.57.45.3.75.76.89 1.38h2.63c-.06-.52-.2-.98-.42-1.4-.3-.57-.71-1.05-1.23-1.43a5.33 5.33 0 00-1.79-.87c-.7-.2-1.42-.3-2.19-.3-.66 0-1.31.08-1.96.25s-1.22.43-1.73.77-.92.79-1.23 1.32c-.31.52-.46 1.15-.46 1.87 0 .37.05.74.15 1.1.1.36.28.7.53 1.02.18.24.41.47.69.67H2c-.55 0-1 .45-1 1s.45 1 1 1h10.14c.02.01.05.02.07.02.3.11.58.29.84.55.25.26.38.67.38 1.21 0 .27-.06.53-.17.79-.11.26-.29.49-.54.69-.25.2-.57.36-.97.49s-.88.19-1.44.19c-.52 0-1.01-.06-1.45-.17-.45-.11-.84-.29-1.19-.54s-.61-.56-.8-.95c-.05-.08-.09-.18-.12-.28H4.11c.09.43.22.82.4 1.18.33.65.77 1.18 1.32 1.59.55.41 1.2.72 1.94.92.74.2 1.53.3 2.37.3.73 0 1.44-.08 2.14-.25.7-.17 1.33-.43 1.88-.79.55-.36.99-.83 1.33-1.39.34-.56.51-1.25.51-2.05 0-.37-.06-.75-.18-1.12a3.12 3.12 0 00-.15-.39H18c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var style_default2 = ["M18 18H2V2h12.3l2-2H1C.4 0 0 .4 0 1v18c0 .6.4 1 1 1h18c.6 0 1-.4 1-1V7.7l-2 2V18zm1.2-18l-7.6 7.6 2.8 2.8L20 4.8V0h-.8zM4 15.9c3.1.2 5.9.2 8.2-2 1.1-1.1 1.1-3 0-4.1-.6-.5-1.3-.8-2-.8s-1.4.3-1.9.8C7.2 11 6.6 14.3 4 15.9z"];
  init_define_process();
  var swap_horizontal_default2 = ["M16.02 10c-.01 0-.01 0 0 0H16h.02zM2 6h13.58l-2.29 2.29a1 1 0 00-.3.71 1.003 1.003 0 001.71.71l4-4c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71l-4-4a1.003 1.003 0 00-1.42 1.42L15.58 4H2c-.55 0-1 .45-1 1s.45 1 1 1zm2 4h-.02H4zm14 4H4.42l2.29-2.29a1 1 0 00.3-.71 1.003 1.003 0 00-1.71-.71l-4 4c-.18.18-.29.43-.29.71 0 .28.11.53.29.71l4 4a1.003 1.003 0 001.42-1.42L4.42 16H18c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var swap_vertical_default2 = ["M9.71 5.3l-4-4A.997.997 0 005 1.01c-.28 0-.53.11-.71.29l-4 4a1.003 1.003 0 001.42 1.42L4 4.42V18c0 .55.45 1 1 1s1-.45 1-1V4.42l2.29 2.29a1 1 0 00.71.3 1.003 1.003 0 00.71-1.71zM10 3.98c0 .01 0 .01 0 0V4v-.02zm0 12.04c0-.01 0-.01 0 0V16v.02zm9-3.03c-.28 0-.53.11-.71.29L16 15.58V2c0-.55-.45-1-1-1s-1 .45-1 1v13.58l-2.29-2.29a1.003 1.003 0 00-1.42 1.42l4 4c.18.18.43.29.71.29.28 0 .53-.11.71-.29l4-4c.18-.18.29-.43.29-.71 0-.56-.45-1.01-1-1.01z"];
  init_define_process();
  var switch_default2 = ["M12.293 2.293l1.414 1.414-7.127 7.129a3.5 3.5 0 11-1.415-1.415l7.128-7.128zM16.5 9a3.5 3.5 0 110 7 3.5 3.5 0 010-7zm-13 2a1.5 1.5 0 100 3 1.5 1.5 0 000-3zm13 0a1.5 1.5 0 100 3 1.5 1.5 0 000-3z"];
  init_define_process();
  var symbol_circle_default2 = ["M10 4.01a6 6 0 100 12 6 6 0 100-12z"];
  init_define_process();
  var symbol_cross_default2 = ["M15 8.01h-3v-3c0-.55-.45-1-1-1H9c-.55 0-1 .45-1 1v3H5c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h3v3c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-3h3c.55 0 1-.45 1-1v-2c0-.56-.45-1-1-1z"];
  init_define_process();
  var symbol_diamond_default2 = ["M15 10.01c0-.21-.08-.39-.18-.54l.02-.01-4-6-.02.01c-.18-.28-.47-.46-.82-.46s-.64.18-.82.45l-.01-.01-4 6 .02.01c-.11.16-.19.34-.19.55s.08.39.18.54l-.02.01 4 6 .02-.01c.18.27.47.46.82.46s.64-.19.82-.46l.02.01 4-6-.02-.01c.1-.16.18-.34.18-.54z"];
  init_define_process();
  var symbol_rectangle_default2 = ["M16 5H4c-.5 0-1 .5-1 1v8c0 .5.5 1 1 1h12c.5 0 1-.5 1-1V6c0-.5-.5-1-1-1z"];
  init_define_process();
  var symbol_square_default2 = ["M15 4.01H5c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h10c.55 0 1-.45 1-1v-10c0-.56-.45-1-1-1z"];
  init_define_process();
  var symbol_triangle_down_default2 = ["M16 5c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1 0 .16.05.31.11.44H4.1l5 10h.01c.17.33.5.56.89.56s.72-.23.89-.56h.01l5-10h-.01c.06-.13.11-.28.11-.44z"];
  init_define_process();
  var symbol_triangle_up_default2 = ["M15.89 14.56l-4.99-10h-.01c-.17-.33-.5-.56-.89-.56s-.72.23-.89.56H9.1l-5 10h.01c-.06.13-.11.28-.11.44 0 .55.45 1 1 1h10c.55 0 1-.45 1-1 0-.16-.05-.31-.11-.44z"];
  init_define_process();
  var syringe_default2 = ["M15.146.854a.5.5 0 01.708-.708l4 4a.5.5 0 01-.708.708l-.646-.647L17.207 5.5l1.647 1.646a.5.5 0 01-.708.708l-.646-.647-1.146 1.146-7.5 7.5a.5.5 0 01-.708 0l-.646-.646-2.646 2.647a.5.5 0 01-.708 0l-.646-.647-2.646 2.647a.5.5 0 01-.708-.708L2.793 16.5l-.647-.646a.5.5 0 010-.708L4.793 12.5l-.647-.646a.5.5 0 010-.708l7.5-7.5L12.794 2.5l-.647-.646a.5.5 0 01.708-.708L14.5 2.793 15.793 1.5l-.647-.646zM12.707 4l.793-.793L16.793 6.5 16 7.293 12.707 4zm2.586 4l-.793.793-1.646-1.647a.5.5 0 00-.708.708L13.793 9.5 12.5 10.793l-1.646-1.647a.5.5 0 00-.708.708l1.647 1.646-1.293 1.293-1.646-1.647a.5.5 0 00-.708.708L9.793 13.5 8.5 14.793 5.207 11.5 12 4.707 15.293 8zM3.207 15.5L5.5 13.207 6.793 14.5 4.5 16.793 3.207 15.5zM16.5 2.207L17.793 3.5 16.5 4.793 15.207 3.5 16.5 2.207z"];
  init_define_process();
  var tag_default2 = ["M2 4a2 2 0 012-2h4.588a2 2 0 011.414.586l7.41 7.41a2 2 0 010 2.828l-4.588 4.588a2 2 0 01-2.829 0l-7.41-7.41A2 2 0 012 8.588V4zm3.489-.006a1.495 1.495 0 100 2.99 1.495 1.495 0 000-2.99z"];
  init_define_process();
  var take_action_default2 = ["M5 7c.28 0 .53-.11.71-.29l5-5A1.003 1.003 0 009.29.29l-5 5A1.003 1.003 0 005 7zm6 6a1.003 1.003 0 001.71.71l5-5a1.003 1.003 0 00-1.42-1.42l-5 5c-.18.18-.29.43-.29.71zm8 5h-1c0-.55-.45-1-1-1h-7c-.55 0-1 .45-1 1H8c-.55 0-1 .45-1 1s.45 1 1 1h11c.55 0 1-.45 1-1s-.45-1-1-1zm-9-6l6-6-1.29-1.29a1.003 1.003 0 00-1.42-1.42L12 2 6 8l1.29 1.29-7 7a1.003 1.003 0 001.42 1.42l7-7L10 12z"];
  init_define_process();
  var tank_default2 = ["M3.956 4.47A1 1 0 014.804 4h6.392a1 1 0 01.848.47L13 6h5a1 1 0 010 2h-5v1h4a3 3 0 110 6H3a3 3 0 010-6V6.287a1 1 0 01.152-.53l.804-1.287zM3 11h14a1 1 0 110 2H3a1 1 0 110-2z"];
  init_define_process();
  var target_default2 = ["M9 5a1 1 0 012 0v3a1 1 0 01-2 0V5zM12 9a1 1 0 000 2h3a1 1 0 000-2h-3zM4 10a1 1 0 011-1h3a1 1 0 010 2H5a1 1 0 01-1-1zM10 11a1 1 0 00-1 1v3a1 1 0 002 0v-3a1 1 0 00-1-1z", "M10 20c5.523 0 10-4.477 10-10S15.523 0 10 0 0 4.477 0 10s4.477 10 10 10zm0-2a8 8 0 100-16 8 8 0 000 16z"];
  init_define_process();
  var taxi_default2 = ["M19 9h-.33l.33 1v.5c0 .15-.03.3-.07.44h.01L17 17.23v.27c0 .83-.67 1.5-1.5 1.5s-1.5-.67-1.5-1.5V17H6v.5c0 .83-.67 1.5-1.5 1.5S3 18.33 3 17.5v-.27l-1.93-6.28h.01c-.05-.15-.08-.3-.08-.45V10s.02-.06.05-.16c.06-.17.16-.47.28-.84H1c-.55 0-1-.45-1-1s.45-1 1-1h1l1-3h-.01v-.01c.25-.64 1-1.31 1.67-1.5 0 0 .78-.21 2.33-.36V1c0-.55.45-1 1-1h4c.55 0 1 .45 1 1v1.13c1.55.14 2.33.36 2.33.36.67.19 1.42.86 1.67 1.5V4H17l1 3h1c.55 0 1 .45 1 1s-.45 1-1 1zM3 11.5c0 .83.67 1.5 1.5 1.5S6 12.33 6 11.5 5.33 10 4.5 10 3 10.67 3 11.5zM16 7l-1-3H5L4 7v1h12V7zm-.5 3c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"];
  init_define_process();
  var temperature_default2 = ["M11 0a2 2 0 00-2 2v10.535a4 4 0 104 0V2a2 2 0 00-2-2zM3 2.5a.5.5 0 01.5-.5h4a.5.5 0 010 1h-4a.5.5 0 01-.5-.5zM3.5 8a.5.5 0 000 1h4a.5.5 0 000-1h-4zM5 5.5a.5.5 0 01.5-.5h2a.5.5 0 010 1h-2a.5.5 0 01-.5-.5zm.5 5.5a.5.5 0 000 1h2a.5.5 0 000-1h-2z"];
  init_define_process();
  var text_highlight_default2 = ["M16 17c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1s1-.45 1-1-.45-1-1-1c-.77 0-1.47.3-2 .78-.53-.48-1.23-.78-2-.78-.55 0-1 .45-1 1s.45 1 1 1 1 .45 1 1v12c0 .55-.45 1-1 1s-1 .45-1 1 .45 1 1 1c.77 0 1.47-.3 2-.78.53.48 1.23.78 2 .78.55 0 1-.45 1-1s-.45-1-1-1zm-4-4H2V7h10V5H1c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1h11v-2zm7-8h-3v2h2v6h-2v2h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1z"];
  init_define_process();
  var th_default2 = ["M19 1H1c-.6 0-1 .5-1 1v16c0 .5.4 1 1 1h18c.5 0 1-.5 1-1V2c0-.5-.5-1-1-1zM7 17H2v-3h5v3zm0-4H2v-3h5v3zm0-4H2V6h5v3zm11 8H8v-3h10v3zm0-4H8v-3h10v3zm0-4H8V6h10v3z"];
  init_define_process();
  var th_derived_default2 = ["M5.3 13.3c-.2.2-.3.4-.3.7 0 .6.4 1 1 1 .3 0 .5-.1.7-.3l3-3c.2-.2.3-.4.3-.7s-.1-.5-.3-.7l-3-3C6.5 7.1 6.3 7 6 7c-.6 0-1 .4-1 1 0 .3.1.5.3.7L6.6 10H1c-.6 0-1 .4-1 1s.4 1 1 1h5.6l-1.3 1.3zM19 1H3c-.5 0-1 .5-1 1v6h1c0-1.7 1.3-3 3-3 .8 0 1.6.3 2.1.9l.1.1H9v.8l1 1V6h8v3h-6.8c.3.3.5.6.6 1H18v3h-6.8l-.1.1-.9.9H18v3h-8v-2.8l-1 1V17H4v-.8c-.6-.5-1-1.3-1-2.2H2v4c0 .5.5 1 1 1h16c.6 0 1-.5 1-1V2c0-.5-.5-1-1-1z"];
  init_define_process();
  var th_disconnect_default2 = ["M14.25 1H19c.5 0 1 .5 1 1v16c0 .5-.5 1-1 1h-7.221l.278-2H18v-3h-5.527l.14-1H18v-3h-4.971l.139-1H18V6h-4.416l.637-4.587c.02-.139.03-.277.03-.413zM8.221 1l-.694 5H2v3h5.11l-.139 1H2v3h4.555l-.14 1H2v3h3.999l-.22 1.587c-.02.139-.03.277-.03.413H1c-.6 0-1-.5-1-1V2c0-.5.4-1 1-1h7.221zM10.26.862a1 1 0 011.98.276l-2.5 18a1 1 0 01-1.98-.276l2.5-18z"];
  init_define_process();
  var th_filtered_default2 = ["M17.333 10l1.435-1.722a1 1 0 00.232-.64V4.85l1-.9V18c0 .5-.5 1-1 1H1c-.6 0-1-.5-1-1V2c0-.5.4-1 1-1h6.722L12 4.85V6H8v3h4v1H8v3h10v-3h-.667zM7 17v-3H2v3h5zm0-4v-3H2v3h5zm0-4V6H2v3h5zm11 8v-3H8v3h10z", "M19.35 0a.642.642 0 01.46 1.1l-3.03 3.03v2.95c0 .18-.07.34-.19.46l-1.28 1.29c-.11.1-.27.17-.45.17-.35 0-.64-.29-.64-.64V4.13L11.19 1.1a.642.642 0 01.45-1.1h7.71z"];
  init_define_process();
  var th_list_default2 = ["M19 1H1c-.6 0-1 .5-1 1v16c0 .5.4 1 1 1h18c.5 0 1-.5 1-1V2c0-.5-.5-1-1-1zm-1 16H2v-3h16v3zm0-4H2v-3h16v3zm0-4H2V6h16v3z"];
  init_define_process();
  var third_party_default2 = ["M8 0C3.58 0 0 3.58 0 8a8 8 0 005.856 7.71c.064-.057.129-.109.19-.156.278-.209.595-.383.896-.53.358-.174.81-.358 1.193-.515.206-.084.393-.16.534-.223a3.93 3.93 0 00.203-.095 4.1 4.1 0 01-.305-.45C8.382 13.911 8.19 14 8 14c-.67 0-1.36-1.1-1.73-3h1.252c.047-.296.153-.571.323-.797l.01-.203H6.12C6.05 9.39 6 8.73 6 8s.05-1.39.12-2h3.76l.037.344c.315-.145.65-.242.979-.295L10.89 6h2.76c.027.077.052.155.076.233l.118-.04A3.62 3.62 0 0114.998 6c.247 0 .51.028.772.086A8 8 0 008 0zm5.17 5h-2.44c-.21-1.11-.51-2.03-.91-2.69 1.43.46 2.61 1.43 3.35 2.69zM8 2c.67 0 1.36 1.1 1.73 3H6.27C6.64 3.1 7.33 2 8 2zm-1.82.31c-.4.66-.71 1.58-.91 2.69H2.83a6.025 6.025 0 013.35-2.69zM2 8c0-.7.13-1.37.35-2h2.76C5.04 6.62 5 7.28 5 8s.04 1.38.11 2H2.35C2.13 9.37 2 8.7 2 8zm.83 3h2.44c.21 1.11.51 2.03.91 2.69A6.025 6.025 0 012.83 11z", "M13.917 15.209c.21.094.444.19.685.288.912.374 1.927.789 2.188 1.355.31.722.186 1.148.186 1.148H6.026s-.13-.426.186-1.148c.256-.584 1.305-1.011 2.234-1.39.22-.088.432-.175.626-.26.909-.4.923-.662.94-.978.002-.037.004-.076.008-.115l.003-.072c.002-.025.004-.049.004-.073a3.067 3.067 0 01-.839-1.237l-.007-.007a.024.024 0 00-.003-.01 1.757 1.757 0 01-.113-.347c-.234-.042-.372-.296-.427-.537a1.045 1.045 0 01-.137-.598c.034-.35.179-.509.337-.57v-.056c0-.44.034-1.065.117-1.478a2.508 2.508 0 01.962-1.623c.426-.33 1.038-.501 1.58-.501.544 0 1.155.172 1.588.502a2.496 2.496 0 01.963 1.622c.075.413.117 1.045.117 1.478v.062c.15.062.288.22.323.564.02.268-.083.502-.138.598-.048.234-.185.488-.42.537a2.635 2.635 0 01-.116.364 3.094 3.094 0 01-.818 1.224c0 .055 0 .11.007.158.004.048.006.095.007.14.011.311.02.57.907.96z", "M14.976 14.57c-.24-.098-.455-.186-.65-.274l-.007-.003a3.801 3.801 0 01-.194-.091c.224-.288.41-.609.554-.946l.001-.002.013-.033c.018-.043.036-.087.052-.13l.011-.027.016-.04c.105-.092.19-.19.256-.284.129-.184.213-.38.265-.563.105-.226.225-.592.192-1.026l-.001-.011-.002-.011a1.855 1.855 0 00-.325-.91 9.924 9.924 0 00-.12-1.246 3.088 3.088 0 00-.106-.474l-.001-.007a3.543 3.543 0 00-.763-1.353c.27-.092.56-.139.83-.139.495 0 1.05.156 1.444.456a2.269 2.269 0 01.875 1.475c.069.375.106.95.106 1.344v.056c.138.056.263.2.294.513.019.244-.075.456-.125.543-.044.213-.169.444-.381.488-.025.1-.056.206-.094.3a2.815 2.815 0 01-.756 1.144c0 .05 0 .1.006.144.004.043.006.086.007.127.01.283.018.518.824.873.192.086.404.172.623.262.83.34 1.752.717 1.99 1.231.28.657.168 1.044.168 1.044h-2.081a3.864 3.864 0 00-.188-.542l-.005-.013-.006-.012c-.183-.397-.491-.681-.76-.88a5.614 5.614 0 00-.896-.522 17.36 17.36 0 00-.916-.4l-.15-.061z"];
  init_define_process();
  var thumbs_down_default2 = ["M18.55 6.56c-.31-.01-.65-.03-1.02-.06.03 0 .06-.01.09-.01.88-.12 1.68-.63 1.76-1.37.08-.75-.58-1.25-1.46-1.33-.32-.03-.65-.05-.99-.08.59-.19 1.05-.54 1.09-1.2.05-.75-.99-1.32-1.87-1.41-.34-.03-.64-.05-.91-.07h-.11c-.28-.02-.54-.02-.77-.02-3.92-.08-7.29.6-9.36 1.93v7.72c2.67 1.66 5.95 4.61 5.26 7.08-.21.76.39 1.35 1.23 1.26 1.01-.11 1.71-1.18 1.75-2.28.05-1.29-.19-2.59-.62-3.74-.05-.32.01-.65.47-.68.61-.04 1.39-.08 1.99-.1.32 0 .64-.01.94-.03h.01c.52-.03 1-.07 1.42-.12.88-.11 1.69-.6 1.79-1.35.1-.75-.55-1.25-1.44-1.35-.07-.01-.13-.02-.2-.02.21-.02.42-.04.61-.06.88-.11 1.69-.6 1.79-1.35.09-.75-.56-1.31-1.45-1.36zM3 3H0v8h3c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var thumbs_up_default2 = ["M3 9H0v8h3c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1zm16.99 3.09c-.1-.75-.91-1.24-1.79-1.35-.19-.02-.4-.05-.61-.06.07-.01.14-.01.2-.02.88-.1 1.53-.61 1.44-1.35-.1-.74-.91-1.24-1.79-1.35-.42-.05-.9-.09-1.42-.12h-.01l-.94-.03c-.6-.02-1.39-.05-1.99-.1-.45-.03-.51-.36-.47-.68.43-1.15.67-2.45.62-3.74-.04-1.11-.74-2.17-1.75-2.28-.84-.09-1.45.5-1.23 1.26.7 2.47-2.58 5.43-5.25 7.08v7.72c2.08 1.33 5.44 2.01 9.35 1.93.24 0 .49-.01.77-.02h.11c.27-.02.57-.04.91-.07.88-.08 1.92-.66 1.87-1.41-.04-.65-.5-1.01-1.09-1.2.34-.03.67-.05.99-.08.89-.08 1.55-.58 1.46-1.33-.08-.75-.88-1.25-1.76-1.37-.03 0-.06-.01-.09-.01.37-.02.71-.04 1.02-.06.91-.05 1.55-.61 1.45-1.36z"];
  init_define_process();
  var tick_default2 = ["M17 4c-.28 0-.53.11-.71.29L7 13.59 3.71 10.3A.965.965 0 003 10a1.003 1.003 0 00-.71 1.71l4 4c.18.18.43.29.71.29s.53-.11.71-.29l10-10A1.003 1.003 0 0017 4z"];
  init_define_process();
  var tick_circle_default2 = ["M10 20C4.48 20 0 15.52 0 10S4.48 0 10 0s10 4.48 10 10-4.48 10-10 10zm5-14c-.28 0-.53.11-.71.29L8 12.59l-2.29-2.3a1.003 1.003 0 00-1.42 1.42l3 3c.18.18.43.29.71.29.28 0 .53-.11.71-.29l7-7A1.003 1.003 0 0015 6z"];
  init_define_process();
  var time_default2 = ["M11 9.59V4c0-.55-.45-1-1-1s-1 .45-1 1v6c0 .28.11.53.29.71l3 3a1.003 1.003 0 001.42-1.42L11 9.59zM10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"];
  init_define_process();
  var timeline_area_chart_default2 = ["M19 16H2V3c0-.55-.45-1-1-1s-1 .45-1 1v14c0 .55.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1zm0-13.41l-7.07 7.07-4.3-3.44-.01.01A.987.987 0 007 6c-.24 0-.46.1-.63.24l-.01-.01L3 9.03V15h16V2.59z"];
  init_define_process();
  var timeline_bar_chart_default2 = ["M19 17H1c-.55 0-1 .45-1 1s.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1zM9 16h2c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1H9c-.55 0-1 .45-1 1v13c0 .55.45 1 1 1zm6 0h2c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1h-2c-.55 0-1 .45-1 1v9c0 .55.45 1 1 1zM3 16h2c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1z"];
  init_define_process();
  var timeline_events_default2 = ["M5 5c.6 0 1-.4 1-1V2c0-.5-.4-1-1-1s-1 .5-1 1v2c0 .6.4 1 1 1zm10 0c.6 0 1-.4 1-1V2c0-.5-.4-1-1-1s-1 .5-1 1v2c0 .6.4 1 1 1zm-9 9H4v2h2v-2zM17 3v1c0 1.1-.9 2-2 2s-2-.9-2-2V3H7v1c0 1.1-.9 2-2 2s-2-.9-2-2V3H2c-.5 0-1 .5-1 1v14c0 .5.5 1 1 1h16c.5 0 1-.5 1-1V4c0-.5-.5-1-1-1h-1zM7 17H3v-4h4v4zm0-5H3V8h4v4zm5 5H8v-4h4v4zm0-5H8V8h4v4zm5 5h-4v-4h4v4zm0-5h-4V8h4v4zm-6 2H9v2h2v-2zm5-5h-2v2h2V9z"];
  init_define_process();
  var timeline_line_chart_default2 = ["M19 16H2v-1.59l5-5 3.29 3.29c.18.19.43.3.71.3s.53-.11.71-.29l7-7a1.003 1.003 0 00-1.42-1.42L11 10.59l-3.29-3.3C7.53 7.11 7.28 7 7 7s-.53.11-.71.29L2 11.59V3c0-.55-.45-1-1-1s-1 .45-1 1v14a.998.998 0 001 1h18c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var tint_default2 = ["M9.86 2S3.98 9.18 3.98 12.17C3.99 15.4 6.78 18 9.96 18c3.18-.01 6.04-2.63 6.03-5.86C15.99 9.05 9.86 2 9.86 2z"];
  init_define_process();
  var torch_default2 = ["M6.97 19c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-2h-6v2zm-3-15l3 4v8h6V8l3-4h-12zm5 5c0-.55.45-1 1-1s1 .45 1 1v2c0 .55-.45 1-1 1s-1-.45-1-1V9zm6-9h-10c-.55 0-1 .45-1 1v2h12V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var tractor_default2 = ["M4.5 11a4.5 4.5 0 110 9 4.5 4.5 0 010-9zm11.499 1a4 4 0 110 8 4 4 0 010-8zm-11.5 1.571a1.928 1.928 0 100 3.857 1.928 1.928 0 000-3.857zM16 14.667a1.333 1.333 0 100 2.666 1.333 1.333 0 000-2.666zM5.999 0C7.46 0 8.527.668 9 2l.851 4.256c1.433.096 2.82.217 4.147.362V2h2L16 6.862c.962.13 1.886.275 2.767.435.779.141 1.232.614 1.232 1.284L20 13a4.995 4.995 0 00-4-1.997A5.001 5.001 0 0011.099 15h-1.12a5.499 5.499 0 00-5.478-4.994 5.482 5.482 0 00-3.377 1.157H.004v-1.18L0 7.327c-.002-.597.37-1.18.999-1.302V1a1 1 0 011-1h4zm1 2H3v4h.75c1.386.027 2.749.073 4.079.139L6.999 2z"];
  init_define_process();
  var train_default2 = ["M16 18h-2l2 2H4l.12-.12L6 18H4c-1.1 0-2-.9-2-2V2c0-1.1 3.58-2 8-2s8 .9 8 2v14c0 1.1-.9 2-2 2zM5.5 15c.83 0 1.5-.67 1.5-1.5S6.33 12 5.5 12 4 12.67 4 13.5 4.67 15 5.5 15zM9 3H4v6h5V3zm7 0h-5v6h5V3zm-1.5 9c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"];
  init_define_process();
  var translate_default2 = ["M19.89 18.56l-4.99-10h-.01c-.17-.33-.5-.56-.89-.56s-.72.23-.89.56h-.01l-1.73 3.46-2.8-2.3 1.99-1.64C11.44 7.34 12 6.23 12 5V4h1c.55 0 1-.45 1-1s-.45-1-1-1H8V1c0-.55-.45-1-1-1S6 .45 6 1v1H1c-.55 0-1 .45-1 1s.45 1 1 1h9v1c0 .62-.28 1.18-.73 1.54L7 8.42 4.73 6.54C4.28 6.18 4 5.62 4 5H2c0 1.23.56 2.34 1.44 3.07l1.99 1.64-3.06 2.52.01.01c-.23.18-.38.45-.38.76 0 .55.45 1 1 1 .24 0 .45-.1.63-.24l.01.01L7 11l3.36 2.77.01-.01c.02.02.05.03.08.05.01 0 .01.01.02.02l-2.36 4.73h.01c-.07.13-.12.28-.12.44 0 .55.45 1 1 1 .39 0 .72-.23.89-.56h.01L11.12 17h5.76l1.22 2.45h.01c.17.32.5.55.89.55.55 0 1-.45 1-1 0-.16-.05-.31-.11-.44zM12.12 15L14 11.24 15.88 15h-3.76z"];
  init_define_process();
  var trash_default2 = ["M17 1h-5c0-.55-.45-1-1-1H9c-.55 0-1 .45-1 1H3c-.55 0-1 .45-1 1v1h16V2c0-.55-.45-1-1-1zm.5 3h-15c-.28 0-.5.22-.5.5s.22.5.5.5H3v14c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V5h.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5zM7 16c0 .55-.45 1-1 1s-1-.45-1-1V8c0-.55.45-1 1-1s1 .45 1 1v8zm4 0c0 .55-.45 1-1 1s-1-.45-1-1V8c0-.55.45-1 1-1s1 .45 1 1v8zm4 0c0 .55-.45 1-1 1s-1-.45-1-1V8c0-.55.45-1 1-1s1 .45 1 1v8z"];
  init_define_process();
  var tree_default2 = ["M11 15.542V20H9v-4.458L2 17l4.5-5.625L4 12l3.655-5.483L6 7l4-7 4 7-1.655-.483L16 12l-2.5-.625L18 17l-7-1.458z"];
  init_define_process();
  var trending_down_default2 = ["M19 10c-.55 0-1 .45-1 1v1.37l-6.25-7.03-.01.01A.971.971 0 0011 5c-.23 0-.42.09-.59.21l-.01-.01-3.43 2.58-5.42-3.61-.01.01A.969.969 0 001 4c-.55 0-1 .45-1 1 0 .35.19.64.46.82l-.01.01 6 4 .01-.02c.15.11.33.19.54.19.23 0 .42-.09.59-.21l.01.01 3.26-2.45L16.77 14H15c-.55 0-1 .45-1 1s.45 1 1 1h4c.55 0 1-.45 1-1v-4c0-.55-.45-1-1-1z"];
  init_define_process();
  var trending_up_default2 = ["M19 4h-4c-.55 0-1 .45-1 1s.45 1 1 1h1.77l-5.91 6.65L7.6 10.2l-.01.01C7.42 10.09 7.23 10 7 10c-.21 0-.39.08-.54.18l-.01-.02-6 4 .01.02c-.27.18-.46.47-.46.82 0 .55.45 1 1 1 .21 0 .39-.08.54-.18l.01.02 5.41-3.61 3.43 2.58.01-.01c.18.11.37.2.6.2.3 0 .56-.14.74-.34l.01.01L18 7.63V9c0 .55.45 1 1 1s1-.45 1-1V5c0-.55-.45-1-1-1z"];
  init_define_process();
  var truck_default2 = ["M16 0a1 1 0 011 1v11a1 1 0 011 1v3h.5a.5.5 0 01.5.5v1a.5.5 0 01-.5.5H17v1a1 1 0 01-1 1h-1a1 1 0 01-1-1v-1H6v1a1 1 0 01-1 1H4a1 1 0 01-1-1v-1H1.5a.5.5 0 01-.5-.5v-1a.5.5 0 01.5-.5H2v-3a1 1 0 011-1V1a1 1 0 112 0v3a2 2 0 012-2h6a2 2 0 012 2V1a1 1 0 011-1zm-4 10H8a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1v-4a1 1 0 00-1-1zm-7 4H4a1 1 0 000 2h1a1 1 0 000-2zm11 0h-1a1 1 0 000 2h1a1 1 0 000-2zm-4.5 0a.5.5 0 110 1h-3l-.09-.008A.5.5 0 018.5 14zm0-1.5a.5.5 0 110 1h-3l-.09-.008a.5.5 0 01.09-.992zm0-1.5a.5.5 0 110 1h-3l-.09-.008A.5.5 0 018.5 11zM14 5H6v3h8V5z"];
  init_define_process();
  var two_columns_default2 = ["M5 0H1C.45 0 0 .45 0 1v18c0 .55.45 1 1 1h4c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm14.71 9.29l-3-3A1.003 1.003 0 0015 7v6a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71zM12 0H8c-.55 0-1 .45-1 1v18c0 .55.45 1 1 1h4c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var unarchive_default2 = ["M16.434 0a1 1 0 01.857.486L20 5v14a1 1 0 01-1 1H1a1 1 0 01-1-1V5L2.709.486A1 1 0 013.566 0h12.868zM10 8c-.28 0-.53.11-.71.29l-3 3-.084.096A1.003 1.003 0 007.71 12.71L9 11.41v4.58l.007.116c.058.496.482.884.993.884.55 0 1-.45 1-1v-4.58l1.29 1.29.081.073c.171.139.389.227.629.227a1.003 1.003 0 00.71-1.71l-3-3-.096-.084A1.002 1.002 0 0010 8zm6-6H4L2 5.002h16L16 2z"];
  init_define_process();
  var underline_default2 = ["M10 17c3.3 0 6-2.7 6-6V3.5c0-.8-.7-1.5-1.5-1.5S13 2.7 13 3.5V11c0 1.7-1.3 3-3 3s-3-1.3-3-3V3.5C7 2.7 6.3 2 5.5 2S4 2.7 4 3.5V11c0 3.3 2.7 6 6 6zM16.5 19h-13c-.3 0-.5.2-.5.5s.2.5.5.5h13c.3 0 .5-.2.5-.5s-.2-.5-.5-.5z"];
  init_define_process();
  var undo_default2 = ["M5 14c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm9-9H3.41L5.7 2.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-4 4C.11 5.47 0 5.72 0 6c0 .28.11.53.29.71l4 4a1.003 1.003 0 001.42-1.42L3.41 7H14c2.21 0 4 1.79 4 4s-1.79 4-4 4H9v2h5c3.31 0 6-2.69 6-6s-2.69-6-6-6z"];
  init_define_process();
  var ungroup_objects_default2 = ["M4.5 6C2.01 6 0 8.01 0 10.5S2.01 15 4.5 15 9 12.99 9 10.5 6.99 6 4.5 6zm11 0C13.01 6 11 8.01 11 10.5s2.01 4.5 4.5 4.5 4.5-2.01 4.5-4.5S17.99 6 15.5 6z"];
  init_define_process();
  var unknown_vehicle_default2 = ["M13 11.988v-4H4v-1l1-3h6V2.003a35.867 35.867 0 00-1-.015c-3.593 0-5.332.488-5.332.488-.67.188-1.424.864-1.674 1.503l-.004.009H3l-1 3H1a1 1 0 100 2h.333l-.28.84-.053.16v7.5a1.5 1.5 0 103 0v-.5h12v.5a1.5 1.5 0 103 0v-4.5h-5a1 1 0 01-1-1zm-8.5 1a1.5 1.5 0 110-3 1.5 1.5 0 010 3zM19.83 2.782a2.392 2.392 0 00-.592-.853c-.276-.264-.64-.485-1.09-.663C17.695 1.09 17.132 1 16.457 1c-.523 0-.996.084-1.418.253a3.157 3.157 0 00-1.084.703c-.299.3-.532.656-.698 1.065-.166.41-.254.861-.264 1.353h2.096c0-.246.028-.476.085-.69.057-.214.145-.4.264-.56.119-.16.27-.287.456-.383.185-.095.406-.143.663-.143.38 0 .677.1.89.3.215.2.321.51.321.93.01.245-.035.45-.135.614-.1.164-.23.314-.392.45a8.598 8.598 0 01-.527.41 3.53 3.53 0 00-.542.485c-.171.187-.32.412-.45.676-.127.265-.206.592-.234.984v.614h1.924v-.519c.038-.273.13-.5.278-.683.147-.182.316-.343.506-.484a13.5 13.5 0 01.606-.424c.214-.14.408-.312.584-.512s.323-.442.442-.724.178-.642.178-1.079c0-.264-.059-.548-.178-.854zm-4.54 6.099v2.103h2.237V8.881H15.29z"];
  init_define_process();
  var unlock_default2 = ["M14 1c-2.21 0-4 1.79-4 4v4H2c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-8c0-.55-.45-1-1-1h-2V5c0-1.1.9-2 2-2s2 .9 2 2v2c0 .55.45 1 1 1s1-.45 1-1V5c0-2.21-1.79-4-4-4z"];
  init_define_process();
  var unpin_default2 = ["M11.77 1.16c-.81.81-.74 2.28.02 3.76L6.1 8.71c-2.17-1.46-4.12-2-4.94-1.18l4.95 4.95-2.12 3.54 3.54-2.12 4.95 4.95c.82-.82.27-2.77-1.19-4.94l3.8-5.69c1.47.76 2.94.84 3.76.02l-7.08-7.08z"];
  init_define_process();
  var unresolve_default2 = ["M11.47 12.46c.16-.36.29-.74.38-1.14 0-.02.01-.04.01-.06.09-.4.14-.82.14-1.26 0-.44-.05-.86-.14-1.27 0-.02-.01-.04-.01-.06-.09-.4-.22-.78-.38-1.14-.01-.02-.02-.03-.02-.05a5.94 5.94 0 00-.61-1.03c0-.01-.01-.01-.01-.02a6.308 6.308 0 00-2.1-1.77c-.19-.1-.39-.18-.59-.26-.03-.01-.06-.02-.1-.03-.17-.07-.34-.12-.52-.17-.05-.01-.1-.03-.15-.04a4.34 4.34 0 00-.52-.09c-.05-.01-.11-.02-.17-.03C6.46 4.02 6.23 4 6 4c-3.31 0-6 2.69-6 6s2.69 6 6 6c.23 0 .46-.02.68-.04l.17-.03c.17-.02.34-.06.51-.09.05-.01.1-.03.15-.04.18-.05.36-.1.53-.17l.09-.03a5.973 5.973 0 002.68-2.04c0-.01.01-.01.01-.02.24-.32.44-.66.61-1.03.02-.01.03-.03.04-.05zM14 4c-.99 0-1.91.24-2.73.66a7.51 7.51 0 010 10.68c.82.42 1.74.66 2.73.66 3.31 0 6-2.69 6-6s-2.69-6-6-6z"];
  init_define_process();
  var updated_default2 = ["M10 0C6.71 0 3.82 1.6 2 4.05V2c0-.55-.45-1-1-1s-1 .45-1 1v4c0 .55.45 1 1 1h4c.55 0 1-.45 1-1s-.45-1-1-1H3.76C5.22 3.17 7.47 2 10 2c4.42 0 8 3.58 8 8s-3.58 8-8 8-8-3.58-8-8c0-.55-.45-1-1-1s-1 .45-1 1c0 5.52 4.48 10 10 10s10-4.48 10-10S15.52 0 10 0zm4 7c-.28 0-.53.11-.71.29L9 11.58 6.71 9.29a1.003 1.003 0 00-1.42 1.42l3 3c.18.18.43.29.71.29.28 0 .53-.11.71-.29l5-5A1.003 1.003 0 0014 7z"];
  init_define_process();
  var upload_default2 = ["M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm4 10c-.28 0-.53-.11-.71-.29L11 7.41V15c0 .55-.45 1-1 1s-1-.45-1-1V7.41l-2.29 2.3a1.003 1.003 0 01-1.42-1.42l4-4c.18-.18.43-.29.71-.29s.53.11.71.29l4 4A1.003 1.003 0 0114 10z"];
  init_define_process();
  var user_default2 = ["M10 0C4.48 0 0 4.48 0 10c0 .33.02.65.05.97.01.12.03.23.05.35.03.2.05.4.09.59.03.14.06.28.1.42l.12.48c.05.16.1.31.15.46.05.13.09.27.15.4.06.16.13.32.21.48.05.11.1.22.16.33.09.17.17.34.27.5.05.09.1.17.15.25.11.18.22.35.34.52.04.06.08.11.12.17 1.19 1.62 2.85 2.86 4.78 3.53l.09.03c.46.15.93.27 1.42.36.08.01.17.03.25.04.49.07.99.12 1.5.12s1.01-.05 1.5-.12c.08-.01.17-.02.25-.04.49-.09.96-.21 1.42-.36l.09-.03c1.93-.67 3.59-1.91 4.78-3.53.04-.05.08-.1.12-.16.12-.17.23-.35.34-.53.05-.08.1-.16.15-.25.1-.17.19-.34.27-.51.05-.11.1-.21.15-.32.07-.16.14-.32.21-.49.05-.13.1-.26.14-.39.05-.15.11-.31.15-.46.05-.16.08-.32.12-.48.03-.14.07-.28.1-.42.04-.19.06-.39.09-.59.02-.12.04-.23.05-.35.05-.32.07-.64.07-.97 0-5.52-4.48-10-10-10zm0 18a7.94 7.94 0 01-6.15-2.89c.84-.44 1.86-.82 2.67-1.19 1.45-.65 1.3-1.05 1.35-1.59.01-.07.01-.14.01-.21-.51-.45-.93-1.08-1.2-1.8l-.01-.01c0-.01-.01-.02-.01-.03a4.42 4.42 0 01-.15-.48c-.33-.07-.53-.44-.61-.79-.08-.14-.23-.48-.2-.87.05-.51.26-.74.49-.83v-.08c0-.63.06-1.55.17-2.15.02-.17.06-.33.11-.5.21-.73.66-1.4 1.26-1.86.62-.47 1.5-.72 2.28-.72.78 0 1.65.25 2.27.73.6.46 1.05 1.12 1.26 1.86.05.16.08.33.11.5.11.6.17 1.51.17 2.15v.09c.22.1.42.33.46.82.04.39-.12.73-.2.87-.07.34-.27.71-.6.78-.04.16-.09.33-.15.48 0 .01-.02.05-.02.05-.26.71-.67 1.33-1.17 1.78 0 .08.01.16.01.23.05.54-.15.94 1.31 1.59.81.36 1.84.74 2.68 1.19A7.958 7.958 0 0110 18z"];
  init_define_process();
  var variable_default2 = ["M4.93 3.79a9.1 9.1 0 012.2-2.27L7.29 1c-1.38.59-2.57 1.33-3.55 2.22C2.46 4.39 1.49 5.72.83 7.23.28 8.51 0 9.81 0 11.12c0 2.28.83 4.57 2.49 6.86l.16-.55c-.49-1.23-.73-2.38-.73-3.44 0-1.67.28-3.46.84-5.36.55-1.9 1.28-3.51 2.17-4.84zm9.38 8.39l-.33-.2c-.37.54-.65.87-.82 1a.74.74 0 01-.42.12c-.19 0-.38-.12-.57-.37-.31-.42-.73-1.59-1.26-3.5.47-.85.86-1.41 1.19-1.67.23-.19.48-.29.74-.29.1 0 .28.04.53.11.26.07.48.11.68.11.27 0 .5-.1.68-.29.18-.19.27-.44.27-.75 0-.33-.09-.58-.27-.77-.18-.19-.44-.29-.78-.29-.3 0-.59.07-.86.22s-.61.47-1.02.97c-.31.37-.77 1.02-1.37 1.94a9.683 9.683 0 00-1.24-3.14l-3.24.59-.06.36c.24-.05.44-.07.61-.07.32 0 .59.14.8.43.33.45.8 1.8 1.39 4.07-.47.64-.78 1.06-.96 1.26-.28.32-.52.53-.7.62-.14.08-.3.11-.48.11-.14 0-.36-.08-.67-.23-.21-.1-.4-.15-.57-.15-.31 0-.57.11-.78.32s-.31.48-.31.8c0 .31.09.55.28.75.19.19.44.29.76.29.31 0 .6-.07.87-.2s.61-.42 1.02-.86c.41-.44.98-1.13 1.7-2.08.28.9.52 1.56.72 1.97.2.41.44.71.7.89.26.18.59.27.99.27.38 0 .77-.14 1.17-.43.54-.36 1.07-1 1.61-1.91zM17.51 1l-.15.54c.49 1.24.73 2.39.73 3.45 0 1.43-.21 2.96-.63 4.6-.33 1.26-.75 2.45-1.27 3.55-.52 1.11-1.02 1.97-1.51 2.6-.49.62-1.09 1.2-1.8 1.72l-.17.53c1.38-.59 2.57-1.34 3.55-2.23 1.29-1.17 2.26-2.5 2.91-4 .55-1.28.83-2.59.83-3.91 0-2.27-.83-4.56-2.49-6.85z"];
  init_define_process();
  var vertical_bar_chart_asc_default2 = ["M8 7H7c-.55 0-1 .45-1 1v11c0 .55.45 1 1 1h1c.55 0 1-.45 1-1V8c0-.55-.45-1-1-1zM3 9H2c-.55 0-1 .45-1 1v9c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-9c0-.55-.45-1-1-1zm10-5h-1c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h1c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zm5-4h-1c-.55 0-1 .45-1 1v18c0 .55.45 1 1 1h1c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1z"];
  init_define_process();
  var vertical_bar_chart_desc_default2 = ["M3 0H2c-.55 0-1 .45-1 1v18c0 .55.45 1 1 1h1c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm5 4H7c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h1c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zm5 3h-1c-.55 0-1 .45-1 1v11c0 .55.45 1 1 1h1c.55 0 1-.45 1-1V8c0-.55-.45-1-1-1zm5 2h-1c-.55 0-1 .45-1 1v9c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-9c0-.55-.45-1-1-1z"];
  init_define_process();
  var vertical_distribution_default2 = ["M1 2h18c.55 0 1-.45 1-1s-.45-1-1-1H1C.45 0 0 .45 0 1s.45 1 1 1zm2 5c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V8c0-.55-.45-1-1-1H3zm16 11H1c-.55 0-1 .45-1 1s.45 1 1 1h18c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var vertical_inbetween_default2 = ["M0 0h20v1a1 1 0 01-1 1H1a1 1 0 01-1-1V0zm6.293 11.293a.999.999 0 000 1.412l2.962 2.963.038.04A.996.996 0 0010 16a.996.996 0 00.745-.332l2.962-2.963a.999.999 0 00-1.412-1.412L10 13.587l-2.295-2.294a.999.999 0 00-1.412 0zm0-3.998a.999.999 0 101.412 1.412L10 6.413l2.295 2.294a.999.999 0 101.412-1.412l-2.962-2.963A.996.996 0 0010 4a.996.996 0 00-.745.332L6.293 7.295zM20 19v1H0v-1a1 1 0 011-1h18a1 1 0 011 1z"];
  init_define_process();
  var video_default2 = ["M19 2H1c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1zM7 14V6l6 4-6 4z"];
  init_define_process();
  var virus_default2 = ["M15.249 13.835l1.251 1.251.354-.354.087-.077a1 1 0 011.327 1.491l-2.122 2.122-.087.077a1 1 0 01-1.327-1.491l.354-.354-1.251-1.251A6.466 6.466 0 0111 16.424L10.999 18h.501a1 1 0 01.117 1.993L11.5 20h-3a1 1 0 01-.117-1.993L8.5 18h.499v-1.577a6.46 6.46 0 01-2.538-.97L5.414 16.5l.354.354a1 1 0 01-1.327 1.491l-.087-.077-2.122-2.122a1 1 0 011.327-1.491l.087.077.354.354.97-.97a6.472 6.472 0 01-1.384-3.057l-.025.002L2 11.06v.44a1 1 0 01-1.993.117L0 11.5v-3a1 1 0 011.993-.117L2 8.5v.56h1.567A6.471 6.471 0 014.97 5.883l-.971-.969-.353.354-.087.077a1 1 0 01-1.327-1.491l2.122-2.122.087-.077a1 1 0 011.327 1.491l-.354.353 1.047 1.048A6.46 6.46 0 019 3.577L9 2h-.5A1 1 0 018.383.007L8.5 0h3a1 1 0 01.117 1.993L11.5 2H11v1.577a6.466 6.466 0 012.838 1.176l.04-.046L15.086 3.5l-.353-.353a1 1 0 011.327-1.491l.087.077 2.122 2.122a1 1 0 01-1.327 1.491l-.087-.077-.354-.354-1.207 1.207-.046.041a6.467 6.467 0 011.16 2.733H18V8.5a1 1 0 011.993-.117L20 8.5v3a1 1 0 01-1.993.117L18 11.5v-.605h-1.561a6.466 6.466 0 01-1.19 2.94zM12.5 11a1.5 1.5 0 100 3 1.5 1.5 0 000-3zM8 6a2 2 0 100 4 2 2 0 000-4z"];
  init_define_process();
  var volume_down_default2 = ["M15.92 3.93l-1.6 1.18A7.948 7.948 0 0116 10c0 1.84-.63 3.54-1.68 4.89l1.6 1.18A9.878 9.878 0 0018 10c0-2.29-.78-4.39-2.08-6.07zM11 3c-.28 0-.53.11-.71.29L7.59 6H3c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h4.59l2.71 2.71c.17.18.42.29.7.29.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var volume_off_default2 = ["M14 3c-.28 0-.53.11-.71.29L10.59 6H6c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h4.59l2.71 2.71c.17.18.42.29.7.29.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"];
  init_define_process();
  var volume_up_default2 = ["M9 3.43c-.28 0-.53.11-.71.29l-2.7 2.71H1c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h4.59l2.71 2.71a1.003 1.003 0 001.71-.71v-12c-.01-.55-.46-1-1.01-1zm8.31-1.56l-1.62 1.2C17.14 5.16 18 7.69 18 10.43s-.86 5.27-2.31 7.37l1.62 1.2C19 16.57 20 13.62 20 10.43c0-3.18-1-6.13-2.69-8.56zm-3.39 2.49l-1.6 1.18A7.948 7.948 0 0114 10.43c0 1.84-.63 3.54-1.68 4.89l1.6 1.18A9.94 9.94 0 0016 10.43c0-2.28-.78-4.38-2.08-6.07z"];
  init_define_process();
  var walk_default2 = ["M16 10h-2c-.23 0-.42-.09-.59-.21l-.01.01-1.69-1.27-.63 3.14 2.62 2.62c.19.18.3.43.3.71v4c0 .55-.45 1-1 1s-1-.45-1-1v-3.59L9.39 12.8l-2.45 6.55h-.01c-.14.38-.5.65-.93.65-.55 0-1-.45-1-1 0-.12.03-.24.07-.35h-.01L9.43 7h-2.9l-1.7 2.55-.01-.01c-.18.27-.47.46-.82.46-.55 0-1-.45-1-1 0-.21.08-.39.18-.54l-.01-.01 2-3 .02.01C5.36 5.19 5.65 5 6 5h4.18l.36-.96c-.33-.43-.54-.96-.54-1.54a2.5 2.5 0 015 0A2.5 2.5 0 0112.5 5c-.06 0-.12-.01-.18-.02l-.44 1.18L14.33 8H16c.55 0 1 .45 1 1s-.45 1-1 1z"];
  init_define_process();
  var warning_sign_default2 = ["M19.86 17.52l.01-.01-9-16-.01.01C10.69 1.21 10.37 1 10 1s-.69.21-.86.52l-.01-.01-9 16 .01.01c-.08.14-.14.3-.14.48 0 .55.45 1 1 1h18c.55 0 1-.45 1-1 0-.18-.06-.34-.14-.48zM11 17H9v-2h2v2zm0-3H9V6h2v8z"];
  init_define_process();
  var waterfall_chart_default2 = ["M13 7h2c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1h-2c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1zm-9 8h1c.55 0 1-.45 1-1v-4c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1zm4-6h2c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1s.45 1 1 1zm11-5h-1c-.55 0-1 .45-1 1v9c0 .55.45 1 1 1h1c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zm0 12H2V3c0-.55-.45-1-1-1s-1 .45-1 1v14a.998.998 0 001 1h18c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var waves_default2 = ["M4.948 2.682a1 1 0 00-1.897.001l-.005.016-.027.074a6.05 6.05 0 01-.6 1.172C1.958 4.635 1.468 5 .999 5a1 1 0 000 2c1.457 0 2.442-1.027 3-1.825C4.558 5.973 5.543 7 7 7s2.442-1.027 3-1.825C10.558 5.973 11.543 7 13 7s2.442-1.027 3-1.825C16.558 5.973 17.544 7 19 7a1 1 0 100-2c-.47 0-.958-.365-1.418-1.055a6.048 6.048 0 01-.628-1.246l-.006-.016a1 1 0 00-1.896 0l-.006.016a5.868 5.868 0 01-.147.364c-.11.246-.272.568-.481.882C13.958 4.635 13.469 5 13 5c-.47 0-.958-.365-1.418-1.055a6.048 6.048 0 01-.628-1.246l-.006-.016a1 1 0 00-1.897 0l-.005.016-.027.074a6.05 6.05 0 01-.6 1.172C7.958 4.635 7.468 5 6.999 5c-.47 0-.958-.365-1.418-1.055A6.05 6.05 0 014.954 2.7l-.006-.016v-.001zm0 6a1 1 0 00-1.897.001l-.005.016-.027.074a6.05 6.05 0 01-.6 1.172c-.46.69-.95 1.055-1.419 1.055a1 1 0 100 2c1.457 0 2.442-1.027 3-1.825C4.558 11.973 5.543 13 7 13s2.442-1.027 3-1.825c.558.798 1.543 1.825 3 1.825s2.442-1.027 3-1.825c.558.798 1.544 1.825 3 1.825a1 1 0 100-2c-.47 0-.958-.365-1.418-1.055a6.048 6.048 0 01-.628-1.246l-.006-.016a1 1 0 00-1.896 0l-.006.016a5.868 5.868 0 01-.147.364c-.11.246-.272.568-.481.882-.46.69-.949 1.055-1.418 1.055-.47 0-.958-.365-1.418-1.055a6.048 6.048 0 01-.628-1.246l-.006-.016a1 1 0 00-1.897 0l-.005.016-.027.074a6.05 6.05 0 01-.6 1.172c-.46.69-.95 1.055-1.419 1.055-.47 0-.958-.365-1.418-1.055A6.05 6.05 0 014.954 8.7l-.006-.016zm-1.896-6zm1.896 12l.006.017.027.074a6.053 6.053 0 00.6 1.172c.46.69.95 1.055 1.419 1.055.47 0 .958-.365 1.418-1.055a6.053 6.053 0 00.628-1.246l.005-.016a1 1 0 011.897 0l.006.016.027.074a6.051 6.051 0 00.6 1.172c.46.69.95 1.055 1.419 1.055.47 0 .958-.365 1.418-1.055a6.051 6.051 0 00.628-1.246l.006-.016a1 1 0 011.896 0l.006.016.027.074a6.051 6.051 0 00.6 1.172c.46.69.95 1.055 1.419 1.055a1 1 0 110 2c-1.456 0-2.442-1.027-3-1.825-.558.798-1.543 1.825-3 1.825s-2.442-1.027-3-1.825C9.442 17.973 8.457 19 7 19s-2.442-1.027-3-1.825C3.442 17.973 2.457 19 1 19a1 1 0 110-2c.47 0 .958-.365 1.418-1.055a6.053 6.053 0 00.628-1.246l.005-.016a1 1 0 011.897-.001z"];
  init_define_process();
  var widget_default2 = ["M18 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zM2 16c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm15-1h2V5h-2v10zM3 5H1v10h2V5zM2 0C.9 0 0 .9 0 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm3 3h10V1H5v2zm13 13c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM5 19h10v-2H5v2z"];
  init_define_process();
  var widget_button_default2 = ["M1 4h18c.55 0 1 .45 1 1v10c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V5c0-.55.45-1 1-1zm1 2v8h16V6H2zm4 5c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm4 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm4 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"];
  init_define_process();
  var widget_footer_default2 = ["M17 0H3c-.55 0-1 .45-1 1v18c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 18H4v-4h12v4zm0-5H4V2h12v11z"];
  init_define_process();
  var widget_header_default2 = ["M17 0H3c-.55 0-1 .45-1 1v18c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-1 18H4V7h12v11zm0-12H4V2h12v4z"];
  init_define_process();
  var wind_default2 = ["M12 6a3 3 0 113 3H4a1 1 0 000 2h11a5 5 0 10-5-5 1 1 0 102 0zM1 12a1 1 0 100 2h10a2 2 0 110 4c-.934 0-1.803-.614-2.057-1.333a1 1 0 10-1.886.666C7.627 18.944 9.321 20 11 20a4 4 0 000-8H1z"];
  init_define_process();
  var wrench_default2 = ["M19.8 4.44L16.13 8.1l-3.55-.71-.71-3.53L15.54.21c-2.01-.53-4.23-.03-5.8 1.53-1.86 1.85-2.23 4.6-1.14 6.83L.59 16.59C.22 16.95 0 17.45 0 18a2 2 0 002 2c.55 0 1.05-.22 1.41-.59l8.03-8.04c2.23 1.05 4.97.67 6.82-1.16 1.57-1.56 2.07-3.77 1.54-5.77z"];
  init_define_process();
  var zoom_in_default2 = ["M19.56 17.44l-4.94-4.94A8.004 8.004 0 0016 8c0-4.42-3.58-8-8-8S0 3.58 0 8s3.58 8 8 8c1.67 0 3.21-.51 4.5-1.38l4.94 4.94a1.498 1.498 0 102.12-2.12zM8 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zm3-7H9V5c0-.55-.45-1-1-1s-1 .45-1 1v2H5c-.55 0-1 .45-1 1s.45 1 1 1h2v2c0 .55.45 1 1 1s1-.45 1-1V9h2c.55 0 1-.45 1-1s-.45-1-1-1z"];
  init_define_process();
  var zoom_out_default2 = ["M11 7H5c-.55 0-1 .45-1 1s.45 1 1 1h6c.55 0 1-.45 1-1s-.45-1-1-1zm8.56 10.44l-4.94-4.94A8.004 8.004 0 0016 8c0-4.42-3.58-8-8-8S0 3.58 0 8s3.58 8 8 8c1.67 0 3.21-.51 4.5-1.38l4.94 4.94a1.498 1.498 0 102.12-2.12zM8 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"];
  init_define_process();
  var zoom_to_fit_default2 = ["M1 7c.55 0 1-.45 1-1V2h4c.55 0 1-.45 1-1s-.45-1-1-1H1C.45 0 0 .45 0 1v5c0 .55.45 1 1 1zm5 1a1.003 1.003 0 00-1.71-.71l-2 2c-.18.18-.29.43-.29.71 0 .28.11.53.29.71l2 2a1.003 1.003 0 001.42-1.42L4.41 10 5.7 8.71c.19-.18.3-.43.3-.71zm2-2c.28 0 .53-.11.71-.29L10 4.41l1.29 1.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-2-2C10.53 2.11 10.28 2 10 2s-.53.11-.71.29l-2 2A1.003 1.003 0 008 6zM6 18H2v-4c0-.55-.45-1-1-1s-1 .45-1 1v5c0 .55.45 1 1 1h5c.55 0 1-.45 1-1s-.45-1-1-1zm8-6a1.003 1.003 0 001.71.71l2-2c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71l-2-2a1.003 1.003 0 00-1.42 1.42l1.3 1.29-1.29 1.29c-.19.18-.3.43-.3.71zm5-12h-5c-.55 0-1 .45-1 1s.45 1 1 1h4v4c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1zm-7 14c-.28 0-.53.11-.71.29L10 15.59 8.71 14.3A.965.965 0 008 14a1.003 1.003 0 00-.71 1.71l2 2c.18.18.43.29.71.29s.53-.11.71-.29l2-2A1.003 1.003 0 0012 14zm7-1c-.55 0-1 .45-1 1v4h-4c-.55 0-1 .45-1 1s.45 1 1 1h5c.55 0 1-.45 1-1v-5c0-.55-.45-1-1-1z"];
  function iconNameToPathsRecordKey(name) {
    return pascalCase(name);
  }
  init_define_process();
  var _a2;
  var BlueprintIcons_16;
  (function (BlueprintIcons_162) {
    BlueprintIcons_162["AddClip"] = "add-clip";
    BlueprintIcons_162["AddColumnLeft"] = "add-column-left";
    BlueprintIcons_162["AddColumnRight"] = "add-column-right";
    BlueprintIcons_162["AddLocation"] = "add-location";
    BlueprintIcons_162["AddRowBottom"] = "add-row-bottom";
    BlueprintIcons_162["AddRowTop"] = "add-row-top";
    BlueprintIcons_162["AddToArtifact"] = "add-to-artifact";
    BlueprintIcons_162["AddToFolder"] = "add-to-folder";
    BlueprintIcons_162["Add"] = "add";
    BlueprintIcons_162["AimpointsTarget"] = "aimpoints-target";
    BlueprintIcons_162["Airplane"] = "airplane";
    BlueprintIcons_162["AlignCenter"] = "align-center";
    BlueprintIcons_162["AlignJustify"] = "align-justify";
    BlueprintIcons_162["AlignLeft"] = "align-left";
    BlueprintIcons_162["AlignRight"] = "align-right";
    BlueprintIcons_162["AlignmentBottom"] = "alignment-bottom";
    BlueprintIcons_162["AlignmentHorizontalCenter"] = "alignment-horizontal-center";
    BlueprintIcons_162["AlignmentLeft"] = "alignment-left";
    BlueprintIcons_162["AlignmentRight"] = "alignment-right";
    BlueprintIcons_162["AlignmentTop"] = "alignment-top";
    BlueprintIcons_162["AlignmentVerticalCenter"] = "alignment-vertical-center";
    BlueprintIcons_162["Anchor"] = "anchor";
    BlueprintIcons_162["Annotation"] = "annotation";
    BlueprintIcons_162["Antenna"] = "antenna";
    BlueprintIcons_162["AppHeader"] = "app-header";
    BlueprintIcons_162["Application"] = "application";
    BlueprintIcons_162["Applications"] = "applications";
    BlueprintIcons_162["Archive"] = "archive";
    BlueprintIcons_162["AreaOfInterest"] = "area-of-interest";
    BlueprintIcons_162["ArrayBoolean"] = "array-boolean";
    BlueprintIcons_162["ArrayDate"] = "array-date";
    BlueprintIcons_162["ArrayFloatingPoint"] = "array-floating-point";
    BlueprintIcons_162["ArrayNumeric"] = "array-numeric";
    BlueprintIcons_162["ArrayString"] = "array-string";
    BlueprintIcons_162["ArrayTimestamp"] = "array-timestamp";
    BlueprintIcons_162["Array"] = "array";
    BlueprintIcons_162["ArrowBottomLeft"] = "arrow-bottom-left";
    BlueprintIcons_162["ArrowBottomRight"] = "arrow-bottom-right";
    BlueprintIcons_162["ArrowDown"] = "arrow-down";
    BlueprintIcons_162["ArrowLeft"] = "arrow-left";
    BlueprintIcons_162["ArrowRight"] = "arrow-right";
    BlueprintIcons_162["ArrowTopLeft"] = "arrow-top-left";
    BlueprintIcons_162["ArrowTopRight"] = "arrow-top-right";
    BlueprintIcons_162["ArrowUp"] = "arrow-up";
    BlueprintIcons_162["ArrowsHorizontal"] = "arrows-horizontal";
    BlueprintIcons_162["ArrowsVertical"] = "arrows-vertical";
    BlueprintIcons_162["Asterisk"] = "asterisk";
    BlueprintIcons_162["At"] = "at";
    BlueprintIcons_162["AutomaticUpdates"] = "automatic-updates";
    BlueprintIcons_162["Backlink"] = "backlink";
    BlueprintIcons_162["Badge"] = "badge";
    BlueprintIcons_162["BanCircle"] = "ban-circle";
    BlueprintIcons_162["BankAccount"] = "bank-account";
    BlueprintIcons_162["Barcode"] = "barcode";
    BlueprintIcons_162["Blank"] = "blank";
    BlueprintIcons_162["BlockedPerson"] = "blocked-person";
    BlueprintIcons_162["Bold"] = "bold";
    BlueprintIcons_162["Book"] = "book";
    BlueprintIcons_162["Bookmark"] = "bookmark";
    BlueprintIcons_162["Box"] = "box";
    BlueprintIcons_162["Briefcase"] = "briefcase";
    BlueprintIcons_162["BringData"] = "bring-data";
    BlueprintIcons_162["Bug"] = "bug";
    BlueprintIcons_162["Buggy"] = "buggy";
    BlueprintIcons_162["Build"] = "build";
    BlueprintIcons_162["Calculator"] = "calculator";
    BlueprintIcons_162["Calendar"] = "calendar";
    BlueprintIcons_162["Camera"] = "camera";
    BlueprintIcons_162["CaretDown"] = "caret-down";
    BlueprintIcons_162["CaretLeft"] = "caret-left";
    BlueprintIcons_162["CaretRight"] = "caret-right";
    BlueprintIcons_162["CaretUp"] = "caret-up";
    BlueprintIcons_162["CargoShip"] = "cargo-ship";
    BlueprintIcons_162["CellTower"] = "cell-tower";
    BlueprintIcons_162["Changes"] = "changes";
    BlueprintIcons_162["Chart"] = "chart";
    BlueprintIcons_162["Chat"] = "chat";
    BlueprintIcons_162["ChevronBackward"] = "chevron-backward";
    BlueprintIcons_162["ChevronDown"] = "chevron-down";
    BlueprintIcons_162["ChevronForward"] = "chevron-forward";
    BlueprintIcons_162["ChevronLeft"] = "chevron-left";
    BlueprintIcons_162["ChevronRight"] = "chevron-right";
    BlueprintIcons_162["ChevronUp"] = "chevron-up";
    BlueprintIcons_162["CircleArrowDown"] = "circle-arrow-down";
    BlueprintIcons_162["CircleArrowLeft"] = "circle-arrow-left";
    BlueprintIcons_162["CircleArrowRight"] = "circle-arrow-right";
    BlueprintIcons_162["CircleArrowUp"] = "circle-arrow-up";
    BlueprintIcons_162["Circle"] = "circle";
    BlueprintIcons_162["Citation"] = "citation";
    BlueprintIcons_162["Clean"] = "clean";
    BlueprintIcons_162["Clip"] = "clip";
    BlueprintIcons_162["Clipboard"] = "clipboard";
    BlueprintIcons_162["CloudDownload"] = "cloud-download";
    BlueprintIcons_162["CloudUpload"] = "cloud-upload";
    BlueprintIcons_162["Cloud"] = "cloud";
    BlueprintIcons_162["CodeBlock"] = "code-block";
    BlueprintIcons_162["Code"] = "code";
    BlueprintIcons_162["Cog"] = "cog";
    BlueprintIcons_162["CollapseAll"] = "collapse-all";
    BlueprintIcons_162["ColorFill"] = "color-fill";
    BlueprintIcons_162["ColumnLayout"] = "column-layout";
    BlueprintIcons_162["Comment"] = "comment";
    BlueprintIcons_162["Comparison"] = "comparison";
    BlueprintIcons_162["Compass"] = "compass";
    BlueprintIcons_162["Compressed"] = "compressed";
    BlueprintIcons_162["Confirm"] = "confirm";
    BlueprintIcons_162["Console"] = "console";
    BlueprintIcons_162["Contrast"] = "contrast";
    BlueprintIcons_162["Control"] = "control";
    BlueprintIcons_162["CreditCard"] = "credit-card";
    BlueprintIcons_162["CrossCircle"] = "cross-circle";
    BlueprintIcons_162["Cross"] = "cross";
    BlueprintIcons_162["Crown"] = "crown";
    BlueprintIcons_162["CubeAdd"] = "cube-add";
    BlueprintIcons_162["CubeRemove"] = "cube-remove";
    BlueprintIcons_162["Cube"] = "cube";
    BlueprintIcons_162["CurvedRangeChart"] = "curved-range-chart";
    BlueprintIcons_162["Cut"] = "cut";
    BlueprintIcons_162["Cycle"] = "cycle";
    BlueprintIcons_162["Dashboard"] = "dashboard";
    BlueprintIcons_162["DataConnection"] = "data-connection";
    BlueprintIcons_162["DataLineage"] = "data-lineage";
    BlueprintIcons_162["Database"] = "database";
    BlueprintIcons_162["Delete"] = "delete";
    BlueprintIcons_162["Delta"] = "delta";
    BlueprintIcons_162["DeriveColumn"] = "derive-column";
    BlueprintIcons_162["Desktop"] = "desktop";
    BlueprintIcons_162["Diagnosis"] = "diagnosis";
    BlueprintIcons_162["DiagramTree"] = "diagram-tree";
    BlueprintIcons_162["DirectionLeft"] = "direction-left";
    BlueprintIcons_162["DirectionRight"] = "direction-right";
    BlueprintIcons_162["Disable"] = "disable";
    BlueprintIcons_162["Divide"] = "divide";
    BlueprintIcons_162["DocumentOpen"] = "document-open";
    BlueprintIcons_162["DocumentShare"] = "document-share";
    BlueprintIcons_162["Document"] = "document";
    BlueprintIcons_162["Dollar"] = "dollar";
    BlueprintIcons_162["Dot"] = "dot";
    BlueprintIcons_162["DoubleCaretHorizontal"] = "double-caret-horizontal";
    BlueprintIcons_162["DoubleCaretVertical"] = "double-caret-vertical";
    BlueprintIcons_162["DoubleChevronDown"] = "double-chevron-down";
    BlueprintIcons_162["DoubleChevronLeft"] = "double-chevron-left";
    BlueprintIcons_162["DoubleChevronRight"] = "double-chevron-right";
    BlueprintIcons_162["DoubleChevronUp"] = "double-chevron-up";
    BlueprintIcons_162["DoughnutChart"] = "doughnut-chart";
    BlueprintIcons_162["Download"] = "download";
    BlueprintIcons_162["DragHandleHorizontal"] = "drag-handle-horizontal";
    BlueprintIcons_162["DragHandleVertical"] = "drag-handle-vertical";
    BlueprintIcons_162["Draw"] = "draw";
    BlueprintIcons_162["DrawerLeftFilled"] = "drawer-left-filled";
    BlueprintIcons_162["DrawerLeft"] = "drawer-left";
    BlueprintIcons_162["DrawerRightFilled"] = "drawer-right-filled";
    BlueprintIcons_162["DrawerRight"] = "drawer-right";
    BlueprintIcons_162["DriveTime"] = "drive-time";
    BlueprintIcons_162["Duplicate"] = "duplicate";
    BlueprintIcons_162["Edit"] = "edit";
    BlueprintIcons_162["Eject"] = "eject";
    BlueprintIcons_162["Emoji"] = "emoji";
    BlueprintIcons_162["Endorsed"] = "endorsed";
    BlueprintIcons_162["Envelope"] = "envelope";
    BlueprintIcons_162["Equals"] = "equals";
    BlueprintIcons_162["Eraser"] = "eraser";
    BlueprintIcons_162["Error"] = "error";
    BlueprintIcons_162["Euro"] = "euro";
    BlueprintIcons_162["Exchange"] = "exchange";
    BlueprintIcons_162["ExcludeRow"] = "exclude-row";
    BlueprintIcons_162["ExpandAll"] = "expand-all";
    BlueprintIcons_162["Export"] = "export";
    BlueprintIcons_162["EyeOff"] = "eye-off";
    BlueprintIcons_162["EyeOn"] = "eye-on";
    BlueprintIcons_162["EyeOpen"] = "eye-open";
    BlueprintIcons_162["FastBackward"] = "fast-backward";
    BlueprintIcons_162["FastForward"] = "fast-forward";
    BlueprintIcons_162["FeedSubscribed"] = "feed-subscribed";
    BlueprintIcons_162["Feed"] = "feed";
    BlueprintIcons_162["Film"] = "film";
    BlueprintIcons_162["FilterKeep"] = "filter-keep";
    BlueprintIcons_162["FilterList"] = "filter-list";
    BlueprintIcons_162["FilterOpen"] = "filter-open";
    BlueprintIcons_162["FilterRemove"] = "filter-remove";
    BlueprintIcons_162["Filter"] = "filter";
    BlueprintIcons_162["Flag"] = "flag";
    BlueprintIcons_162["Flame"] = "flame";
    BlueprintIcons_162["Flash"] = "flash";
    BlueprintIcons_162["FloatingPoint"] = "floating-point";
    BlueprintIcons_162["FloppyDisk"] = "floppy-disk";
    BlueprintIcons_162["FlowBranch"] = "flow-branch";
    BlueprintIcons_162["FlowEnd"] = "flow-end";
    BlueprintIcons_162["FlowLinear"] = "flow-linear";
    BlueprintIcons_162["FlowReviewBranch"] = "flow-review-branch";
    BlueprintIcons_162["FlowReview"] = "flow-review";
    BlueprintIcons_162["Flows"] = "flows";
    BlueprintIcons_162["FolderClose"] = "folder-close";
    BlueprintIcons_162["FolderNew"] = "folder-new";
    BlueprintIcons_162["FolderOpen"] = "folder-open";
    BlueprintIcons_162["FolderSharedOpen"] = "folder-shared-open";
    BlueprintIcons_162["FolderShared"] = "folder-shared";
    BlueprintIcons_162["Follower"] = "follower";
    BlueprintIcons_162["Following"] = "following";
    BlueprintIcons_162["Font"] = "font";
    BlueprintIcons_162["Fork"] = "fork";
    BlueprintIcons_162["Form"] = "form";
    BlueprintIcons_162["Fuel"] = "fuel";
    BlueprintIcons_162["FullCircle"] = "full-circle";
    BlueprintIcons_162["FullStackedChart"] = "full-stacked-chart";
    BlueprintIcons_162["Fullscreen"] = "fullscreen";
    BlueprintIcons_162["Function"] = "function";
    BlueprintIcons_162["GanttChart"] = "gantt-chart";
    BlueprintIcons_162["Geofence"] = "geofence";
    BlueprintIcons_162["Geolocation"] = "geolocation";
    BlueprintIcons_162["Geosearch"] = "geosearch";
    BlueprintIcons_162["GitBranch"] = "git-branch";
    BlueprintIcons_162["GitCommit"] = "git-commit";
    BlueprintIcons_162["GitMerge"] = "git-merge";
    BlueprintIcons_162["GitNewBranch"] = "git-new-branch";
    BlueprintIcons_162["GitPull"] = "git-pull";
    BlueprintIcons_162["GitPush"] = "git-push";
    BlueprintIcons_162["GitRepo"] = "git-repo";
    BlueprintIcons_162["Glass"] = "glass";
    BlueprintIcons_162["GlobeNetwork"] = "globe-network";
    BlueprintIcons_162["Globe"] = "globe";
    BlueprintIcons_162["GraphRemove"] = "graph-remove";
    BlueprintIcons_162["Graph"] = "graph";
    BlueprintIcons_162["GreaterThanOrEqualTo"] = "greater-than-or-equal-to";
    BlueprintIcons_162["GreaterThan"] = "greater-than";
    BlueprintIcons_162["GridView"] = "grid-view";
    BlueprintIcons_162["Grid"] = "grid";
    BlueprintIcons_162["GroupObjects"] = "group-objects";
    BlueprintIcons_162["GroupedBarChart"] = "grouped-bar-chart";
    BlueprintIcons_162["HandDown"] = "hand-down";
    BlueprintIcons_162["HandLeft"] = "hand-left";
    BlueprintIcons_162["HandRight"] = "hand-right";
    BlueprintIcons_162["HandUp"] = "hand-up";
    BlueprintIcons_162["Hand"] = "hand";
    BlueprintIcons_162["Hat"] = "hat";
    BlueprintIcons_162["HeaderOne"] = "header-one";
    BlueprintIcons_162["HeaderThree"] = "header-three";
    BlueprintIcons_162["HeaderTwo"] = "header-two";
    BlueprintIcons_162["Header"] = "header";
    BlueprintIcons_162["Headset"] = "headset";
    BlueprintIcons_162["HeartBroken"] = "heart-broken";
    BlueprintIcons_162["Heart"] = "heart";
    BlueprintIcons_162["HeatGrid"] = "heat-grid";
    BlueprintIcons_162["Heatmap"] = "heatmap";
    BlueprintIcons_162["Helicopter"] = "helicopter";
    BlueprintIcons_162["Help"] = "help";
    BlueprintIcons_162["HelperManagement"] = "helper-management";
    BlueprintIcons_162["HighPriority"] = "high-priority";
    BlueprintIcons_162["HighVoltagePole"] = "high-voltage-pole";
    BlueprintIcons_162["Highlight"] = "highlight";
    BlueprintIcons_162["History"] = "history";
    BlueprintIcons_162["Home"] = "home";
    BlueprintIcons_162["HorizontalBarChartAsc"] = "horizontal-bar-chart-asc";
    BlueprintIcons_162["HorizontalBarChartDesc"] = "horizontal-bar-chart-desc";
    BlueprintIcons_162["HorizontalBarChart"] = "horizontal-bar-chart";
    BlueprintIcons_162["HorizontalDistribution"] = "horizontal-distribution";
    BlueprintIcons_162["HorizontalInbetween"] = "horizontal-inbetween";
    BlueprintIcons_162["Hurricane"] = "hurricane";
    BlueprintIcons_162["IdNumber"] = "id-number";
    BlueprintIcons_162["ImageRotateLeft"] = "image-rotate-left";
    BlueprintIcons_162["ImageRotateRight"] = "image-rotate-right";
    BlueprintIcons_162["Import"] = "import";
    BlueprintIcons_162["InboxFiltered"] = "inbox-filtered";
    BlueprintIcons_162["InboxGeo"] = "inbox-geo";
    BlueprintIcons_162["InboxSearch"] = "inbox-search";
    BlueprintIcons_162["InboxUpdate"] = "inbox-update";
    BlueprintIcons_162["Inbox"] = "inbox";
    BlueprintIcons_162["InfoSign"] = "info-sign";
    BlueprintIcons_162["Inheritance"] = "inheritance";
    BlueprintIcons_162["InheritedGroup"] = "inherited-group";
    BlueprintIcons_162["InnerJoin"] = "inner-join";
    BlueprintIcons_162["Insert"] = "insert";
    BlueprintIcons_162["Intelligence"] = "intelligence";
    BlueprintIcons_162["Intersection"] = "intersection";
    BlueprintIcons_162["IpAddress"] = "ip-address";
    BlueprintIcons_162["IssueClosed"] = "issue-closed";
    BlueprintIcons_162["IssueNew"] = "issue-new";
    BlueprintIcons_162["Issue"] = "issue";
    BlueprintIcons_162["Italic"] = "italic";
    BlueprintIcons_162["JoinTable"] = "join-table";
    BlueprintIcons_162["KeyBackspace"] = "key-backspace";
    BlueprintIcons_162["KeyCommand"] = "key-command";
    BlueprintIcons_162["KeyControl"] = "key-control";
    BlueprintIcons_162["KeyDelete"] = "key-delete";
    BlueprintIcons_162["KeyEnter"] = "key-enter";
    BlueprintIcons_162["KeyEscape"] = "key-escape";
    BlueprintIcons_162["KeyOption"] = "key-option";
    BlueprintIcons_162["KeyShift"] = "key-shift";
    BlueprintIcons_162["KeyTab"] = "key-tab";
    BlueprintIcons_162["Key"] = "key";
    BlueprintIcons_162["KnownVehicle"] = "known-vehicle";
    BlueprintIcons_162["LabTest"] = "lab-test";
    BlueprintIcons_162["Label"] = "label";
    BlueprintIcons_162["LayerOutline"] = "layer-outline";
    BlueprintIcons_162["Layer"] = "layer";
    BlueprintIcons_162["Layers"] = "layers";
    BlueprintIcons_162["LayoutAuto"] = "layout-auto";
    BlueprintIcons_162["LayoutBalloon"] = "layout-balloon";
    BlueprintIcons_162["LayoutCircle"] = "layout-circle";
    BlueprintIcons_162["LayoutGrid"] = "layout-grid";
    BlueprintIcons_162["LayoutGroupBy"] = "layout-group-by";
    BlueprintIcons_162["LayoutHierarchy"] = "layout-hierarchy";
    BlueprintIcons_162["LayoutLinear"] = "layout-linear";
    BlueprintIcons_162["LayoutSkewGrid"] = "layout-skew-grid";
    BlueprintIcons_162["LayoutSortedClusters"] = "layout-sorted-clusters";
    BlueprintIcons_162["Layout"] = "layout";
    BlueprintIcons_162["Learning"] = "learning";
    BlueprintIcons_162["LeftJoin"] = "left-join";
    BlueprintIcons_162["LessThanOrEqualTo"] = "less-than-or-equal-to";
    BlueprintIcons_162["LessThan"] = "less-than";
    BlueprintIcons_162["Lifesaver"] = "lifesaver";
    BlueprintIcons_162["Lightbulb"] = "lightbulb";
    BlueprintIcons_162["Lightning"] = "lightning";
    BlueprintIcons_162["Link"] = "link";
    BlueprintIcons_162["ListColumns"] = "list-columns";
    BlueprintIcons_162["ListDetailView"] = "list-detail-view";
    BlueprintIcons_162["List"] = "list";
    BlueprintIcons_162["Locate"] = "locate";
    BlueprintIcons_162["Lock"] = "lock";
    BlueprintIcons_162["LogIn"] = "log-in";
    BlueprintIcons_162["LogOut"] = "log-out";
    BlueprintIcons_162["LowVoltagePole"] = "low-voltage-pole";
    BlueprintIcons_162["Manual"] = "manual";
    BlueprintIcons_162["ManuallyEnteredData"] = "manually-entered-data";
    BlueprintIcons_162["ManyToMany"] = "many-to-many";
    BlueprintIcons_162["ManyToOne"] = "many-to-one";
    BlueprintIcons_162["MapCreate"] = "map-create";
    BlueprintIcons_162["MapMarker"] = "map-marker";
    BlueprintIcons_162["Map"] = "map";
    BlueprintIcons_162["Maximize"] = "maximize";
    BlueprintIcons_162["Media"] = "media";
    BlueprintIcons_162["MenuClosed"] = "menu-closed";
    BlueprintIcons_162["MenuOpen"] = "menu-open";
    BlueprintIcons_162["Menu"] = "menu";
    BlueprintIcons_162["MergeColumns"] = "merge-columns";
    BlueprintIcons_162["MergeLinks"] = "merge-links";
    BlueprintIcons_162["Minimize"] = "minimize";
    BlueprintIcons_162["Minus"] = "minus";
    BlueprintIcons_162["MobilePhone"] = "mobile-phone";
    BlueprintIcons_162["MobileVideo"] = "mobile-video";
    BlueprintIcons_162["ModalFilled"] = "modal-filled";
    BlueprintIcons_162["Modal"] = "modal";
    BlueprintIcons_162["Moon"] = "moon";
    BlueprintIcons_162["More"] = "more";
    BlueprintIcons_162["Mountain"] = "mountain";
    BlueprintIcons_162["Move"] = "move";
    BlueprintIcons_162["Mugshot"] = "mugshot";
    BlueprintIcons_162["MultiSelect"] = "multi-select";
    BlueprintIcons_162["Music"] = "music";
    BlueprintIcons_162["Nest"] = "nest";
    BlueprintIcons_162["NewDrawing"] = "new-drawing";
    BlueprintIcons_162["NewGridItem"] = "new-grid-item";
    BlueprintIcons_162["NewLayer"] = "new-layer";
    BlueprintIcons_162["NewLayers"] = "new-layers";
    BlueprintIcons_162["NewLink"] = "new-link";
    BlueprintIcons_162["NewObject"] = "new-object";
    BlueprintIcons_162["NewPerson"] = "new-person";
    BlueprintIcons_162["NewPrescription"] = "new-prescription";
    BlueprintIcons_162["NewTextBox"] = "new-text-box";
    BlueprintIcons_162["Ninja"] = "ninja";
    BlueprintIcons_162["NotEqualTo"] = "not-equal-to";
    BlueprintIcons_162["NotificationsSnooze"] = "notifications-snooze";
    BlueprintIcons_162["NotificationsUpdated"] = "notifications-updated";
    BlueprintIcons_162["Notifications"] = "notifications";
    BlueprintIcons_162["NumberedList"] = "numbered-list";
    BlueprintIcons_162["Numerical"] = "numerical";
    BlueprintIcons_162["Office"] = "office";
    BlueprintIcons_162["Offline"] = "offline";
    BlueprintIcons_162["OilField"] = "oil-field";
    BlueprintIcons_162["OneColumn"] = "one-column";
    BlueprintIcons_162["OneToMany"] = "one-to-many";
    BlueprintIcons_162["OneToOne"] = "one-to-one";
    BlueprintIcons_162["OpenApplication"] = "open-application";
    BlueprintIcons_162["Outdated"] = "outdated";
    BlueprintIcons_162["PageLayout"] = "page-layout";
    BlueprintIcons_162["PanelStats"] = "panel-stats";
    BlueprintIcons_162["PanelTable"] = "panel-table";
    BlueprintIcons_162["Paperclip"] = "paperclip";
    BlueprintIcons_162["Paragraph"] = "paragraph";
    BlueprintIcons_162["PathSearch"] = "path-search";
    BlueprintIcons_162["Path"] = "path";
    BlueprintIcons_162["Pause"] = "pause";
    BlueprintIcons_162["People"] = "people";
    BlueprintIcons_162["Percentage"] = "percentage";
    BlueprintIcons_162["Person"] = "person";
    BlueprintIcons_162["Phone"] = "phone";
    BlueprintIcons_162["PieChart"] = "pie-chart";
    BlueprintIcons_162["Pin"] = "pin";
    BlueprintIcons_162["PivotTable"] = "pivot-table";
    BlueprintIcons_162["Pivot"] = "pivot";
    BlueprintIcons_162["Play"] = "play";
    BlueprintIcons_162["Playbook"] = "playbook";
    BlueprintIcons_162["Plus"] = "plus";
    BlueprintIcons_162["PolygonFilter"] = "polygon-filter";
    BlueprintIcons_162["Power"] = "power";
    BlueprintIcons_162["PredictiveAnalysis"] = "predictive-analysis";
    BlueprintIcons_162["Prescription"] = "prescription";
    BlueprintIcons_162["Presentation"] = "presentation";
    BlueprintIcons_162["Print"] = "print";
    BlueprintIcons_162["Projects"] = "projects";
    BlueprintIcons_162["Properties"] = "properties";
    BlueprintIcons_162["Property"] = "property";
    BlueprintIcons_162["PublishFunction"] = "publish-function";
    BlueprintIcons_162["Pulse"] = "pulse";
    BlueprintIcons_162["Rain"] = "rain";
    BlueprintIcons_162["Random"] = "random";
    BlueprintIcons_162["Record"] = "record";
    BlueprintIcons_162["RectHeight"] = "rect-height";
    BlueprintIcons_162["RectWidth"] = "rect-width";
    BlueprintIcons_162["Rectangle"] = "rectangle";
    BlueprintIcons_162["Redo"] = "redo";
    BlueprintIcons_162["Refresh"] = "refresh";
    BlueprintIcons_162["Regex"] = "regex";
    BlueprintIcons_162["RegressionChart"] = "regression-chart";
    BlueprintIcons_162["RemoveColumnLeft"] = "remove-column-left";
    BlueprintIcons_162["RemoveColumnRight"] = "remove-column-right";
    BlueprintIcons_162["RemoveColumn"] = "remove-column";
    BlueprintIcons_162["RemoveRowBottom"] = "remove-row-bottom";
    BlueprintIcons_162["RemoveRowTop"] = "remove-row-top";
    BlueprintIcons_162["Remove"] = "remove";
    BlueprintIcons_162["Repeat"] = "repeat";
    BlueprintIcons_162["Reset"] = "reset";
    BlueprintIcons_162["Resolve"] = "resolve";
    BlueprintIcons_162["Rig"] = "rig";
    BlueprintIcons_162["RightJoin"] = "right-join";
    BlueprintIcons_162["Ring"] = "ring";
    BlueprintIcons_162["RocketSlant"] = "rocket-slant";
    BlueprintIcons_162["Rocket"] = "rocket";
    BlueprintIcons_162["RotateDocument"] = "rotate-document";
    BlueprintIcons_162["RotatePage"] = "rotate-page";
    BlueprintIcons_162["Route"] = "route";
    BlueprintIcons_162["Satellite"] = "satellite";
    BlueprintIcons_162["Saved"] = "saved";
    BlueprintIcons_162["ScatterPlot"] = "scatter-plot";
    BlueprintIcons_162["SearchAround"] = "search-around";
    BlueprintIcons_162["SearchTemplate"] = "search-template";
    BlueprintIcons_162["SearchText"] = "search-text";
    BlueprintIcons_162["Search"] = "search";
    BlueprintIcons_162["SegmentedControl"] = "segmented-control";
    BlueprintIcons_162["Select"] = "select";
    BlueprintIcons_162["Selection"] = "selection";
    BlueprintIcons_162["SendMessage"] = "send-message";
    BlueprintIcons_162["SendToGraph"] = "send-to-graph";
    BlueprintIcons_162["SendToMap"] = "send-to-map";
    BlueprintIcons_162["SendTo"] = "send-to";
    BlueprintIcons_162["SeriesAdd"] = "series-add";
    BlueprintIcons_162["SeriesConfiguration"] = "series-configuration";
    BlueprintIcons_162["SeriesDerived"] = "series-derived";
    BlueprintIcons_162["SeriesFiltered"] = "series-filtered";
    BlueprintIcons_162["SeriesSearch"] = "series-search";
    BlueprintIcons_162["Settings"] = "settings";
    BlueprintIcons_162["Shapes"] = "shapes";
    BlueprintIcons_162["Share"] = "share";
    BlueprintIcons_162["SharedFilter"] = "shared-filter";
    BlueprintIcons_162["Shield"] = "shield";
    BlueprintIcons_162["Ship"] = "ship";
    BlueprintIcons_162["Shop"] = "shop";
    BlueprintIcons_162["ShoppingCart"] = "shopping-cart";
    BlueprintIcons_162["SignalSearch"] = "signal-search";
    BlueprintIcons_162["SimCard"] = "sim-card";
    BlueprintIcons_162["Slash"] = "slash";
    BlueprintIcons_162["SmallCross"] = "small-cross";
    BlueprintIcons_162["SmallInfoSign"] = "small-info-sign";
    BlueprintIcons_162["SmallMinus"] = "small-minus";
    BlueprintIcons_162["SmallPlus"] = "small-plus";
    BlueprintIcons_162["SmallSquare"] = "small-square";
    BlueprintIcons_162["SmallTick"] = "small-tick";
    BlueprintIcons_162["Snowflake"] = "snowflake";
    BlueprintIcons_162["SocialMedia"] = "social-media";
    BlueprintIcons_162["SortAlphabeticalDesc"] = "sort-alphabetical-desc";
    BlueprintIcons_162["SortAlphabetical"] = "sort-alphabetical";
    BlueprintIcons_162["SortAsc"] = "sort-asc";
    BlueprintIcons_162["SortDesc"] = "sort-desc";
    BlueprintIcons_162["SortNumericalDesc"] = "sort-numerical-desc";
    BlueprintIcons_162["SortNumerical"] = "sort-numerical";
    BlueprintIcons_162["Sort"] = "sort";
    BlueprintIcons_162["SplitColumns"] = "split-columns";
    BlueprintIcons_162["Square"] = "square";
    BlueprintIcons_162["StackedChart"] = "stacked-chart";
    BlueprintIcons_162["StadiumGeometry"] = "stadium-geometry";
    BlueprintIcons_162["StarEmpty"] = "star-empty";
    BlueprintIcons_162["Star"] = "star";
    BlueprintIcons_162["StepBackward"] = "step-backward";
    BlueprintIcons_162["StepChart"] = "step-chart";
    BlueprintIcons_162["StepForward"] = "step-forward";
    BlueprintIcons_162["Stop"] = "stop";
    BlueprintIcons_162["Stopwatch"] = "stopwatch";
    BlueprintIcons_162["Strikethrough"] = "strikethrough";
    BlueprintIcons_162["Style"] = "style";
    BlueprintIcons_162["SwapHorizontal"] = "swap-horizontal";
    BlueprintIcons_162["SwapVertical"] = "swap-vertical";
    BlueprintIcons_162["Switch"] = "switch";
    BlueprintIcons_162["SymbolCircle"] = "symbol-circle";
    BlueprintIcons_162["SymbolCross"] = "symbol-cross";
    BlueprintIcons_162["SymbolDiamond"] = "symbol-diamond";
    BlueprintIcons_162["SymbolRectangle"] = "symbol-rectangle";
    BlueprintIcons_162["SymbolSquare"] = "symbol-square";
    BlueprintIcons_162["SymbolTriangleDown"] = "symbol-triangle-down";
    BlueprintIcons_162["SymbolTriangleUp"] = "symbol-triangle-up";
    BlueprintIcons_162["Syringe"] = "syringe";
    BlueprintIcons_162["Tag"] = "tag";
    BlueprintIcons_162["TakeAction"] = "take-action";
    BlueprintIcons_162["Tank"] = "tank";
    BlueprintIcons_162["Target"] = "target";
    BlueprintIcons_162["Taxi"] = "taxi";
    BlueprintIcons_162["Temperature"] = "temperature";
    BlueprintIcons_162["TextHighlight"] = "text-highlight";
    BlueprintIcons_162["ThDerived"] = "th-derived";
    BlueprintIcons_162["ThDisconnect"] = "th-disconnect";
    BlueprintIcons_162["ThFiltered"] = "th-filtered";
    BlueprintIcons_162["ThList"] = "th-list";
    BlueprintIcons_162["Th"] = "th";
    BlueprintIcons_162["ThirdParty"] = "third-party";
    BlueprintIcons_162["ThumbsDown"] = "thumbs-down";
    BlueprintIcons_162["ThumbsUp"] = "thumbs-up";
    BlueprintIcons_162["TickCircle"] = "tick-circle";
    BlueprintIcons_162["Tick"] = "tick";
    BlueprintIcons_162["Time"] = "time";
    BlueprintIcons_162["TimelineAreaChart"] = "timeline-area-chart";
    BlueprintIcons_162["TimelineBarChart"] = "timeline-bar-chart";
    BlueprintIcons_162["TimelineEvents"] = "timeline-events";
    BlueprintIcons_162["TimelineLineChart"] = "timeline-line-chart";
    BlueprintIcons_162["Tint"] = "tint";
    BlueprintIcons_162["Torch"] = "torch";
    BlueprintIcons_162["Tractor"] = "tractor";
    BlueprintIcons_162["Train"] = "train";
    BlueprintIcons_162["Translate"] = "translate";
    BlueprintIcons_162["Trash"] = "trash";
    BlueprintIcons_162["Tree"] = "tree";
    BlueprintIcons_162["TrendingDown"] = "trending-down";
    BlueprintIcons_162["TrendingUp"] = "trending-up";
    BlueprintIcons_162["Truck"] = "truck";
    BlueprintIcons_162["TwoColumns"] = "two-columns";
    BlueprintIcons_162["Unarchive"] = "unarchive";
    BlueprintIcons_162["Underline"] = "underline";
    BlueprintIcons_162["Undo"] = "undo";
    BlueprintIcons_162["UngroupObjects"] = "ungroup-objects";
    BlueprintIcons_162["UnknownVehicle"] = "unknown-vehicle";
    BlueprintIcons_162["Unlock"] = "unlock";
    BlueprintIcons_162["Unpin"] = "unpin";
    BlueprintIcons_162["Unresolve"] = "unresolve";
    BlueprintIcons_162["Updated"] = "updated";
    BlueprintIcons_162["Upload"] = "upload";
    BlueprintIcons_162["User"] = "user";
    BlueprintIcons_162["Variable"] = "variable";
    BlueprintIcons_162["VerticalBarChartAsc"] = "vertical-bar-chart-asc";
    BlueprintIcons_162["VerticalBarChartDesc"] = "vertical-bar-chart-desc";
    BlueprintIcons_162["VerticalDistribution"] = "vertical-distribution";
    BlueprintIcons_162["VerticalInbetween"] = "vertical-inbetween";
    BlueprintIcons_162["Video"] = "video";
    BlueprintIcons_162["Virus"] = "virus";
    BlueprintIcons_162["VolumeDown"] = "volume-down";
    BlueprintIcons_162["VolumeOff"] = "volume-off";
    BlueprintIcons_162["VolumeUp"] = "volume-up";
    BlueprintIcons_162["Walk"] = "walk";
    BlueprintIcons_162["WarningSign"] = "warning-sign";
    BlueprintIcons_162["WaterfallChart"] = "waterfall-chart";
    BlueprintIcons_162["Waves"] = "waves";
    BlueprintIcons_162["WidgetButton"] = "widget-button";
    BlueprintIcons_162["WidgetFooter"] = "widget-footer";
    BlueprintIcons_162["WidgetHeader"] = "widget-header";
    BlueprintIcons_162["Widget"] = "widget";
    BlueprintIcons_162["Wind"] = "wind";
    BlueprintIcons_162["Wrench"] = "wrench";
    BlueprintIcons_162["ZoomIn"] = "zoom-in";
    BlueprintIcons_162["ZoomOut"] = "zoom-out";
    BlueprintIcons_162["ZoomToFit"] = "zoom-to-fit";
  })(BlueprintIcons_16 || (BlueprintIcons_16 = {}));
  var BLUEPRINT_ICONS_16_CODEPOINTS = (_a2 = {}, _a2[BlueprintIcons_16.AddClip] = "61697", _a2[BlueprintIcons_16.AddColumnLeft] = "61698", _a2[BlueprintIcons_16.AddColumnRight] = "61699", _a2[BlueprintIcons_16.AddLocation] = "61700", _a2[BlueprintIcons_16.AddRowBottom] = "61701", _a2[BlueprintIcons_16.AddRowTop] = "61702", _a2[BlueprintIcons_16.AddToArtifact] = "61703", _a2[BlueprintIcons_16.AddToFolder] = "61704", _a2[BlueprintIcons_16.Add] = "61705", _a2[BlueprintIcons_16.AimpointsTarget] = "62261", _a2[BlueprintIcons_16.Airplane] = "61706", _a2[BlueprintIcons_16.AlignCenter] = "61707", _a2[BlueprintIcons_16.AlignJustify] = "61708", _a2[BlueprintIcons_16.AlignLeft] = "61709", _a2[BlueprintIcons_16.AlignRight] = "61710", _a2[BlueprintIcons_16.AlignmentBottom] = "61711", _a2[BlueprintIcons_16.AlignmentHorizontalCenter] = "61712", _a2[BlueprintIcons_16.AlignmentLeft] = "61713", _a2[BlueprintIcons_16.AlignmentRight] = "61714", _a2[BlueprintIcons_16.AlignmentTop] = "61715", _a2[BlueprintIcons_16.AlignmentVerticalCenter] = "61716", _a2[BlueprintIcons_16.Anchor] = "62256", _a2[BlueprintIcons_16.Annotation] = "61717", _a2[BlueprintIcons_16.Antenna] = "61718", _a2[BlueprintIcons_16.AppHeader] = "61719", _a2[BlueprintIcons_16.Application] = "61720", _a2[BlueprintIcons_16.Applications] = "61721", _a2[BlueprintIcons_16.Archive] = "61722", _a2[BlueprintIcons_16.AreaOfInterest] = "61723", _a2[BlueprintIcons_16.ArrayBoolean] = "61724", _a2[BlueprintIcons_16.ArrayDate] = "61725", _a2[BlueprintIcons_16.ArrayFloatingPoint] = "62253", _a2[BlueprintIcons_16.ArrayNumeric] = "61726", _a2[BlueprintIcons_16.ArrayString] = "61727", _a2[BlueprintIcons_16.ArrayTimestamp] = "61728", _a2[BlueprintIcons_16.Array] = "61729", _a2[BlueprintIcons_16.ArrowBottomLeft] = "61730", _a2[BlueprintIcons_16.ArrowBottomRight] = "61731", _a2[BlueprintIcons_16.ArrowDown] = "61732", _a2[BlueprintIcons_16.ArrowLeft] = "61733", _a2[BlueprintIcons_16.ArrowRight] = "61734", _a2[BlueprintIcons_16.ArrowTopLeft] = "61735", _a2[BlueprintIcons_16.ArrowTopRight] = "61736", _a2[BlueprintIcons_16.ArrowUp] = "61737", _a2[BlueprintIcons_16.ArrowsHorizontal] = "61738", _a2[BlueprintIcons_16.ArrowsVertical] = "61739", _a2[BlueprintIcons_16.Asterisk] = "61740", _a2[BlueprintIcons_16.At] = "62257", _a2[BlueprintIcons_16.AutomaticUpdates] = "61741", _a2[BlueprintIcons_16.Backlink] = "61742", _a2[BlueprintIcons_16.Badge] = "61743", _a2[BlueprintIcons_16.BanCircle] = "61744", _a2[BlueprintIcons_16.BankAccount] = "61745", _a2[BlueprintIcons_16.Barcode] = "61746", _a2[BlueprintIcons_16.Blank] = "61747", _a2[BlueprintIcons_16.BlockedPerson] = "61748", _a2[BlueprintIcons_16.Bold] = "61749", _a2[BlueprintIcons_16.Book] = "61750", _a2[BlueprintIcons_16.Bookmark] = "61751", _a2[BlueprintIcons_16.Box] = "61752", _a2[BlueprintIcons_16.Briefcase] = "61753", _a2[BlueprintIcons_16.BringData] = "61754", _a2[BlueprintIcons_16.Bug] = "62254", _a2[BlueprintIcons_16.Buggy] = "61755", _a2[BlueprintIcons_16.Build] = "61756", _a2[BlueprintIcons_16.Calculator] = "61757", _a2[BlueprintIcons_16.Calendar] = "61758", _a2[BlueprintIcons_16.Camera] = "61759", _a2[BlueprintIcons_16.CaretDown] = "61760", _a2[BlueprintIcons_16.CaretLeft] = "61761", _a2[BlueprintIcons_16.CaretRight] = "61762", _a2[BlueprintIcons_16.CaretUp] = "61763", _a2[BlueprintIcons_16.CargoShip] = "61764", _a2[BlueprintIcons_16.CellTower] = "61765", _a2[BlueprintIcons_16.Changes] = "61766", _a2[BlueprintIcons_16.Chart] = "61767", _a2[BlueprintIcons_16.Chat] = "61768", _a2[BlueprintIcons_16.ChevronBackward] = "61769", _a2[BlueprintIcons_16.ChevronDown] = "61770", _a2[BlueprintIcons_16.ChevronForward] = "61771", _a2[BlueprintIcons_16.ChevronLeft] = "61772", _a2[BlueprintIcons_16.ChevronRight] = "61773", _a2[BlueprintIcons_16.ChevronUp] = "61774", _a2[BlueprintIcons_16.CircleArrowDown] = "61775", _a2[BlueprintIcons_16.CircleArrowLeft] = "61776", _a2[BlueprintIcons_16.CircleArrowRight] = "61777", _a2[BlueprintIcons_16.CircleArrowUp] = "61778", _a2[BlueprintIcons_16.Circle] = "61779", _a2[BlueprintIcons_16.Citation] = "61780", _a2[BlueprintIcons_16.Clean] = "61781", _a2[BlueprintIcons_16.Clip] = "61782", _a2[BlueprintIcons_16.Clipboard] = "61783", _a2[BlueprintIcons_16.CloudDownload] = "61784", _a2[BlueprintIcons_16.CloudUpload] = "61785", _a2[BlueprintIcons_16.Cloud] = "61786", _a2[BlueprintIcons_16.CodeBlock] = "61787", _a2[BlueprintIcons_16.Code] = "61788", _a2[BlueprintIcons_16.Cog] = "61789", _a2[BlueprintIcons_16.CollapseAll] = "61790", _a2[BlueprintIcons_16.ColorFill] = "62248", _a2[BlueprintIcons_16.ColumnLayout] = "61791", _a2[BlueprintIcons_16.Comment] = "61792", _a2[BlueprintIcons_16.Comparison] = "61793", _a2[BlueprintIcons_16.Compass] = "61794", _a2[BlueprintIcons_16.Compressed] = "61795", _a2[BlueprintIcons_16.Confirm] = "61796", _a2[BlueprintIcons_16.Console] = "61797", _a2[BlueprintIcons_16.Contrast] = "61798", _a2[BlueprintIcons_16.Control] = "61799", _a2[BlueprintIcons_16.CreditCard] = "61800", _a2[BlueprintIcons_16.CrossCircle] = "62262", _a2[BlueprintIcons_16.Cross] = "61801", _a2[BlueprintIcons_16.Crown] = "61802", _a2[BlueprintIcons_16.CubeAdd] = "61803", _a2[BlueprintIcons_16.CubeRemove] = "61804", _a2[BlueprintIcons_16.Cube] = "61805", _a2[BlueprintIcons_16.CurvedRangeChart] = "61806", _a2[BlueprintIcons_16.Cut] = "61807", _a2[BlueprintIcons_16.Cycle] = "61808", _a2[BlueprintIcons_16.Dashboard] = "61809", _a2[BlueprintIcons_16.DataConnection] = "61810", _a2[BlueprintIcons_16.DataLineage] = "61811", _a2[BlueprintIcons_16.Database] = "61812", _a2[BlueprintIcons_16.Delete] = "61813", _a2[BlueprintIcons_16.Delta] = "61814", _a2[BlueprintIcons_16.DeriveColumn] = "61815", _a2[BlueprintIcons_16.Desktop] = "61816", _a2[BlueprintIcons_16.Diagnosis] = "61817", _a2[BlueprintIcons_16.DiagramTree] = "61818", _a2[BlueprintIcons_16.DirectionLeft] = "61819", _a2[BlueprintIcons_16.DirectionRight] = "61820", _a2[BlueprintIcons_16.Disable] = "61821", _a2[BlueprintIcons_16.Divide] = "62247", _a2[BlueprintIcons_16.DocumentOpen] = "61822", _a2[BlueprintIcons_16.DocumentShare] = "61823", _a2[BlueprintIcons_16.Document] = "61824", _a2[BlueprintIcons_16.Dollar] = "61825", _a2[BlueprintIcons_16.Dot] = "61826", _a2[BlueprintIcons_16.DoubleCaretHorizontal] = "61827", _a2[BlueprintIcons_16.DoubleCaretVertical] = "61828", _a2[BlueprintIcons_16.DoubleChevronDown] = "61829", _a2[BlueprintIcons_16.DoubleChevronLeft] = "61830", _a2[BlueprintIcons_16.DoubleChevronRight] = "61831", _a2[BlueprintIcons_16.DoubleChevronUp] = "61832", _a2[BlueprintIcons_16.DoughnutChart] = "61833", _a2[BlueprintIcons_16.Download] = "61834", _a2[BlueprintIcons_16.DragHandleHorizontal] = "61835", _a2[BlueprintIcons_16.DragHandleVertical] = "61836", _a2[BlueprintIcons_16.Draw] = "61837", _a2[BlueprintIcons_16.DrawerLeftFilled] = "61838", _a2[BlueprintIcons_16.DrawerLeft] = "61839", _a2[BlueprintIcons_16.DrawerRightFilled] = "61840", _a2[BlueprintIcons_16.DrawerRight] = "61841", _a2[BlueprintIcons_16.DriveTime] = "61842", _a2[BlueprintIcons_16.Duplicate] = "61843", _a2[BlueprintIcons_16.Edit] = "61844", _a2[BlueprintIcons_16.Eject] = "61845", _a2[BlueprintIcons_16.Emoji] = "61846", _a2[BlueprintIcons_16.Endorsed] = "61847", _a2[BlueprintIcons_16.Envelope] = "61848", _a2[BlueprintIcons_16.Equals] = "61849", _a2[BlueprintIcons_16.Eraser] = "61850", _a2[BlueprintIcons_16.Error] = "61851", _a2[BlueprintIcons_16.Euro] = "61852", _a2[BlueprintIcons_16.Exchange] = "61853", _a2[BlueprintIcons_16.ExcludeRow] = "61854", _a2[BlueprintIcons_16.ExpandAll] = "61855", _a2[BlueprintIcons_16.Export] = "61856", _a2[BlueprintIcons_16.EyeOff] = "61857", _a2[BlueprintIcons_16.EyeOn] = "61858", _a2[BlueprintIcons_16.EyeOpen] = "61859", _a2[BlueprintIcons_16.FastBackward] = "61860", _a2[BlueprintIcons_16.FastForward] = "61861", _a2[BlueprintIcons_16.FeedSubscribed] = "61862", _a2[BlueprintIcons_16.Feed] = "61863", _a2[BlueprintIcons_16.Film] = "61864", _a2[BlueprintIcons_16.FilterKeep] = "61865", _a2[BlueprintIcons_16.FilterList] = "61866", _a2[BlueprintIcons_16.FilterOpen] = "61867", _a2[BlueprintIcons_16.FilterRemove] = "61868", _a2[BlueprintIcons_16.Filter] = "61869", _a2[BlueprintIcons_16.Flag] = "61870", _a2[BlueprintIcons_16.Flame] = "61871", _a2[BlueprintIcons_16.Flash] = "61872", _a2[BlueprintIcons_16.FloatingPoint] = "62252", _a2[BlueprintIcons_16.FloppyDisk] = "61873", _a2[BlueprintIcons_16.FlowBranch] = "61874", _a2[BlueprintIcons_16.FlowEnd] = "61875", _a2[BlueprintIcons_16.FlowLinear] = "61876", _a2[BlueprintIcons_16.FlowReviewBranch] = "61877", _a2[BlueprintIcons_16.FlowReview] = "61878", _a2[BlueprintIcons_16.Flows] = "61879", _a2[BlueprintIcons_16.FolderClose] = "61880", _a2[BlueprintIcons_16.FolderNew] = "61881", _a2[BlueprintIcons_16.FolderOpen] = "61882", _a2[BlueprintIcons_16.FolderSharedOpen] = "61883", _a2[BlueprintIcons_16.FolderShared] = "61884", _a2[BlueprintIcons_16.Follower] = "61885", _a2[BlueprintIcons_16.Following] = "61886", _a2[BlueprintIcons_16.Font] = "61887", _a2[BlueprintIcons_16.Fork] = "61888", _a2[BlueprintIcons_16.Form] = "61889", _a2[BlueprintIcons_16.Fuel] = "62243", _a2[BlueprintIcons_16.FullCircle] = "61890", _a2[BlueprintIcons_16.FullStackedChart] = "61891", _a2[BlueprintIcons_16.Fullscreen] = "61892", _a2[BlueprintIcons_16.Function] = "61893", _a2[BlueprintIcons_16.GanttChart] = "61894", _a2[BlueprintIcons_16.Geofence] = "61895", _a2[BlueprintIcons_16.Geolocation] = "61896", _a2[BlueprintIcons_16.Geosearch] = "61897", _a2[BlueprintIcons_16.GitBranch] = "61898", _a2[BlueprintIcons_16.GitCommit] = "61899", _a2[BlueprintIcons_16.GitMerge] = "61900", _a2[BlueprintIcons_16.GitNewBranch] = "61901", _a2[BlueprintIcons_16.GitPull] = "61902", _a2[BlueprintIcons_16.GitPush] = "61903", _a2[BlueprintIcons_16.GitRepo] = "61904", _a2[BlueprintIcons_16.Glass] = "61905", _a2[BlueprintIcons_16.GlobeNetwork] = "61906", _a2[BlueprintIcons_16.Globe] = "61907", _a2[BlueprintIcons_16.GraphRemove] = "61908", _a2[BlueprintIcons_16.Graph] = "61909", _a2[BlueprintIcons_16.GreaterThanOrEqualTo] = "61910", _a2[BlueprintIcons_16.GreaterThan] = "61911", _a2[BlueprintIcons_16.GridView] = "61912", _a2[BlueprintIcons_16.Grid] = "61913", _a2[BlueprintIcons_16.GroupObjects] = "61914", _a2[BlueprintIcons_16.GroupedBarChart] = "61915", _a2[BlueprintIcons_16.HandDown] = "61916", _a2[BlueprintIcons_16.HandLeft] = "61917", _a2[BlueprintIcons_16.HandRight] = "61918", _a2[BlueprintIcons_16.HandUp] = "61919", _a2[BlueprintIcons_16.Hand] = "61920", _a2[BlueprintIcons_16.Hat] = "61921", _a2[BlueprintIcons_16.HeaderOne] = "61922", _a2[BlueprintIcons_16.HeaderThree] = "61923", _a2[BlueprintIcons_16.HeaderTwo] = "61924", _a2[BlueprintIcons_16.Header] = "61925", _a2[BlueprintIcons_16.Headset] = "61926", _a2[BlueprintIcons_16.HeartBroken] = "61927", _a2[BlueprintIcons_16.Heart] = "61928", _a2[BlueprintIcons_16.HeatGrid] = "61929", _a2[BlueprintIcons_16.Heatmap] = "61930", _a2[BlueprintIcons_16.Helicopter] = "61931", _a2[BlueprintIcons_16.Help] = "61932", _a2[BlueprintIcons_16.HelperManagement] = "61933", _a2[BlueprintIcons_16.HighPriority] = "61934", _a2[BlueprintIcons_16.HighVoltagePole] = "62259", _a2[BlueprintIcons_16.Highlight] = "61935", _a2[BlueprintIcons_16.History] = "61936", _a2[BlueprintIcons_16.Home] = "61937", _a2[BlueprintIcons_16.HorizontalBarChartAsc] = "61938", _a2[BlueprintIcons_16.HorizontalBarChartDesc] = "61939", _a2[BlueprintIcons_16.HorizontalBarChart] = "61940", _a2[BlueprintIcons_16.HorizontalDistribution] = "61941", _a2[BlueprintIcons_16.HorizontalInbetween] = "62249", _a2[BlueprintIcons_16.Hurricane] = "61942", _a2[BlueprintIcons_16.IdNumber] = "61943", _a2[BlueprintIcons_16.ImageRotateLeft] = "61944", _a2[BlueprintIcons_16.ImageRotateRight] = "61945", _a2[BlueprintIcons_16.Import] = "61946", _a2[BlueprintIcons_16.InboxFiltered] = "61947", _a2[BlueprintIcons_16.InboxGeo] = "61948", _a2[BlueprintIcons_16.InboxSearch] = "61949", _a2[BlueprintIcons_16.InboxUpdate] = "61950", _a2[BlueprintIcons_16.Inbox] = "61951", _a2[BlueprintIcons_16.InfoSign] = "61952", _a2[BlueprintIcons_16.Inheritance] = "61953", _a2[BlueprintIcons_16.InheritedGroup] = "61954", _a2[BlueprintIcons_16.InnerJoin] = "61955", _a2[BlueprintIcons_16.Insert] = "61956", _a2[BlueprintIcons_16.Intelligence] = "62263", _a2[BlueprintIcons_16.Intersection] = "61957", _a2[BlueprintIcons_16.IpAddress] = "61958", _a2[BlueprintIcons_16.IssueClosed] = "61959", _a2[BlueprintIcons_16.IssueNew] = "61960", _a2[BlueprintIcons_16.Issue] = "61961", _a2[BlueprintIcons_16.Italic] = "61962", _a2[BlueprintIcons_16.JoinTable] = "61963", _a2[BlueprintIcons_16.KeyBackspace] = "61964", _a2[BlueprintIcons_16.KeyCommand] = "61965", _a2[BlueprintIcons_16.KeyControl] = "61966", _a2[BlueprintIcons_16.KeyDelete] = "61967", _a2[BlueprintIcons_16.KeyEnter] = "61968", _a2[BlueprintIcons_16.KeyEscape] = "61969", _a2[BlueprintIcons_16.KeyOption] = "61970", _a2[BlueprintIcons_16.KeyShift] = "61971", _a2[BlueprintIcons_16.KeyTab] = "61972", _a2[BlueprintIcons_16.Key] = "61973", _a2[BlueprintIcons_16.KnownVehicle] = "61974", _a2[BlueprintIcons_16.LabTest] = "61975", _a2[BlueprintIcons_16.Label] = "61976", _a2[BlueprintIcons_16.LayerOutline] = "61977", _a2[BlueprintIcons_16.Layer] = "61978", _a2[BlueprintIcons_16.Layers] = "61979", _a2[BlueprintIcons_16.LayoutAuto] = "61980", _a2[BlueprintIcons_16.LayoutBalloon] = "61981", _a2[BlueprintIcons_16.LayoutCircle] = "61982", _a2[BlueprintIcons_16.LayoutGrid] = "61983", _a2[BlueprintIcons_16.LayoutGroupBy] = "61984", _a2[BlueprintIcons_16.LayoutHierarchy] = "61985", _a2[BlueprintIcons_16.LayoutLinear] = "61986", _a2[BlueprintIcons_16.LayoutSkewGrid] = "61987", _a2[BlueprintIcons_16.LayoutSortedClusters] = "61988", _a2[BlueprintIcons_16.Layout] = "61989", _a2[BlueprintIcons_16.Learning] = "61990", _a2[BlueprintIcons_16.LeftJoin] = "61991", _a2[BlueprintIcons_16.LessThanOrEqualTo] = "61992", _a2[BlueprintIcons_16.LessThan] = "61993", _a2[BlueprintIcons_16.Lifesaver] = "61994", _a2[BlueprintIcons_16.Lightbulb] = "61995", _a2[BlueprintIcons_16.Lightning] = "61996", _a2[BlueprintIcons_16.Link] = "61997", _a2[BlueprintIcons_16.ListColumns] = "61998", _a2[BlueprintIcons_16.ListDetailView] = "61999", _a2[BlueprintIcons_16.List] = "62000", _a2[BlueprintIcons_16.Locate] = "62001", _a2[BlueprintIcons_16.Lock] = "62002", _a2[BlueprintIcons_16.LogIn] = "62003", _a2[BlueprintIcons_16.LogOut] = "62004", _a2[BlueprintIcons_16.LowVoltagePole] = "62258", _a2[BlueprintIcons_16.Manual] = "62005", _a2[BlueprintIcons_16.ManuallyEnteredData] = "62006", _a2[BlueprintIcons_16.ManyToMany] = "62007", _a2[BlueprintIcons_16.ManyToOne] = "62008", _a2[BlueprintIcons_16.MapCreate] = "62009", _a2[BlueprintIcons_16.MapMarker] = "62010", _a2[BlueprintIcons_16.Map] = "62011", _a2[BlueprintIcons_16.Maximize] = "62012", _a2[BlueprintIcons_16.Media] = "62013", _a2[BlueprintIcons_16.MenuClosed] = "62014", _a2[BlueprintIcons_16.MenuOpen] = "62015", _a2[BlueprintIcons_16.Menu] = "62016", _a2[BlueprintIcons_16.MergeColumns] = "62017", _a2[BlueprintIcons_16.MergeLinks] = "62018", _a2[BlueprintIcons_16.Minimize] = "62019", _a2[BlueprintIcons_16.Minus] = "62020", _a2[BlueprintIcons_16.MobilePhone] = "62021", _a2[BlueprintIcons_16.MobileVideo] = "62022", _a2[BlueprintIcons_16.ModalFilled] = "62023", _a2[BlueprintIcons_16.Modal] = "62024", _a2[BlueprintIcons_16.Moon] = "62025", _a2[BlueprintIcons_16.More] = "62026", _a2[BlueprintIcons_16.Mountain] = "62027", _a2[BlueprintIcons_16.Move] = "62028", _a2[BlueprintIcons_16.Mugshot] = "62029", _a2[BlueprintIcons_16.MultiSelect] = "62030", _a2[BlueprintIcons_16.Music] = "62031", _a2[BlueprintIcons_16.Nest] = "62032", _a2[BlueprintIcons_16.NewDrawing] = "62033", _a2[BlueprintIcons_16.NewGridItem] = "62034", _a2[BlueprintIcons_16.NewLayer] = "62035", _a2[BlueprintIcons_16.NewLayers] = "62036", _a2[BlueprintIcons_16.NewLink] = "62037", _a2[BlueprintIcons_16.NewObject] = "62038", _a2[BlueprintIcons_16.NewPerson] = "62039", _a2[BlueprintIcons_16.NewPrescription] = "62040", _a2[BlueprintIcons_16.NewTextBox] = "62041", _a2[BlueprintIcons_16.Ninja] = "62042", _a2[BlueprintIcons_16.NotEqualTo] = "62043", _a2[BlueprintIcons_16.NotificationsSnooze] = "62044", _a2[BlueprintIcons_16.NotificationsUpdated] = "62045", _a2[BlueprintIcons_16.Notifications] = "62046", _a2[BlueprintIcons_16.NumberedList] = "62047", _a2[BlueprintIcons_16.Numerical] = "62048", _a2[BlueprintIcons_16.Office] = "62049", _a2[BlueprintIcons_16.Offline] = "62050", _a2[BlueprintIcons_16.OilField] = "62051", _a2[BlueprintIcons_16.OneColumn] = "62052", _a2[BlueprintIcons_16.OneToMany] = "62053", _a2[BlueprintIcons_16.OneToOne] = "62054", _a2[BlueprintIcons_16.OpenApplication] = "62251", _a2[BlueprintIcons_16.Outdated] = "62055", _a2[BlueprintIcons_16.PageLayout] = "62056", _a2[BlueprintIcons_16.PanelStats] = "62057", _a2[BlueprintIcons_16.PanelTable] = "62058", _a2[BlueprintIcons_16.Paperclip] = "62059", _a2[BlueprintIcons_16.Paragraph] = "62060", _a2[BlueprintIcons_16.PathSearch] = "62061", _a2[BlueprintIcons_16.Path] = "62062", _a2[BlueprintIcons_16.Pause] = "62063", _a2[BlueprintIcons_16.People] = "62064", _a2[BlueprintIcons_16.Percentage] = "62065", _a2[BlueprintIcons_16.Person] = "62066", _a2[BlueprintIcons_16.Phone] = "62067", _a2[BlueprintIcons_16.PieChart] = "62068", _a2[BlueprintIcons_16.Pin] = "62069", _a2[BlueprintIcons_16.PivotTable] = "62070", _a2[BlueprintIcons_16.Pivot] = "62071", _a2[BlueprintIcons_16.Play] = "62072", _a2[BlueprintIcons_16.Playbook] = "62244", _a2[BlueprintIcons_16.Plus] = "62073", _a2[BlueprintIcons_16.PolygonFilter] = "62074", _a2[BlueprintIcons_16.Power] = "62075", _a2[BlueprintIcons_16.PredictiveAnalysis] = "62076", _a2[BlueprintIcons_16.Prescription] = "62077", _a2[BlueprintIcons_16.Presentation] = "62078", _a2[BlueprintIcons_16.Print] = "62079", _a2[BlueprintIcons_16.Projects] = "62080", _a2[BlueprintIcons_16.Properties] = "62081", _a2[BlueprintIcons_16.Property] = "62082", _a2[BlueprintIcons_16.PublishFunction] = "62083", _a2[BlueprintIcons_16.Pulse] = "62084", _a2[BlueprintIcons_16.Rain] = "62085", _a2[BlueprintIcons_16.Random] = "62086", _a2[BlueprintIcons_16.Record] = "62087", _a2[BlueprintIcons_16.RectHeight] = "62245", _a2[BlueprintIcons_16.RectWidth] = "62246", _a2[BlueprintIcons_16.Rectangle] = "62241", _a2[BlueprintIcons_16.Redo] = "62088", _a2[BlueprintIcons_16.Refresh] = "62089", _a2[BlueprintIcons_16.Regex] = "62255", _a2[BlueprintIcons_16.RegressionChart] = "62090", _a2[BlueprintIcons_16.RemoveColumnLeft] = "62091", _a2[BlueprintIcons_16.RemoveColumnRight] = "62092", _a2[BlueprintIcons_16.RemoveColumn] = "62093", _a2[BlueprintIcons_16.RemoveRowBottom] = "62094", _a2[BlueprintIcons_16.RemoveRowTop] = "62095", _a2[BlueprintIcons_16.Remove] = "62096", _a2[BlueprintIcons_16.Repeat] = "62097", _a2[BlueprintIcons_16.Reset] = "62098", _a2[BlueprintIcons_16.Resolve] = "62099", _a2[BlueprintIcons_16.Rig] = "62100", _a2[BlueprintIcons_16.RightJoin] = "62101", _a2[BlueprintIcons_16.Ring] = "62102", _a2[BlueprintIcons_16.RocketSlant] = "62103", _a2[BlueprintIcons_16.Rocket] = "62104", _a2[BlueprintIcons_16.RotateDocument] = "62105", _a2[BlueprintIcons_16.RotatePage] = "62106", _a2[BlueprintIcons_16.Route] = "62107", _a2[BlueprintIcons_16.Satellite] = "62108", _a2[BlueprintIcons_16.Saved] = "62109", _a2[BlueprintIcons_16.ScatterPlot] = "62110", _a2[BlueprintIcons_16.SearchAround] = "62111", _a2[BlueprintIcons_16.SearchTemplate] = "62112", _a2[BlueprintIcons_16.SearchText] = "62113", _a2[BlueprintIcons_16.Search] = "62114", _a2[BlueprintIcons_16.SegmentedControl] = "62115", _a2[BlueprintIcons_16.Select] = "62116", _a2[BlueprintIcons_16.Selection] = "62117", _a2[BlueprintIcons_16.SendMessage] = "62118", _a2[BlueprintIcons_16.SendToGraph] = "62119", _a2[BlueprintIcons_16.SendToMap] = "62120", _a2[BlueprintIcons_16.SendTo] = "62121", _a2[BlueprintIcons_16.SeriesAdd] = "62122", _a2[BlueprintIcons_16.SeriesConfiguration] = "62123", _a2[BlueprintIcons_16.SeriesDerived] = "62124", _a2[BlueprintIcons_16.SeriesFiltered] = "62125", _a2[BlueprintIcons_16.SeriesSearch] = "62126", _a2[BlueprintIcons_16.Settings] = "62127", _a2[BlueprintIcons_16.Shapes] = "62128", _a2[BlueprintIcons_16.Share] = "62129", _a2[BlueprintIcons_16.SharedFilter] = "62130", _a2[BlueprintIcons_16.Shield] = "62131", _a2[BlueprintIcons_16.Ship] = "62132", _a2[BlueprintIcons_16.Shop] = "62133", _a2[BlueprintIcons_16.ShoppingCart] = "62134", _a2[BlueprintIcons_16.SignalSearch] = "62135", _a2[BlueprintIcons_16.SimCard] = "62136", _a2[BlueprintIcons_16.Slash] = "62137", _a2[BlueprintIcons_16.SmallCross] = "62138", _a2[BlueprintIcons_16.SmallInfoSign] = "62260", _a2[BlueprintIcons_16.SmallMinus] = "62139", _a2[BlueprintIcons_16.SmallPlus] = "62140", _a2[BlueprintIcons_16.SmallSquare] = "62141", _a2[BlueprintIcons_16.SmallTick] = "62142", _a2[BlueprintIcons_16.Snowflake] = "62143", _a2[BlueprintIcons_16.SocialMedia] = "62144", _a2[BlueprintIcons_16.SortAlphabeticalDesc] = "62145", _a2[BlueprintIcons_16.SortAlphabetical] = "62146", _a2[BlueprintIcons_16.SortAsc] = "62147", _a2[BlueprintIcons_16.SortDesc] = "62148", _a2[BlueprintIcons_16.SortNumericalDesc] = "62149", _a2[BlueprintIcons_16.SortNumerical] = "62150", _a2[BlueprintIcons_16.Sort] = "62151", _a2[BlueprintIcons_16.SplitColumns] = "62152", _a2[BlueprintIcons_16.Square] = "62153", _a2[BlueprintIcons_16.StackedChart] = "62154", _a2[BlueprintIcons_16.StadiumGeometry] = "62155", _a2[BlueprintIcons_16.StarEmpty] = "62156", _a2[BlueprintIcons_16.Star] = "62157", _a2[BlueprintIcons_16.StepBackward] = "62158", _a2[BlueprintIcons_16.StepChart] = "62159", _a2[BlueprintIcons_16.StepForward] = "62160", _a2[BlueprintIcons_16.Stop] = "62161", _a2[BlueprintIcons_16.Stopwatch] = "62162", _a2[BlueprintIcons_16.Strikethrough] = "62163", _a2[BlueprintIcons_16.Style] = "62164", _a2[BlueprintIcons_16.SwapHorizontal] = "62165", _a2[BlueprintIcons_16.SwapVertical] = "62166", _a2[BlueprintIcons_16.Switch] = "62167", _a2[BlueprintIcons_16.SymbolCircle] = "62168", _a2[BlueprintIcons_16.SymbolCross] = "62169", _a2[BlueprintIcons_16.SymbolDiamond] = "62170", _a2[BlueprintIcons_16.SymbolRectangle] = "62242", _a2[BlueprintIcons_16.SymbolSquare] = "62171", _a2[BlueprintIcons_16.SymbolTriangleDown] = "62172", _a2[BlueprintIcons_16.SymbolTriangleUp] = "62173", _a2[BlueprintIcons_16.Syringe] = "62174", _a2[BlueprintIcons_16.Tag] = "62175", _a2[BlueprintIcons_16.TakeAction] = "62176", _a2[BlueprintIcons_16.Tank] = "62177", _a2[BlueprintIcons_16.Target] = "62178", _a2[BlueprintIcons_16.Taxi] = "62179", _a2[BlueprintIcons_16.Temperature] = "62180", _a2[BlueprintIcons_16.TextHighlight] = "62181", _a2[BlueprintIcons_16.ThDerived] = "62182", _a2[BlueprintIcons_16.ThDisconnect] = "62183", _a2[BlueprintIcons_16.ThFiltered] = "62184", _a2[BlueprintIcons_16.ThList] = "62185", _a2[BlueprintIcons_16.Th] = "62186", _a2[BlueprintIcons_16.ThirdParty] = "62187", _a2[BlueprintIcons_16.ThumbsDown] = "62188", _a2[BlueprintIcons_16.ThumbsUp] = "62189", _a2[BlueprintIcons_16.TickCircle] = "62190", _a2[BlueprintIcons_16.Tick] = "62191", _a2[BlueprintIcons_16.Time] = "62192", _a2[BlueprintIcons_16.TimelineAreaChart] = "62193", _a2[BlueprintIcons_16.TimelineBarChart] = "62194", _a2[BlueprintIcons_16.TimelineEvents] = "62195", _a2[BlueprintIcons_16.TimelineLineChart] = "62196", _a2[BlueprintIcons_16.Tint] = "62197", _a2[BlueprintIcons_16.Torch] = "62198", _a2[BlueprintIcons_16.Tractor] = "62199", _a2[BlueprintIcons_16.Train] = "62200", _a2[BlueprintIcons_16.Translate] = "62201", _a2[BlueprintIcons_16.Trash] = "62202", _a2[BlueprintIcons_16.Tree] = "62203", _a2[BlueprintIcons_16.TrendingDown] = "62204", _a2[BlueprintIcons_16.TrendingUp] = "62205", _a2[BlueprintIcons_16.Truck] = "62206", _a2[BlueprintIcons_16.TwoColumns] = "62207", _a2[BlueprintIcons_16.Unarchive] = "62208", _a2[BlueprintIcons_16.Underline] = "62209", _a2[BlueprintIcons_16.Undo] = "62210", _a2[BlueprintIcons_16.UngroupObjects] = "62211", _a2[BlueprintIcons_16.UnknownVehicle] = "62212", _a2[BlueprintIcons_16.Unlock] = "62213", _a2[BlueprintIcons_16.Unpin] = "62214", _a2[BlueprintIcons_16.Unresolve] = "62215", _a2[BlueprintIcons_16.Updated] = "62216", _a2[BlueprintIcons_16.Upload] = "62217", _a2[BlueprintIcons_16.User] = "62218", _a2[BlueprintIcons_16.Variable] = "62219", _a2[BlueprintIcons_16.VerticalBarChartAsc] = "62220", _a2[BlueprintIcons_16.VerticalBarChartDesc] = "62221", _a2[BlueprintIcons_16.VerticalDistribution] = "62222", _a2[BlueprintIcons_16.VerticalInbetween] = "62250", _a2[BlueprintIcons_16.Video] = "62223", _a2[BlueprintIcons_16.Virus] = "62224", _a2[BlueprintIcons_16.VolumeDown] = "62225", _a2[BlueprintIcons_16.VolumeOff] = "62226", _a2[BlueprintIcons_16.VolumeUp] = "62227", _a2[BlueprintIcons_16.Walk] = "62228", _a2[BlueprintIcons_16.WarningSign] = "62229", _a2[BlueprintIcons_16.WaterfallChart] = "62230", _a2[BlueprintIcons_16.Waves] = "62231", _a2[BlueprintIcons_16.WidgetButton] = "62232", _a2[BlueprintIcons_16.WidgetFooter] = "62233", _a2[BlueprintIcons_16.WidgetHeader] = "62234", _a2[BlueprintIcons_16.Widget] = "62235", _a2[BlueprintIcons_16.Wind] = "62236", _a2[BlueprintIcons_16.Wrench] = "62237", _a2[BlueprintIcons_16.ZoomIn] = "62238", _a2[BlueprintIcons_16.ZoomOut] = "62239", _a2[BlueprintIcons_16.ZoomToFit] = "62240", _a2);
  init_define_process();
  init_define_process();
  var __assign3 = function () {
    __assign3 = Object.assign || (function __assign4(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p3 in s) if (Object.prototype.hasOwnProperty.call(s, p3)) t[p3] = s[p3];
      }
      return t;
    });
    return __assign3.apply(this, arguments);
  };
  var IconNamesNew = {};
  var IconNamesLegacy = {};
  for ((_i = 0, _a3 = Object.values(BlueprintIcons_16)); _i < _a3.length; _i++) {
    name_1 = _a3[_i];
    IconNamesNew[pascalCase(name_1)] = name_1;
    IconNamesLegacy[snakeCase(name_1).toUpperCase()] = name_1;
  }
  var name_1;
  var _i;
  var _a3;
  var IconNames = __assign3(__assign3({}, IconNamesNew), IconNamesLegacy);
  var IconSize;
  (function (IconSize2) {
    IconSize2[IconSize2["STANDARD"] = 16] = "STANDARD";
    IconSize2[IconSize2["LARGE"] = 20] = "LARGE";
  })(IconSize || (IconSize = {}));
  var Icon = (function (_super) {
    __extends(Icon2, _super);
    function Icon2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Icon2.prototype.render = function () {
      var icon = this.props.icon;
      if (icon == null || typeof icon === "boolean") {
        return null;
      } else if (typeof icon !== "string") {
        return icon;
      }
      var _a3 = this.props, className = _a3.className, color = _a3.color, htmlTitle = _a3.htmlTitle, iconSize = _a3.iconSize, intent = _a3.intent, _b2 = _a3.size, size = _b2 === void 0 ? iconSize !== null && iconSize !== void 0 ? iconSize : IconSize.STANDARD : _b2, title = _a3.title, _c2 = _a3.tagName, tagName = _c2 === void 0 ? "span" : _c2, htmlprops = __rest(_a3, ["className", "color", "htmlTitle", "iconSize", "intent", "size", "title", "tagName"]);
      var pixelGridSize = size >= IconSize.LARGE ? IconSize.LARGE : IconSize.STANDARD;
      var paths = this.renderSvgPaths(pixelGridSize, icon);
      var classes = (0, import_classnames.default)(classes_exports.ICON, classes_exports.iconClass(icon), classes_exports.intentClass(intent), className);
      var viewBox = ("0 0 ").concat(pixelGridSize, " ").concat(pixelGridSize);
      var titleId = uniqueId("iconTitle");
      return React3.createElement(tagName, __assign(__assign({}, htmlprops), {
        "aria-hidden": title ? void 0 : true,
        className: classes,
        title: htmlTitle
      }), React3.createElement("svg", {
        fill: color,
        "data-icon": icon,
        width: size,
        height: size,
        viewBox,
        "aria-labelledby": title ? titleId : void 0,
        role: "img"
      }, title && React3.createElement("title", {
        id: titleId
      }, title), paths));
    };
    Icon2.prototype.renderSvgPaths = function (pathsSize, iconName) {
      var svgPathsRecord = pathsSize === IconSize.STANDARD ? paths_exports : paths_exports2;
      var paths = svgPathsRecord[iconNameToPathsRecordKey(iconName)];
      if (paths == null) {
        return null;
      }
      return paths.map(function (path, i) {
        return React3.createElement("path", {
          key: i,
          d: path,
          fillRule: "evenodd"
        });
      });
    };
    Icon2.displayName = ("").concat(DISPLAYNAME_PREFIX, ".Icon");
    return Icon2;
  })(AbstractPureComponent2);
  init_define_process();
  var import_classnames2 = __toESM(require_classnames());
  var React4 = __toESM(__require("react"));
  var SpinnerSize;
  (function (SpinnerSize2) {
    SpinnerSize2[SpinnerSize2["SMALL"] = 20] = "SMALL";
    SpinnerSize2[SpinnerSize2["STANDARD"] = 50] = "STANDARD";
    SpinnerSize2[SpinnerSize2["LARGE"] = 100] = "LARGE";
  })(SpinnerSize || (SpinnerSize = {}));
  var R = 45;
  var SPINNER_TRACK2 = ("M 50,50 m 0,-").concat(R, " a ").concat(R, ",").concat(R, " 0 1 1 0,").concat(R * 2, " a ").concat(R, ",").concat(R, " 0 1 1 0,-").concat(R * 2);
  var PATH_LENGTH = 280;
  var MIN_SIZE = 10;
  var STROKE_WIDTH = 4;
  var MIN_STROKE_WIDTH = 16;
  var Spinner = (function (_super) {
    __extends(Spinner2, _super);
    function Spinner2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Spinner2.prototype.componentDidUpdate = function (prevProps) {
      if (prevProps.value !== this.props.value) {
        this.forceUpdate();
      }
    };
    Spinner2.prototype.render = function () {
      var _a3;
      var _b2 = this.props, className = _b2.className, intent = _b2.intent, value = _b2.value, _c2 = _b2.tagName, tagName = _c2 === void 0 ? "div" : _c2, htmlProps = __rest(_b2, ["className", "intent", "value", "tagName"]);
      var size = this.getSize();
      var classes = (0, import_classnames2.default)(classes_exports.SPINNER, classes_exports.intentClass(intent), (_a3 = {}, _a3[classes_exports.SPINNER_NO_SPIN] = value != null, _a3), className);
      var strokeWidth = Math.min(MIN_STROKE_WIDTH, STROKE_WIDTH * SpinnerSize.LARGE / size);
      var strokeOffset = PATH_LENGTH - PATH_LENGTH * (value == null ? 0.25 : clamp(value, 0, 1));
      return React4.createElement(tagName, __assign({
        "aria-valuemax": 100,
        "aria-valuemin": 0,
        "aria-valuenow": value === void 0 ? void 0 : value * 100,
        className: classes,
        role: "progressbar"
      }, htmlProps), React4.createElement(tagName, {
        className: classes_exports.SPINNER_ANIMATION
      }, React4.createElement("svg", {
        width: size,
        height: size,
        strokeWidth: strokeWidth.toFixed(2),
        viewBox: this.getViewBox(strokeWidth)
      }, React4.createElement("path", {
        className: classes_exports.SPINNER_TRACK,
        d: SPINNER_TRACK2
      }), React4.createElement("path", {
        className: classes_exports.SPINNER_HEAD,
        d: SPINNER_TRACK2,
        pathLength: PATH_LENGTH,
        strokeDasharray: ("").concat(PATH_LENGTH, " ").concat(PATH_LENGTH),
        strokeDashoffset: strokeOffset
      }))));
    };
    Spinner2.prototype.validateProps = function (_a3) {
      var _b2 = _a3.className, className = _b2 === void 0 ? "" : _b2, size = _a3.size;
      if (size != null && (className.indexOf(classes_exports.SMALL) >= 0 || className.indexOf(classes_exports.LARGE) >= 0)) {
        console.warn(SPINNER_WARN_CLASSES_SIZE);
      }
    };
    Spinner2.prototype.getSize = function () {
      var _a3 = this.props, _b2 = _a3.className, className = _b2 === void 0 ? "" : _b2, size = _a3.size;
      if (size == null) {
        if (className.indexOf(classes_exports.SMALL) >= 0) {
          return SpinnerSize.SMALL;
        } else if (className.indexOf(classes_exports.LARGE) >= 0) {
          return SpinnerSize.LARGE;
        }
        return SpinnerSize.STANDARD;
      }
      return Math.max(MIN_SIZE, size);
    };
    Spinner2.prototype.getViewBox = function (strokeWidth) {
      var radius = R + strokeWidth / 2;
      var viewBoxX = (50 - radius).toFixed(2);
      var viewBoxWidth = (radius * 2).toFixed(2);
      return ("").concat(viewBoxX, " ").concat(viewBoxX, " ").concat(viewBoxWidth, " ").concat(viewBoxWidth);
    };
    Spinner2.displayName = ("").concat(DISPLAYNAME_PREFIX, ".Spinner");
    return Spinner2;
  })(AbstractPureComponent2);
  var AbstractButton = (function (_super) {
    __extends(AbstractButton2, _super);
    function AbstractButton2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.state = {
        isActive: false
      };
      _this.handleKeyDown = function (e) {
        var _a3, _b2;
        if (keys_exports.isKeyboardClick(e.which)) {
          e.preventDefault();
          if (e.which !== _this.currentKeyDown) {
            _this.setState({
              isActive: true
            });
          }
        }
        _this.currentKeyDown = e.which;
        (_b2 = (_a3 = _this.props).onKeyDown) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, e);
      };
      _this.handleKeyUp = function (e) {
        var _a3, _b2, _c2;
        if (keys_exports.isKeyboardClick(e.which)) {
          _this.setState({
            isActive: false
          });
          (_a3 = _this.buttonRef) === null || _a3 === void 0 ? void 0 : _a3.click();
        }
        _this.currentKeyDown = void 0;
        (_c2 = (_b2 = _this.props).onKeyUp) === null || _c2 === void 0 ? void 0 : _c2.call(_b2, e);
      };
      _this.handleBlur = function (e) {
        var _a3, _b2;
        if (_this.state.isActive) {
          _this.setState({
            isActive: false
          });
        }
        (_b2 = (_a3 = _this.props).onBlur) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, e);
      };
      return _this;
    }
    AbstractButton2.prototype.getCommonButtonProps = function () {
      var _a3;
      var _b2 = this.props, _c2 = _b2.active, active = _c2 === void 0 ? false : _c2, alignText = _b2.alignText, fill = _b2.fill, large = _b2.large, _d2 = _b2.loading, loading = _d2 === void 0 ? false : _d2, outlined = _b2.outlined, minimal = _b2.minimal, small = _b2.small, tabIndex = _b2.tabIndex;
      var disabled = this.props.disabled || loading;
      var className = (0, import_classnames3.default)(classes_exports.BUTTON, (_a3 = {}, _a3[classes_exports.ACTIVE] = !disabled && (active || this.state.isActive), _a3[classes_exports.DISABLED] = disabled, _a3[classes_exports.FILL] = fill, _a3[classes_exports.LARGE] = large, _a3[classes_exports.LOADING] = loading, _a3[classes_exports.MINIMAL] = minimal, _a3[classes_exports.OUTLINED] = outlined, _a3[classes_exports.SMALL] = small, _a3), classes_exports.alignmentClass(alignText), classes_exports.intentClass(this.props.intent), this.props.className);
      return {
        className,
        disabled,
        onBlur: this.handleBlur,
        onClick: disabled ? void 0 : this.props.onClick,
        onFocus: disabled ? void 0 : this.props.onFocus,
        onKeyDown: this.handleKeyDown,
        onKeyUp: this.handleKeyUp,
        tabIndex: disabled ? -1 : tabIndex
      };
    };
    AbstractButton2.prototype.renderChildren = function () {
      var _a3 = this.props, children = _a3.children, icon = _a3.icon, loading = _a3.loading, rightIcon = _a3.rightIcon, text = _a3.text;
      var maybeHasText = !utils_exports.isReactNodeEmpty(text) || !utils_exports.isReactNodeEmpty(children);
      return [loading && React5.createElement(Spinner, {
        key: "loading",
        className: classes_exports.BUTTON_SPINNER,
        size: IconSize.LARGE
      }), React5.createElement(Icon, {
        key: "leftIcon",
        icon,
        "aria-hidden": maybeHasText,
        tabIndex: maybeHasText ? -1 : void 0
      }), maybeHasText && React5.createElement("span", {
        key: "text",
        className: classes_exports.BUTTON_TEXT
      }, text, children), React5.createElement(Icon, {
        key: "rightIcon",
        icon: rightIcon
      })];
    };
    return AbstractButton2;
  })(AbstractPureComponent2);
  var Button = (function (_super) {
    __extends(Button2, _super);
    function Button2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.buttonRef = null;
      _this.handleRef = refHandler(_this, "buttonRef", _this.props.elementRef);
      return _this;
    }
    Button2.prototype.render = function () {
      return React6.createElement("button", __assign({
        type: "button",
        ref: this.handleRef
      }, removeNonHTMLProps(this.props), this.getCommonButtonProps()), this.renderChildren());
    };
    Button2.prototype.componentDidUpdate = function (prevProps) {
      if (prevProps.elementRef !== this.props.elementRef) {
        setRef(prevProps.elementRef, null);
        this.handleRef = refHandler(this, "buttonRef", this.props.elementRef);
        setRef(this.props.elementRef, this.buttonRef);
      }
    };
    Button2.displayName = ("").concat(DISPLAYNAME_PREFIX, ".Button");
    return Button2;
  })(AbstractButton);
  var AnchorButton = (function (_super) {
    __extends(AnchorButton2, _super);
    function AnchorButton2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.buttonRef = null;
      _this.handleRef = refHandler(_this, "buttonRef", _this.props.elementRef);
      return _this;
    }
    AnchorButton2.prototype.render = function () {
      var _a3 = this.props, href = _a3.href, _b2 = _a3.tabIndex, tabIndex = _b2 === void 0 ? 0 : _b2;
      var commonProps = this.getCommonButtonProps();
      return React6.createElement("a", __assign({
        role: "button",
        ref: this.handleRef
      }, removeNonHTMLProps(this.props), commonProps, {
        href: commonProps.disabled ? void 0 : href,
        tabIndex: commonProps.disabled ? -1 : tabIndex
      }), this.renderChildren());
    };
    AnchorButton2.prototype.componentDidUpdate = function (prevProps) {
      if (prevProps.elementRef !== this.props.elementRef) {
        setRef(prevProps.elementRef, null);
        this.handleRef = refHandler(this, "buttonRef", this.props.elementRef);
        setRef(this.props.elementRef, this.buttonRef);
      }
    };
    AnchorButton2.displayName = ("").concat(DISPLAYNAME_PREFIX, ".AnchorButton");
    return AnchorButton2;
  })(AbstractButton);
  init_define_process();
  var import_classnames4 = __toESM(require_classnames());
  var React7 = __toESM(__require("react"));
  var ButtonGroup = (function (_super) {
    __extends(ButtonGroup2, _super);
    function ButtonGroup2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ButtonGroup2.prototype.render = function () {
      var _a3;
      var _b2 = this.props, alignText = _b2.alignText, className = _b2.className, elementRef = _b2.elementRef, fill = _b2.fill, minimal = _b2.minimal, large = _b2.large, vertical = _b2.vertical, htmlProps = __rest(_b2, ["alignText", "className", "elementRef", "fill", "minimal", "large", "vertical"]);
      var buttonGroupClasses = (0, import_classnames4.default)(classes_exports.BUTTON_GROUP, (_a3 = {}, _a3[classes_exports.FILL] = fill, _a3[classes_exports.LARGE] = large, _a3[classes_exports.MINIMAL] = minimal, _a3[classes_exports.VERTICAL] = vertical, _a3), classes_exports.alignmentClass(alignText), className);
      return React7.createElement("div", __assign({}, htmlProps, {
        className: buttonGroupClasses,
        ref: elementRef
      }), this.props.children);
    };
    ButtonGroup2.displayName = ("").concat(DISPLAYNAME_PREFIX, ".ButtonGroup");
    return ButtonGroup2;
  })(AbstractPureComponent2);
  var import_jsx_runtime = __require("react/jsx-runtime");
  var A2dUiButtons = class extends import_react.default.Component {
    constructor(props) {
      super(props);
      this.state = {
        isPaused: false
      };
    }
    toggleGamePause() {
      const currentState = this.state.isPaused;
      this.props.onClick(!currentState);
      this.setState({
        isPaused: !currentState
      });
    }
    render() {
      return (0, import_jsx_runtime.jsx)(ButtonGroup, {
        children: (0, import_jsx_runtime.jsx)(Button, {
          className: "a2d-play-toggle-button",
          icon: this.state.isPaused ? IconNames.PLAY : IconNames.PAUSE,
          active: false,
          onClick: () => this.toggleGamePause(),
          text: this.state.isPaused ? "Resume Game" : "Pause Game"
        })
      });
    }
  };
  var GameTab = class extends import_react.default.Component {
    constructor(props) {
      super(props);
      this.state = {
        game: void 0
      };
    }
    componentDidMount() {
      var _a3, _b2, _c2;
      if (((_a3 = document.querySelector('[id="bp4-tab-panel_side-content-tabs_Arcade2D Tab"]')) == null ? void 0 : _a3.ariaHidden) === "true") {
        return;
      }
      const config = (_c2 = (_b2 = this.props.context.result) == null ? void 0 : _b2.value) == null ? void 0 : _c2.gameConfig;
      this.setState({
        game: new import_phaser.default.Game(config)
      });
    }
    shouldComponentUpdate() {
      return false;
    }
    toggleGamePause(pause) {
      var _a3, _b2, _c2, _d2;
      if (pause) {
        (_a3 = this.state.game) == null ? void 0 : _a3.scene.pause("default");
        (_b2 = this.state.game) == null ? void 0 : _b2.sound.pauseAll();
      } else {
        (_c2 = this.state.game) == null ? void 0 : _c2.scene.resume("default");
        (_d2 = this.state.game) == null ? void 0 : _d2.sound.resumeAll();
      }
    }
    componentWillUnmount() {
      var _a3, _b2;
      (_a3 = this.state.game) == null ? void 0 : _a3.sound.stopAll();
      (_b2 = this.state.game) == null ? void 0 : _b2.destroy(false, false);
    }
    render() {
      return (0, import_jsx_runtime.jsxs)("div", {
        id: "a2d-tab",
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          flexDirection: "column"
        },
        children: [(0, import_jsx_runtime.jsx)("div", {
          id: "phaser-game"
        }), (0, import_jsx_runtime.jsx)(A2dUiButtons, {
          onClick: p3 => this.toggleGamePause(p3)
        })]
      });
    }
  };
  var ArcadeTwod_default = {
    toSpawn(context) {
      var _a3, _b2;
      const config = (_b2 = (_a3 = context.result) == null ? void 0 : _a3.value) == null ? void 0 : _b2.gameConfig;
      if (config) {
        return true;
      }
      return false;
    },
    body: context => (0, import_jsx_runtime.jsx)(GameTab, {
      context
    }),
    label: "Arcade2D Tab",
    iconName: IconNames.SHAPES
  };
  return __toCommonJS(ArcadeTwod_exports);
})()["default"]